---
title: 自动驾驶工具
toc: true
date: 2024-08-20 22:13:00
categories: 自动驾驶
tags:
- c plus plus
- Windows Program
- Qt
- 可视化
---

## C++

### `sregex_token_iterator`的特性

### `string`转数字

### 关于时间的函数和结构体

#### `time`函数

```c++
#include <time.h>
time_t time(time_t* calptr)
```

得到自 1970-1-1 00:00:00 以来经过的秒数，结果可以通过返回值，也可以通过参数得到

```c++
time_t now;
time(&now);
// 等同于 now = time(NULL)
printf("now time is %d\n", now);
```

#### `localtime`

```c++
struct tm {
    int tm_sec;       /* 秒 – 取值区间为 [0,59] */
    int tm_min;       /* 分 - 取值区间为 [0,59] */
    int tm_hour;      /* 时 - 取值区间为 [0,23] */
    int tm_mday;     /* 一个月中的日期 - 取值区间为 [1,31] */
    int tm_mon;     /* 月份（从一月开始，0 代表一月） - 取值区间为 [0,11] */
    int tm_year;     /* 年份，其值等于实际年份减去 1900 */
    int tm_wday;    /* 星期 – 取值区间为 [0,6]，其中 0 代表星期天，1 代表星期一 */
    int tm_yday;    /* 从每年 1 月 1 日开始的天数– 取值区间 [0,365]，其中 0 代表 1 月 1 日 */
    int tm_isdst;    /* 夏令时标识符，夏令时 tm_isdst 为正；不实行夏令时 tm_isdst 为 0 */    
};

struct tm *localtime(const time_t* calptr);
```

用来获取系统时间，精度为秒；将时间（秒）数值变换成本地时间，考虑到本地时区和夏令时标志

```c++
time_t now;
struct tm *tm_now;
time(&now);
tm_now = localtime(&now);
//把秒变换成年月日
printf("now datetime: %d-%d-%d %d:%d:%d\n", 
    tm_now->tm_year+1900,
    tm_now->tm_mon+1,
    tm_now->tm_mday,
    tm_now->tm_hour,
    tm_now->tm_min,
    tm_now->tm_sec
);
```

#### `localtime_r`

```c++
struct tm *localtime_r(const time_t *timep, struct tm *result);
```

用来获取系统时间，运行于 linux 平台下

```c++
#include <stdio.h>
#include <time.h>
     
int main()
{
    time_t time_seconds = time(0);
    struct tm now_time;
    localtime_r(&time_seconds, &now_time);
 
    printf("%d-%d-%d %d:%d:%d\n",
        now_time.tm_year + 1900,
        now_time.tm_mon + 1,
        now_time.tm_mday,
        now_time.tm_hour,
        now_time.tm_min,
        now_time.tm_sec
    );
}
```

#### `localtime_s`

用来获取系统时间，运行于 windows 平台下，与`localtime_r`只有参数顺序不一样

```c++
 #include <iostream>
#include <time.h>
     
int main()
{
    time_t time_seconds = time(0);
    struct tm now_time;
    localtime_s(&now_time,&time_seconds);
    printf("%d-%d-%d %d:%d:%d\n",
        now_time.tm_year + 1900,
        now_time.tm_mon + 1,
        now_time.tm_mday,
        now_time.tm_hour,
        now_time.tm_min,
        now_time.tm_sec
    );
}
```

{% note warning %}
`localtime`和`localtime_r`二者区别

* `localtime`对于多线程不安全，因为`localtime`在使用时，只需定义一个指针，申请空间的动作由函数自己完成，这样在多线程的情况下，如果有另一个线程调用了这个函数，那么指针指向的 s`truct tm`结构体的数据就会改变
* 在 l`ocaltime_s`与`localtime_r`调用时，定义的是`struct tm`的结构体，获取到的时间已经保存在`struct tm`中，并不会受其他线程的影响
{% endnote %}

#### `gettimeofday`

```c++
#include <sys/time.h>

struct timezone {
    int tz_minuteswest;/*格林威治时间往西方的时差*/
    int tz_dsttime;/*DST 时间的修正方式*/
}
        
struct timeval {
    long int tv_sec; // 秒数
    long int tv_usec; // 微秒数
}

int gettimeofday(struct timeeval* tv, struct timezone* tz);
```

获取秒、微秒、时区等信息；其参数`tv`是保存获取时间结果的结构体，参数`tz`用于保存时区结果，`timezone`参数若不使用则传入`NULL`即可

```c++
struct timeval tv_begin, tv_end;
gettimeofday(&tv_begin, NULL);
foo();
gettimeofday(&tv_end, NULL);
```

它获得的时间精确到微秒`1e-6s`量级，在一段代码前后分别使用`gettimeofday`可以计算代码执行时间

### linux下`sprintf_s`函数的替代

windows平台下线程安全的格式化字符串函数`sprint_s`并非标准C函数，因此linux下无法使用，但可以使用`snprintf`函数代替

```c++
/*函数原型：*/
int snprintf(char *dest, size_t n, const char *fmt, ...);

/*函数说明: 最多从源串中拷贝n－1个字符到目标串中，然后再在后面加一个0。所以如果目标串的大小为n的话，将不会溢出。
函数返回值: 若成功则返回存入数组的字符数，若编码出错则返回负值。
推荐的用法：*/
void f(const char *p)
{
    char buf[11] = { 0 };
    snprintf(buf, sizeof(buf), "%10s", p); // 注意：这里第2个参数应当用sizeof(str)，而不要使用硬编码11，也不应当使用sizeof(str)-1或10
    printf("%sn", buf);
}
```

### <font color="#FF204E">incomplete type `xxx` used in nested name specifier</font>

{% note danger %}
Error: incomplete type 'QTime' used in nested name specifier
{% endnote  %}

声明/定义了`QTime`类型的变量，但是没有引入相应的头文件，即`#include <QTime>`

## Windows 编程

### WMIC 指令

## Linux

### 从windows拷贝文件到WSL最快速的方法

* 在WSL用`sudo ls /mnt/*`列出系统所有的挂载盘，可以看到windows系统的所有盘都列出来了
* 然后使用`cp`命令

## Git

### 递归`git push/pull`

在Git中，递归`git push/pull`操作是指在父模块中递归地操作子模块的push和pull操作。当一个代码库包含多个子模块时，可以使用递归`git push/pull`操作来同时对所有子模块进行相关操作，从而避免了手动逐个操作子模块的繁琐

#### 递归`git push`

```bash
git push --recurse-submodules=on-demand
```

#### 递归`git pull`

```bash
git pull --recurse-submodules
```

{% note warning %}

* 确保所有子模块都已经初始化和更新。如果有尚未初始化或更新的子模块，可以使用`git submodule init`和`git submodule update`命令来初始化和更新子模块
* 如果在父模块中进行了修改，并且同时也在某个子模块中进行了修改，那么在递归`git push/pull`操作时可能会出现冲突。如果出现冲突，需要手动解决冲突并再次进行递归`git push/pull`操作
* 在进行递归`git push/pull`操作时，确保所有子模块的远程仓库地址正确设置，并且拥有push/pull权限

{% endnote %}


### 如何删除Git中的未跟踪文件 untracked files

要删除所有未跟踪的文件，可以运行以下命令

```bash
git clean -f # 该命令中的 -f 参数表示强制执行删除操作
```

如果想要删除未跟踪的文件和目录，可以使用`-d`参数

```bash
git clean -f -d
```
