---
title: 现代 C++基础
toc: true
date: 2024-06-03 14:11:57
categories: C++
tags:
- C++
- 现代 C++
mathjax: true
toc: true
sticky: 600
---

### Basics Review

#### Array Type

* Multidimensional array 多维数组
  * 除了第一维其它维必须明确指出大小（explicit size）
  * 不可以全部 decay
  * Dynamic allocation
    * `malloc` in C and `new`/`new []` in C++
    * `new`和`malloc`返回都是指针
    * 释放

#### Function

* 函数返回类型不能是函数或者数组（但是可以是它们的引用）
  * 不应该返回局部变量的指针或者引用（超出了局部变量生命周期的范围）
    * e.g. `int& Test() { int a = 1; return &a; }`
  * 声明为`static`的局部变量具有全局性
* Function pointers 函数指针
  * `void(*)(int)`
  * clockwise/spiral rule
  * Type alias 用 C++ 11 中的`using`
  
    ```C++
    using MyFuncType1 = int(*)(float);
    using MyFuncType2 = int(*)(int);
    using MyFuncType3 = int(*)(MyFuncType1);
    ``` 

  * C 语言中可以用`typedef`，但是没有`using`强大

#### Attribute

* `[[attribute]]` C++ 11，`[[attribute("reason")]]` C++ 20
* `[[deprecated]]`和`[[deprecated("reason")]]` C++ 14
* `[[noreturn]]` C++ 11
* `[[maybe_unused]]` C++ 17

e.g.

```C++
[[nodiscard]] int Add(int a, int b) { return a + b; }

int main()
{
    Add(1, 2); // int res = Add(1, 2);
    return 0
}
```

warning: 放弃具有 [[nodiscard]] 属性函数的返回值

#### Enumeration

> 一个被限制取值的类

* 比较像使用全局变量
* 同时进行整形运算也没有安全检查
* C++ 11 引入了 scoped enumeration 提高安全性

e.g.

```C++
// enum Day { Monday };
enum class Day { Monday };

int main()
{
    // int a = Monday;
    Day a = Day::Monday
    return 0;
}
```

* 可以使用`std::underlying_type<Day>::type`或者`std::underlying_type_t<Day>` C++ 14 转成整数类型
  * C++ 23 中也可以使用`std::to_underlying<Day>(day)`
* 可以使用`Day day{1};` 初始化 C++ 17，但是不能直接赋值`Day day = 1;`或`day = 1;`
* 可以使用位操作符

#### Expression

* 运算符和表达式三个重要概念
  * Precedence 优先级
  * Associativity 结合性
  * Order 顺序
* From the view of compiler, an expressiong is in fact a tree, determined by associativity and precedence. e.g. `9 / 3 / 2 + 2 * 3`
  * Precedence is used to split terms first.
  * Associativity determines how the tree will grow.
  * Then, it's order of expression evaluation that computes the whole tree. 但是顺序是不确定的
    * `f1() + f2() + f3()`，`f1()`，`f1()`，`f1()`哪一个先被 evaluated 是不确定的
* There are some rules
  * For `&&` and `||`, since they have short-circuit property, the first part will be fully evaluated.
  * For a function call, all parameters (including `a` for e.g. `a.Func()` or `a->Func()`) are fully evaluated before entering the function.
  * 三目运算
  * 逗号表达式
  * C++ 17
    * Parameters in function are evaluated indeterminately, i.e. every sub-tree represneted by te parameter is fully evaluated in a **non-overlap** way 不会以交叠的形式 evaluated
    * 运算符重载，和 build-in 运算符的 evaluated 顺序一致，而不是被当作普通函数
    * More useful examples: chained call
  
```C++
std::string s = "I have it even works if you don't believe";
s.replace(0, 8, "").replace(s.find("even"), 4, "sometimes").replace(s.find("you don't"), 9, "I");
```

### class

#### Ctor & Dtor

* 拷贝构造函数
* 赋值构造函数
* The recommended way is member initializer list:
  * `member1{ ... }, member2{ ... }, ... { /* function body */ }`
  * `{}` is used since C++ 11
* 默认构造函数建议使用`Class() = default;`
* 如果成员变量有默认值，就不建议使用上面的构造函数的形式，而是直接用默认值初始化

#### Initialization of Object

* Since C++ 11, Uniform Initialization is introduced
  * 所有的初始化都可以用`{}`
  * 相比于`()`更安全 Narrowing Conversion 缩窄变换检查
    * the converted type cannot represent all values
      * `uint32_t`类型用`uint16_t`初始化，编译器会报错
    * the facilitaties type safety
* Value initialization: No parameter for initialization `T a()`， `T a{}`， `new T{}`， `new T()`
* Direct initialization: `T a(x, y, ...)`，`T(x, y, ...)`，`new T(x, y, ...)`，`T a{x, y, ...}`
* Copy initialization: `T a = xx;`，`T a[] = { xx, ... };`
  * Ctors that use `explicit` cannot use this way
  * Before C++ 17, this also requires available copy ctor.
  
```C++
class A { public: explicit A(int a) {} };
void Func(A a) {}
int main()
{
    A a = 1;    // error
    A a = A(1);
    Func(1);    // error
    Func(A(1)); 
    return 0
}
```

* List initialization
* Agregate initialization

#### Member Functions

* 所有的成员函数都隐式有一个`this`指针
* 如果期望函数不能更改成员变量，可以使用`const`关键字 make `this` to be `const`
* 静态成员函数
  * 没有`this`指针

#### Access Control

* `private`、`protected`、`public`，默认是`private`
* `protected`用在继承中
* 友元

#### Inheritance

* 子类/派生类、父类/基类
* 子类/派生类可以访问父类中所有`public`和`protected`成员
* 继承和组合
* 派生类可以隐式的转化成基类

#### Polmorphism 多态

* you can use the base class to load the derived object and call tis own methods 使用基类的指针/引用，承载派生类的对象，从而调用派生类的方法
* virtual pointer and virtual table
* Every object whose class has a virtal method will have a virtual pointer, which points to virtual table of its class 每个类中都有一个指向虚表的指针，虚表内容就是声明为`virtual`函数的地址
* In C++ 11, it's recommended to use `override` 子类没有`override`编译器会报错
* `final` It means override, and the derived class cannot override again 继承链中的最后一个节点
  * `class A final { ... };` 让类不能被继承
  * 去虚化，编译优化
* `abstract class` 抽象类
  * 抽象类不能被实例化
  * 可以是使用抽象类的指针，指向的都是派生类的对象
  * C++通过纯虚函数实现抽象类 `virtual void PrintInfo() const = 0;`
  * 派生类继承自抽象类必须实现纯虚函数，否则仍然是抽象类
  * Don't call **any** virtual function and any functoin that calls virtual function in ctor & dtor 在构造函数和析构函数中不要调用任何虚函数，也不要掉调用任何可能调用虚函数的函数
  * You should usually make dtor of base class `virtual` 通常将析构函数声明为虚函数
    * deleting `Base*` that cast from `Derived*` will lead to correct dtor 派生类指针赋给基类，当调用`delete`时，如果不基类不是虚析构函数，就会调用基类的析构函数
  * 构造函数不能时纯虚函数

#### Some Covert Facts in Inheritance

* `override`不止表示复写虚函数的含义，对于非虚函数的复写也叫“override”
* `private` inheritance usually denotes the relation of **has-a**
* 虚函数的返回类型可以有些许改变：you can use `Base*` to both accept `Base*` and `Derived*` 复写虚函数的返回值可以是指向基类的指针，也可以是指向派生类的指针
  * 智能指针不能有“协变”
* 当虚方法有默认参数的时候，用什么类型的指针调用时，就会返回该类型内的默认值
  * 默认的参数在编译期间被识别，虚表是在运行时跳转的

e.g.

```C++
void Parent::Go(int i = 2) { std::cout << "Base's go with i = " << i << "\n"; }
void Child::Go(int i = 4) { std::cout << "Derived's go with i = " << i << "\n"; }

Child child;
child.Go(); // Derived's go with i = 4
Parent& childRef = child;
childRef.Go();  // Base's go with i = 2
```

* 可以更改虚方法的访问属性（但是不建议）

### `struct`

* 和`class`基本上一样，除了`struct`默认的访问控制是`public`
  * 不应该有成员函数，最多有 ctor、dtor 和运算符重载
  * With these constraints (except for ctor), `struct` will be an aggregate, which can use aggregate initialization
    * Since C++ 20, aggregate can also use **designated initialization** 指定初始化

e.g.

```C++
struct Priority { int cal; }
struct Point
{
    int x, y;
    Priority priority[2];
}

int main()
{
    Point p{ .x = 1, .y = 2, .priority = { { .val = 1}, { .val = 2 } } };
    return 0;
}
```

### Function Overloading 函数重载

* C++ 中就是相同的函数名不同的参数
  * C 中时禁止的
* This is done by compilers using a technique called **name mangling**
* Operator Overloading 运算符重载
  * `+`，`-`，`*`，`/`，`%`，`|`，`&`，`^`，`<<`，`>>`：推荐使用在全局函数中
  * `+=`，`-=`，`*=`，`/=`，`|=`，`&=`，`^=`，`<<=`，`>>=`：必须时成员函数 since the first operand must be a "named" object; return reerence (i.e. `*this`)
  * Prefix`++` & Prefix`--`：必须是成员函数 return `*this`
  * Postfix`++` & Postfix`--` have an unused parameter int, which is used to distinguish the prefix and postfix
  * `*`，`->`：usually used in e.g. some wrapper of pointers
  * `&&`，`||`：short-circuit 特性会失效
  * `<=>`：三路比较运算符
  * `()`
  * `[]`
    * Since C++ 23, you can use multidimensional subscript in `operator[]`

### Lambda Expression

* 本质上时一个匿名的`struct`，重载了`operator() const`方法
* Basic format: `auto func = [captures](params) -> ReturnType { function body; };`
  * Captures are actually members of the `struct`
  * ReturnType, params and function are for `operator()`
  * Every lambda expression has its unique type
  * 不传任何参数`()`可以省略掉
* 建议将 Lambda 表达式中的捕获的东西明确写出来
* static 和 global 变量是不需要被捕获的
* 捕获`this`指针
  * `this` by reference, since only copy pointer
  * `*this` really copy all members
  * 包括私有成员也可以捕获
* You may add specifiers after `()`
  * `mutable`: since C++ 17, remove `const` in `operator()`
  * `static`: since C++ 23, same as `static operator()`
  * `constexpr`、`consteval`、`noexcept`

```C++
int main()
{
    int i = 0;
    auto m = [i] {i = 1; return 0; }; // 不允许修改 i = 1，因为重载的 operator() 是 const
    auto m = [i]() mutable {i = 1; return 0; }; // 修改的不是外面定义的变量，本质上修改的是 i 的拷贝
}
```

* It's also legal to add attributes between `[]` and `()`
* 函数也可以写成 Lambda 表达式的形式 `auto Foo(params) -> ReturnType { function body; }`

Code Block With Initializer

```C++
auto it = table.find(1);
if (it == table.end())
    //
else
    //
```

* `it`会泄露出去，下面如果继续判断会再定义迭代器类型的变量
* Since C++ 17, you mey code like

```C++
if (auto it = table.find(1); it == table.end())
    //
else
    //
```

* Since C++ 20, range-based for loop can also add an additional initializer, e.g. `for (auto vec = GetVec(); auto& m : vec);`
* Since C++ 23, type alias declaration can also be initializer, e.g. `if (using T = xx; ...)`

### Template

* Since C++ 17, CATD(class template argument deduction) is introduced, meaning that the argument of ctor can deduce the template parameter of class. e.g. `std::vector v{1, 2, 3, 4}`
* Lambda expressiong can slso use template

### Container

* `std::size_t`: the type of `sizeof()` 意味着对象的大小不能超过`std::size_t`所表示的范围
  * 也意味着数组的大小不能超过`std::size_t`所表示的范围
  * 容器的大小也不能超过`std::size_t`
* `std::ptrdiff_t`：两个指针相减得到的类型

#### Iterators

* Input/Output iterator
  * For output `*it = val`, `it++`, `++it`, 'it1 = it2'
  * For input `==`, `!=`, `->`
* Forward iterator: e.g. linked list
* Bidirectional iterator: `--it`, `it--` e.g. double linked list, map
* Random access iterator: `+`, `-`, `+=`, `-=`, `[]`, `<`, `>`, `<=`, `>=`, `!=` e.g. deque
* Contiguous iterator (since C++ 17): 保证地址空间是连续的
* **IMPOERTANT**: Iterator are as unsage us pointers 线程不安全的
* All containers can get their iterators by:
  * `.begin()`, `.end()`
  * `.cbegin()`, `cend()` read-only access
* 双向链表等还提供了倒序的遍历迭代器
  * `.rbegin()`, `.rend()`, `.crbegin()`, `crend()`
* 还可以使用全局的方法得到迭代器
  * `std::begin(vec)`, `std::end(vec)`
  * C++ 20 建议使用`std::ranges::begin`
  * 只有类似`int arr[5]`传入到`std::begin()`或`std::end()`中才有效，指针传入进来时无效的
* There are also general methods of iterator operations, defined in `<iterator>`
  * `std::advance(InputIt& it, n)`: `it += n`
  * `std::next(InputIt it, n = 1)`: `return it + n`
  * `std::prev(InputIt it, n = 1)`: `return it - n`
  * `std::distance(InputIt it1, InputIt it2)`: `retur it2 - it1` 不同的容器时间复杂度不一样

##### Iterator traits（显著的特点，特征）

* Iteratos provide some types to show their information:
  * `value_type`: The type of elements referred to
  * `difference_type`: The type that can be used to represent the distance between elements (usually `ptrdiff_t`) 迭代器之间的距离所表示的类型，一般就是`ptrdiff_t`
  * `iterator_category`: e.g. `input_iterator_tag`, `continuous_iterator_tag`
  * `pointer` & `reference`: only availiable in container iterators 只有在容器中才会有的特性
    * 可以使用`std::iterator_traits<IteratorType>::xxx`获取

##### Stream iterator

* `std::istream_iterator<T>` & `std:ostream_iterator<T>`
* The dafault construsted `istream_iterator` is `end()` 默认的构造函数表示终止的迭代器

##### Iterator adaptor

有两种类型的迭代器适配器

* One is created from iterators to preform different utilities:
  * E.g. reversed iterators 反向迭代器，++ 的本质上是 --，所以可以用`begin()`初始化，即`std:::reverse_iterator r{ p.begin() }`
  * You can get the underlying iterator by `.base()`, which actually returns the iterator that points to the elements after the referred one 调用`.base()`实际上是指向当前指向位置的下一个元素
    * `rbegin().base() == end()`
* Another is created from containers to work more than "iterate"
  * `std::back_insert_iterator{container}`: `*it = val` will call `push_back(val)` to insert
  * `std:front_insert_iterator{container}`: call `push_front(val)` to insert
  * `std::insert_iterator{container, pos}`: call `insert(pos, val)` to insert
* Notice that inserting/assigning a range directly is usually better than inserting one by one for `vector` or `deque`

### Sequential Container

#### Array

* E.g. `int a[5]` will decay to `int*` when passing to function, and the size information is dropped 以参数的方式传递到函数中会退化成指针，并且大小也被舍弃了
* `std::array<T, size>` the same as `T[size]`. It always preserves size, can copy from another array, and can do more things like bound check
* It's allocated on stack
  * But if you `new std::array`, then it;s still allocated on heap
* 特殊的构造函数需要额外的`{}` e.g. `struct S { int i; int j; }`初始化时是`std::array<S, 2> arr{{ {1, 2}, {3, 4}}}`
  * 第一个`{}`是`array`本身初始化的`{}`
  * 第二个`{}`是数组初始化的`{}`
* For member accessing 成员访问
  * `operator[]`
  * `at()` will check the bound
  * `front()`, `back()`: get the first/last element of vector 首先要保证非空
  * If you want to get the raw pointer of array content, you can use `.data()`
* Additonal methods
  * `.swap()`
  * `operator=`, `operator<=>` 三路比较运算符
  * `.fill()` 将整个数组填充为某个特定值
  * `std::to_array`(C-style array)
* Size operations
  * `.size()`: return `size_t`
  * `empty()`
  * `.max_size()`: get maximum possible size in this system(usually useless)

#### vector

* 动态数组
  * 支持随机访问，占据连续空间
  * When insering and removing elements at the end (i.e. pushing/poping back), the complexity is amoritized（均摊） $O(1)$
  * If not at end, it'll be $O(n)$
* 在 cache 上的效果非常不错，对 cache 利用率非常显著
* 实现思路
  * 准备一部分空间，这样在 pushing 或者 poping 的时候时间复杂度才是$O(1)$
  * 当容量不够的时候在重新分配（reallocation），重分配的均摊复杂度也要求是$O(1)$
  * The element number is called size; total space is called capacity
  * 重分配的策略
    * The easiest strategy is increasing space linearly
      * E.g. 0 -> 4 -> 8 -> 12 -> 16 -> ...
      * Every $k$ operations will trigger reallocation an copy $n = km$ elements
        * So, the amortized complexity is $\Theta(\frac{\sum_{i = 1}^m{ki}}{km}) = \Theta(m) = \Theta(\frac{n}{k})$
        * Considering that $k$ is an constant, this is still $O(n)$
    * So, what about exponentially（指数）?
      * E.g. 1 -> 2 -> 4 -> 8 -> 16 -> 32 -> ...
      * Every $2^k$ operations will trigger reallocation an copy $n = 2^k$ elements
        * So, the amortized complexity is $\Theta(\frac{\sum_{i = 1}^k{2^i}}{2^k}) = \Theta(1)$
    * Finally, why is the exponent 2?
      * 可以证明任何大于 1 的指数最后的均摊复杂度都是$O(1)$
      * This is a trade-off between space and time 空间和时间的权衡
      * In MS（微软）, it's 1.5
  * vector 不会自动的进行缩容（shrink），但是会暴露出接口手动缩容
  * Insert 是从后向前的（move backwards）
  * Removal is similar, but move forwards from the end of deletion to the deletion point, and finally destruct the last several elements
  * `std::initializer_list`
  * For member accessing (same as array)
    * operator[]`, `at()`: accesing by index; `at()` will check th bound, i.e. if the index is greater than size, `std::out_of_range` will be thrown
    * `front()`, `back()`: get the first/last element of vector
    * If you want to get the raw pointer of array content, you can use `.data()`
  * For capacity operations (i.e. adjust memory)
    * `.capacity()`: get capacity (return `size_t`)
    * `.reserve(n)`: 直接分配`n`大小的内存，如果比当前 capacity 小就什么都不做，size 是不会改变的
      * 作用是前提知道需要分配的数量，一次性分配，就不需要有扩容的操作了
    * `.shrink_to_fit`: request to shrink the capacity so that `capacity == size`
  * For size operations
    * `.size()`
    * `.empty()`
    * `.resize(n, obj = Object{})`
    * `.clear()`: remove all things; size will be 0 after this
  * `.push_back(obj)`
  * `.emplace_back(params)`: insert an element constructed by params at the end 就地根据`params`构造元素
    * Since C++ 17, it returns reference of inserted element (before it's `void`)
  * `.pop_back()`
  * `.insert(const_iterator pos, xxx)`
  * `.erase(const_iteraor pos)`, `.erase(const_iterator first, const_iterator last)`: erase a single element/elements from `[first, last)`
    * insert/erase will return next calid iterator of inserted/erase elements
  * Interact with another vector
    * `.assign`
    * `.swap(vec)`
  * Since C++ 23, ranges-related methods are added
    * `.assign_range(Range)`
    * `insert_range(const_iterator pos, Range)`
    * `append_range(Range)`

#### Iterator Invalidation

* 迭代器就是指针的包装，但是指针是不安全的
* 导致不安全的情况
  * reallocation 重分配，造成原来保存的指针悬垂
  * Insertion & removal 插入和删除
* For vector
  * If the capacity changes, all iterators are invalid

    ```c++
    #include<vector>

    int main()
    {
        std::vctorv{1, 2, 3, 4};
        auto it = v.begin();
        v.reserve(10086); // 会导致上一行的`it`失效
        it = v.begin(); // 必须进行重新获取
    }
    ```

  * If the capacity doesn't change, but some elements are moved, iterators after the changed points are invalid

#### Span

* 视图 View means that it doesn't catually hold the data; it observes the data
* Span is a view for contiguous memory (e.g. vector, array, string, C-sytle array initializer list, etc.)
* 可以像 array 一样操控 span
* `.first(N)/.last(N)`
* `.subspan(beginPos(, size))`
* span is just a pointer with a size

#### Dequeue Double-Ended Queue 双端队列

* 最主要的特点就是
  * $O(1)$ on insertion & removal of elements at the front or the back
  * Random access
* Other properties are just like vector
  * `push_front`
  * `emplace_front`
  * `pop_front`
  * `prepend_range` C++ 23
* Circular queue
  * When enqueue, tail moves forward
  * When dequeue, head moves forward
  * If `tail == head` i.e. the queue is full, overwrite the element at head, both tail and head move forward
* Dequeue 相当于动态的循环队列，当队列满的时候需要进行扩容
  * 扩容是做到均摊复杂度是$O(1)$
  * 可以做到随机访问的原理是 e.g. `deque[i]` is just `vec[(head + i) % size]`
* 实现方式
  * 降低拷贝的代价
  * 通常的实现方式是使用动态循环队列（called map），里面的元素是指针
    * 指针指向一个 block，block 中存储对象
    * block 的大小是固定的
  * Dequeue 中的数据结构
    * The map and its size
    * The block size
    * The global offset of the first element `off`
      * We can use `off / block_size` to know the position of head
    * Element nunmbers
  * 重新分配的时候只需要拷贝指针
  * Map reallocation in dequeue
    * 假设新加的 block 的大小是`count`
    * 需要使得循环队列仍然是连续的
      * First, copy all elements from `vec[head, vecEnd]` to `newVec[head, currEnd]`
      * Then, if `head <= count`, copy `[0, head)` to `[currEnd, ...)`
      * Else, copy after `currEnd` as mush as posisble, and the rest is arranged to the `newVecBegin`
      * Finally, set all the rest to `nullptr`
* Dequeue iterator incalidation
  * All iterators are seen as invalid after insertion 插入之后所有的迭代器都是失效的，还包括
    * `resize`
    * `shrink_to_fit`
    * `clear`

#### List

* Double linked list
* Properties
  * $O(1)$ insertion and removal
  * $O(1)$ splice 融合另一个 list 的一部分元素
  * 不支持随机访问
* 每个节点都已一个数据`T data`、`prev`、`next`，并且第一个节点的`prev`指向`nullptr`，最后一个节点的`next`指向`nullptr`
* 微软用循环 list 实现的
  * 引入了哨兵节点 sentinel node，是`prev`指针的前一个节点，`next`指针的后一个节点
  * 不需要特判 nullptr`
* There are two mehods to move nodes from another list
  * 和`insert(pos, it1, it2)`有区别，`insert`只是拷贝，没有清除操作
  * `.merge(list2)/.mearge(list2, cmp)`，通常用在已排序的 list 中
  * `.splice(pos, list2, ...)`
    * `()`: insert the total `list2` to pos
    * `(it2)`: insert `it2` to `pos` (and remove it from `list2`)
    * `(first, last)`: insert `[first, last)` to `pos` (abd remove them from `list2`)

#### Froward list

* Single linked list
* Foward list 的目的是为了减少存储空间，所以不提供`.size()`函数
* 只存储头部节点

#### Container adaptors

* 容器适配器是对已经存在的容器进行包装，通常情况下不提供迭代器

##### Stack

* Stack is a LIFO data structure
* The provide container show have `push_back`, `emplace_back`, `pop_back`, so vector, deque and list are all OK
* APIs
  * `.pop()`
  * `.push(val)`, `.emplace(params)`
  * `.push_range(params)` C++ 23
  * `.top()`
  * `.empty()`, `.size()`
  * `.swap(s2)`
  * `operator=`
  * `operator<=>`

#### Queue

* Queue is a FIFO data structure
* `.front()`
* `.end()`

##### Priority queue

* It's defined in `<queue>`
* It's in fact max heap
  * 插入或者弹出元素的时间复杂度是$O(\mathbf{log} n)$
  * 建堆的时间复杂度是$O(n)$
  * Percolation is the core algorithm
    * 插入的时候进行上滤 precolate up
    * 删除的时候进行下滤 precolate down

##### Flat containers

* The only defect of map/unordered_map/... is that they're rellay cache-unfriendly
* Flat containers 对缓存利用率更高
  * The functionality is same as set/map
  * But it's in fact an ordered "vector"
    * 没有冗余的数据，对 cache 更友好
    * 本质上时两个 "vector"
* The whole definition is `std::flat_map<Key, Value, Compare = std::less<Key>, ContainerForKey = std::vector<Key>, ContainerForValue = std::vector<Value>>`
* 也可以使用 deque 作为容器
* The complexity
  * For lookup, $O(\mathbf{log}N)$ 二分查找
  * For insertion/removal, $O(n)$
  * For `iterator++`, $O(1)$

#### Associative containers

* They're called associative because they associate key with value
  * The value can also be omitted
* There exist ordered one and unordered one
  * 有序的需要比较函数 less than
    * BBST (balanced binary serch tree) 查找、插入、删除的时间复杂度都是$o(\mathbf{log}n)$
      * RB tree
      * AVL
  * 无序的需要提供哈希函数和判断是否相等的函数
    * 查找、插入、删除的时间复杂度都是$o(1)$

##### Map

* The key is unique; a signle key cannot be mapped to multiple values
* `std::map<Key, Value, CMPForKey = std::less<Key>>`
  * 默认是小于号
  * `CMPForKey` should be able to accept `const key`
* For member accessing
  * `operator[]`, `at()`
  * Bidirectional iterators
    * Notice that the worst complexity of `++/--` is $O(\mathbf{log}N)$
    * 对 BBST 进行中序遍历就能得到有序的序列
      * `.begin()` is just the leftmost node and `.rbegin()` is just the rightmost node
* Note
  * `operator[]` will insert a default-constructed value if the key doesn't exits
    * 如果 key 不存在并且默认构造的值也不是真正需要的，用`insert_xxx`效率更高
    * `const map`不能用`operator[]`
    * 如果 value 是不能被默认构造的（例如没有默认构造函数）也是不能用`operator[]`
  * Key-value pair is stored in RB tree, so iterator also points to the pair
  * You can use structured binding to facilitate iteration

```C++
std::map<string::string, int> scoreTable{
    { "Li", 99 },
    { "God Liu", 99 },
    { "Saint Liu", 99 },
    { "Liang", 99 },
};

for (auto& [name, score] : scoreTable)
    std::cout << name << ' ' << score << '\n';
```

* APIs
  * `.lower_bound(key)`: find `it` that `prev(it)->key < key <= it->key`
    * Use key as a lower bound to make `[it, end) >= key`
  * `.lower_bound(key)`: find `it` that `prev(it)->key <= key < it->key`
    * Use key as a lower bound to make `[begin, it) <= key`
  * `.equal_range(key)`: find `it` pair with the same key as `key` in range
  * Insertion
    * 因为键是唯一的，插入的时候如果 key 存在会失败；无论失败成功都返回`pair<iterator, bool>`
      * If succeed, `iterator` refers to inserted element and `bool` is `true`
      * If fail, `iterator` refers to the element with the same key and `bool` is false`
    * 插入失败会有多个处理方式
      * Leave it unchanged
        * `.insert({key, value})`
        * `.emplace(params)`
      * Overwrite it (C++ 17)
        * `.insert_or_assign(key, value)`: return `pair<iterator, bool>`
      * Leave it unchanged and even not contruct the inserted value (C++ 17)
        * `.try_emplace(key, params)`: same as `empalce`, except that the params are used to construct value, and `emplace` is not forbidden to construct the pair in failure 构造 value 时非常昂贵的时候使用
    * You can also provide a hint iterator for insertion
      * hint iteraotr 在被插入元素后面的时候会有效率提升，在前面的话会使效率降低
      * Hint is often used in idiom blow
        
        ```C++
        auto pLoc = someMap.lower_bound(someKey);
        if (pLoc != someMap.end() && !(someMap.Key_comp()(someKey, pLoc->first)))
            return pLoc->second;
        else {
            auto newValue = expensiveCalculation();
            someMap.insert(pLoc, make_pair(someKey, new Value));
            return newValue;
        }
        ```

  * Erasure
    * `.erase(...)`
      * `(key)`
      * `(iterator pos)`
      * `(iterator first, iterator last)`
  * `.extract(key)`, `extract(iterator pos)`: extract out the node from the map
  * `.insert(node_type&&)`: insert the node to the map
  * `.merge(another map/multimap)`

> **Structured binding**
> 
> * Structured binding is just `auto& [...]{ xx }`
>   * `{ xx }` can be `(xx)` or `=xx`
>   * `auto&` can be anything
>   * `xx` can be a pair; it can also be
>     * An object with all public data members, which will be bound on them
>     * A C-style array or `std::array`, which will be bound on elements `arr[i]`
>     * A tuple-like thing, which will be bound on every element
>   * Note
>     * pair and `std::array` is also somewhat tuple-like thing and can use some tuple methods, e.g. `std::get` pair 和`std::array`也可以像 tuple 一样，访问的时候也可以使用访问 tuple 的方法
>     * 结构化绑定时一个新的声明，不能绑定已经存在的变量，如果想绑定已存在的变量可以使用`std::tie(name, score) = pair`
>     * 结构化绑定的本质是匿名结构体，结构体中的变量是别名
> 
>         ```C++
>         std::tuple<int, float> a{ 1, 1.0f };
>         const auto& [b, c] = a;
>         decltype(b) m = 0; // const int m  = 0;
>         ``` 
> 
>     * Structured binding is usually more efficient than novice/careless programmers 建议使用结构化绑定
> 
> **Tuple**
> 
> * `std::tuple<int, float, double> t{1, 2.0f, 3.0};`
> * It can only be accessed by an index that can be determined in compile time 下标访问的下标只能在编译时确定
>   * `std::get<0>(tuple)` to get the `int 1`
>   * C++ 14 可以使用类型获取相应的值，前提是类型不能重复 e.g. `std::get<int>(tuple)`
>   * `std::tuple_cat`
>

##### Set

* Set is just a map without value
* The only difference with amp is that it doesn't have `operator[]` and `.at()`
* The iterator points to only key instead of key-value pair

##### Multimap

* 把 key 的唯一性取消了
* 不能使用`operator[]`和`.at()`
* 相等的值的顺序取决于插入时的顺序
* 插入永远都是成功的
* Nodes of multimap and map can be exchanged 两个容器的节点是可以相互替换的

##### Multiset

* Except for only key and no value, same as multimap
* You can also exchange nodes of multiset and set

##### Unordered map

* `std::unordered_map<Key, Value, Hash = std::hash<key>, Equal = std::equal_to<Key>>`
* Many types have `std::hash<Type>`, e.g. `std::string`, `float`, etc.
* The hash value of different keys may be same, so we need `Equal` to judge which key is wanted
* 微软的实现在解决冲突的时候用双向链表，并且链接相邻的 Bucket 延申出来的双向链表，并添加一个哨兵节点
* 当插入数据太多的时候，每个 bucket 也会链接很多数据
  * 这样会增加查找的复杂度
  * $\frac{\text{size}}{\text{bucket num}}$ is called load factor 装载因子
  * 装载因子过大时，需要对 bucket array 进行扩容
  * Rehash 重哈希
* APIs
  * `.bucket_count()`: size of bucket array
  * `.load_factor()`: `size() / bucket_count()`
  * `.max_load_factor()`: when load factor exceeds this limit, refresh will happen
  * `.rehash(n)`: make `bucket_count() = max(n, ceil(size() / max_load_factor()))` and rehash
  * `.reserve(n)`
  * `.bucket(key)`: get the bucket index of the key
  * `.begin(index)`, `.cbegin(index)`, `.end(index)`, `.cend(index)`: get the iterator of the bucket at index
  * `.bucket_size(index)`: get the size of bucket at index
* You can also extract nodes and insert them