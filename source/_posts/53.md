---
title: 现代 C++基础
toc: true
date: 2024-06-03 14:11:57
categories: C++
tags:
- C++
- 现代 C++
mathjax: true
sticky: 600
---

### Basics Review

#### Array Type

* Multidimensional array 多维数组
  * 除了第一维其它维必须明确指出大小（explicit size）
  * 不可以全部 decay
  * Dynamic allocation
    * `malloc` in C and `new`/`new []` in C++
    * `new`和`malloc`返回都是指针
    * 释放

#### Function

* 函数返回类型不能是函数或者数组（但是可以是它们的引用）
  * 不应该返回局部变量的指针或者引用（超出了局部变量生命周期的范围）
    * e.g. `int& Test() { int a = 1; return &a; }`
  * 声明为`static`的局部变量具有全局性
* Function pointers 函数指针
  * `void(*)(int)`
  * clockwise/spiral rule
  * Type alias 用 C++ 11 中的`using`
  
    ```C++
    using MyFuncType1 = int(*)(float);
    using MyFuncType2 = int(*)(int);
    using MyFuncType3 = int(*)(MyFuncType1);
    ``` 

  * C 语言中可以用`typedef`，但是没有`using`强大

#### Attribute

* `[[attribute]]` C++ 11，`[[attribute("reason")]]` C++ 20
* `[[deprecated]]`和`[[deprecated("reason")]]` C++ 14
* `[[noreturn]]` C++ 11
* `[[maybe_unused]]` C++ 17

e.g.

```C++
[[nodiscard]] int Add(int a, int b) { return a + b; }

int main()
{
    Add(1, 2); // int res = Add(1, 2);
    return 0
}
```

warning: 放弃具有 [[nodiscard]] 属性函数的返回值

#### Enumeration

> 一个被限制取值的类

* 比较像使用全局变量
* 同时进行整形运算也没有安全检查
* C++ 11 引入了 scoped enumeration 提高安全性

e.g.

```C++
// enum Day { Monday };
enum class Day { Monday };

int main()
{
    // int a = Monday;
    Day a = Day::Monday
    return 0;
}
```

* 可以使用`std::underlying_type<Day>::type`或者`std::underlying_type_t<Day>` C++ 14 转成整数类型
  * C++ 23 中也可以使用`std::to_underlying<Day>(day)`
* 可以使用`Day day{1};` 初始化 C++ 17，但是不能直接赋值`Day day = 1;`或`day = 1;`
* 可以使用位操作符

#### Expression

* 运算符和表达式三个重要概念
  * Precedence 优先级
  * Associativity 结合性
  * Order 顺序
* From the view of compiler, an expressiong is in fact a tree, determined by associativity and precedence. e.g. `9 / 3 / 2 + 2 * 3`
  * Precedence is used to split terms first.
  * Associativity determines how the tree will grow.
  * Then, it's order of expression evaluation that computes the whole tree. 但是顺序是不确定的
    * `f1() + f2() + f3()`，`f1()`，`f1()`，`f1()`哪一个先被 evaluated 是不确定的
* There are some rules
  * For `&&` and `||`, since they have short-circuit property, the first part will be fully evaluated.
  * For a function call, all parameters (including `a` for e.g. `a.Func()` or `a->Func()`) are fully evaluated before entering the function.
  * 三目运算
  * 逗号表达式
  * C++ 17
    * Parameters in function are evaluated indeterminately, i.e. every sub-tree represneted by te parameter is fully evaluated in a **non-overlap** way 不会以交叠的形式 evaluated
    * 运算符重载，和 build-in 运算符的 evaluated 顺序一致，而不是被当作普通函数
    * More useful examples: chained call
  
```C++
std::string s = "I have it even works if you don't believe";
s.replace(0, 8, "").replace(s.find("even"), 4, "sometimes").replace(s.find("you don't"), 9, "I");
```

### class

#### Ctor & Dtor

* 拷贝构造函数
* 赋值构造函数
* The recommended way is member initializer list:
  * `member1{ ... }, member2{ ... }, ... { /* function body */ }`
  * `{}` is used since C++ 11
* 默认构造函数建议使用`Class() = default;`
* 如果成员变量有默认值，就不建议使用上面的构造函数的形式，而是直接用默认值初始化

#### Initialization of Object

* Since C++ 11, Uniform Initialization is introduced
  * 所有的初始化都可以用`{}`
  * 相比于`()`更安全 Narrowing Conversion 缩窄变换检查
    * the converted type cannot represent all values
      * `uint32_t`类型用`uint16_t`初始化，编译器会报错
    * the facilitates type safety
* Value initialization: No parameter for initialization `T a()`， `T a{}`， `new T{}`， `new T()`
* Direct initialization: `T a(x, y, ...)`，`T(x, y, ...)`，`new T(x, y, ...)`，`T a{x, y, ...}`
* Copy initialization: `T a = xx;`，`T a[] = { xx, ... };`
  * Ctors that use `explicit` cannot use this way
  * Before C++ 17, this also requires available copy ctor.
  
```C++
class A { public: explicit A(int a) {} };
void Func(A a) {}
int main()
{
    A a = 1;    // error
    A a = A(1);
    Func(1);    // error
    Func(A(1)); 
    return 0
}
```

* List initialization
* Aggregate initialization

#### Member Functions

* 所有的成员函数都隐式有一个`this`指针
* 如果期望函数不能更改成员变量，可以使用`const`关键字 make `this` to be `const`
* 静态成员函数
  * 没有`this`指针

#### Access Control

* `private`、`protected`、`public`，默认是`private`
* `protected`用在继承中
* 友元

#### Inheritance

* 子类/派生类、父类/基类
* 子类/派生类可以访问父类中所有`public`和`protected`成员
* 继承和组合
* 派生类可以隐式的转化成基类

#### Polymorphism 多态

* you can use the base class to load the derived object and call tis own methods 使用基类的指针/引用，承载派生类的对象，从而调用派生类的方法
* virtual pointer and virtual table
* Every object whose class has a virtal method will have a virtual pointer, which points to virtual table of its class 每个类中都有一个指向虚表的指针，虚表内容就是声明为`virtual`函数的地址
* In C++ 11, it's recommended to use `override` 子类没有`override`编译器会报错
* `final` It means override, and the derived class cannot override again 继承链中的最后一个节点
  * `class A final { ... };` 让类不能被继承
  * 去虚化，编译优化
* `abstract class` 抽象类
  * 抽象类不能被实例化
  * 可以是使用抽象类的指针，指向的都是派生类的对象
  * C++通过纯虚函数实现抽象类 `virtual void PrintInfo() const = 0;`
  * 派生类继承自抽象类必须实现纯虚函数，否则仍然是抽象类
  * Don't call **any** virtual function and any functoin that calls virtual function in ctor & dtor 在构造函数和析构函数中不要调用任何虚函数，也不要掉调用任何可能调用虚函数的函数
  * You should usually make dtor of base class `virtual` 通常将析构函数声明为虚函数
    * deleting `Base*` that cast from `Derived*` will lead to correct dtor 派生类指针赋给基类，当调用`delete`时，如果不基类不是虚析构函数，就会调用基类的析构函数
  * 构造函数不能是纯虚函数

#### Some Covert Facts in Inheritance

* `override`不止表示复写虚函数的含义，对于非虚函数的复写也叫“override”
* `private` inheritance usually denotes the relation of **has-a**
* 虚函数的返回类型可以有些许改变：you can use `Base*` to both accept `Base*` and `Derived*` 复写虚函数的返回值可以是指向基类的指针，也可以是指向派生类的指针
  * 智能指针不能有“协变”
* 当虚方法有默认参数的时候，用什么类型的指针调用时，就会返回该类型内的默认值
  * 默认的参数在编译期间被识别，虚表是在运行时跳转的

e.g.

```C++
void Parent::Go(int i = 2) { std::cout << "Base's go with i = " << i << "\n"; }
void Child::Go(int i = 4) { std::cout << "Derived's go with i = " << i << "\n"; }

Child child;
child.Go(); // Derived's go with i = 4
Parent& childRef = child;
childRef.Go();  // Base's go with i = 2
```

* 可以更改虚方法的访问属性（但是不建议）

### `struct`

* 和`class`基本上一样，除了`struct`默认的访问控制是`public`
  * 不应该有成员函数，最多有 ctor、dtor 和运算符重载
  * With these constraints (except for ctor), `struct` will be an aggregate, which can use aggregate initialization
    * Since C++ 20, aggregate can also use **designated initialization** 指定初始化

e.g.

```C++
struct Priority { int cal; }
struct Point
{
    int x, y;
    Priority priority[2];
}

int main()
{
    Point p{ .x = 1, .y = 2, .priority = { { .val = 1}, { .val = 2 } } };
    return 0;
}
```

### Function Overloading 函数重载

* C++ 中就是相同的函数名不同的参数
  * C 中是禁止的
* This is done by compilers using a technique called **name mangling**
* Operator Overloading 运算符重载
  * `+`，`-`，`*`，`/`，`%`，`|`，`&`，`^`，`<<`，`>>`：推荐使用在全局函数中
  * `+=`，`-=`，`*=`，`/=`，`|=`，`&=`，`^=`，`<<=`，`>>=`：必须是成员函数 since the first operand must be a "named" object; return reference (i.e. `*this`)
  * Prefix`++` & Prefix`--`：必须是成员函数 return `*this`
  * Postfix`++` & Postfix`--` have an unused parameter int, which is used to distinguish the prefix and postfix
  * `*`，`->`：usually used in e.g. some wrapper of pointers
  * `&&`，`||`：short-circuit 特性会失效
  * `<=>`：三路比较运算符
  * `()`
  * `[]`
    * Since C++ 23, you can use multidimensional subscript in `operator[]`

### Lambda Expression

* 本质上是一个匿名的`struct`，重载了`operator() const`方法
* Basic format: `auto func = [captures](params) -> ReturnType { function body; };`
  * Captures are actually members of the `struct`
  * ReturnType, params and function are for `operator()`
  * Every lambda expression has its unique type
  * 不传任何参数`()`可以省略掉
* 建议将 Lambda 表达式中的捕获的东西明确写出来
* static 和 global 变量是不需要被捕获的
* 捕获`this`指针
  * `this` by reference, since only copy pointer
  * `*this` really copy all members
  * 包括私有成员也可以捕获
* You may add specifiers after `()`
  * `mutable`: since C++ 17, remove `const` in `operator()`
  * `static`: since C++ 23, same as `static operator()`
  * `constexpr`、`consteval`、`noexcept`

```C++
int main()
{
    int i = 0;
    auto m = [i] {i = 1; return 0; }; // 不允许修改 i = 1，因为重载的 operator() 是 const
    auto m = [i]() mutable {i = 1; return 0; }; // 修改的不是外面定义的变量，本质上修改的是 i 的拷贝
}
```

* It's also legal to add attributes between `[]` and `()`
* 函数也可以写成 Lambda 表达式的形式 `auto Foo(params) -> ReturnType { function body; }`

Code Block With Initializer

```C++
auto it = table.find(1);
if (it == table.end())
    //
else
    //
```

* `it`会泄露出去，下面如果继续判断会再定义迭代器类型的变量
* Since C++ 17, you mey code like

```C++
if (auto it = table.find(1); it == table.end())
    //
else
    //
```

* Since C++ 20, range-based for loop can also add an additional initializer, e.g. `for (auto vec = GetVec(); auto& m : vec);`
* Since C++ 23, type alias declaration can also be initializer, e.g. `if (using T = xx; ...)`

### Template

* Since C++ 17, CATD(class template argument deduction) is introduced, meaning that the argument of ctor can deduce the template parameter of class. e.g. `std::vector v{1, 2, 3, 4}`
* Lambda expression can also use template

## Container

* `std::size_t`: the type of `sizeof()` 意味着对象的大小不能超过`std::size_t`所表示的范围
  * 也意味着数组的大小不能超过`std::size_t`所表示的范围
  * 容器的大小也不能超过`std::size_t`
* `std::ptrdiff_t`：两个指针相减得到的类型

### Iterators

* Input/Output iterator
  * For output `*it = val`, `it++`, `++it`, 'it1 = it2'
  * For input `==`, `!=`, `->`
* Forward iterator: e.g. linked list
* Bidirectional iterator: `--it`, `it--` e.g. double linked list, map
* Random access iterator: `+`, `-`, `+=`, `-=`, `[]`, `<`, `>`, `<=`, `>=`, `!=` e.g. deque
* Contiguous iterator (since C++ 17): 保证地址空间是连续的
* **IMPORTANT**: Iterator are as unsafe as pointers 线程不安全的
* All containers can get their iterators by:
  * `.begin()`, `.end()`
  * `.cbegin()`, `cend()` read-only access
* 双向链表等还提供了倒序的遍历迭代器
  * `.rbegin()`, `.rend()`, `.crbegin()`, `crend()`
* 还可以使用全局的方法得到迭代器
  * `std::begin(vec)`, `std::end(vec)`
  * C++ 20 建议使用`std::ranges::begin`
  * 只有类似`int arr[5]`传入到`std::begin()`或`std::end()`中才有效，指针传入进来是无效的
* There are also general methods of iterator operations, defined in `<iterator>`
  * `std::advance(InputIt& it, n)`: `it += n`
  * `std::next(InputIt it, n = 1)`: `return it + n`
  * `std::prev(InputIt it, n = 1)`: `return it - n`
  * `std::distance(InputIt it1, InputIt it2)`: `return it2 - it1` 不同的容器时间复杂度不一样

#### Iterator traits（显著的特点，特征）

* Iterators provide some types to show their information:
  * `value_type`: The type of elements referred to
  * `difference_type`: The type that can be used to represent the distance between elements (usually `ptrdiff_t`) 迭代器之间的距离所表示的类型，一般就是`ptrdiff_t`
  * `iterator_category`: e.g. `input_iterator_tag`, `continuous_iterator_tag`
  * `pointer` & `reference`: only available in container iterators 只有在容器中才会有的特性
    * 可以使用`std::iterator_traits<IteratorType>::xxx`获取

#### Stream iterator

* `std::istream_iterator<T>` & `std:ostream_iterator<T>`
* The default constructed `istream_iterator` is `end()` 默认的构造函数表示终止的迭代器

#### Iterator adaptor

有两种类型的迭代器适配器

* One is created from iterators to preform different utilities:
  * E.g. reversed iterators 反向迭代器，++ 的本质上是 --，所以可以用`begin()`初始化，即`std:::reverse_iterator r{ p.begin() }`
  * You can get the underlying iterator by `.base()`, which actually returns the iterator that points to the elements after the referred one 调用`.base()`实际上是指向当前指向位置的下一个元素
    * `rbegin().base() == end()`
* Another is created from containers to work more than "iterate"
  * `std::back_insert_iterator{container}`: `*it = val` will call `push_back(val)` to insert
  * `std:front_insert_iterator{container}`: call `push_front(val)` to insert
  * `std::insert_iterator{container, pos}`: call `insert(pos, val)` to insert
* Notice that inserting/assigning a range directly is usually better than inserting one by one for `vector` or `deque`

### Sequential Container

#### Array

* E.g. `int a[5]` will decay to `int*` when passing to function, and the size information is dropped 以参数的方式传递到函数中会退化成指针，并且大小也被舍弃了
* `std::array<T, size>` the same as `T[size]`. It always preserves size, can copy from another array, and can do more things like bound check
* It's allocated on stack
  * But if you `new std::array`, then it;s still allocated on heap
* 特殊的构造函数需要额外的`{}` e.g. `struct S { int i; int j; }`初始化时是`std::array<S, 2> arr{{ {1, 2}, {3, 4}}}`
  * 第一个`{}`是`array`本身初始化的`{}`
  * 第二个`{}`是数组初始化的`{}`
* For member accessing 成员访问
  * `operator[]`
  * `at()` will check the bound
  * `front()`, `back()`: get the first/last element of vector 首先要保证非空
  * If you want to get the raw pointer of array content, you can use `.data()`
* Additonal methods
  * `.swap()`
  * `operator=`, `operator<=>` 三路比较运算符
  * `.fill()` 将整个数组填充为某个特定值
  * `std::to_array`(C-style array)
* Size operations
  * `.size()`: return `size_t`
  * `empty()`
  * `.max_size()`: get maximum possible size in this system(usually useless)

#### vector

* 动态数组
  * 支持随机访问，占据连续空间
  * When insering and removing elements at the end (i.e. pushing/poping back), the complexity is amoritized（均摊） $O(1)$
  * If not at end, it'll be $O(n)$
* 在 cache 上的效果非常不错，对 cache 利用率非常显著
* 实现思路
  * 准备一部分空间，这样在 pushing 或者 poping 的时候时间复杂度才是$O(1)$
  * 当容量不够的时候在重新分配（reallocation），重分配的均摊复杂度也要求是$O(1)$
  * The element number is called size; total space is called capacity
  * 重分配的策略
    * The easiest strategy is increasing space linearly
      * E.g. 0 -> 4 -> 8 -> 12 -> 16 -> ...
      * Every $k$ operations will trigger reallocation an copy $n = km$ elements
        * So, the amortized complexity is $\Theta(\frac{\sum_{i = 1}^m{ki}}{km}) = \Theta(m) = \Theta(\frac{n}{k})$
        * Considering that $k$ is an constant, this is still $O(n)$
    * So, what about exponentially（指数）?
      * E.g. 1 -> 2 -> 4 -> 8 -> 16 -> 32 -> ...
      * Every $2^k$ operations will trigger reallocation an copy $n = 2^k$ elements
        * So, the amortized complexity is $\Theta(\frac{\sum_{i = 1}^k{2^i}}{2^k}) = \Theta(1)$
    * Finally, why is the exponent 2?
      * 可以证明任何大于 1 的指数最后的均摊复杂度都是$O(1)$
      * This is a trade-off between space and time 空间和时间的权衡
      * In MS（微软）, it's 1.5
  * vector 不会自动的进行缩容（shrink），但是会暴露出接口手动缩容
  * Insert 是从后向前的（move backwards）
  * Removal is similar, but move forwards from the end of deletion to the deletion point, and finally destruct the last several elements
  * `std::initializer_list`
  * For member accessing (same as array)
    * operator[]`,`at()`: accessing by index; `at()` will check th bound, i.e. if the index is greater than size, `std::out_of_range` will be thrown
    * `front()`, `back()`: get the first/last element of vector
    * If you want to get the raw pointer of array content, you can use `.data()`
  * For capacity operations (i.e. adjust memory)
    * `.capacity()`: get capacity (return `size_t`)
    * `.reserve(n)`: 直接分配`n`大小的内存，如果比当前 capacity 小就什么都不做，size 是不会改变的
      * 作用是前提知道需要分配的数量，一次性分配，就不需要有扩容的操作了
    * `.shrink_to_fit`: request to shrink the capacity so that `capacity == size`
  * For size operations
    * `.size()`
    * `.empty()`
    * `.resize(n, obj = Object{})`
    * `.clear()`: remove all things; size will be 0 after this
  * `.push_back(obj)`
  * `.emplace_back(params)`: insert an element constructed by params at the end 就地根据`params`构造元素
    * Since C++ 17, it returns reference of inserted element (before it's `void`)
  * `.pop_back()`
  * `.insert(const_iterator pos, xxx)`
  * `.erase(const_iteraor pos)`, `.erase(const_iterator first, const_iterator last)`: erase a single element/elements from `[first, last)`
    * insert/erase will return next calid iterator of inserted/erase elements
  * Interact with another vector
    * `.assign`
    * `.swap(vec)`
  * Since C++ 23, ranges-related methods are added
    * `.assign_range(Range)`
    * `insert_range(const_iterator pos, Range)`
    * `append_range(Range)`

#### Iterator Invalidation

* 迭代器就是指针的包装，但是指针是不安全的
* 导致不安全的情况
  * reallocation 重分配，造成原来保存的指针悬垂
  * Insertion & removal 插入和删除
* For vector
  * If the capacity changes, all iterators are invalid

    ```c++
    #include<vector>

    int main()
    {
        std::vctorv{1, 2, 3, 4};
        auto it = v.begin();
        v.reserve(10086); // 会导致上一行的`it`失效
        it = v.begin(); // 必须进行重新获取
    }
    ```

  * If the capacity doesn't change, but some elements are moved, iterators after the changed points are invalid

#### Span

* 视图 View means that it doesn't catually hold the data; it observes the data
* Span is a view for contiguous memory (e.g. vector, array, string, C-sytle array initializer list, etc.)
* 可以像 array 一样操控 span
* `.first(N)/.last(N)`
* `.subspan(beginPos(, size))`
* span is just a pointer with a size

#### Dequeue Double-Ended Queue 双端队列

* 最主要的特点就是
  * $O(1)$ on insertion & removal of elements at the front or the back
  * Random access
* Other properties are just like vector
  * `push_front`
  * `emplace_front`
  * `pop_front`
  * `prepend_range` C++ 23
* Circular queue
  * When enqueue, tail moves forward
  * When dequeue, head moves forward
  * If `tail == head` i.e. the queue is full, overwrite the element at head, both tail and head move forward
* Dequeue 相当于动态的循环队列，当队列满的时候需要进行扩容
  * 扩容是做到均摊复杂度是$O(1)$
  * 可以做到随机访问的原理是 e.g. `deque[i]` is just `vec[(head + i) % size]`
* 实现方式
  * 降低拷贝的代价
  * 通常的实现方式是使用动态循环队列（called map），里面的元素是指针
    * 指针指向一个 block，block 中存储对象
    * block 的大小是固定的
  * Dequeue 中的数据结构
    * The map and its size
    * The block size
    * The global offset of the first element `off`
      * We can use `off / block_size` to know the position of head
    * Element nunmbers
  * 重新分配的时候只需要拷贝指针
  * Map reallocation in dequeue
    * 假设新加的 block 的大小是`count`
    * 需要使得循环队列仍然是连续的
      * First, copy all elements from `vec[head, vecEnd]` to `newVec[head, currEnd]`
      * Then, if `head <= count`, copy `[0, head)` to `[currEnd, ...)`
      * Else, copy after `currEnd` as mush as posisble, and the rest is arranged to the `newVecBegin`
      * Finally, set all the rest to `nullptr`
* Dequeue iterator incalidation
  * All iterators are seen as invalid after insertion 插入之后所有的迭代器都是失效的，还包括
    * `resize`
    * `shrink_to_fit`
    * `clear`

#### List

* Double linked list
* Properties
  * $O(1)$ insertion and removal
  * $O(1)$ splice 融合另一个 list 的一部分元素
  * 不支持随机访问
* 每个节点都已一个数据`T data`、`prev`、`next`，并且第一个节点的`prev`指向`nullptr`，最后一个节点的`next`指向`nullptr`
* 微软用循环 list 实现的
  * 引入了哨兵节点 sentinel node，是`prev`指针的前一个节点，`next`指针的后一个节点
  * 不需要特判 nullptr`
* There are two mehods to move nodes from another list
  * 和`insert(pos, it1, it2)`有区别，`insert`只是拷贝，没有清除操作
  * `.merge(list2)/.mearge(list2, cmp)`，通常用在已排序的 list 中
  * `.splice(pos, list2, ...)`
    * `()`: insert the total `list2` to pos
    * `(it2)`: insert `it2` to `pos` (and remove it from `list2`)
    * `(first, last)`: insert `[first, last)` to `pos` (abd remove them from `list2`)

#### Froward list

* Single linked list
* Foward list 的目的是为了减少存储空间，所以不提供`.size()`函数
* 只存储头部节点

### Container adaptors

* 容器适配器是对已经存在的容器进行包装，通常情况下不提供迭代器

#### Stack

* Stack is a LIFO data structure
* The provide container show have `push_back`, `emplace_back`, `pop_back`, so vector, deque and list are all OK
* APIs
  * `.pop()`
  * `.push(val)`, `.emplace(params)`
  * `.push_range(params)` C++ 23
  * `.top()`
  * `.empty()`, `.size()`
  * `.swap(s2)`
  * `operator=`
  * `operator<=>`

### Queue

* Queue is a FIFO data structure
* `.front()`
* `.end()`

#### Priority queue

* It's defined in `<queue>`
* It's in fact max heap
  * 插入或者弹出元素的时间复杂度是$O(\mathbf{log} n)$
  * 建堆的时间复杂度是$O(n)$
  * Percolation is the core algorithm
    * 插入的时候进行上滤 precolate up
    * 删除的时候进行下滤 precolate down

#### Flat containers

* The only defect of map/unordered_map/... is that they're rellay cache-unfriendly
* Flat containers 对缓存利用率更高
  * The functionality is same as set/map
  * But it's in fact an ordered "vector"
    * 没有冗余的数据，对 cache 更友好
    * 本质上是两个 "vector"
* The whole definition is `std::flat_map<Key, Value, Compare = std::less<Key>, ContainerForKey = std::vector<Key>, ContainerForValue = std::vector<Value>>`
* 也可以使用 deque 作为容器
* The complexity
  * For lookup, $O(\mathbf{log}N)$ 二分查找
  * For insertion/removal, $O(n)$
  * For `iterator++`, $O(1)$

### Associative containers

* They're called associative because they associate key with value
  * The value can also be omitted
* There exist ordered one and unordered one
  * 有序的需要比较函数 less than
    * BBST (balanced binary serch tree) 查找、插入、删除的时间复杂度都是$o(\mathbf{log}n)$
      * RB tree
      * AVL
  * 无序的需要提供哈希函数和判断是否相等的函数
    * 查找、插入、删除的时间复杂度都是$o(1)$

#### Map

* The key is unique; a signle key cannot be mapped to multiple values
* `std::map<Key, Value, CMPForKey = std::less<Key>>`
  * 默认是小于号
  * `CMPForKey` should be able to accept `const key`
* For member accessing
  * `operator[]`, `at()`
  * Bidirectional iterators
    * Notice that the worst complexity of `++/--` is $O(\mathbf{log}N)$
    * 对 BBST 进行中序遍历就能得到有序的序列
      * `.begin()` is just the leftmost node and `.rbegin()` is just the rightmost node
* Note
  * `operator[]` will insert a default-constructed value if the key doesn't exits
    * 如果 key 不存在并且默认构造的值也不是真正需要的，用`insert_xxx`效率更高
    * `const map`不能用`operator[]`
    * 如果 value 是不能被默认构造的（例如没有默认构造函数）也是不能用`operator[]`
  * Key-value pair is stored in RB tree, so iterator also points to the pair
  * You can use structured binding to facilitate iteration

```C++
std::map<string::string, int> scoreTable{
    { "Li", 99 },
    { "God Liu", 99 },
    { "Saint Liu", 99 },
    { "Liang", 99 },
};

for (auto& [name, score] : scoreTable)
    std::cout << name << ' ' << score << '\n';
```

* APIs
  * `.lower_bound(key)`: find `it` that `prev(it)->key < key <= it->key`
    * Use key as a lower bound to make `[it, end) >= key`
  * `.lower_bound(key)`: find `it` that `prev(it)->key <= key < it->key`
    * Use key as a lower bound to make `[begin, it) <= key`
  * `.equal_range(key)`: find `it` pair with the same key as `key` in range
  * Insertion
    * 因为键是唯一的，插入的时候如果 key 存在会失败；无论失败成功都返回`pair<iterator, bool>`
      * If succeed, `iterator` refers to inserted element and `bool` is `true`
      * If fail, `iterator` refers to the element with the same key and `bool` is false`
    * 插入失败会有多个处理方式
      * Leave it unchanged
        * `.insert({key, value})`
        * `.emplace(params)`
      * Overwrite it (C++ 17)
        * `.insert_or_assign(key, value)`: return `pair<iterator, bool>`
      * Leave it unchanged and even not contruct the inserted value (C++ 17)
        * `.try_emplace(key, params)`: same as `empalce`, except that the params are used to construct value, and `emplace` is not forbidden to construct the pair in failure 构造 value 非常昂贵的时候使用
    * You can also provide a hint iterator for insertion
      * hint iteraotr 在被插入元素后面的时候会有效率提升，在前面的话会使效率降低
      * Hint is often used in idiom blow
        
        ```C++
        auto pLoc = someMap.lower_bound(someKey);
        if (pLoc != someMap.end() && !(someMap.Key_comp()(someKey, pLoc->first)))
            return pLoc->second;
        else {
            auto newValue = expensiveCalculation();
            someMap.insert(pLoc, make_pair(someKey, new Value));
            return newValue;
        }
        ```

  * Erasure
    * `.erase(...)`
      * `(key)`
      * `(iterator pos)`
      * `(iterator first, iterator last)`
  * `.extract(key)`, `extract(iterator pos)`: extract out the node from the map
  * `.insert(node_type&&)`: insert the node to the map
  * `.merge(another map/multimap)`

> **Structured binding**
> 
> * Structured binding is just `auto& [...]{ xx }`
>   * `{ xx }` can be `(xx)` or `=xx`
>   * `auto&` can be anything
>   * `xx` can be a pair; it can also be
>     * An object with all public data members, which will be bound on them
>     * A C-style array or `std::array`, which will be bound on elements `arr[i]`
>     * A tuple-like thing, which will be bound on every element
>   * Note
>     * pair and `std::array` is also somewhat tuple-like thing and can use some tuple methods, e.g. `std::get` pair 和`std::array`也可以像 tuple 一样，访问的时候也可以使用访问 tuple 的方法
>     * 结构化绑定时一个新的声明，不能绑定已经存在的变量，如果想绑定已存在的变量可以使用`std::tie(name, score) = pair`
>     * 结构化绑定的本质是匿名结构体，结构体中的变量是别名
> 
>         ```C++
>         std::tuple<int, float> a{ 1, 1.0f };
>         const auto& [b, c] = a;
>         decltype(b) m = 0; // const int m  = 0;
>         ``` 
> 
>     * Structured binding is usually more efficient than novice/careless programmers 建议使用结构化绑定
> 
> **Tuple**
> 
> * `std::tuple<int, float, double> t{1, 2.0f, 3.0};`
> * It can only be accessed by an index that can be determined in compile time 下标访问的下标只能在编译时确定
>   * `std::get<0>(tuple)` to get the `int 1`
>   * C++ 14 可以使用类型获取相应的值，前提是类型不能重复 e.g. `std::get<int>(tuple)`
>   * `std::tuple_cat`
>

#### Set

* Set is just a map without value
* The only difference with amp is that it doesn't have `operator[]` and `.at()`
* The iterator points to only key instead of key-value pair

#### Multimap

* 把 key 的唯一性取消了
* 不能使用`operator[]`和`.at()`
* 相等的值的顺序取决于插入时的顺序
* 插入永远都是成功的
* Nodes of multimap and map can be exchanged 两个容器的节点是可以相互替换的

#### Multiset

* Except for only key and no value, same as multimap
* You can also exchange nodes of multiset and set

#### Unordered map

* `std::unordered_map<Key, Value, Hash = std::hash<key>, Equal = std::equal_to<Key>>`
* Many types have `std::hash<Type>`, e.g. `std::string`, `float`, etc.
* The hash value of different keys may be same, so we need `Equal` to judge which key is wanted
* 微软的实现在解决冲突的时候用双向链表，并且链接相邻的 Bucket 延申出来的双向链表，并添加一个哨兵节点
* 当插入数据太多的时候，每个 bucket 也会链接很多数据
  * 这样会增加查找的复杂度
  * $\frac{\text{size}}{\text{bucket num}}$ is called load factor 装载因子
  * 装载因子过大时，需要对 bucket array 进行扩容
  * Rehash 重哈希
* APIs
  * `.bucket_count()`: size of bucket array
  * `.load_factor()`: `size() / bucket_count()`
  * `.max_load_factor()`: when load factor exceeds this limit, refresh will happen
  * `.rehash(n)`: make `bucket_count() = max(n, ceil(size() / max_load_factor()))` and rehash
  * `.reserve(n)`
  * `.bucket(key)`: get the bucket index of the key
  * `.begin(index)`, `.cbegin(index)`, `.end(index)`, `.cend(index)`: get the iterator of the bucket at index
  * `.bucket_size(index)`: get the size of bucket at index
* You can also extract nodes and insert them

## Ranges

* Using ranges is very like functional programming
* There are three important components in ranges:
  * Range: A type provides a begin iterator and end sentinel, so that it can be iterated over
  * View: A range that can be moved in $O(1)$, copied in $O(1)$ (or cannot be copied) and destructed in $O(1)$
  * Range adaptor
* Note
  * Range 可以按照迭代器进行分类
  * 计算是惰性计算
* They're all defined in `<range>`; all views are defines as `std::ranges::xx_view`, and all range adaptors are defined as `std::views::xx`
  * 一般用别名来简化定义`namespace stdr = std::ranges`和`namespace stdv = std::views`
  * `stdr::iota_view{lower, upper = INF}`, `stdv::iota(lower, upper = INF)`: 和 python 中的`range(a, b)`类似

  ```C++
  for (const auto oddNum : stdv::iota(1, 10)
    | stdv::filter([](int num) { return num % 2 == 1; })
    | stdv::take(3))
  {
      std::cout << oddNum << '';
  }
  ```

* Writable
  * `stdv::filter(Pred)`: drop the element if the predicate function `Pred` returns `false`
  * `stdv::take(x)`: take first `x` elements (but not exceed `end`)
  * `stdv::take_while(Pred)`: take elements until `Pred` return `false` (or `end`)
  * `stdv::drop(x)`: drop first `x` elements
  * `stdv::drop_while(Pred)`: drop elements unitl `Pred` returns `false`
  * `stdv::reverse`
  * `stdv::keys`: get the first element from a tuple-like thing
  * `stdv::values`
  * `stdv::elements<i>`: get the `i`th elemnt from a tuple-like thing
  * `stdv::stride(k)`: use `k` as stride to iterate
    * e.g. `stdv::iota(1, 0) | stdv::stride(2)` gets `{1, 3, 5, 7, 9}`
  * `stdv::join`: flattens the ranges to a single range 需要用`|`连接
  * `stdv::join_with(xx)`: fill the interval with `xx` 需要用`|`连接
  * `stdv::zip(r1, r2, ...)`: zip values from ranges to a tuple
  * `stdv::cartesian_product(r1, r2, ...)`: return a tuple of elements from the cartesian product of these ranges
  * `stdv::enumerate`: return `std::tuple<Integer, T&>`; Integer is index whose tpe is diff typr of iterator
  * `stdv::slide(width)`: slide the range in a sliding window of `width`
    * e.g. `std::vector v{1, 2, 3, 4, 5}; v | stdv::slide(3)` gets `{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}`
  * `stdv::adjacent<width>`: same as `stdv::slide(width)`
  * `stdv::pairwise`: i.e. stdv::adjacent<2>
  * `stdv::chunk(width)`: partition the range by `width`
  * `stdv::chunj_by(pred2)`: partition the range by `pred2`, i.e. a view sill stop when `pred2(*it, *next(it))` return `false`
  * `stdv::split(xx)`
  * `stdv::lazy_split(xx)`
* Read-only
  * Either make the view const, i.e. `std::as_const`; this will return `const T&` or `tuple<const T&, ...>`
  * Or return value, i.e. transform-related, which will return `T` or `tuple<T, ...>`
    * `stdv::zip_transform(TransformN, r1, r2, ...)`: return a view of `TransformN(ele1, ele2, ...)`
    * `stdv::adjacent_transform<N>(TransformN)`: return a view of `TransformN(...)`, where `...` is the elements of the sliding windows
    * `stdv::transform(Transform)`: transform element to another element
      
      ```C++
      std::vector<int> v{ 1, 2, 3, 4, 5 };
      int cnt = 0;
      auto r = v | stdv::transform([&cnt](const int ele) {
          std::cout << std::format("cnt={}, ele={}\n", cnt, ele);
          cnt++;
          return cnt + ele;
      }) | stdv::take_while([](const int ele) { return ele < 10; });
      for (const auto& i : r);
      // output:
      // cnt=0, ele=1
      // cnt=1, ele=1
      // cnt=2, ele=2
      // cnt=3, ele=2
      // cnt=4, ele=3
      // cnt=5, ele=3
      // cnt=6, ele=4
      ```

      * `++` will trigger transfrom since `take_while` needs the transformed value to advance the iterator (i.e. by `Pred(*it)`)
      * `const auto& ele = *it` will trigger it again
      * That's because the result doesn't reference some existing elements, but generate from temporary; every time you need it, lazy evaluation generate it again 太 lazy 了
      * Sometimes, you may want to convert a range to a e.g. container, which needs to eagerly evaluate all
        * `stdr::to`, e.g. `stdr::to<std::vector>()`
* There are also some naïve range factories
  * `stdv::single(obj)`: make a view that copies/moves an object, i.e. the view owns only a single element
  * `stdv::empty<T>`: create an empty view
  * `stdv::repeat(r, k = INF)`: repeat a range `r` for `k` times, i.e. like a range `[r, r, r, ...]`
  * `stdv::istream<xxx>(stream)`: similar to `istream_iterator`; it caches value
  * `stdr::subrange(first, last)`

## Generator

```python
def func(end):
    begin = 0
    while begin != end:
        yield begin
        begin += 1

generator = func(10)
for num in generator:
    print(num)
```

When the function reaches `yield`, it will pause and `return` the number; when iterator moves forward, the function will resume and continue to execute until the next `yield` or real `return`

* Since C++ 23, generator is also supported by **corutine**
  * Coroutines **cooperates** with each other and yield their excution flow themselves 协程之间是相互配合的控制流
    * By contrast, for threads, they usually compete with each other and are interrupted by OS to give other threads chances to execute 线程则是抢占式的
* Generator is just the same; when you need the next value , you just yield your execution flow to the generator function; when the generator function completes its task, it will give back the right of execution
* Generator is also an `input_range` and view; it provides `begin()` and `end()` to iterate, and `++` the iterator will resume the function
  * NOTICE: Call `.begin()` will start the coroutine

e.g.

```C++
std::generator<int> func(int end)
{
    std::cout << "Ahh...";
    for (int begin = 0; begin < end; begin++)
        co_yield begin;
    co_return;
}
auto generator = func(3);

for (auto it = generator.begin(); it != generator.end(); it++)
    std::cout << *it;
// or
for (auto& num : generator)
    std::cout << num;
```

* Some notes
  * One generator can only be used once 只能使用一次
  * Generator has `operator=`
  * `co_return` can be omitted
  * Saving contexts also needs memory, so an allocator can also be provided as the last template parameter

## Function

### Pointer to member functions

* Memeber fuctions can be static or non-static
  * Static ones are just normal functions with some `Class::`, their pointers are same as normal ones
  * Non-static ones are always bound to some specific objects, i.e. there is a `this` pointer as a parameter

e.g.

```C++
class Person
{
    public: unsigned int age;
    void AddAge(unsigned int n) {
        age += n;
    }
}

using FuncPtr = void (Person::*)(unsigned int);

int main()
{
    Person p{ 0 }, *pointer = &p;
    FuncPtr ptr = &Person::AddAge;
    (p.*ptr)(5);
    (pointer->*ptr)(5);

    // C++ 17
    std::invoke(ptr, p, 5);
    std::invoke(ptr, pointer, 5);
    return 0;
}
```

* Define a pointer to member function is `Ret (Class::*)(params)`
* `std::invoke` define in `<functional>` since C++ 17
* Since C++ 23, `std::invoke_r<Result>` is provided

### Callable parameter

#### Function as parameter

* 函数指针也可以实现将函数视为参数来传递，但是有两个问题
  * 有时候函数指针的参数类型有严格的限制，例如 `int` can be converted to `double`, `func(double)` is also acceptable
  * In C++, usually what you need is just "something callable", i.e. a functor is allowed 有时候只是想传入一个可调用的类型
* 有两种方式解决
  * Use a template parameter `<algorithm>`常用的方法采用模板参数接受可调用的参数
  * Use a `std::function` defined in `<functional>`
    * `std::function<RetType(Args...)>` can adopt almost all callable that have the return type **convertible** to `RetType` and accept `Args`
    * The member function even preserves polymorphism
    * After getting the `std::function`, you can just use `operator()` to call it
    * Even more powerful, you can bind some parameters to get new functors
      * E.g. you can use `std::bind(any_callable, params)` to get a `std::function` `std::bind`已经没有用了，完全可以用 Lambda 表达式绑定
    * There are two defects
      * Performance: It roughly causes 10% - 20% performance loss compared with direct function call
        * 有可能会用`new`/`delete`自定义`ctor`/`dtor`
        * 解决方式是使用 SOO(small object optimization)，在栈上准备一块小的 buffer 用于分配函数空间
        * 如果绑定的 Lambda 表达是太大可以使用`auto lambda = xx;`，然后再通过`std::ref(lambda)`传给`std::function`的构造函数（但是要注意声明周期），但是不可以使用`std::ref(&&xx)(){...}`，lambda 表达式会立马失效
      * The second defect of `std::function` is that it cannot really accept all functors 并不是支持所有的可调用类型
        * When the functor is not copiable (e.g. move-only, like `std::unique_ptr`) 仿函数不能拷贝的就不能接受
          * Thus, since C++ 23, `std::move_only_function` is introduced
  * Reference wrapper
    * `std::(c)ref()` in fact create `std::reference_wrapper<(const) T>`, which can be seen as an instantiated reference
      * 例如容器中不可能存储引用类型的，如果想储存引用类型可以使用`std::vector<std::reference_wrapper<T>>`
      * It's in fact a wrapper of pointer, but it cannot be null, just like reference
      * Different from reference, it can be bound to another object by `operator=`, just like pointer 引用是不可以换绑的，但是`std::ref()`可以
    * It's also used to denote "it should be a reference" exlicitly in some methods in standard library, e.g. `std::bind_back` or `std::bind_front`
* There are also some predefined template functors in `<functional>`
  * Arithmetic functors: `plus`, `minus`, `multiplies`, `divides`, `modulus`, `negate`
  * Comparison functors: `equal_to`, `not_equal_to`, `greater`, `less`, `greater_equal`, `less_equal`, `compare_three_way`
  * Logical functors: `logical_and`, `logical_or`, `logical_not`
  * Bitwise functors: `bit_and`, `bit_or`, `bit_xor`, `bit_not`
  * These `Functor<T>` all have `auto operator()(const T&, const T&) const`

#### Lambda expression

* We call lambda expression without capture *stateless lambda*; otherwise *stateful lambda*
* 可以使用`decltype(...)`去推断 lambda 表达式的类型
* 理论上可以使用推断出来的仿函数的类型进行声明，但是只有再 C++ 20 之后才是合法的
  * E.g. `auto l = [](int a, int b) { return a + b; }; using T = decltype(l); T l2{};`
  * 只适用 stateless lambda

## Algorithms

### Algorithms' Consiit

* Iterator pairs 迭代器对，或者直接传入 ranges
* Predicate function / transform function 判别函数或者变换函数，通常情况下变换都是`const&`，或者对于比较小的类型传入拷贝
* 大部分算法都返回一个范围迭代器
* 从来都不会改变序列的大小
* Callables of algorithm are of value type instead of reference type 判别函数或者变换函数都是传递值类型，不是引用类型

### Search

* 两种搜索算法
  * Linear seach
    * Find single value
      * `std::find`
      * `std::find_if`
    * Find one of values in a range
      * `std::find_first_of`
    * Find a sub-sequence in a sequence (Pattern matching)
      * `std::search`
      * `std::find_end`
    * Others
      * `std::adjacent_find(begin, end[, Pred2])`: 相邻元素相等的位置
      * `std::sratch_n(begin, end, count, value, [, Pred2])`
  * Binary search, which is applied on sorted sequence
    * `std::binary_search`: return bool, denoting whether `value` exists in `[begin, end)`
    * `std::lower_bound`: return `it` so that `value` is the lower bound of `[it, end)`
    * `std::upper_bound`: return `it` so that `value` is the lower upper of `[begin, end)`
    * `std::equal_range`: return an iterator pair `(it1, it2)` so that `value` is equal to `[it1, it2)`

### Comparison

* `std::equal(begin1, end1, ..., [, Pred2])`: return a bool
* `std::lexicographical_compare(begin1, end1, begin2, end2[, Pred2])`: return bool; Pred2` acts as `operator<>`
  * Compare until `ele1 < ele2 || ele2 < ele1`
* `std::lexicographical_compare_three_way(begin1, end1, begin2, end2[, Pred2])`: return an ordering; `Pred2` acts as `operator<=>`
* `std::mismatch(begin1, end1, ...[, Pred2])`:  return an iterator pair `(it1, it2)` denoting the first occurrence of mismatching
* These algorithms are all $O(N)$

### Counting

* `std::all_of/any_of/none_of(begin, end, Pred)`
* `std::count(begin, end, value)`
* `std::count_if(begin, end, Pred)`
* These algorithms are all $O(N)$

### Generating and Trankforming

* `std::fill(begin, end, value)`
* `std::fill_n(begin, count, value)`
* `std::generate(begin, end, Gen)`: for each element in `[begin, end)`, `ele = Gen()`
* `std::for_each(begin, end, Transform)`: for each element in `[begin, end)`, call `Transform(ele)`
* `std::transform`: There are unary/binary transforms
  * `(begin, end, dstBegin, Transform)`: unary 一元
  * `(begin, end, begin2, dstBeing, Transform)`: binary, the transformation is `Transform(*it1, *it2)`

### Modifying

* `std::remove(begin, end, value)/std::remove_if(begin, end, Pred)`: return the iterator so that `[begin, it)` has no element that is equal to `value` or make `Pred` return `true`
  * 不会真的擦除迭代器
  * Since C++ 20, they're integrated as methods `std::erase/std::erase_if`
* `std::unique(begin, end[, Pred2])`: return the iterator so that `[begin, it)` has not adjacent equal element; `Pred2` acts as `operator==` 使得在`[begin, it)`区间内没有相邻且相等的元素
* These algorithms are all $O(N)$, by the technique of dual pointers 算法用双指针实现
  * 定义两个指针`before`和`after`
  * 两个指针一开始都指向`begin`
  * 先前进`after`
  * 判断`*before == *after`；相等只前进`after`，不相等则前进`before`，并将`after`指向的值和`before`交换，前进`after`
  * 直到`after == end`
  * 需要考虑`begin == end`和整个序列就是 unique 的情况
* `std::replace(begin, end, oldValue, newValue)/std::replace_if(begin, end, Pred, newValue)`
* `std::swap(x, y)`
* `std::iter_swap(it1, it2)`
* `std::swap_range(begin1, end1, begin2)`
* `std::reverse(begin, end)`
* `std::rotate(begin, mid, end)`: left rotate `[begin, mid)`
  * 2, 3, 4, 4, 5 -> 4, 5, 2, 3, 4 相当于左移
  * Rotate is also $O(n)$
    * brute-force method: swap each element ot its position (just like bubble sort). This will be $O(k(n - k))$ 一个一个的交换，需要两层循环
      * 可以考虑将第一个元素拿出来，再确定序列中哪一个元素会再下一步出现在第一个位置，然后进行替换，以此类推完成旋转
      * 但是这种方式对 cache 不友好
    * swap all groups together
      * The complexity is $O(n)$
        <center>
            <img src="53/algorithm-modifying-rotate.png" />
        </center>
    * reverse
      * In fact, reverse is the basis of many algorithms
      * `[begin, mid - 1]``[mid, end - 1]`
      * Reverse two sub-sequences, get `[mid - 1, being]``[end - 1, mid]`
      * Reverse the total sequence, get `[mid, end - 1]``[begin, mid - 1]`
      * The complexity is $\Theta(k) + \Theta(n - k) + \Theta(n)$
* `std::shift_left/right(begin, end, n)`: the dropped elements are permanently dropped (invalid)

### Copying

* `std::copy(begin1, end1, dstBegin)`
* `std::copy_if(begin1, end1, dstBegin[, Pred])`
* `std::copy_n(begin1, n, dstBegin)`
* `std::copy_backward(begin1, end1, dstBegin)`

### Partition and Sort

#### Partition

Partition denotes that a range is divide into two parts; assuming predicate function `Pred`, then there exists an iterator `it` (i.e. partition point 轴点） so that all elements in `[begin, it)` make `Pred` return `true` while `[it, end)` make `Pred` return `false` 左边的都小于轴点（使得`Pred`函数返回`true`），右边的都大于轴点（使得`Pred`函数返回`false`）

* `std::is_partitioned(begin, end, Pred)`
* `std::partition(begin, end, Pred)`
* `std::stable_partition(begin, end, Pred)`: each sub-partition preserves the original order 保证 partition 后的结果和原序列的顺序一致
  * 原序列 `{ 0, 1, 9, 4, 5, 2, 7, 8 }`, `Pred`为`[](const int ele) { return ele % 2; }`左边是奇数右边是偶数
  * `std::partition`: `{ 7, 1, 9, 5, 4, 2, 0, 8}`
  * `std::stable_partition`: `{ 1, 9, 5, 7, 0, 4, 2, 8 }`
  * Implementation:
    * When the memory is enough （内存足够）, prepare a buffer; move the `false` range to the buffer and move the `true` range to be consecutive (just like preform `std::remove_if()`, with removed range saved in buffer). Then move the buffer elements back
    * When the memory is not enough （内存不够）, divide the sequence into two halves and stable partition each half
      * This will from `[true, false], [true, false]` sequence 最终都会变成这样的序列
      * Rotate the middle `[false, true]` so that the final result is totally partitioned
      * $T(n) = 2T(\frac{n}{2}) + O(n)$, to it's overall $o(n\mathbf{log}n)$
* `std::partition_point(begin, end, Pred)`: assume the range is a partition 前提是序列已经是 partition

#### Sort

* `std::is_sorted(begin, end[, Pred2])` $O(N)$
* `std::is_sorted_until(begin, end[, Pred2])` $O(N)$
* `std::sort(begin, end[, Pred2])` $O(N \mathbf{log}N)$
* `std::stable_sort(begin, end[, Pred2])`
  * $O(N)$ space complexity, $O(N \mathbf{log}N)$ time complexity
  * If space is insufficient, $O(N (\mathbf{log}N)^2)$ time complexity
* Since `std::sort` requires the complexity exactly $O(N \mathbf{log}N)$, quick sort is not enough 快排只是平均意义上的$O(N \mathbf{log}N)$，最坏的情况是$O(N^2)$
* C++标准库广泛使用的排序算法是 Inrosprective Sort( InroSrot)
  * It integrates insrtion srot, heap sort and quick sort 结合了插入排序，堆排序和快排
  * When the element number is **low enough**, insertion sort is used
  * When the recursion is too deep, heap sort is used
    * 避免快排的最坏情况
    * 堆排序是稳定$O(N \mathbf{log}N)$
    * 堆排序速度不是很快，对 cache 也不是很友好
* `std::partial_sort(begin, mid, end)`
* `std::nth_element(begin, mid, end)`: rearrange `[begin, end)` so that `*mid` is sorted (i.e. same as the `*mid` in the full sorted range) and the whole range is partitioned by it 在排好序的中第 n 个位置的元素
* `std::merge(begin1, end1, begin2, end2, dstBegin[, Pred2])`
* `std::inplace_merge(begin, mid, end)`

#### Heap

* `std::is_heap(_until)(begin, end[, Pred2])`
* `std::make_heap(begin, end[, Pred2])`: Floyd algorithm $O(N)$
* `std::push_heap(begin, end[, Pred2])`
* `std::pop_heap(begin, end[, Pred2])`
* `std::sort_heap(begin, end[, Pred2])`

#### Set Operations

Set operations are used on **sorted** range, including `set`

* `std::includes(begin1, end1, begin2, end2[, Pred2])`: check whether th second range is subset of the first range
  <center>
      <img src="53/set-operations-inclues-1.png" />
      <img src="53/set-operations-inclues-2.png" />
  </center>
* `std::set_intersection(begin1, end1, begin2, end2, dstBegin[, Pred2])`: $A \cap B$
* `std::set_union(begin1, end1, begin2, end2, dstBegin[, Pred2])`: $A \cup B$
* `std::set_symmetric_difference(begin1, end1, begin2, end2, dstBegin[, Pred2])`: $A - B$
* `std::set_difference(begin1, end1, begin2, end2, dstBegin[, Pred2])`: $A - (A \cap B)$

#### MinMax

* `std::min/max/minmax(a, b[, Pred2])`: return (pair of) reference of the smaller/bigger element
* `std::min_element/max_element/minmax_element(begin, end[, Pred2])`: return the iterator of the minimum/maximum value in the range
* `std::clamp(value, low, high)`

#### Permutation

Permutation means that two sequence are **unorderly equal**

* `std::is_permutation(begin, end1, begin2[, Pred2])`
  * $O(n^2)$
* `std::prev/next_permutation(begin, end[, Pred2])`: return the sequence to the previous/next permutation

#### Numeric Algorithms

They are all $O(N)$

* For the most basic ones:
  * `std::iota(begin, end, beginVal)`: fill in `[begin, end)` with `{beginVal, ++beginVal, ...}`
  * `std::adjacent_difference(begin, end, dstBegin, Op = std::minus)`: as its name, output `{val[0], val[1] - val[0], val[2] - val[1], ...}`
  * `std::accumulate(begin, end, initVal, Op = std::plus)`: accumulate all values, return $\text{initVal} + \sum_{\text{begin}}^{\text{end}}\text{val}$
  * `std::partial_sum(begin, end, dstBegin, Op = std::plus)`: output `{val[0], val[0] + val[1], val[0] + val[1] + val[2], ...}`
  * `std::inner_product(begin1, end1, begin2, initVal, Op1 = std::plus, Op2 = std::multiplies)`: finally get `initVal + a[0] * b[0] + a[1] * b[1] + ...`
  * `std::reduce(begin, end, initVal, Op = std::plus)`: same as accumulate
  * `std::inclusive_scan(begin, end, dstBegin, Op = std::plus[, initVal])`: same as partial sum
  * `std::transform_reduce(begin1, end1, begin2, initVal, ReduceOp = std::plus, BiTransfromOp = std::multiplies)`: same as inner product
  * `std::exclusive_scan(begin, end, dstBegin, initVal, Op = std::plus)`: similar to partial, but exclude the element itself, i.e. the sequence is `{initVal, initVal + val[0], ..., initVal + val[0] + ... + val[n - 2]}`
  * `std::transform_inclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])`
  * `std::transform_exclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])`
* `std::gcd(a, b)`: 最大公约数
* `std::lcm(a, b)`: 最小公倍数
* `std::midpoint(a, b)`: since C++ 20, return `a + (b - a) / 2`

#### Parallel Algorithm

* There are two kinds of parallelism
  * SIMD: single instruction multiple data 单指令多数据
  * SIMT: single instruction multiple threads
* Since C++ 17, parallel-version algorithms are added
* Defined in `<execution>`
  * There are four execution policies defined in `std::execution`
    * `seq`: sequenced policy 完全不并行
    * `par`: parallel policy 并行
    * `unseq`: unsequenced policy (since C++ 20) 算法可以适应 SIMD
    * `par_unseq`: parallel and unsequenced policy
* There are four kinds of data dependencies
  * RAR: read after read 可以使用`par_unseq`
    * E.g. `std::adjacent_find`
  * RAW: read after write, e.g. `a[j] = a[j - 1] + 1`
  * WAR: write after read, e.g. `a[j - 1] = a[j] + 1`
  * WAW: write after write
* Parallel algorithms
  * `std::partition`, `std::nth_element`
  * `std::merge`
  * `std::inplace_merge`
* There are also some algorithms that cannot be parallelized
  * Those who only operate on serveral values, e.g. `std::min/max/minmax/clamp`, `std::swap/iter_swap`
  * 随机算法
  * `std::search`
  * `std::push/pop/make/sort_heap`
  * 排列算法
  * 二叉搜索算法
  * Oerdered numeric algorithms, i.e. `std::iota/accumulate/inner_product/partial_sum`

#### Range-version Algorithms

算法中需要声明迭代器，当操作的是一整个容器时，就需要`begin`和`end`，所以可以使用`ranges`。range-version 算法也可以叫做 constrained algorithms，使得算法操作更加灵活

* You can additionally specify **projection** as the last parameter, i.e. transformation of elements before entering the real function 最后一个参数可以指定一个映射，例如使用 transform 在传入函数前进行变换
  * This just changes criteria（标准；条件）, the element itself is unchanged
  * Multiple ranges may specify multiple projections

```c++
std::vector vec{ -1, 2, -3, 4, -5, 6 };
auto print = [](int i) {
    std::cout << i << ", ";
};
std::cout << "with abs() projection: \n";
std::ranges::sort(vec, {}, [](int i) { return std::abs(i); });
std::range::for_each(vec, print);
```

* Range-version algorithms also have these advantages 
  * 使用了 C++20 中的 concept
  * The range doesn't need to be commaon (i.e. `begin/end` with the same type) `begin`和`end`不要求类型相同
  * 更加安全
  * 有些算法被加强了
  * 新的方法加入进来
  * 用模板方法更容易
* There are also some defects
  * 不能使用并行算法
  * 一些算法被削弱了
  * 返回值类型并不和`std::`相同，返回值改变有以下几种形式
    * `stdr::in_in_result<I1, I2>`: 本来返回两个迭代器，现在返回了一个结构体，里面的成员变量是两个迭代器
    * `stdr::in_out_result<I, O>`
    * `stdr::in_in_out_result<I1, I2, O>`
      * `stdr::set_union/intersection/symmetric_difference`
      * `stdr::merge`
      * binary `stdr::transform`
    * `stdr::in_out_out_result<I1, I2, O>`
      * `stdr::partition_copy`
    * `stdr::in_found_result<T>`