---
title: RO
toc: true
date: 2024-05-09 18:43:00
categories:
- 面试
tags:
- 战斗
mathjax: true
---

## 客户端自动战斗 AI
### Behaviour Designer 行为树插件
#### AI 的解决方案
- 编码：反应型 AI
  - 状态机
  - 行为树
  - 基于规则的系统
- 求解：协商行 AI
  - A*
  - 目标导向型行动计划（GOAP）
  - 层次人物网规划（HTN）
  - 规划器
- 学习：机器学习
  - 模仿学习
  - 强化学习

游戏中常见的 AI 解决方案都是反应型 AI，RO 中大量用到反应型 AI 的行为树作为解决方案，这个行为树插件就是 Behaviour Designer

### Behaviour Designer 中的 Task

简单行为树实际上就是 Task 的集合，Task 有四种不同的类型：
- Action 动作——代表了某种状态，最基本的任务
- Conditional 条件——用来检测是否达到某种条件
- Composite 复合——包含了一系列子任务列表的父任务
- Decorator 修饰符——也是一个父任务，并且只能包含一个子任务，是用来修改子任务的行为。例如将一个子任务运行 10 次（Repeater），或者对子任务的结果取反（Inverter）

#### Action 和 Conditional 自定义 Task

一般情况下只会在 Behaviour Designer 中定义 Action 和 Conditional，Composite 和 Decorator 使用提供的就可以，下面的 Action 代码由工具自动生成

```c#
[BehaviorDesigner.Runtime.Tasks.TaskDescriptionAttribute("血量属性比较")]
public class MAISelfCompareByHP : BehaviorDesigner.Runtime.Tasks.Action
{
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("是否自己")]
    public BehaviorDesigner.Runtime.SharedBool is_self;
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("目标")]
    public BehaviorDesigner.Runtime.SharedTransform target;
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("值类型 (hp 血量 、hp 百分比）")]
    public MoonClient.MAISelfCompareByHP.MHPValueType hp_value_type;
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("比较类型")]
    public MoonClient.MNumberComparisonType hp_cmp_type;
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("右值")]
    public BehaviorDesigner.Runtime.SharedFloat right_value;
    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute("保存左值结果")]
    public BehaviorDesigner.Runtime.SharedFloat store_left_value;
    private MoonClient.MAISelfCompareByHP node;
    private MEntity entity;
    private MoonClient.MAISelfCompareByHP.MNodeArgs args;
   
    public override void OnAwake()
    {
     entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.gameObject.name));
     if(entity == null) return;
     node = new MoonClient.MAISelfCompareByHP();
     args = new MoonClient.MAISelfCompareByHP.MNodeArgs();
      args.is_self = is_self.swigValue;
      args.hp_value_type = hp_value_type;
      args.hp_cmp_type = hp_cmp_type;
      args.right_value = right_value.swigValue;
      args.store_left_value = store_left_value.swigValue;
     node.SetNodeArgs(args);
    }
    
    public override TaskStatus OnUpdate()
    {
     if(entity == null) return TaskStatus.Failure;
     return node.Update(entity) ? TaskStatus.Success : TaskStatus.Failure;
    }
}
```

#### 常用的 Parent Tasks

- Composite 复合类型
  - Sequence 将其所有子节点依次执行，也就是说当前一个返回“完成”状态后，再运行先一个子节点
[Image]
  The sequence task is similar to an "and" operation. It will return failure as soon as one of its child tasks return failure. If a child task returns success then it will sequentially run the next task. If all child tasks return success then it will return success.
  和“and”操作符逻辑类似，下面的子任务按照从左到右的顺序执行，如果有一个子任务返回 false，后续子任务都不执行，并且该任务直接返回 false
  - Selector 选择其子节点的某一个执行
[Image]
  The selector task is similar to an "or" operation. It will return success as soon as one of its child tasks return success. If a child task returns failure then it will sequentially run the next task. If no child task returns success then it will return failure.
  和“or”操作符逻辑类似，让子任务从左到右依次执行，如果有一个人物返回 true，后续所有人物就不执行，该任务直接返回 true
  - Parallel 将其所有子节点都运行一遍
- Decorator 装饰器类型
  - Inverter
  - Repeater
  - Return Failure 和 Return Success
  ```c#
    // ReturnFailure.cs
    public override TaskStatus Decorate(TaskStatus status)
    {
        // Return failure even if the child task returned success.
        if (status == TaskStatus.Success) {
            return TaskStatus.Failure;
        }
        return status;
    }

    // ReturnSuccess.cs
    public override TaskStatus Decorate(TaskStatus status)
    {
        // Return success even if the child task returned failure.
        if (status == TaskStatus.Failure) {
            return TaskStatus.Success;
        }
        return status;
    }
  ```
  无论返回成功还是失败，都是返回相应任务对应的结果
  - Until Failure 和 Until Success
  - Random Probability

### 变量相关

行为树的优点是非常灵活，因为所有任务都是解耦合的，任务之间是不互相依赖的。但是有时候需要提供彼此共享的信息，这是会用到行为树提供的共享变量类型。在需要的 Task 中定义了某个类型，需要在行为树中创建该类型，并在 Task 中引用该类型

局部变量就是当前行为树可以共享的变量，全局变量就是所有行为树都可以共享的变量，Behaviour Designer 内置的共享变量类型有以下几种：

```c#
SharedAnimationCurve
SharedBool
SharedColor
SharedFloat
SharedGameObject
SharedGameObjectList
SharedInt
SharedMaterial
SharedObject
SharedObjectList
SharedQuaternion
SharedRect
SharedString
SharedTransform
SharedTransformList
SharedVector2
SharedVector3Int
SharedVector3
SharedVector3Int
SharedVector4
```

### Behaviour Designer 中的共享变量的理解

Behaviour Designer 的共享变量是一种黑板（Blackboard）设计模式
输入内容的来源取决于行为树用在整个 AI 架构的哪一层，可以是游戏世界的信息，或者是上层模块的输出。输入的形式，可以是分散的（Decentralized），也可以是集中的（Centralized）。举个例子来说，如果我们做一个战士是移动，还是攻击的决策，这是决策层的行为，所以输入内容就是游戏世界的信息，它可能包括战士自身状态（在模块 A 中），敌人状态（在模块 B 中），装备物品情况（在模块 C），地图场景情况（在模块 D 中）等等，所以，当我们搜索和执行行为树时，我们需要从 4 个模块中获取信息来帮助决策，这样的方式就是我上面说的分散的方式，它的好处是调用非常直接（可能是用多个 Singleton 提供的接口），没有数据冗余，缺点是使得行为树对于数据的依赖度太分散。

集中的方式的话，就是我们可以定义一个数据结构专门用于行为树的输入，将上面提到的需要用到的数据，在进行行为树决策前，先从各个模块中收集到这个数据结构里，然后再递交给行为树使用。集中式的输入减少了输入和行为树之间的接口数量（只和预定义的数据结构通信），但缺点是，存在数据冗余。不过，我们可以看到集中式的数据输入使得行为树的表现更像一个黑盒了（可以伪造数据来测试行为树），这也是我们一直以来想要的。可以参看下面对于两种方式的示意图：
在行为树的使用过程中，发现有时候节点和节点间，行为树和行为树之间确实需要有数据共享，比如对于序列（Sequence）节点来说，它的执行行为是依次执行每一个子节点，直白一点说的话，就是执行完一个再执行下一个。一般用到序列的行为，其子节点间总会有一些联系，这里就可能存在节点间通信的问题。再比如，在一些团队 AI 的决策过程中，当前 AI 的行为树决策可能需要参考其他 AI 的决策结果，所以这样就存在了行为树之间需要通信的情况。

所以，在实践过程中，我们还会定义另一块黑板来负责行为树间和节点间的通信需求，示意图如下

### RO 中的`MShareData`

#### 可共享的变量类型

```c#
public enum MSharedDataType
{    
    kSharedDataInt = 0,
    kSharedDataBool,
    kSharedDataFloat,
    kSharedDataString,
    kSharedDataVector,
    kSharedDataTransform,
    kSharedDataInt64,
    kSharedDataTypeCount,
};
```

#### AI 节点中变量名和值的存储

主要由记录变量名对应的哈希值（其实就是自增值）和存储各个变量类型的数组（类型值数组）建立起来的映射关系，这些数组里以变量名的哈希值作为下标，存储相应的值；主要的变量如下：
```c#
// 存储变量名的哈希值，每种变量类型分别记录，读取时根据不同的变量类型读取相应的类型值数组
private static Dictionary<string, uint>[] name_hash_ =
    new Dictionary<string, uint>[(int)MSharedDataType.kSharedDataTypeCount];
private static uint[] name_index_ =
    new uint[(int)MSharedDataType.kSharedDataTypeCount]; //int 型数组里面的值默认初始化为 0
    
// 声明类型值数组
private const int kMaxAIDataCount = 150; // 所有变量的数量上限
private float[] float_var_;
private int[] int_var_;
private long[] long_var_;
private bool[] bool_var_;
private ulong[] trans_var_;
private string[] string_var_;
private Vector3[] vector3_var_;

/*默认初始化 
 * bool --> false
 * int、float --> 0
 * 其他值类型 --> 该类型字段默认值
 * 引用类型（包括 string) --> null
*/
float_var_ = new float[kMaxAIDataCount];
int_var_ = new int[kMaxAIDataCount];
long_var_ = new long[kMaxAIDataCount];
bool_var_ = new bool[kMaxAIDataCount];
trans_var_ = new ulong[kMaxAIDataCount];
string_var_ = new string[kMaxAIDataCount];
vector3_var_ = new Vector3[kMaxAIDataCount];
```

运行时通过以下映射关系读取对应 AI 节点中的变量值

<center>
    <img src="50/type-map.png" />
</center>

#### PB 数据

##### 客户端行为树的 Node 生成

- 主要解析运行时 AI 代码的源文件，遍历 Assets/Scripts/MoonClient/AI/Node 目录下所有。cs 文件，源文件中每个类都继承自 MAINodeAction 或者 MAINodeAction，根据基类的不同导出不同类型的节点
[Image]
- 根据类中定义 MNodeArgs 的成员变量添加 public 成员变量，成员变量的类型根据下面的字典映射
  ```c#
    private static readonly Dictionary<Type, Type> typeRemapDict = new Dictionary<Type, Type>()
    {
        {typeof(int), typeof(SharedInt) },
        {typeof(long), typeof(SharedLong) },
        {typeof(ulong), typeof(SharedULong) },
        {typeof(float), typeof(SharedFloat) },
        {typeof(string), typeof(SharedString) },
        {typeof(bool), typeof(SharedBool) },
        {typeof(UnityEngine.Vector3), typeof(SharedUnityVector3) },
        {typeof(ROGameLibs.Vector3), typeof(SharedVector3) },
        {typeof(SWIGTYPE_p_Vector3), typeof(SharedVector3) },
    #if LIBS_EDITOR
        {typeof(SWIGTYPE_p_ROObject), typeof(SharedTransform) },
    #endif
        {typeof(MoonClient.MEntity), typeof(SharedTransform) },
        {typeof(IntVector), typeof(SharedIntList) },
        {typeof(LongVector), typeof(SharedLongList) },
        {typeof(FloatVector), typeof(SharedFloatList) },
        {typeof(StringVector), typeof(SharedStringList) },
        {typeof(ULongVector), typeof(SharedULongList) },
    };
  ```
- 同时根据属性 NodeComment，设置编辑器中变量的悬浮注释
- 固定格式的代码段
  ```c#
  private MoonClient.XXX node; // XXX 为源文件类名
  private MEntity entity;
  private MoonClient.XXX.MNodeArgs args; // XXX 为源文件类名
  
  public override void OnAwake()
  {
      entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.  gameObject.name));
      if(entity == null) return;
      node = new MoonClient.MAIAutoFollow();
      args = new MoonClient.MAIAutoFollow.MNodeArgs();
      // args.follow_target_radius = follow_target_radius.swigValue;
      // args.teleport_distance = teleport_distance.swigValue;
      // 源文件中 MNodeArgs 的成员变量赋值
      node.SetNodeArgs(args);
  }

  public override TaskStatus OnUpdate()
  {
      if(entity == null) return TaskStatus.Failure;
      return node.Update(entity) ? TaskStatus.Success : TaskStatus.  Failure;
  }
  ```

### 运行时 AI
#### 初始化
- 初始化 AI 组件：MPlayer::InitComponents
- 初始化行为树：MAIComponent::InitBehaviorTree
  - 初始化所有玩家通用的 AI 树：MAIBehaviorTree::Init
    - 加载 PlayerAI/Player_Auto_AI.bytes 文件：MAITreeManager::LoadFile
    - 构造 AI 树：MAITreeManager::BuildAITree
    - 递归构造节点：MAITreeManager::BuildOneNode
      - 未初始化时，初始化所有节点类型对象的委托：MAINodeFactory::CreateAINodeByName
      - 初始化完成即调用，解析 PB 初始化节点

#### 调用逻辑
- 在 MAIComponent::Update 每次 Update 满足一定条件后都执行一次_behaviorTree.Tick(Entity)
- 每次 tick 都从 AINode 的 RootNode 递归到每个子节点，执行相应业务逻辑节点的 Update 函数中的逻辑

#### 客户端如何进行自动释放

* 策划会在行为树中配置一些列的条件（顺序执行或选择执行）
  * 自动跟随的距离
  * Entity 类型限制
  * 战斗半径大小
  * 变身情况
  * ...
* 依次遍历装配在自动战斗槽位的技能（1~6）
* 当第 i 个槽位有装配技能时，根据技能 id 读取技能表中配置的`AITreeName`
* 将查询到的`AITreeName`放置到`tree_name`共享变量中
* 再通过`MAIDynamicTreeReference`读取`tree_name`中的值，并读取改节点树的 PB，合并到当前`MAIDynamicTreeReference`的父节点上
* 读取到相关技能节点树后，根据策划的配置条件，满足后可释放
  * 技能是否存在
  * 释放技能后，是否存在不可叠加的 buff
  * ...
* 释放技能：通过`MWaitingDataMgr`添加可释放的技能到待执行队列中，每次 update 走技能释放逻辑

### 相关改进

线上 bug：某些职业释放技能后，已经上了不可叠加的 buff（buff 效果消失之前不能够重复释放改技能），但是客户端的 AI 依然会继续持续释放，造成抽搐的表现（偶现问题没有查到具体原因）
解决方案：更改`MAICastSkill`节点，释放次数超过一定数值，不可释放该技能

## 附身

### 需求

* 技能：灵喵附身
* 技能描述：喵喵附身于选中的队友身上，每秒消耗 5 点自然力量，持续 20 秒，自身处于无敌状态，且将自身 10%的六维属性附加于附身的队友

### 实现方式

* 释放技能为角色添加 Buff
* 客户端根据 Buff 状态类型进行判断，如果是附身 Buff 状态类型
  * 附身目标只有一个，取服务器发过来的第一个 Buff 相关目标（区别于 Buff 目标）的 uid
  * 在`MBuffComponent`组件中记录该 uid
  * 广播`StopMove`事件，让玩家无法移动
  * 设置玩家的位置、朝向与被附身的玩家一致
* 屏蔽玩家的碰撞体，使玩家和被附身的人保持一致
* 在`MHideComponent`组件中，将玩家设置为半透明状态
* 控制移动
  * 屏蔽摇杆和点击地面的移动效果
  * 在`MMoveComponent`组件的 Update 中，每帧设置玩家的移动距离改为和被附身的玩家做差
    ```c#
    var buffFollowTarget = Entity.BuffFollowTarget;
    if (buffFollowTarget != null)
    {
        Entity.AppendMove(buffFollowTarget.Position - Entity.Position);
    }
    else
    {
        Entity.AppendMove(Entity.ServerPos - Entity.Position);
    }
    ```

## Odin OdinMenuTree

## UI 框架

### Windows 生命周期

* 打开 UI：Active -> BindEvents -> OnActive -> OnShow -> AfterShow
* 关闭 UI：Deactive -> UnBindEvents -> OnHide -> OnDeActive -> AfterOnDeActive -> ReleaseAll

### `UIManager`

* UIManager 打开关闭界面以组的方式进行处理。
* 所有的组信息都会进栈进行管理。
* 会根据配置来确定这个组里面有哪些界面
* 没做配置的界面会把这一个界面当成一组
* 支持静态配置和打开界面时传递动态配置

> * `ActiveUI`打开某个 Window 函数入口
> * 通过`require`指定 Window 名字，并进行初始化`UI[panelClassName].new()`
> * 为当前 Window 添加`groupName`
> * `_createUIPanelConfig` 生成 UIPanel 配置，得到界面的配置数据
> * `ActiveUIPanelInGroup` 打开界面时对栈进行处理

#### 设置 UI 层级（UILayer）
```lua
---@class UILayer
UILayer = {
    Normal = 0,   -- 20
    Function = 1, -- 40
    Tips = 2,     -- 60
    Guiding = 3,  -- 80
    Top = 4       -- 100
}
```

#### 界面类型（ActiveType）

* `None`：不做任何处理
* `Normal`：显示时会把这个界面加入主界面组中（NormalLayer -> MainPanelsGroupGroup，无视设置的 UILayer 放到 NormalLayer）
* `Exclusive`：显示时会隐藏前面的组（隐藏 Normal Exclusive 类型 UI，Layer 无关）
* `Standalone`：显示后不会被 Exclusive 类型隐藏

## 剧本解析

### 代码结构

```
clientcode\CSProject\MoonClient\CommandSystem:. 
│  CommandBlock.cs 创建以及执行 Block 的方法都会在这里
│  CommandBlockManager.cs 上下文环境管理，变量储存
│  CommandBlockTriggerManager.cs 触发器管理
│  CommandConst.cs 所有与命令相关的常量都会记录在这里
│   
├─Attribute 静态语法检查
│      CommandArgsAttribute.cs 
│      CommandCheckAttribute.cs 
│       
├─Checker 静态语法检查
│      CommandBlockChecker.cs 
│       
├─Commands C#命令
│  │  BaseCommand.cs 
│  │  LuaCommand.cs 
│  │   
│  ├─NPC 
│  │      ChangeEmotionCommand.cs 
│  │      .​.. 省略
│  │       
│  ├─Other 
│  │      FindElfCommand.cs 
│  │      ShowModelAlarmCommand.cs 
│  │       
│  └─System 
│          AddLocalBuffCommand.cs 
│          .​.. 省略
│           
├─Compile 二进制编译
│      CommandBlockBinaryCompiler.cs 
│      CommandBlockParser.cs 
│       
├─Data PB 数据结构以及动态参数解析
│      BaseArg.cs 
│      BlockIndexArg.cs 
│      BlockVarArg.cs 
│      CommandBlockArg.cs 
│      CommandBlockStringArg.cs 
│      CommandData.cs 
│      CommandLuaArg.cs 
│      ExpressionArg.cs 
│      FunctionArg.cs 
│      ValueArg.cs 
│       
├─Expression 表达式词法解析器
│      EOFToken.cs 
│      IdentifierToken.cs 
│      Lexer.cs 
│      LuaConverter.cs 
│      NumberToken.cs 
│      StringToken.cs 
│      Token.cs 
│       
└─Trigger 触发器相关
    │  CommandTrigger.cs 
    │   
    └─Event 触发器事件埋点
            BaseEvent.cs 
            OnCollectSuccEvent.cs 
            OnDamagedByPlayerEvent.cs 
            OnEnterDungeons.cs 
            OnExitDungeons.cs 
            OnKilledByPlayerEvent.cs 
            OnNpcCreateEvent.cs 
            OnNpcDestroyEvent.cs 
            OnStartCollectEvent.cs
```

在`ScriptHandle`函数解析每一行剧本时确定是用 C#中的`BaseCommand`还是 Lua 中的`LuaCommand`进行解析