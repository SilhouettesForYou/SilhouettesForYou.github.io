---
title: 面经
toc: true
date: 2024-05-13 22:12:47
categories: 面试
tags:
- Unity
- C#
---

## 波克城市

### 协程是否共享堆栈

* 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
* 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)
* **协程和线程**一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度

### 透明物体位于 Unity 哪个渲染阶段

### 已知法向纹理，如何还原法线向量

### 如何计算 MipMap 个数

### 描述 Blooming 方法

### 如何解决 AssetBundle 依赖

## B 站

### 图集是怎样生成的

### 资源加载

#### Unity `AssetDatabase`和`Resources`资源管理

Unity 常用的资源大概有以下几类：

* 纯资源（material，texture，shader，audio，...）这些资源不能直接拖到场景里使用
* 预置（prefab），这种资源需要实例化之后才能使用
* scene 也是一种资源
* 脚本对象，文本文件，unity 自己内置的资源（像新建粒子时的默认材质之类的）

Unity 管理这些资源分为两种：

* 在编辑器内管理，使用`AssetDatabase`加载卸载资源
  * 在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用
* 运行时管理，简单化使用`Resources`，复杂化使用 AssetBundle
  * 在运行时管理资源，简单的方法就是使用`Resources`接口。这种方式控制资源的管理效率高，资源需要放在 Resources 文件夹下。这就说明 Unity 在打包时只会打包 Resources 文件夹下的资源到终端上。 加载这个文件夹下的资源不需要扩展名。最好不要建立多个 Resources 文件夹，否则 Unity 可能会不知道要加载哪一个

## 叠纸一面

### C# 调用 Lua GC 是如何产生的，如何避免 GC

### UGUI 自适应大小

### 如何避免装箱拆箱

### Lua 元表是什么

原表是 Lua 中元表（Metatable）的一种特殊类型。元表是一种可选的附加到表上的表，用于控制表的行为。当我们进行特定的操作时，例如访问表中不存在的键、进行算术运算或比较等，Lua 会在元表中查找相应的元方法并执行相关的操作。

元表通过定义元方法来定义特定操作的行为。元方法是一组预定义的函数，以特定的键存储在元表中。当执行相关操作时，Lua 会检查元表中是否存在对应的元方法，并根据元方法的定义来处理操作。

以下是一些常见的元方法及其对应的操作：

- `__index`：该元方法用于处理当访问表中不存在的键时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__index 元方法。如果存在，Lua 会调用该元方法，并将表和被访问的键作为参数传递给它。该元方法可以返回一个值来作为访问的结果，或者可以是一个函数，以便进行进一步的操作。
- `__newindex`：该元方法用于处理当对表中不存在的键进行赋值时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__newindex 元方法。如果存在，Lua 会调用该元方法，并将表、被赋值的键和赋予的值作为参数传递给它。我们可以在该元方法中自定义处理逻辑，例如捕获赋值操作并执行自定义的操作或者抛出错误。
- `__add`、`__sub`、`__mul`、`__div`等：这些元方法用于重载表的算术运算符。当进行相应的算术运算时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的操作。我们可以在这些元方法中实现自定义的算术运算逻辑。
- `__eq`、`__lt`、`__le`：这些元方法用于重载表的比较运算符。当进行相应的比较操作时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的比较逻辑。我们可以在这些元方法中实现自定义的比较逻辑。
要将元表关联到表上，我们使用 setmetatable 函数。通过将表作为第一个参数，元表作为第二个参数传递给 setmetatable 函数，即可将元表关联到表上。

原表的应用非常广泛，可以用于实现面向对象的特性，例如继承、多态等。我们可以通过定义元方法来自定义对象的行为，同时还可以通过原表来实现一些高级功能，如代理（Proxy）、属性访问、事件触发等。通过定义适当的元方法，我们可以拦截和重定义对表的操作，从而实现各种定制化的行为。

以下是一个更具专业性的示例，演示了如何使用原表来实现代理模式：

```lua
-- 原始对象
local realObject = {
  value = 42,
  getName = function(self)
    return "Real Object"
  end
}

-- 代理对象
local proxyObject = {
  value = 0,
  getName = function(self)
    return "Proxy Object"
  end
}

-- 定义代理的元表
local proxyMetatable = {
  __index = function(table, key)
    -- 当访问值时，代理返回代理对象的值
    if key == "value" then
      return table.value
    end
    -- 当调用方法时，代理返回原始对象的方法
    if key == "getName" then
      return realObject.getName
    end
  end,
  __newindex = function(table, key, value)
    -- 代理只允许修改代理对象的值，而不影响原始对象
    if key == "value" then
      table.value = value
    end
  end
}
```

### TimeLine 和 Animator

Animator 是组件，而 Timeline 是资产

Animator 这个组件，是用来实现“使用某种动画数据来驱动所在 GameObject 及其子物体的各种参数随时间推移而发生变化”这一功能的。比如：Animator 告诉 Transform 组件将 position 和 rotation 设置到某一个数值，而这个数值的来源就是我们的动画片段（Animation clip，也就是。anim 文件资产）

但 Animator 这个组件并不直接读取。anim 资产的数据，而是通过 Animator Controller 资产来间接获取。Animator Controller 是一个状态机，可以设置一系列参数来控制多个多个动画片段之间的融合过渡。有了 Animator Controller 的参与，Animator 组件就不需要直接控制很多很多的动画片段了（特别特别麻烦），只需要控制相应的“参数”就可以达到控制很多动画片段之间的融合过渡的目的

Animator Controller 是用来整合。anim 数据的资产，Timeline 一定程度上也是。Timeline 的 Animation Track 做到事情，就是将多个动画片段按时间顺序连接起来（你可以把 Timeline 理解成一个非线性动画编辑器），这样我们就不需要手动控制这些动画片段的播放时间，只需要在需要的时候播放 Timeline 即可。当然，使用 Animator Controller 也能达到类似的目的，比如将多个片段“串起来”，但 Timeline 的整合显然更直观更好用

### Animator 如何解决帧数冲突

### Lua 插入哈希表还是数组

### `readonly`和`const`区别

- `const`修饰符
  - 初始化时机：编译时，即编译程序时将值已经嵌入代码中；
  - 值状态：不允许动态修改
  - 修饰范围：字段、局部变量
  - 主要应用场景：主要应用于程序运行中不需要改变的变量的值，比如数学符号 PI；
- `static`修饰符
  - 初始化时机：运行时，可以声明时赋值，也可以在构造函数，或使用时赋值
  - 值状态：允许修改
  - 修饰范围：类、字段、属性、方法、运算符、事件、构造函数（不能用于索引器、析构函数或类以外的类型）
  - 主要应用场景：主要作用于类的公共属性
- `readonly`修饰符
  - 初始化时机：运行时，可以声明时赋值或在类中的构造函数中赋值
  - 值状态：允许修改，但只能在构造函数中修改
  - 修饰范围：字段
  - 主要应用场景：主要作用于实例化的对象的只读属性
- `static readonly`修饰符
  - 初始化时机：运行时，是两个关键字的组合
  - 值状态：允许修改，声明时赋值或者静态构造函数中赋值
  - 修饰范围：字段
  - 主要应用场景：
    - 和`const`相比，它主要应用于引用性变量；而`const`，只能用于`string`类型的引用性变量；
    - 类的只读公共属性
总结：
- `const`是静态的、编译期变量，只能在声明变量的时候赋值。
- `readonly`是运行时变量，可以在声明的时候或在构造函数内赋值。
- `static readonly`变量就变成了静态的、编译期变量。只能静态构造函数中进行初始化。
- 同时`static readonly`可以理解为是最简单的一种单例模式实现方式。
- `const`是静态常量，`readonly`是动态常量。`const`高效，`readonly`灵活！但实际开发中我们经常用`static readonly`来代替`const`, 以平衡`const`在灵活性上的不足

## 叠纸二面

### Used Total 和 Reserved Total

在 Profiler 工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 Used Total（使用总内存）和 Reserved Total（预定总内存）。Used Total 和 Reserved 均是物理内存，其中 Reserved 是 unity 向系统申请的总内存，Unity 底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的 Reserved 内存，而运行时，unity 所使用的内存首先是向 Reserved 中来申请内存，当不使用时也是先向 Reserved 中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total 越大，则 Reserved Total 越大，而当 Used Total 降下去后，Reserved Total 也是会随之下降的（但并不一定与 Used Total 同步）

### 如何实现历史记录

### `EditorWindow`生命周期

<center>
    <img src="51/editor-window-life.png" />
</center>

### `Animation Clip`数据结构

### 协程的原理

#### `yield`和`IEnumerator`什么关系

`yield`是 C#的关键字，其实就是快速定义迭代器的语法糖。只要是`yield`出现在其中的方法就会被编译器自动编译成一个迭代器，对于这样的函数可以称之为迭代器函数。迭代器函数的返回值就是自动生成的迭代器类的一个对象

试试想象如果没有`yield`关键字，我们每定义一个迭代器，就要创建一个类，实现`IEnumerator`接口，接口包含的属性与方法都要正确的实现，是不是很麻烦？而利用`yield`关键字，只需要下面简单的几行代码，就可以快速定义一个迭代器。诸如迭代器类的创建，`IEnumerator`接口的实现工作编译器通通帮你做了

```C#
// 由迭代器函数定义的迭代器
IEnumerator Test()
{
    yield return 1;
    Debug.Log("Surprise");
    yield return 3;
    yield break;
    yield return 4;
}

```

#### Unity 协程机制的实现原理

协程是一种比线程更轻量级的存在，协程可完全由用户程序控制调度。协程可以通过`yield`方式进行调度转移执行权，调度时要能够保存上下文，在调度回来的时候要能够恢复。这是不是和上面“停住”代码然后又原位恢复的执行效果很像？没错，Unity 实现协程的原理，就是通过`yield return`生成的`IEnumerator`再配合控制何时触发`MoveNext`来实现了执行权的调度

具体而言，Unity 每通过`MonoBehaviour.StartCoroutine`启动一个协程，就会获得一个`IEnumerator`（`StartCoroutine`的参数就是`IEnumerator`，参数是方法名的重载版本也会通过反射拿到该方法对应的`IEnumerator`）。并在它的游戏循环中，根据条件判断是否要执行`MoveNext`方法。而这个条件就是根据`IEnumerator`的`Current`属性获得的，即`yield return`返回的值。

在启动一个协程时，Unity 会先调用得到的`IEnumerator`的`MoveNext`一次，以拿到`IEnumerator`的`Current`值。所以每启动一个协程，协程函数会立即执行到第一个 yield return 处然后“停住”。

对于不同的`Current`类型（一般是`YieldInstruction`的子类），Unity 已做好了一些默认处理，比如：

- 如果`Current`是`null`，就相当于什么也不做。在下一次游戏循环中，就会调用`MoveNext`。所以`yield return null`就起到了等待一帧的作用
- 如果`Current`是`WaitForSeconds`类型，Unity 会获取它的等待时间，每次游戏循环中都会判断时间是否到了，只有时间到了才会调用`MoveNext`。所以`yield return WaitForSeconds`就起到了等待指定时间的作用
- 如果`Current`是`UnityWebRequestAsyncOperation`类型，它是`AsyncOperation`的子类，而`AsyncOperation`有`isDone`属性，表示操作是否完成，只有`isDone`为`true`时，Unity 才会调用 M`oveNext`。对于`UnityWebRequestAsyncOperation`而言，只有请求完成了，才会将`isDone`属性设置为`true`。

也因此我们才可以使用下面的同步代码，完成本来是异步的网络请求操作。

```C#
using(UnityWebRequest webRequest = UnityWebRequest.Get("https://www.cnblogs.com/iwiniwin/p/13705456.html"))
{
    yield return webRequest.SendWebRequest();
    if(webRequest.isNetworkError)
    {
        Debug.Log("Error " + webRequest.error);
    }
    else
    {
        Debug.Log("Received " + webRequest.downloadHandler.text);
    }
}
```

## 游卡

### LoopScrollView

### UI 框架

### 表格加载

## 莉莉丝

### C# 字符串优化

### 图片压缩

## 叠纸三面

### C#内存分配

### 堆和栈的访问速度

### C# GC

### Lua 元表

### 红点系统

## 米哈游一面

### Top K 问题

### Lua 和 C#交互

### Rebatch 和 Rebuild 的作用

### 前向渲染和延迟渲染

## 网易

### C++构造函数可以是虚函数吗

#### 为什么构造函数不可以是虚函数

##### 从内存的角度看

虚函数对应一个虚函数表，虚函数表是存储在对象的内存空间中的。而调用虚函数使用过调用虚函数表来实现的。如果构造函数是虚函数，那么就需要通过虚函数表来调用，但是对象是通过构造函数实例化的，**在调用构造函数之前，虚函数表内存空间还没有被创建，无法找到虚表**。所以构造函数不能是虚函数

##### 从使用的角度看

虚函数是通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。但是构造函数是通过创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以规定构造函数不能是虚函数

#### 为什么析构函数可以是虚函数

一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于基类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。
C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和 C 语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员

### 渲染流程，CPU 阶段的剔除操作有哪些

剔除有视锥体剔除（Frustum Culling）、层级剔除（Layer Culling Mask）、遮挡剔除（Occlusion Culling）等步骤，目的是将不想被摄像机看到的物体剔除掉，减少不必要的性能开销，提高渲染效率

#### 视锥体剔除

在 Unity 中，摄像机的可视区域是一个横放的金字塔形称为视锥体，由近裁面、远裁面、视场角三个参数控制，通过计算这个视锥体与场景中的模型是否相交，没有相交就说明位于可视区域外，这样的模型就应该进行剔除
<center>
    <img src="51/frustum-culling.jpg" />
</center>

由于模型一般面数较多，因此会采用给模型创建包围体再计算包围体与可视区域是否相交的方式简化计算。包围体有多种计算方法，常用的有 OBB（Oriented Bounding Box，有向包围盒）、AABB（Axis-Aligned Bounding Box，轴对齐包围盒）、球形包围体（外接球）等，其中 AABB 因为计算方便而更为常用

<center>
    <img src="51/obb.png" />
</center>

#### 层级剔除

Unity 中的模型可以设置自身所处的层级（Layer），而摄像机则可以设置需要剔除掉的层级，从而跳过特定物体的渲染

<center>
    <img src="51/layer-maks-culling.jpg" />
</center>

#### 遮挡剔除

在渲染时，如果物体有前后顺序并且后方的物体完全被前方物体遮挡住，此时后方物体在摄像机中完全看不见，也就没有必要进行计算，可以进行剔除

<center>
    <img src="51/occlusion-culling.png" />
</center>

### LRU 算法

LRU（Least recently used，最近最少使用）是缓存置换策略中的一种常用的算法。其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存队列已满时，新的元素加入队列时，需要从现有队列中移除一个元素，LRU 策略就是将最近最少被访问的元素移除，从而腾出空间给新的元素。

当对 key 进行访问时（一般有查询，更新，增加，在`get()`和`set()`两个方法中实现即可）时，将该 key 放到队列的最前端（或最后端）就行了，这样就实现了对 key 按其最后一次访问的时间降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。

#### 普通实现

借助于普通 dict 和 list 来实现，dict 保存键值对，list 保证插入的有序（借助列表来记录插入的顺序）

```python
# 基于普通 dict 和 list 实现
class LRUCache(object):
    def __init__(self, size=5):
        self.size = size
        self.cache = dict()
        self.key_list = []
 
    def get(self, key):
        if key in self.cache:
            self.key_list.remove(key)
            self.key_list.insert(0, key)
            return self.cache[key]
        else:
            return None
 
    def set(self, key, value):
        if key in self.cache:  # 更新
            self.key_list.remove(key)  
        elif len(self.cache) == self.size:  # 删除插入
            old_key = self.key_list.pop()
            self.cache.pop(old_key)
        self.cache[key] = value       # 一般插入
        self.key_list.insert(0, key)
```
使用 hash 表来定位结点位置，`get()`和`set()`的时间复杂度均为$O(1)$，空间复杂度为$O(n)$

#### 借助`OrderedDict`

python 中有一个标准库的类的`OrderedDict`（有序字典），该类有以下两个方法用来实现 LRU 算法就十分简单：

* `popitem(last=True)`：有序字典的 `popitem()` 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对
* `move_to_end(key, last=True)`：将现有 key 移动到有序字典的任一端。 如果 last 为真值（默认）则将元素移至末尾；如果 last 为假值则将元素移至开头。如果 key 不存在则会触发 KeyError`

```python
from collections import OrderedDict, defaultdict
 
class LRU:
    def __init__(self, capacity=128):
        self.capacity = capacity    # 缓存容量
        self.cache = OrderedDict()  # 有序字典缓存
 
    def put(self, key, value):
        if key in self.cache:
            # 若数据已存在，表示命中一次，需要把数据移到缓存队列末端
            self.cache.move_to_end(key)
            return
        if len(self.cache) >= self.capacity:
            # 若缓存已满，则需要淘汰最早没有使用的数据
            self.cache.popitem(last=False)
        # 录入缓存
        self.cache[key]=value
 
    # 遍历 key
    def travel(self):
        for key in self.cache.keys():
            print(key)
 
    def get(self, key):
        if key in self.cache:
            val = self.cache.pop(key)
            self.cache[key] = val
        else:
            val = None
 
        return val
```

### 缓存算法

#### FIFO算法

如果一个数据最先进入缓存，则应该最早淘汰掉

* `get(key)`：如果Cache中存在该key，则返回对应的value值，否则，返回-1
* `set(key,value)`：如果Cache中存在该key，则重置value值；如果不存在该key，则将该key插入Cache，若Cache已满，则淘汰最早进入Cache的数据

#### LRU：Least Recently used

如果数据最近被访问过，那么将来被访问的几率也更高

#### LFU：Least Frequency Used

如果数据过去被访问多次，那么将来被访问的频率也更高。注意LFU和LRU的区别，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数

为了能够淘汰最少使用的数据，LFU算法最简单的一种设计思路就是：利用一个数组存储数据项，用hashmap存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来，在插入数据和访问数据的时候都能达到$O(1)$的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为$O(n)$。
另外还有一种实现思路就是利用小顶堆+hashmap，小顶堆插入、删除操作都能达到$O(logn)$时间复杂度，因此效率相比第一种实现方法更加高效