---
title: 面经
toc: true
date: 2024-05-13 22:12:47
categories: 面试
tags:
- Unity
- C#
---

## 波克城市

### 协程是否共享堆栈

### 动态合批和静态合批，触发条件是什么

### 透明物体位于 Unity 哪个渲染阶段

### 已知法向纹理，如何还原法线向量

### 如何计算 MipMap 个数

### 描述 Blooming 方法

### 如何解决 AssetBundle 依赖

## B 站

### 图集是怎样生成的

### 资源加载

#### Unity `AssetDatabase`和`Resources`资源管理

Unity 常用的资源大概有以下几类：

- 纯资源（material，texture，shader，audio，...）这些资源不能直接拖到场景里使用
- 预置（prefab），这种资源需要实例化之后才能使用
- scene 也是一种资源
- 脚本对象，文本文件，unity 自己内置的资源（像新建粒子时的默认材质之类的）

Unity 管理这些资源分为两种：

- 在编辑器内管理，使用`AssetDatabase`加载卸载资源
  - 在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用
- 运行时管理，简单化使用`Resources`，复杂化使用 AssetBundle
  - 在运行时管理资源，简单的方法就是使用`Resources`接口。这种方式控制资源的管理效率高，资源需要放在 Resources 文件夹下。这就说明 Unity 在打包时只会打包 Resources 文件夹下的资源到终端上。 加载这个文件夹下的资源不需要扩展名。最好不要建立多个 Resources 文件夹，否则 Unity 可能会不知道要加载哪一个

## 

### C# 调用 Lua GC 是如何产生的，如何避免 GC

### UGUI 自适应大小

### 如何避免装箱拆箱

### Lua 元表是什么

原表是 Lua 中元表（Metatable）的一种特殊类型。元表是一种可选的附加到表上的表，用于控制表的行为。当我们进行特定的操作时，例如访问表中不存在的键、进行算术运算或比较等，Lua 会在元表中查找相应的元方法并执行相关的操作。

元表通过定义元方法来定义特定操作的行为。元方法是一组预定义的函数，以特定的键存储在元表中。当执行相关操作时，Lua 会检查元表中是否存在对应的元方法，并根据元方法的定义来处理操作。

以下是一些常见的元方法及其对应的操作：

- `__index`：该元方法用于处理当访问表中不存在的键时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__index 元方法。如果存在，Lua 会调用该元方法，并将表和被访问的键作为参数传递给它。该元方法可以返回一个值来作为访问的结果，或者可以是一个函数，以便进行进一步的操作。
- `__newindex`：该元方法用于处理当对表中不存在的键进行赋值时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__newindex 元方法。如果存在，Lua 会调用该元方法，并将表、被赋值的键和赋予的值作为参数传递给它。我们可以在该元方法中自定义处理逻辑，例如捕获赋值操作并执行自定义的操作或者抛出错误。
- `__add`、`__sub`、`__mul`、`__div`等：这些元方法用于重载表的算术运算符。当进行相应的算术运算时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的操作。我们可以在这些元方法中实现自定义的算术运算逻辑。
- `__eq`、`__lt`、`__le`：这些元方法用于重载表的比较运算符。当进行相应的比较操作时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的比较逻辑。我们可以在这些元方法中实现自定义的比较逻辑。
要将元表关联到表上，我们使用 setmetatable 函数。通过将表作为第一个参数，元表作为第二个参数传递给 setmetatable 函数，即可将元表关联到表上。

原表的应用非常广泛，可以用于实现面向对象的特性，例如继承、多态等。我们可以通过定义元方法来自定义对象的行为，同时还可以通过原表来实现一些高级功能，如代理（Proxy）、属性访问、事件触发等。通过定义适当的元方法，我们可以拦截和重定义对表的操作，从而实现各种定制化的行为。

以下是一个更具专业性的示例，演示了如何使用原表来实现代理模式：
```lua
-- 原始对象
local realObject = {
  value = 42,
  getName = function(self)
    return "Real Object"
  end
}

-- 代理对象
local proxyObject = {
  value = 0,
  getName = function(self)
    return "Proxy Object"
  end
}

-- 定义代理的元表
local proxyMetatable = {
  __index = function(table, key)
    -- 当访问值时，代理返回代理对象的值
    if key == "value" then
      return table.value
    end
    -- 当调用方法时，代理返回原始对象的方法
    if key == "getName" then
      return realObject.getName
    end
  end,
  __newindex = function(table, key, value)
    -- 代理只允许修改代理对象的值，而不影响原始对象
    if key == "value" then
      table.value = value
    end
  end
}
```

### TimeLine 和 animator

### animator 如何解决帧数冲突

### Lua 插入哈希表还是数组

### `readonly`和`const`区别

- `const`修饰符
  - 初始化时机：编译时，即编译程序时将值已经嵌入代码中；
  - 值状态：不允许动态修改
  - 修饰范围：字段、局部变量
  - 主要应用场景：主要应用于程序运行中不需要改变的变量的值，比如数学符号 PI；
- `static`修饰符
  - 初始化时机：运行时，可以声明时赋值，也可以在构造函数，或使用时赋值
  - 值状态：允许修改
  - 修饰范围：类、字段、属性、方法、运算符、事件、构造函数（不能用于索引器、析构函数或类以外的类型）
  - 主要应用场景：主要作用于类的公共属性
- `readonly`修饰符
  - 初始化时机：运行时，可以声明时赋值或在类中的构造函数中赋值
  - 值状态：允许修改，但只能在构造函数中修改
  - 修饰范围：字段
  - 主要应用场景：主要作用于实例化的对象的只读属性
- `static readonly`修饰符
  - 初始化时机：运行时，是两个关键字的组合
  - 值状态：允许修改，声明时赋值或者静态构造函数中赋值
  - 修饰范围：字段
  - 主要应用场景：
    - 和`const`相比，它主要应用于引用性变量；而`const`，只能用于`string`类型的引用性变量；
    - 类的只读公共属性
总结：
- `const`是静态的、编译期变量，只能在声明变量的时候赋值。
- `readonly`是运行时变量，可以在声明的时候或在构造函数内赋值。
- `static readonly`变量就变成了静态的、编译期变量。只能静态构造函数中进行初始化。
- 同时`static readonly`可以理解为是最简单的一种单例模式实现方式。
- `const`是静态常量，`readonly`是动态常量。`const`高效，`readonly`灵活！但实际开发中我们经常用`static readonly`来代替`const`, 以平衡`const`在灵活性上的不足

##

### Used Total 和 Reserved Total

在 Profiler 工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 Used Total（使用总内存）和 Reserved Total（预定总内存）。Used Total 和 Reserved 均是物理内存，其中 Reserved 是 unity 向系统申请的总内存，Unity 底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的 Reserved 内存，而运行时，unity 所使用的内存首先是向 Reserved 中来申请内存，当不使用时也是先向 Reserved 中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total 越大，则 Reserved Total 越大，而当 Used Total 降下去后，Reserved Total 也是会随之下降的（但并不一定与 Used Total 同步）

## 

### LoopScrollView

### UI 框架

### 表格加载

## 

### C# 字符串优化
