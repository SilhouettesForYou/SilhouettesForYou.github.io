---
title: 面经
toc: true
date: 2024-05-13 22:12:47
categories: 面试
tags:
- Unity
- C#
---

## 波克城市

### 协程是否共享堆栈

* 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度
* 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度（标准线程是的）
* **协程和线程**一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度

### 透明物体位于 Unity 哪个渲染阶段

### 已知法向纹理，如何还原法线向量

### 如何计算 MipMap 个数

### 描述 Blooming 方法

### 如何解决 AssetBundle 依赖

## B 站

### 图集是怎样生成的

### 资源加载

#### Unity `AssetDatabase`和`Resources`资源管理

Unity 常用的资源大概有以下几类：

* 纯资源（material，texture，shader，audio，...）这些资源不能直接拖到场景里使用
* 预置（prefab），这种资源需要实例化之后才能使用
* scene 也是一种资源
* 脚本对象，文本文件，unity 自己内置的资源（像新建粒子时的默认材质之类的）

Unity 管理这些资源分为两种：

* 在编辑器内管理，使用`AssetDatabase`加载卸载资源
  * 在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用
* 运行时管理，简单化使用`Resources`，复杂化使用 AssetBundle
  * 在运行时管理资源，简单的方法就是使用`Resources`接口。这种方式控制资源的管理效率高，资源需要放在 Resources 文件夹下。这就说明 Unity 在打包时只会打包 Resources 文件夹下的资源到终端上。 加载这个文件夹下的资源不需要扩展名。最好不要建立多个 Resources 文件夹，否则 Unity 可能会不知道要加载哪一个

## 叠纸一面

### C# 调用 Lua GC 是如何产生的，如何避免 GC

### UGUI 自适应大小

### 如何避免装箱拆箱

### Lua 元表是什么

原表是 Lua 中元表（Metatable）的一种特殊类型。元表是一种可选的附加到表上的表，用于控制表的行为。当我们进行特定的操作时，例如访问表中不存在的键、进行算术运算或比较等，Lua 会在元表中查找相应的元方法并执行相关的操作。

元表通过定义元方法来定义特定操作的行为。元方法是一组预定义的函数，以特定的键存储在元表中。当执行相关操作时，Lua 会检查元表中是否存在对应的元方法，并根据元方法的定义来处理操作。

以下是一些常见的元方法及其对应的操作：

- `__index`：该元方法用于处理当访问表中不存在的键时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__index 元方法。如果存在，Lua 会调用该元方法，并将表和被访问的键作为参数传递给它。该元方法可以返回一个值来作为访问的结果，或者可以是一个函数，以便进行进一步的操作。
- `__newindex`：该元方法用于处理当对表中不存在的键进行赋值时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__newindex 元方法。如果存在，Lua 会调用该元方法，并将表、被赋值的键和赋予的值作为参数传递给它。我们可以在该元方法中自定义处理逻辑，例如捕获赋值操作并执行自定义的操作或者抛出错误。
- `__add`、`__sub`、`__mul`、`__div`等：这些元方法用于重载表的算术运算符。当进行相应的算术运算时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的操作。我们可以在这些元方法中实现自定义的算术运算逻辑。
- `__eq`、`__lt`、`__le`：这些元方法用于重载表的比较运算符。当进行相应的比较操作时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的比较逻辑。我们可以在这些元方法中实现自定义的比较逻辑。
要将元表关联到表上，我们使用 setmetatable 函数。通过将表作为第一个参数，元表作为第二个参数传递给 setmetatable 函数，即可将元表关联到表上。

原表的应用非常广泛，可以用于实现面向对象的特性，例如继承、多态等。我们可以通过定义元方法来自定义对象的行为，同时还可以通过原表来实现一些高级功能，如代理（Proxy）、属性访问、事件触发等。通过定义适当的元方法，我们可以拦截和重定义对表的操作，从而实现各种定制化的行为。

以下是一个更具专业性的示例，演示了如何使用原表来实现代理模式：

```lua
-- 原始对象
local realObject = {
  value = 42,
  getName = function(self)
    return "Real Object"
  end
}

-- 代理对象
local proxyObject = {
  value = 0,
  getName = function(self)
    return "Proxy Object"
  end
}

-- 定义代理的元表
local proxyMetatable = {
  __index = function(table, key)
    -- 当访问值时，代理返回代理对象的值
    if key == "value" then
      return table.value
    end
    -- 当调用方法时，代理返回原始对象的方法
    if key == "getName" then
      return realObject.getName
    end
  end,
  __newindex = function(table, key, value)
    -- 代理只允许修改代理对象的值，而不影响原始对象
    if key == "value" then
      table.value = value
    end
  end
}
```

### TimeLine 和 Animator

Animator 是组件，而 Timeline 是资产

Animator 这个组件，是用来实现“使用某种动画数据来驱动所在 GameObject 及其子物体的各种参数随时间推移而发生变化”这一功能的。比如：Animator 告诉 Transform 组件将 position 和 rotation 设置到某一个数值，而这个数值的来源就是我们的动画片段（Animation clip，也就是。anim 文件资产）

但 Animator 这个组件并不直接读取。anim 资产的数据，而是通过 Animator Controller 资产来间接获取。Animator Controller 是一个状态机，可以设置一系列参数来控制多个多个动画片段之间的融合过渡。有了 Animator Controller 的参与，Animator 组件就不需要直接控制很多很多的动画片段了（特别特别麻烦），只需要控制相应的“参数”就可以达到控制很多动画片段之间的融合过渡的目的

Animator Controller 是用来整合。anim 数据的资产，Timeline 一定程度上也是。Timeline 的 Animation Track 做到事情，就是将多个动画片段按时间顺序连接起来（你可以把 Timeline 理解成一个非线性动画编辑器），这样我们就不需要手动控制这些动画片段的播放时间，只需要在需要的时候播放 Timeline 即可。当然，使用 Animator Controller 也能达到类似的目的，比如将多个片段“串起来”，但 Timeline 的整合显然更直观更好用

### Animator 如何解决帧数冲突

### Lua 插入哈希表还是数组

### `readonly`和`const`区别

- `const`修饰符
  - 初始化时机：编译时，即编译程序时将值已经嵌入代码中；
  - 值状态：不允许动态修改
  - 修饰范围：字段、局部变量
  - 主要应用场景：主要应用于程序运行中不需要改变的变量的值，比如数学符号 PI；
- `static`修饰符
  - 初始化时机：运行时，可以声明时赋值，也可以在构造函数，或使用时赋值
  - 值状态：允许修改
  - 修饰范围：类、字段、属性、方法、运算符、事件、构造函数（不能用于索引器、析构函数或类以外的类型）
  - 主要应用场景：主要作用于类的公共属性
- `readonly`修饰符
  - 初始化时机：运行时，可以声明时赋值或在类中的构造函数中赋值
  - 值状态：允许修改，但只能在构造函数中修改
  - 修饰范围：字段
  - 主要应用场景：主要作用于实例化的对象的只读属性
- `static readonly`修饰符
  - 初始化时机：运行时，是两个关键字的组合
  - 值状态：允许修改，声明时赋值或者静态构造函数中赋值
  - 修饰范围：字段
  - 主要应用场景：
    - 和`const`相比，它主要应用于引用性变量；而`const`，只能用于`string`类型的引用性变量；
    - 类的只读公共属性
总结：
- `const`是静态的、编译期变量，只能在声明变量的时候赋值。
- `readonly`是运行时变量，可以在声明的时候或在构造函数内赋值。
- `static readonly`变量就变成了静态的、编译期变量。只能静态构造函数中进行初始化。
- 同时`static readonly`可以理解为是最简单的一种单例模式实现方式。
- `const`是静态常量，`readonly`是动态常量。`const`高效，`readonly`灵活！但实际开发中我们经常用`static readonly`来代替`const`, 以平衡`const`在灵活性上的不足

## 叠纸二面

### Used Total 和 Reserved Total

在 Profiler 工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 Used Total（使用总内存）和 Reserved Total（预定总内存）。Used Total 和 Reserved 均是物理内存，其中 Reserved 是 unity 向系统申请的总内存，Unity 底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的 Reserved 内存，而运行时，unity 所使用的内存首先是向 Reserved 中来申请内存，当不使用时也是先向 Reserved 中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total 越大，则 Reserved Total 越大，而当 Used Total 降下去后，Reserved Total 也是会随之下降的（但并不一定与 Used Total 同步）

### 如何实现历史记录

### `EditorWindow`生命周期

<center>
    <img src="51/editor-window-life.png" />
</center>

### `Animation Clip`数据结构

### 协程的原理

#### `yield`和`IEnumerator`什么关系

`yield`是 C#的关键字，其实就是快速定义迭代器的语法糖。只要是`yield`出现在其中的方法就会被编译器自动编译成一个迭代器，对于这样的函数可以称之为迭代器函数。迭代器函数的返回值就是自动生成的迭代器类的一个对象

试试想象如果没有`yield`关键字，我们每定义一个迭代器，就要创建一个类，实现`IEnumerator`接口，接口包含的属性与方法都要正确的实现，是不是很麻烦？而利用`yield`关键字，只需要下面简单的几行代码，就可以快速定义一个迭代器。诸如迭代器类的创建，`IEnumerator`接口的实现工作编译器通通帮你做了

```C#
// 由迭代器函数定义的迭代器
IEnumerator Test()
{
    yield return 1;
    Debug.Log("Surprise");
    yield return 3;
    yield break;
    yield return 4;
}

```

#### Unity 协程机制的实现原理

协程是一种比线程更轻量级的存在，协程可完全由用户程序控制调度。协程可以通过`yield`方式进行调度转移执行权，调度时要能够保存上下文，在调度回来的时候要能够恢复。这是不是和上面“停住”代码然后又原位恢复的执行效果很像？没错，Unity 实现协程的原理，就是通过`yield return`生成的`IEnumerator`再配合控制何时触发`MoveNext`来实现了执行权的调度

具体而言，Unity 每通过`MonoBehaviour.StartCoroutine`启动一个协程，就会获得一个`IEnumerator`（`StartCoroutine`的参数就是`IEnumerator`，参数是方法名的重载版本也会通过反射拿到该方法对应的`IEnumerator`）。并在它的游戏循环中，根据条件判断是否要执行`MoveNext`方法。而这个条件就是根据`IEnumerator`的`Current`属性获得的，即`yield return`返回的值。

在启动一个协程时，Unity 会先调用得到的`IEnumerator`的`MoveNext`一次，以拿到`IEnumerator`的`Current`值。所以每启动一个协程，协程函数会立即执行到第一个 yield return 处然后“停住”。

对于不同的`Current`类型（一般是`YieldInstruction`的子类），Unity 已做好了一些默认处理，比如：

- 如果`Current`是`null`，就相当于什么也不做。在下一次游戏循环中，就会调用`MoveNext`。所以`yield return null`就起到了等待一帧的作用
- 如果`Current`是`WaitForSeconds`类型，Unity 会获取它的等待时间，每次游戏循环中都会判断时间是否到了，只有时间到了才会调用`MoveNext`。所以`yield return WaitForSeconds`就起到了等待指定时间的作用
- 如果`Current`是`UnityWebRequestAsyncOperation`类型，它是`AsyncOperation`的子类，而`AsyncOperation`有`isDone`属性，表示操作是否完成，只有`isDone`为`true`时，Unity 才会调用 M`oveNext`。对于`UnityWebRequestAsyncOperation`而言，只有请求完成了，才会将`isDone`属性设置为`true`。

也因此我们才可以使用下面的同步代码，完成本来是异步的网络请求操作。

```C#
using(UnityWebRequest webRequest = UnityWebRequest.Get("https://www.cnblogs.com/iwiniwin/p/13705456.html"))
{
    yield return webRequest.SendWebRequest();
    if(webRequest.isNetworkError)
    {
        Debug.Log("Error " + webRequest.error);
    }
    else
    {
        Debug.Log("Received " + webRequest.downloadHandler.text);
    }
}
```

#### Lua 协程

Lua 协程的相关函数封装在 coroutine 中，对应的 C API 为`lua_newthread`，`lua_resume`等。Lua 文档中的 thread 和 coroutine 是一个概念，但与操作系统的线程是两个东西。C API 通过`lua_State`维护一个协程的状态（以及 Lua 虚拟机状态的引用），协程的状态主要指协程上下文（如交互栈），Lua 虚拟机状态是全局的，可被多个协程共享

当调用`lua_newstate`时，实际上分为两步

* 创建并初始化一个 Lua 虚拟机`global_State`
* 创建一个主协程运行于虚拟机中，并返回主协程的执行上下文 LuaState

调用`lua_newthread`时，将在已有 Lua 虚拟机上，创建另一个协程执行环境，该协程与已有协程共享虚拟机状态（同一个 Lua 虚拟机中的不同协程共享`global_State`)，并返回新的执行上下文。因此将 LuaState 理解为协程执行上下文可能更合适，LuaState 本身也是一个类型为 thread 的 GCObject，无需手动释放

## 游卡

### LoopScrollView

### UI 框架

### 表格加载

## 莉莉丝

### C# 字符串优化

* 使用`string.Empty`给一个空字符串变量赋初始值，`String.Empty`是一个指代，而`""`是具体的实现
* 使用`str.Length == 0`做空串比较
* 避免不必要的字符串`ToUpper`、`ToLower`类操作
  * `ToUpper`、`ToLower`这类方法均会重新生成字符串对
  * `String.Compare`可实现忽略字符串大小写
  
  ```c#
  //不推荐的写法
  if(s1.ToUpper() == s2.ToUpper())
  //推荐的写法
  if(String.Compare(s1, s2, true) == 0)
  ```

* 用`StringBuilder`进行字符串拼接操作
* 创建`StringBuilder`应指定初始大小
* 避免滥用`StringBuilder`
  * 类似`str1 + str2 + str3 + str4`的字符串拼接操作会被编译为`String.Concat(str1, str2, str3, str4)`，效率反而高于`StringBuilder`。`String.Concat`会一次性确定字符串长度，`StringBuilder`需要做`Resize`，适用于多次生成`string`对象的情况
* 通过直接设置`.Length = 0`来初始化`StringBuilder`
* 不要使用`.Length = 0`来释放`StringBuilder`占用的内存

### 图片压缩

#### 术语

* **内存**：例如`A8R8G8B8`格式中一个像素占 4 字节，如果是 512x512 分辨率内存就占用`512 * 512 * 4B = 1048576B = 1MB`，这种内存消耗在低端设备上根本无法接受
* **带宽**：在渲染 3D 场景时，会有大量的贴图被传输到 GPU，若不限制，总线带宽很快就会成为瓶颈
* **有损**：表示对于渲染来说，有损压缩是可以接受的，一般选择压缩格式时需要在纹理质量和文件大小上寻求一个平衡
* **固定速率压缩**：因为 GPU 需要能够高效的随机访问一个像素，这意味着对任意像素，解码速度不该有太大的变化。因此，见的贴图压缩算法都是固定速率压缩。相反的例如 zip 则是一种可变速率压缩
* **向量量化（Vector Quantization，VQ）**：此技术原用于资料压缩，透过分割大数量的资料点（函数），让每个小群集都有相同的资料点，而这些小群集的所有资料就由其正中央的点作为代表
* **编码和解码速度**：一般来说编码速度慢没关系，因为通常纹理压缩只需要在游戏打包时进行一次，对于用户运行时体验完全没有影响。但解码速度必须足够快，而且基本上不能影响到渲染性能
* **压缩比**：通常以比特率或每像素的平均比特数（bits per pixel，bpp）表示，常见的为 2~8bpp。一般 RGB 原生纹理的像素指 24 位，4bpp 表示每像素占 4 位，所以也可以认为 4bpp 表示压缩比为 6:1

#### ETC

##### 基本思想

将图片分成 4x4 的若干个像素块，每个像素块按照一定规则编码成为一个 64 位 (8 字节）的数据，大概的想法是计算像素块的平均颜色，然后记录这个平均颜色和每个像素相对平均颜色的差值，平均颜色只耗费了一个像素的数据，而差值也并不记录完全真实的差值，而是从一个固定的静态数据中找到最接近的差值（RGB 三个通道差值一样），每个像素只需要记录其差值在静态数据中的索引即可

* 压缩比：对于 RGB24 图片，每个块的数据由 4x4x3 = 48 字节，压缩为 8 字节，压缩比为 6:1，针对 Alpha 图片，由 4x4x1 = 16 字节 压缩为 8 字节，所以，对于普通的 RGBA 分离为 RGB24 和 Alpha 之后分别进行 ETC1 压缩的图片，整体压缩比为 (48 + 16) : (8 + 8) = 4:1
* 文件头数据：除了编码后的数据块之外，还会存储一部分文件头数据，用来表示文件的特征码、宽高等

##### 像素块编码思想

* 将 4x4 的像素块分为两个 4x2 的子块，有水平和竖直两种分法。使用 1 位数据 flipbit 来表示是哪一种分法，还剩下 63 位数据

<center>
    <img src="51/pixel-split.webp" />
</center>

* 分别计算两个分块中 8 个像素颜色的平均值，根据两个块颜色平均值的差值，确定使用 individual 模式还是 differential 模式。使用 1 位数据 diffbit 来表示是哪种模式，还剩下 62 位数据
* 存放两个子块的平均颜色信息，individual 模式用 R4G4B4 的格式分别表示两个子块的平均颜色，differential 模式使用 R5G5B5 格式表示第一个子块的平均颜色，R3G3B3 格式表示第二个子块与第一个子块平均颜色的差值。这里使用了 8 * 3 = 24 位数据，还剩下 62 - 24 = 38 位数据
* 所有的图片共享一个全局的映射表数据，这个数据是固定的全局静态数据，并不会进入到编码数据中，这个表是一个 8 x 4 的二维数组，使用 3 位数表示第一个子块在映射表中查询的第一维索引，需要 3 位来表示 0 - 7 的下标，第二个子块同样需要 3 位数来表示，还剩下 38 - 3 * 2 = 32 位数据
* 4 x 4 像素块中的每个像素，使用 2 位数来表示该像素在映射表中查询的第二维索引，需要 2 位数来表示 0 - 3 的下标，所以消耗了 4 x 4 x 2 = 32 位数据

##### 内存布局和解码过程

以 RGB555 基本色和 RGB3333 颜色差表示的编码为例，每个 4x4 像素块经过 ETC1 编码后的 64 位数据的内存布局大概是这样

<center>
    <img src="51/etc-memory-layout.webp" />
</center>

假如编码前像素块表示为下图，需要得到图中编号 2 对应像素的颜色，需要进行如下的解码步骤：

<center>
    <img src="51/etc-decode.webp" />
</center>

* 获取目标所在的子块：根据第 32 位 flipbit 标志位，知道这个像素块采用的是横版划分子块，2 号像素处在子块 2 中
* 获取子块 1 基本颜色：首先根据第 33 位 diffbit 标志位得知，这里采用的是 R5G5B5 基本色 + R3G3B3 差值的方式。分别从 59-63 位 (11100)、51-55 位 (00100) 和 43-47 位 (00011) 读取子块 1 基本色 RGB1=(11100, 00100, 00011) = (28, 4, 3)
* 获取子块 2 的颜色差值：这里是 differential 模式，所以需要读取子块 2 的颜色差值，从 56-58 位 (100)、48-50 位 (010) 和 40-42 位 (000) 获得颜色差值 RGB_offset=(100, 010, 000) = (-4, 2, 0)，注意这里的 3 位数据中最高位是符号位，所以差值部分的取值范围是 [-4, 3]
* 计算子块 2 的基本色：将子块 1 基本色和子块 2 差值相加，得到子块 2 的基本色，RGB2=RGB1 + RGB_offset = (28 - 4, 4+2, 3+0) = (24, 6, 3)，转为 5 位二进制表示为 RGB2=(11000, 00110, 00011)
* 扩展子块 2 基本色分量为 8 位：对 5 位标识的基本色补位为 8 位表示，得到 RGB1 = (11000110, 00110110, 00011011) = (198, 54, 27)，这就是子块 2 的基本色
  > 补位规则：
  > * individual 模式，直接将 4 位数复制到尾部，得到 8 位
  > * differential 模式，将 5 位中的高 3 位复制到尾部，得到 8 位
  > * differential 模式，一定是将子块 1 基本色和子块 2 偏移值相加后再进行补位
* 获得目标像素的颜色偏移值：目标像素下标为 2，在编码数据的第 2 位得到映射表的下标的低位 (lsb) 为 1，第 18 位得到映射表的下标高位 (msb) 为 1，假如使用如下的映射表，则可以得到映射表下标为 (lsb, msb)=(1,1)，对应下标为 -b

<center>
    <img src="51/etc-mapped.webp" />
</center>

  上面知道目标像素位于子块 2，这里还需要从编码数据的 34-36 获得子块 2 的修正表索引，得到索引为 (1,1,0)=6，根据上面的映射表，根据下标 (6, -b) 可以索引到像素的颜色差值为-106

* 计算目标像素的最终颜色值：这里 RGB 三个分量的差值相同，目标像素最终的颜色值为子块 2 的基本颜色 + 目标像素的颜色偏移值：
RGB_target = RGB2 + (-106, -106, -106) = (198 - 106, 54 - 106, 27 - 106)，修正后得到目标颜色值 RGB_target = (92, 204, 177)

##### 编码过程

* 将图划分为 4x4 的像素块，如果不够 4x4，则将这些像素填充在 4x4 块的左上角
* 针对每个 4x4 的像素块尝试以下编码，取解码后和原像素差值最小的那种编码作为结果
  1. 确定 flipbit，并计算两个子块的平均颜色值，这里我猜测是先将 8 个像素的 R8G8B8 取均值得到像素的平均值，然后将每个分量的后三位直接抛弃，得到 R5G5B5
  2. 根据两个子块颜色值的差值，确定 diffbit，根据上面得到的两个子块的 R5G5B5，计算差值，如果差值在 [-4, 3] 之间，说明差值可以用 3 位带符号的二进制数表示，可以用 differential 模式，否则用 individual 模式
  3. 枚举不同的子块索引，确定每个子块使用映射表中的哪一组偏移值
  4. 枚举每个像素的映射下标，确定像素使用映射表中的哪一个偏移值
  5. 针对第 3 步和第 4 步的枚举，可以得到很多组不同的编码，将编码结果解压后和原始像素数据对比，取相差最小的一组编码作为最终结果
* 将图片中各个像素块编码合并

##### Unity 的几种 ETC 纹理压缩格式

* RGB ETC1 4 bit：4 bits/pixel，对 RGB 压缩比 6:1，不支持 Alpha，绝大部分安卓设备都支持
* RGB ETC2 4 bit：4 bits/pixel，对 RGB 压缩比 6:1。不支持 Alpha，ETC2 兼容 ETC1，压缩质量可能更高，但对于色度变化大的块误差也更大，需要在 OpenGL ES 3.0 和 OpenGL 4.3 以上版本
* RGBA ETC2 8bit：8 bits/pixel，对 RGBA 压缩比 4:1。支持完全的透明通道，版本要求同上
* RGB +1bit Alpha ETC2 4bit：4 bits/pixel。支持 1bit 的 Alpha 通道，也就是只支持镂空图，图片只有透明和不透明部分，没有中间的透明度

#### DXT

DXT是一种有损纹理压缩算法，微软的Direct中支持，DXT的格式包括DXT1~DXT5，其中DXT1和DXT5较为多见

<center>
    <img src="51/dxt.webp" />
</center>

DXT算法非常容易理解，而且整体看上去效果不错，但如果对局部特写，会发现在细节上会有很多丢失，这也是算法本身导致的，毕竟每个块只有两个颜色，而其他颜色都是在这两个颜色区间的差值，如果当前区域内还有其他显著颜色则必然会有丢失

这种信息的丢失主要集中在比较细的边界中，但DXT1在压缩率上是RGB的6倍，这种问题可以通过提高纹理分辨率的方式来解决，高宽放大41%(1.41*1.41=1.9881)，这样整个纹理是以前的2倍，但压缩率还能保持为3倍，也是可以接受的。在DXT中还有一个主要的损失，就是RGB的24位转为了16位颜色，16位中R&B各占5位，但是G占了6位，这是因为人眼对绿色最为敏感

<center>
    <img src="51/dxt-16bits.webp" />
</center>

另外一个问题就是DXT3和DXT5之间的对比，相比DXT1不支持透明度（但支持是否透明），DXT5要大一倍（多了64bit），和之前颜色保存方案一样对透明度也保存了两个16位的颜色和对应的调色板，对RGBA的效果也得到了保证，但DXT3思路不一样，它是对每一个像素保存了4bit的透明度，同样也是多了64bit，但此时毕竟只有16个透明度选项，相比DXT5，在压缩率上相当，但对透明色的处理不够细腻，因此在实用性上并不推荐DXT3

#### PVRTC

PVRTC不同于DXT和ETC这类基于块的算法，而将整张纹理分为了高频信号和低频信号，低频信号由两张低分辨率的图像A和B表示，这两张图在两个维度上都缩小了4倍，高频信号则是全分辨率但低精度的调制图像M，M记录了每个像素混合的权重。要解码时，A和B图像经过双线性插值（Bilinearly）宽高放大4倍，然后与M图上的权重进行混合

<center>
    <img src="51/pvrtc.webp" />
</center>

PVRTC 4-bpp模式下，每4x4像素占一个64位数据块，2-bpp模式下每8x4像素会有一个64位数据块。4-bpp模式下，A图和B图缩小后都只保存一个颜色值，如下图所示，Color A比Color B少1位，但两张图都可以选择以RGB或ARGB的方式存储（最高位决定为哪种），Color A可以用RGB554或ARGB3443格式编码，Color B可以用RGB555或ARGB3444格式编码

<center>
    <img src="51/pvrtc-block.webp" />
</center>

在解码时，为了解码任意像素，必须读取4个相邻的PVRTC块，使用这4个块来解码一个5x5块

<center>
    <img src="51/pvrtc-decode.webp" />
</center>

使用双线性过滤来对A和B图进行扩大，然后A和B图根据M图与`Mode`位进行混合，这里的`Mode`位为1时，M图中10值像素被看作是开启了punch-through alpha，Alpha通道会被强制清零，是为了兼容旧应用程序

<center>
    <img src="51/pvrtc-bilinear-filter.webp" />
</center>

#### ASTC

以下每个用例都对压缩方案有自己的要求：

* 支持从 1 到 4 个分量的纹理。虽然单通道纹理也可以使用BC7、PVRTC2或ETC2来存储，但空通道上大量bit被浪费掉了。
* 在通道之间数据无相关性的情况下，拥有可以接受的质量。这对于法线图和 RGBA 图像来说非常重要。
* 支持 LDR 和 HDR。BC6H可用于HDR纹理压缩，但它不支持alpha通道。
* 跨平台。特别是：PVRTC 只在 iOS 平台上可用，BC6H/BC7 在移动设备中缺失，ETC 不被桌面级 GPU 所支持。对于跨平台应用程序的开发者来说，有诸多不便。
比特率/质量比的灵活性。根据纹理类型，不同程度的压缩伪影是可以接受的，因为不同图像的可压缩性是不同的。前文中提到的格式里，能提供的比特率/质量选项的不超过两个 (BC1/BC7或PVRTC 4bpp/2bpp) 。如果不能使用 5bpp 的压缩级别 (如果4bpp的质量略显不足) ，就必须使用8bpp的选项。带宽增加了一倍，但质量却没有明显改善。
* 支持 2D 和 3D 纹理。

概念上讲，ASTC 类似于 S3TC/BC7：一个压缩块中最多存储四个端点对和插值权重，只支持预定义的分区，特定的分区由分区ID指定，也存储在一个块中。在弱相关的情况下，该通道会存储一个独立的索引表。每个独立的编码被称为一个平面。或许 ASTC 最主要、最有趣的创新是用小数位编码整数值的技术，称为BISE。同时，BISE可以在硬件中有效实现

##### 有界整数序列编码 (Bounded Integer Sequence Encoding, BISE)

有界整数序列编码，或称 BISE，解决了如下抽象问题：从大小为$N$的字母表中给定等概率的符号序列， 找到一种编码，使得能够在常数时间复杂度内使用最少的硬件消耗提取第$i$个符号，并允许相同硬件设计能够用于多种不同大小的字母表，同时具备存储效率

例如，考虑一个由 5 个整数组成的序列，其中每个整数可以是 0，1 或 2（译者注：5 位的 3 进制数）。使用标准二进制编码时，需要为每个值分配 2 位，总共 10 位。但不同序列的数量是$3^5 = 243$，小于$2^8 = 256$。因此，可以用 8 比特对整个序列进行编码，每个值的比特率为 1.6。换句话说，可以用8比特来表示5 位的 3 进制数

现在，考虑任意长度的序列，其中每个值都属于范围$[0, N - 1]$，其中$N = 3 \times 2^n$。每个值都可以用一个三进制位和$n$个比特来表示。假设$N = 12$，那么满足该条件的任何值都可以用以下形式表示：$X = t2^2 + b_1{2^1} + b_0{2^0}$，其中$t$是一个三进制位，$b_1$和$b_0$是比特位。整个序列可以被划分为五组值，最后一组会在必要时填充$0$。二进制形式下，一个特定的组可以表示为一个比特串$t_4B_4t_3B_3t_2B_2t_1B_1t_0B_0$，其中$t_i$是一个三进制位的$2$比特表示，$B_i$是一个值的剩余比特位(译注: 即上文中的$b_1$和$b_0$)。只要三进制位与比特信息保持这种相关性，就可以用比特串$T_{[7]}B_4T_{[6:5]}B_3T_{[4]}B_2T_{[3:2]}B_1T_{[1:0]}B_0$保存这五组值。其中$T_{[i:j]}$为$T$的各个比特，这段数据要比原先短$2$比特

事实证明，这种编码能够保留尾部的零。例如，如果我们序列中的最后一组被填充了两个零 (所以$t_4B_4$和$t_3B_3$是零) ，那么$T_{[7]}B_4$和$T_{[6:5]}B_3$是零，它们不需要被存储。因此，任何长度的序列，假如其数值范围从$0$到$3 \times 2^n - 1$，都可以用接近于理论上的最小的比特率进行编码。同时，其中的任意值能以最小的硬件消耗容易的提取出来

同样的推理也可以应用于$N = 5 \times 2^n$的序列。这里，$3$个五进制数 (基数为$5$的数字) 可以用$7$位来编码，因为$5^3 = 125$小于$2^7 = 128$。因此，使用三进制数和五进制数的BISE技术在存储方面都是是有效率的 

<center>
    <img src="51/astc-BISE.jpg" />
</center>

##### 其他改进

ASTC 还改进了分区模式。BC6H 和 BC7 压缩方案也使用了预定义的分区集表，但这种方法不适合 ASTC，因为它支持大量的瓦片尺寸，支持更多的区域，还增加了分区ID字段的大小 (10位，而BC7是6位) 。ASTC 的分区模式是用一个特殊的哈希函数生成的，它为每个纹素分配一个分区索引。这个函数将纹素在瓦片中的位置、分区ID、瓦片大小和分区数量作为输入，并输出一个分区索引。该函数很简单，可以用硬件实现。该函数也用于 3D 纹理。图中描述了 8x8 瓦片的所有分区模式

<center>
    <img src="51/astc-8x8.jpg" />
</center>

ASTC 的一个更显著的特点是内插权重的编码方式。S3TC 系列方案使用每个顶点的索引来设置插值权重。根据块的类型，索引的大小可以是 2、3 或 4 比特。然而，对于 12x12 瓦片来说，即使每个像素使用 1bit 的索引，也无法存储在一个 128 位块。因此，ASTC 为权重和纹素提供独立的网格大小。例如，对于 12x12 的瓦片，只能存储 4x6 的权重网格。在解码阶段，权重网格被双线性地放大到瓦片大小。不过虽然看起来像，但是它和简单的瓦片缩放并不一样。例如，平滑的梯度通常可以用一个小的权重网格来表示，如 2x2。因此有更多的比特可用于端点。同时尖锐的边缘和颜色过渡可以用适合的分区模式进行编码。权重网格的大小是根据每个块来选择的。因此某些具有强烈垂直特征的瓦片，可以用 4x2 或 8x4 的权重网格进行编码

所有这些配置数据 (网格大小、分区数量、端点格式) 都必须存储在一个压缩块中。虽然不得不牺牲一些颜色数据位，因而可能降低图像质量，但这种方法带来了很好的灵活性，并且大大增强了压缩质量。ASTC 允许在每个块中进行不同的比特权衡，任意瓦片都可以在分区、端点和权重之间的分布选用最合适的比特分布进行编码。事实证明，即使在较低的比特率下，ASTC也能够提供比 PVRTC、BC1-BC5 和 ETC 更好的质量。PSNR (译注：峰值信噪比) 增益平均为 1.5dB 至 2dB，大多数观察者 (译注：推测此处数值为 ASTC 对比其他压缩格式获得的增益 ) 大约能察觉 0.25dB 的增益。BC6H的质量与之相当，而 BC7 平均比 ASTC 多出0.5dB。不过在 8bpp 时，ASTC 和 BC7 压缩图像的 PSNR 质量都在45dB左右，这种差异很难从视觉上发现

此外，ASTC 是第一个支持 3D 纹理的标准压缩方案，它利用了所有三个维度的颜色相关性。nVidia 的 OpenGL(26)的 VTC 扩展也是针对3D纹理的，但它只是把一个3D瓦片分成2D片，使用BC1方案进行压缩。ASTC 则使用 3D 权重网格和分区，利用分区模式生成器来压缩整个3D瓦片。不过权重网格是用单线法而非三线插值法进行放大的 (67) 。整个 3D 瓦片的压缩比分片压缩的 PSNR 高出 2dB

另外，ASTC 的所有特征都是 “正交 “的，即任何特征都可以独立使用，例如可以用两个弱相关的HDR通道来压缩一个三维纹理

### ASTC 块

首先是一些全局解码参数，这些参数对任何特定的纹理都是一样的。因此，没有必要在压缩块中存储这些

* 动态范围 (LDR/HDR)
* 纹理尺寸(2D/3D)
* 瓦片尺寸
* 输出色彩空间 (sRGB/RGB)

而每块指定的数据如下

* 权重网格大小
* 权重范围 (用于BISE解码）
* 权重值
* 分区的数量
* 分区模式 ID
* 颜色端点模式
* 颜色端点数据
* 平面的数量 (1或2)
* 平面到通道的分配

纹理可以被编码为单通道、双通道、三通道或四通道图像。但解码后的值总是以 RGBA 格式输出。在LDR sRGB 模式下，颜色值以 8 位整数返回，否则以 16 位浮点数返回。图40展示了 ASTC 块的布局

<center>
    <img src="51/astc-block.png" />
</center>

除了BlockMode和Part字段，所有字段的长度都是可变的。

Part字段指定了分区的数量 (减一) 。在双平面模式下，分区的数量必须是1、2或3。BlockMode字段指定了平面数、权重范围和权重网格的大小。ConfigData和MoreConfigData字段指定每个端点对的端点模式。

如果是 2D 瓦片，BlockMode由5个字段组成。A、B、R、D、H。 特殊的void-exten模式有一个单独的编码，用于单色瓦片。void-exten 块还允许识别附近的单色区域。可以缩短获取相同的块的过程，并进一步减少内存带宽占用

<center>
    <img src="51/astc-block-mode.jpg" />
</center>

A、B 字段分别指定权重网格的宽度 (N) 和高度 (M) 。D位 (双倍) 被设置为表示双平面模式。R字段 (范围) 和H位 (高精度) 指定重量范围 (见表14) 。注意，由于R字段的编码，为了避免产生歧义，位$R_1$和$R_2$不能同时为零

<center>
    <img src="51/weight-encode.png" />
</center>

ConfigData 和 MoreConfigData 指定了端点对的编码，每个端点对都可以有独立的编码模式。共有16种编码模式：10 种 LDR 格式和 6 种 HDR 格式。然而，HDR 纹理可以使用其中任何一种。所有这些端点格式都是基于以下基本方法之一:

* 独立性。两个k位的值直接存储。
* base + offset (类似于ETC的差分编码) 。第一个值为base, 用 (k+1) 位存储。第二个值为 offset, 用 (k-1) 位存储。
* base + scale。两个RGB值由四个数值 (R、G、B、s) 表示。颜色一等于 (R，G，B) ，颜色二等于 (sR，sG，sB) 

从概念上讲，ASTC块的解码是这样进行的。BlockMode 字段用于确定权重范围和权重网格的大小。权重数据从压缩块的尾部读取，并使用BISE进行解包。之后，权重被反量化为 [0, 64] 范围。如果权重网格的尺寸小于瓦片的尺寸，则使用双线性插值进行升格。

之后，Part 字段用于指定分区的数值。分区模式 ID 从块中读出，然后针对每个纹素生成哈希作为分区索引。给定分区数量，还可以利用 ConfigData 和 MoreConfigData 字段计算标量的总值，该值会被用于端点编码 (端点可以有不同数量的通道，不同的端点存储模式下会使用不同数量的值) 。然而，这些标量值的范围在 BISE 解码时必须是已知的，因为该范围并没有被明确指出。在权重和分区数据解码阶段之后，就可以知道可用于彩色端点数据的比特数。颜色端点的值会使用适用于上述比特数的最大范围的值来存储。端点被解压缩和反量化。端点对会根据分区索引来选择。端点的颜色则使用插值权重来混合

## 叠纸三面

### C#内存分配

### 堆和栈的访问速度

### C# GC

### 红点系统

## 米哈游一面

### Top K 问题

### Lua 和 C#交互

### Rebatch 和 Rebuild 的作用

### 前向渲染和延迟渲染

## 网易

### C++构造函数可以是虚函数吗

#### 为什么构造函数不可以是虚函数

##### 从内存的角度看

虚函数对应一个虚函数表，虚函数表是存储在对象的内存空间中的。而调用虚函数使用过调用虚函数表来实现的。如果构造函数是虚函数，那么就需要通过虚函数表来调用，但是对象是通过构造函数实例化的，**在调用构造函数之前，虚函数表内存空间还没有被创建，无法找到虚表**。所以构造函数不能是虚函数

##### 从使用的角度看

虚函数是通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。但是构造函数是通过创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以规定构造函数不能是虚函数

#### 为什么析构函数可以是虚函数

一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于基类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。
C++不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和 C 语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员

### 渲染流程，CPU 阶段的剔除操作有哪些

剔除有视锥体剔除（Frustum Culling）、层级剔除（Layer Culling Mask）、遮挡剔除（Occlusion Culling）等步骤，目的是将不想被摄像机看到的物体剔除掉，减少不必要的性能开销，提高渲染效率

#### 视锥体剔除

在 Unity 中，摄像机的可视区域是一个横放的金字塔形称为视锥体，由近裁面、远裁面、视场角三个参数控制，通过计算这个视锥体与场景中的模型是否相交，没有相交就说明位于可视区域外，这样的模型就应该进行剔除
<center>
    <img src="51/frustum-culling.jpg" />
</center>

由于模型一般面数较多，因此会采用给模型创建包围体再计算包围体与可视区域是否相交的方式简化计算。包围体有多种计算方法，常用的有 OBB（Oriented Bounding Box，有向包围盒）、AABB（Axis-Aligned Bounding Box，轴对齐包围盒）、球形包围体（外接球）等，其中 AABB 因为计算方便而更为常用

<center>
    <img src="51/obb.png" />
</center>

#### 层级剔除

Unity 中的模型可以设置自身所处的层级（Layer），而摄像机则可以设置需要剔除掉的层级，从而跳过特定物体的渲染

<center>
    <img src="51/layer-maks-culling.jpg" />
</center>

#### 遮挡剔除

在渲染时，如果物体有前后顺序并且后方的物体完全被前方物体遮挡住，此时后方物体在摄像机中完全看不见，也就没有必要进行计算，可以进行剔除

<center>
    <img src="51/occlusion-culling.png" />
</center>

### LRU 算法

LRU（Least recently used，最近最少使用）是缓存置换策略中的一种常用的算法。其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存队列已满时，新的元素加入队列时，需要从现有队列中移除一个元素，LRU 策略就是将最近最少被访问的元素移除，从而腾出空间给新的元素。

当对 key 进行访问时（一般有查询，更新，增加，在`get()`和`set()`两个方法中实现即可）时，将该 key 放到队列的最前端（或最后端）就行了，这样就实现了对 key 按其最后一次访问的时间降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。

#### 普通实现

借助于普通 dict 和 list 来实现，dict 保存键值对，list 保证插入的有序（借助列表来记录插入的顺序）

```python
# 基于普通 dict 和 list 实现
class LRUCache(object):
    def __init__(self, size=5):
        self.size = size
        self.cache = dict()
        self.key_list = []
 
    def get(self, key):
        if key in self.cache:
            self.key_list.remove(key)
            self.key_list.insert(0, key)
            return self.cache[key]
        else:
            return None
 
    def set(self, key, value):
        if key in self.cache:  # 更新
            self.key_list.remove(key)  
        elif len(self.cache) == self.size:  # 删除插入
            old_key = self.key_list.pop()
            self.cache.pop(old_key)
        self.cache[key] = value       # 一般插入
        self.key_list.insert(0, key)
```
使用 hash 表来定位结点位置，`get()`和`set()`的时间复杂度均为$O(1)$，空间复杂度为$O(n)$

#### 借助`OrderedDict`

python 中有一个标准库的类的`OrderedDict`（有序字典），该类有以下两个方法用来实现 LRU 算法就十分简单：

* `popitem(last=True)`：有序字典的 `popitem()` 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对
* `move_to_end(key, last=True)`：将现有 key 移动到有序字典的任一端。 如果 last 为真值（默认）则将元素移至末尾；如果 last 为假值则将元素移至开头。如果 key 不存在则会触发 KeyError`

```python
from collections import OrderedDict, defaultdict
 
class LRU:
    def __init__(self, capacity=128):
        self.capacity = capacity    # 缓存容量
        self.cache = OrderedDict()  # 有序字典缓存
 
    def put(self, key, value):
        if key in self.cache:
            # 若数据已存在，表示命中一次，需要把数据移到缓存队列末端
            self.cache.move_to_end(key)
            return
        if len(self.cache) >= self.capacity:
            # 若缓存已满，则需要淘汰最早没有使用的数据
            self.cache.popitem(last=False)
        # 录入缓存
        self.cache[key]=value
 
    # 遍历 key
    def travel(self):
        for key in self.cache.keys():
            print(key)
 
    def get(self, key):
        if key in self.cache:
            val = self.cache.pop(key)
            self.cache[key] = val
        else:
            val = None
 
        return val
```

### 缓存算法

#### FIFO 算法

如果一个数据最先进入缓存，则应该最早淘汰掉

* `get(key)`：如果 Cache 中存在该 key，则返回对应的 value 值，否则，返回-1
* `set(key,value)`：如果 Cache 中存在该 key，则重置 value 值；如果不存在该 key，则将该 key 插入 Cache，若 Cache 已满，则淘汰最早进入 Cache 的数据

#### LRU：Least Recently used

如果数据最近被访问过，那么将来被访问的几率也更高

#### LFU：Least Frequency Used

如果数据过去被访问多次，那么将来被访问的频率也更高。注意 LFU 和 LRU 的区别，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数

为了能够淘汰最少使用的数据，LFU 算法最简单的一种设计思路就是：利用一个数组存储数据项，用 hashmap 存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来，在插入数据和访问数据的时候都能达到$O(1)$的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为$O(n)$。
另外还有一种实现思路就是利用小顶堆+hashmap，小顶堆插入、删除操作都能达到$O(logn)$时间复杂度，因此效率相比第一种实现方法更加高效

##

### Unity 资源管理

在 Unity 中，一般来说，资源加载方式主要分为`Resources`加载和`AssetBundle`加载。Unity 有个特殊文件夹 Resources，放在这个文件夹下的资源可以通过`Resources.Load()`来直接加载。即`Resources`加载资源方式。当获得`AssetBundle`之后，也可以调用`AssetBundle 对应`的 API 来加载资源

AB 包全名 AssetBundle（资源包）。是一种 Unity 提供的用于存放资源的包。通过将资源分布在不同的 AB 包中可以最大程度地减少运行时的内存压力，并且可以有选择地加载内容

#### 为什么要用 AB 包

1. 热更新（要热更新需要确保 AB 包打出来的资源具有唯一性，且相同资源的 AB 包检验码相同）
2. Resources 加载虽然简单方便，但是也有很多问题
   1. 对内存管理造成一定的负担
   2. 在打开应用时加载时间很长
   3. Resources 文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型 AB 包有什么问题它就有什么问题），对资源优化有一定的限制
   4. 不建议大量使用 Resources

#### 获取 AB 包方法

```C#
AssetBundle.LoadFromFile(string path)
AssetBundle.LoadFromFileAsync(string path)
AssetBundle.LoadFromMemory(byte[] binary)
AssetBundle.LoadFromMemoryAsync(byte[] binary)
AssetBundle.LoadFromStream(Stream stream)
AssetBundle.LoadFromStreamAsync(Stream stream)
WWW.AssetBundle
```

* `LoadFromFile`是从文件中加载 AB 包，它从一个给定的路径来加载 AB 包。如果 AB 包是 LZ4 加载方式，它只会加载 AB 包的 Header，之后需要什么资源再加载那部分的 AB 包 chunk。极大的减少了内存占用。
  * `LoadFromFileAsync`是它的异步版本
* `LoadFromMemory`是从内存中加载 AB 包，它从内存中的`byte[]`中加载 AB 包。它会完整的把 AB 包加载出来
  * `LoadFromMemoryAsync`是它的异步版本
* `LoadFromStream`是从流中加载 AB 包，它从一个 Stream 中加载 AB 包。跟`LoadFromFile`一样，如果 AB 包是 LZ4 加载方式，它也是只会加载 AB 包的 Header。
  * `LoadFromStreamAsync`是它的异步版本
* WWW 是 Unity 中的跟网络相关的类，可以通过该类从网络中下载资源，之后加载成 AB 包

#### 加载资源方法

```C#
AssetBundle.LoadAsset(string assetName, Type resType)
AssetBundle.LoadAssetAsync(string assetName, Type resType)
```

#### LZMA 和 LZ4

LZMA 是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载 AB 包时，需要将整个包解压，会造成卡顿和额外内存占用。

LZ4 是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。如果需要实时解压随机读取，块压缩是比较好的选择。`LoadFromFile()`和`LoadFromStream()`都只会加载 AB 包的 Header，相对`LoadFromMemory()`来说大大节省了内存

#### 内存占用

AB 包内的资源需要通过`AssetBundle.Load()`来加载到内存中

* 对于 GameObject 来说，通常情况下需要对其进行改动，所以它是完全复制一份该资源来进行的实例化。也就是说，当 AB 包中的 GameObject 从内存中卸载后，实例化的 GameObject 不会因此丢失。并且对实例化对象的修改不会影响到 GameObject 资源
* 对于 Shader 和 Texture 来说，通常情况下不需要对其进行改动，所以它是通过引用来进行的实例化。也就是说，当 AB 包中的 Shader 和 Texture 资源从内存中卸载后，实例化的 Shader 和 Texture 会出现资源丢失的情况。并且对实例化对象的修改会影响到 Shader 和 Texture 资源
* 对于 Material 和 Mesh 来说，有时候可能需要对其进行改动，所以它是通过引用+复制来进行的实例化。也就是说，当 AB 包中的 Material 和 Mesh 资源从内存中卸载后，实例化的 Material 和 Mesh 会出现资源丢失的情况。并且对实例化对象的修改不会影响到 Material 和 Mesh 资源

> AB 包先要从硬盘或者网络中加载到内存中，然后将 AB 包内的每一份资源加载到内存中，再之后在内存中实例化这些资源。每种资源有其自己不同的实例化方式，卸载资源的时候需要注意

#### AB 包内部结构

* `AssetBundleFileHeader`：记录了版本号、压缩等主要描述信息
* `AssetFileHeader`：包含一个文件列表，记录了每个资源的 name、offset、length 等信息
* Asset1：
  * `AssetHeader`：记录了`TypeTree`大小、文件大小、format 等信息
  * `TypeTree`（可选）：记录了`Asset`对象的 class ID。Unity 可以用 class ID 来序列化和反序列化一个类（每个 class 对应了一个 ID，如 0 是`Object`类，1 是`GameObject`类等，具体可在 Unity 官网上查询）
  * `ObjectPath`：记录了 path ID（资源唯一索引 ID）等
  * `AssetRef`：记录了 AB 包对外部资源对引用情况
* Asset2
* ...

#### 依赖问题

依赖问题，通俗的话来说就是 A 包中某资源用了 B 包中的某资源。然而如果 A 包加载了，B 包没有加载，这就会导致 A 包中的资源出现丢资源的现象。在 Unity5.0 后，`BuildAssetBundleOptions.CollectDependencies`永久开启，即 Unity 会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。因为这个特性，有些情况下，如果没指定某公共资源的存放在哪个 AB 包中，这个公共资源就会被自动打进引用它的 AB 包中，所以出现多个不同的 AB 包中有重复的资源存在的现象。这就是资源冗余。

要防止资源冗余，就需要明确指出资源存放在哪个 AB 包中，形成依赖关系。所以对于一些公共资源，建议单独存放在一个 AB 包中。在加载的时候，如果 AB 包之间相互依赖，那么加载一个 AB 包中的资源时，先需要加载出另一个 AB 包的资源。这样就会导致不必要的消耗。所以说尽可能地减少 AB 包之间的依赖，并且公共资源尽量提前加载完成

#### 细粒度问题

细粒度问题即每个 AB 包分别放入多少资源的问题，一个好的策略至关重要。加载资源时，先要加载 AB 包，再加载资源。如果 AB 包使用了 LZMA 或 LZ4 压缩算法，还需要先给 AB 包解压。

* AB 包数量较多，包内资源较少；AB 包数量较少，包内资源较多
* 加载一个 AB 包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长；加载一个 AB 包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快
* 热更新灵活，要更新下载的包体较小；热更新不灵活，要更新下载的包体较大
* IO 次数过多，增大了硬件设备耗能和发热压力；IO 次数不多，硬件压力小

简单策略：

* 经常更新和不经常更新的对象拆分到不同的 AB 包中
* 同时加载的对象放在一个 AB 包中
* 不可能同时加载的对象拆分到不同的 AB 包中
* 根据项目逻辑功能来分组打 AB 包
* 根据同一类型对象来分组打 AB 包
* 公共资源和非公共资源拆分到不同的 AB 包中

#### 卸载问题

* 当调用`Resources.UnloadAsset()`时，虽`Object`被销毁，但 Instance ID 被保留且包含有效的 GUID 和 Local ID 引用
* 当调用`AssetBundle.Unload(true)`时，不仅`Object`被销毁，而且 Instance ID 的 GUID 和 Local ID 引用变无效
* 当调用`AssetBundle.Unload(false)`时，虽`Object`不被销毁，但 Instance ID 的 GUID 和 Local ID 引用变无效。场景中的物体会与该 AB 包分离链接。即该物体的 Instance ID 引用的 GUID 和 Local ID 会断开引用，无法再通过该 Instance ID 找到 GUID 和 Local ID
* 如果再次加载该 AB 包时，分离了链接的物体不会受该新加载的 AB 包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity 中有`Resources.UnloadUnusedAssets()`方法可以很好地解决这个问题

#### 各种 ID

* 序列化后，资源用 GUID 和 Local ID 管理
* GUID 对应 Asset，GUID 存在。meta 文件中，提供了文件特定位置的抽象，是一种映射，无需关心资源在磁盘上的存放位置
* Local ID 对应 Asset 内的每一个 Object
* 虽然 GUID 和 Local ID 比较好用，但是毕竟因为存在磁盘上，读取比较耗时。因此 Unity 缓存一个 Instance ID 对应 Object，通过 Instance ID 快速找到 Object。Instance ID 是一种快速获取对象实例的 ID，包含着对 GUID 和 Local ID 的引用。解析 Instance ID 可以快速返回 Instance 表示的已加载对象，如果为加载目标对象，则可以将文件 GUID 和 Local ID 解析为对象源数据，从而允许 Unity 即时加载对象。每次 AB 包重新加载时，都会为每个对象创建新的 Instance ID

### Lua 弱表

弱表是用来告诉 Lua 虚拟机，被弱表引用的对象，不应该阻止他们被 gc 回收。与弱表相对的是强表。对于强表来说，所有被强表引用到的 gc 对象，都会被标记，从而不会被 gc 机制回收，哪怕这些变量再也没被使用到。因此，对于强表来说，如果你希望被它引用的对象能够被 gc 回收，那么你需要将它的值设置为 nil。对于弱表来说，但凡被设置为弱引用的对象，均不会被 gc 标记，当再也没有其他地方引用该对象时，它们会从弱表中被清除

```lua
t = {}

-- 使用一个 table 作为 t 的 key 值
key1 = {name = "key1"}
t[key1] = 1
key1 = nil

-- 又使用一个 table 作为 t 的 key 值
key2 = {name = "key2"}
t[key2] = 1
key2 = nil

for key, value in pairs(t) do
    print(key.name .. ":" .. value)
end
-- 强制进行一次垃圾收集
-- 此时 key1 和 key2 表都被置 nil，但是并没有被强制回收，换句话说，虽然 key1 本身为 nil，但是他先前指向的内容并没有被删除，因为这个内容被保存在了 t 中
collectgarbage()

for key, value in pairs(t) do
    print(key.name .. ":" .. value)
end
```

```lua
t = {}
-- 给 t 设置一个元表，增加__mode 元方法，赋值为"k"
setmetatable(t, {__mode = "k"});

-- 使用一个 table 作为 t 的 key 值
key1 = {name = "key1"}
t[key1] = 1
key1 = nil

-- 又使用一个 table 作为 t 的 key 值
key2 = {name = "key2"}
t[key2] = 1
key2 = nil

for key, value in pairs(t) do
    print(key.name .. ":" .. value)
end
-- 强制进行一次垃圾收集
collectgarbage()

for key, value in pairs(t) do
    print(key.name .. ":" .. value)
end
```

以上代码在创建了表`t`后，立即将 t 设置为元表，元表里面有一个`__mode`字段，值为`k`，在执行`collectgarbage()`之前，能够输出`t`中的元素，但是执行垃圾回收之后，就不能再次输出`t`中的元素的，这是因为将表设置为元表后，通过`__mode = "k"`将其指定为对键的弱引用，也就是说，一旦表中的某个键被垃圾回收，`t`中会删除这个键对应的元素

#### 弱表的用途

* 缓存机制添加自动回收功能
  当外部通过`getFromCache`获取到`tbl[key]`的值之后，如果一直持有，那么这个值就会一直在`tbl`缓存中，如果外部不再引用`tbl[key]`值时，那么它会在下一轮 gc 的时候从`tbl`被清理。这样，我们就不用去实现相对复杂的 LRU 机制，来对`tbl`的内存进行限制和处理了

```lua
local mt = {__mode="v"}
local tbl = setmetable({}, mt)

local function getFromCache(key)
    if tbl[key] then
        return tbl[key]
    end

    tbl[key] = loadFromDB(key)
    return tbl[key]
end
```

* 弱表实现默认值

```lua
local defaults = {}
setmetatable(defaults, {__mode = "k"})
local mt = {__index = function(t) return defaults[t]  end}
 
function setDefault(t, d)
    defaults[t] = d
    setmetatable(t, mt)
end
```

```lua
local metas = {}
setmetatable(metas, {__mode = "v"})
 
function setDefault(t, d)
    local mt = metas[d]
    if mt == nil then
        mt = {__index = function() return d  end}
        metas[d] = mt
    end
    setmetatable(t, mt)
end
```

### C#委托和`event`区别

委托`delegate`其实就是函数的模版，这个模版可以用来放入各种格式和他相同的函数，也就是这些真实函数的引用
当声明委托时，在编译阶段会自动生成一个类，并且继承自`MulticastDelegate`，`MulticastDelegate`继承自`Delegate`。当对委托`+=`操作时候其实是调用了`Delegate.Combine()`函数，当对委托`-=`操作时候其实是调用了`Delegate.Remove()`函数，一旦执行`Invoke`，便调用所有的回调函数

事件就是委托的一种特殊封装，事件本身其实就是一种特殊的委托。如果加了`event`的情况下，在其他类中使用带`event`字段的委托是不能直接使用`=`赋值符号的，只能使用`+=`，注意这里说的是其他类中，如果直接在声明`event`的类中还是可以直接使用`=`赋值的，当在委托声明的时候加了`event`字段之后，直接赋值的操作会变成`private`权限，那么自然在其他类中就无法直接赋值了，`+=`和`-=`重写变成了`add`和`remove`的方法，是`public`的，所以可以在外部调用

### Lambda 表达式的捕获变量

Lambda 表达式可以捕获其所在作用域中的变量。这些变量将作为 Lambda 表达式的外部变量，在 Lambda 表达式内部被引用。但是，Lambda 表达式只能捕获引用类型的变量，而不能捕获值类型的变量（除非阀门是局部变量并且被标记为`readonly`或在 Lamda 表达式之前赋值）

### Lua 空表大小

> `debug.tablemem(t)`函数用于获取`table`自身占用内存空间的大小，该函数返回四个字段：`table`占用内存大小、数组部分长度、以 2 为底哈希表部分长度的对数、哈希表部分是否为假节点。[`debug.tablemem`](https://github.com/zhyingkun/lua-5.3.5/blob/master/liblua/libraries/ldblib.c)

```lua
local tbl = {}
print(debug.tablemem(tbl)) --> 56   0   0   true
```

```c
// luaobject.h
typedef union lua_Value {
    struct GCObject* gc;
    void* p;
    int b;
    lua_Interger i;
    lua_Number n;
    lua_CFunction f;
} Value;

typedef struct lua_TValue {
    Value value_;
    int tt_;
} TValue;

// lua Table
typedef union TKey {
    struct {
        Value value_;
        int tt; // 用来标记 value_是什么类型
        int next;
    } nk;
    TValue tvk;
} TKey;

typedef struct Node {
    TKey key;
    TValue value;
} Node;

struct Table {
    CommonHeader;               // GC 部分
    TValue* array;              // 数组部分
    unsigned int arraysize;     // 数组大小
    Node* node;                 // hash 部分
    unsigned int lsizenode;     // hash 大小，实际大小为 2<sup>lsizenode
    Node* lastfree;             // 空闲指针
    struct GCObject* gclist;    // GC 部分
}
```

### C# 字典原理

```c#
private int[] buckets;  // Hash 桶
private Entry[] entries; // Entry 数组，存放元素
```

字典内部有两个主要的数组

* `Entry`结构体数组：其中存储 hash 值、键值对、发生冲突指向的上一个`Entry`位置
* `buckets`数组：存放对应`Entry`下标

### C# 变量赋值

* 值类型变量的赋值： 值类型变量中保存的是实际数据，在赋值的时候只是把数据复制一份，然后赋给另一个变量

```c#
int var1 = 2;
int var2 = var1; //编译器会先复制 var1 的值，然后把它赋给 var2. 很明显 var2 的值也为 2
```

* 引用类型变量的赋值： 引用类型变量中保存的是“指向实际数据的引用指针”。在进行赋值操作的时候，它和值类型一样，也是先有一个复制的操作，不过它复制的不是实际的数据，而是引用（真实数据的内存地址）所以引用类型的变量在赋值的时候，赋给另一变量的实际上是内存地址

```c#
class MyClass
{
    public int val;
}
struct MyStruct 
{
    public int val;
}

class Program {
    static void Main(string[] args)
    {
        MyClass objectA = new MyClass();
        MyClass objectB = objectA; //引用变量的赋值 赋值操作完成后，两个变量都指向同一内存地址 
        objectA.val = 10; //给 objectA.val 赋值=10 由于 objectB 和 objectA 指向同一内存地址，所以 ojbectB.val 的值也为 10
        objectB.val = 20; //给 objectB.val 赋值=20 由于 objectB 和 objectA 指向同一内存地址，所以 objectA.val 的值也为 20
        MyStruct structA = new MyStruct();
        MyStruct structB = structA; //结构是值类型 赋值操作完成后，两个结构中的结构信息一致。注意是“结构中的信息”一致。
        structA.val = 30;
        structB.val = 40;
        Console.WriteLine("objectA.val={0}", objectA.val); //输出结果是 20
        Console.WriteLine("objectB.val={0}", objectB.val); //输出结果是 20
        Console.WriteLine("structA.val={0}", structA.val); //输出结果是 30
        Console.WriteLine("structB.val={0}", structB.val); //输出结果是 40
    }
}
```

### Unity 中影响渲染顺序的因素

<center>
    <img src="51/unity-render-order.png" />
</center>

* Canvas
  * 不同 Canvas 之间可以用以下两个属性控制渲染层级
    * Sorting Layer
    * Order in Layer
* Hierarchy 中顺序
  * 在同一个 Canvas 中，Hierarchy 的顺序决定了控件的层级关系

#### 模型深度的控制

* 空间深度：对于 3D 物体的显示先后就是完全按空间的先后来的，当然可以在 fragment shader 中关闭深度测试，或进行其他影响帧缓冲区的操作
* RenderQueue：RenderQueue 是对 unity 中所有可以渲染的物体都适用

#### 粒子特效渲染层级的控制

* 空间深度：和 3D 模型一致
* RenderQueue：和 3D 模型一致
* Sorting Order：粒子系统本身是一个 Renderer 组件，它渲染的是一个一个精灵，是一个一个片，该属性有效

### C# 垃圾回收

#### 检查回收对象

GC 能够了解某个实体目前是否依旧被应用程序的某些活动对象所引用；对于那些没有被任何活动对象直接或间接引用的对象，GC 会将其判断为垃圾。GC 在其专门的线程中运行，默默地为程序清除不再使用的内存。压缩托管堆（将当前仍旧使用的对象放在连续的内存中，可以利用局部性原理提高性能），因此空余的空间也会是一块连续的内存

垃圾回收器采用的是 mark-and-compact 算法（标记和更改对象的同步块索引中的一个位 bit），在执行垃圾回收的时候，GC 不是枚举所有访问不到的对象；相反，它是通过压缩所有相邻的可达对象来执行垃圾回收。这样，由不可访问的对象占用的内存就会被覆盖

#### 代

自上一次垃圾收集以来，新创建的对象属于第 0 代对象，而若是某个对象在经过过一次垃圾收集之后仍旧存活，那么它将成为第 1 代对象。两次及两次以上垃圾收集后仍旧没有被销毁的对象就变成了第 2 代对象。（第 0 代对象大多属于局部变量，而成员变量和全局变量（CLR 允许全局变量的定义，即便 C#中不支持）则会很快成为第 1 代对象，直至第 2 代）

每一代都会有一个预算容量（以 KB 为单位），如果分配一个新对象造成超出预算，就会启动一次垃圾回收。CLR 垃圾回收器是自调节的，所以会根据回收垃圾对象的数量动态设置预算容量的大小。 一般来说，大概 10 个周期的 GC 中，会有一次同时检查第 0 代和第 1 代对象，大概 100 个周期的 GC 中，会有一次同时检查所有对象

#### 非托管资源

.Net 提供了两种控制非托管资源生命周期的机制：终结器（finalizer）和 `IDisposable`接口

##### 终结器

* 终结器将由 GC 调用，调用将发生在对象成为垃圾之后的某个时间（无法确定其发生的具体时间），因此 .Net 并不能保证析构操作的确切时间
* 依赖终结器还会带来性能上的问题。当 GC 发现某个对象属于垃圾，但该对象需要执行终结操作时（定义了析构函数），就不能将其直接从内存中移除。首先，GC 将调用其终结器，而终结器并不在执行垃圾收集的线程上执行。GC 将把所有需要执行终结的对象放在专门的队列中，然后让另一个线程来执行这些对象的终结器。这样，GC 可以继续执行其当前的工作，在内存中移除垃圾对象。而在下一次的 GC 调用时，才会从内存中移除这些已被终结的对象。因此需要调用终结器的对象将在内存中多停留一次 GC 周期的时间，如果终结对象进入第 1 代或第 2 代，那么将停留更长的 GC 周期

因此，尽量不要使用终结器来释放非托管资源

##### `IDisposable`接口

`IDisposable.Dispose()`方法的实现中需要完成如下 4 个任务

* 释放所有非托管资源
* 释放所有托管资源，包括释放事件监听程序
* 设置一个状态标志，表示该对象已经被销毁，若是在销毁之后再次调用对象的公有方法，那么应该抛出 `ObjectDisposed`异常。
* 跳过终结操作，调用`GC.SuppressFinalize(this)`即可

由于很多非托管资源都非常宝贵（如数据库和文件句柄），所以它们应尽可能快地被清除，而不能依靠垃圾回收的发生。.Net 中使用了一种标准的模式能够在使用者正常调用是通过`IDisposable`接口释放掉非托管资源，也会在使用者忘记的情况下使用终结器释放。这个模式和 GC 配合，可以保证仅在最糟糕的情况下才调用终结器，尽可能降低其带来的性能影响

### 如何进行内存优化

* 类中存在空的`Update`、`LateUpdate`和`FixedUpdate`方法

  Unity 中的脚本其实默认都是继承自这个`Monobehavior`。`Update`、`LateUpdate`和`FixedUpdate`属于`Monobehaviour`类的“Messages”，虽然不由`Monobehavior`类继承而来，但是在`Monobehaviour`类的脚本中会生效——如果脚本中写上了这些方法，相应的脚本放到场景中，并且`enable`为`true`，那么游戏运行过程中每帧都会对其进行调用。即使这些方法为空，在运行时，它们依然会因为被调用而造成 CPU 时间的开销，其原因主要有两点

  * 这些方法是 Native 层对托管层的调用，C++与 C#之间的通信本身存在一定的开销
  * 当调用这些方法时，Unity 会进行一系列安全检测（比如确保`GameObject`没有被销毁等）导致 CPU 时间的消耗

* 对纹理`SetPixels`的调用

  `SetPixels`可用于对纹理特定的 mipmap 层的像素进行修改，它会将一组数组的像素值赋值到贴图的指定 mipmap 层，调用`Apply()`后会将像素传至显卡。需注意的是，由于`Color32`比`Color`类型所占的空间更小，使用`SetPixels32`比`SetPixels`造成的 CPU 耗时也更小。所以在效果允许的情况下，我们推荐使用`SetPixels32()`方法来取代`SetPixels()`

  * 从内存分配上讲，该函数会在托管堆中分配内存，用以存储纹理数据的像素信息，但引擎不会对其进行缓存。所以如果在频繁调用的函数中使用，就会造成持续性的堆内存分配
  * 从耗时上讲，擅长执行大规模并行运算的 GPU 来处理图片信息是非常容易的，但 CPU 在进行逐个像素信息的获取时，就显得有些吃力了。并且`GetPixels()`在实现上是由 CPU 同步执行的，所以耗时会较高，同时会阻塞调用的线程，从而可能会造成卡顿。因此在非必要的情况下，并不建议使用`GetPixels()`
* `GetComponentsInChildren`和`GetComponentsInParent`的调用
  
  `GetComponentsInChildren`用于获得**当前**`GameObject`及其**子节点**的所有给定类型的组件，返回的是一个包含所有符合条件的对象的数组；而`GetComponentsInParent`则是用于获得**当前**对象及其**父节点**上的所有给定类型的组件

  这两者的使用都会涉及到较大范围内的搜索遍历，会挤占 CPU 较大的计算资源，所以应当尽量减少相关的调用，可以尝试缓存调用的结果，避免使其出现在`Update`这样的频繁调用的函数当中。此外，对于这两个函数，建议使用接受`List`类型的引用作为参数的版本，这样就可以避免每次调用都造成堆内存的分配

* `Linq`相关函数的调用
  
  `Linq`相关的函数一般都用于对数据的查询和处理。功能上简单来讲，就是对一堆数据进行各种`if`判断和`for`循环处理。使用`Linq`提供的 API，可以写出 SQL 语句风格的代码来进行集合数据的处理，这能够明显提升代码的简明性、可读性，维护上也更方便，从而提升编写效率，但是这些优点是以性能的开销为代价的

  `Linq`在执行过程中会产生一些临时变量，而且会用到委托（`lambda`表达式）。如果使用委托作为条件的判定方法，时间开销就会很高，并且会造成一定的堆内存分配。所以在一般的 Unity 游戏项目开发中，不推荐使用`Linq`相关的函数。在编辑器功能开发中，才常常把`Linq`和`Reflection`进行配合使用

* 对`Renderer`进行`Material`/`Materials`的获取
  
  在 Unity 中，如果对`Renderer`类型调用`.material`和`.materials`，那么 Unity 就会生成新的材质球实例。其主要影响如下：
  * 通过`.material`，创建材质实例，并修改属性的方式实现多样的渲染效果，时间开销会较高
  * 使用相同 Shader，但因为`Material`实例不同的`GameObject`，所以无法进行合批，导致 Draw Call 增加，变相造成了 CPU 耗时的增加
  * 每次对新的`GameObject`的`Renderer`调用`.material`，都会生成一个新的`Material`实例，且`GameObject`销毁后，`Material`实例无法自动销毁，这会对资源管理造成一定的成本，想要处理的话就需要手动调用`UnloadUnusedAssets`来卸载，但这样就造成了性能开销；管理不好可能会造成材质球大量冗余甚至泄露，极端情况下甚至会导致过高的内存

### UI 如何降低 Draw Call

* 每个单独的材质/纹理的渲染一定是会产生 DrawCall 的，将多张小图打包成一个图集，在渲染 UI 时就可使用同一个材质/纹理，即可有效降低 Draw Call 的产生
  * 从功能角度划分图集，例如将公共 UI 打包成一个图集，将每个系统的 UI 分别打成单独的图集，主要原则是将显示上密切相关的图片打包到一起
  * 避免将无关联的东西打包在一个图集里，特别是那些不可能同时出现的元素，这样不但无法减少 DrawCall，还会增加内存消耗
  * 控制图集大小，不要让图集太大
* 合并 UI 元素
  * UGUI 的渲染过程是通过 Canvas 组件实现的。每个 Canvas 都有一个 Sorting Layer 和一个 Order in Layer 属性，用于控制 UI 元素的渲染顺序。如果 UI 元素在同一个 Sorting Layer 和 Order in Layer 下，它们就会被合并成一个 DrawCall。可以将相同的 UI 元素放在同一个 Sorting Layer 和 Order in Layer 下，以减少 DrawCall 的数量

#### 合批的规则

UGUI 在合批之前，会根据节点的 Depth、Material InstanceID 、Texture InstanceID、RendererOrder 进行排序，之后对相邻的节点进行检测，判断 Material InstanceID 和 Texture InstanceID 是否相同，如果相同则可以进行合批处理，如果这两个 UI 的 Material InstanceID 和 Texture InstanceID 都相同，但是不连续，中间有其他不同 Material InstanceID 或 Texture InstanceID 的 UI 则会打断合批

Depth 排序

* 筛选掉 Depth 为-1 的值，这部分默认不渲染
* 判断是否该元素底部是否有物体，如果没有则赋值 Depth 为 0，如果盖住物体（这块是通过 Mesh 进行判断，判断 Mesh 是否相交）则等于底部盖住的 UI 元素中 Depth 最大的值+1
* 如果两个相邻元素通过了合批测试，则这两个相邻元素的深度值相等

深度排序之后，就会根据 Texture InstanceID 进行排序，如果材质相同则对 Texture InstanceID 进行排序，如果也相同，那会根据 Inspection 面板上的 RendererOrder，最后真正进行 UI 的合批

#### Mask 影响合批

* 在`StencilMaterial.Add`的时候为这个节点增加了一个新的材质，导致了 Mask 内的物体无法和外部同样材质的物体合批
* Mask 会进行两次 Pass，第一步是对在模板缓冲中的值进行赋值，将要显示的部分缓存值设置为 1，不显示的部分设置为 0，在第二个 Pass 绘制时对模板缓冲值为 0 的部分进行剔除，所以这两个 Pass 也会带来两个 Draw Call 的生成
  
所以添加一个 Mask 最起码会增加 3 个 Draw Call

> 不同的 Mask 之间是可以合批的，虽然 Mask 会对原来的材质进行替换，添加一个新的材质，但是两个 Mask 添加的材质是相同的就支持合批（前提是两个 Mask 不重叠，当他们重叠时，因为被剔除的部分参与了运算，发现 Depth 不同并且 Material InstanceID 也不同，就无法进行合批）

#### RectMask2D 与 Mask 的区别

和 Mask 不同的是，RectMask2D 并不会产生两额外的 Pass 增加两个 Draw Call 的消耗。RectMask2D 是通过 canvasRender 里面进行了 ClipRect 的剔除，这样相比于 Mask 会带来以下不同

* RectMask2D 之间无法进行合批
* 被 RectMask2D 隐藏的物体不会参与合批计算
* RectMask2D 组件上挂载的 Image 可以参与外部的合批

### Lua 中的`pcall`和`xpcall`

* `pcall(f, arg1, ···)`：在保护模式下，用给定的参数调用函数`f`，这意味着`f`内部的任何错误，都会被`pcall`捕获，而不会传播出去。`pcall`的第一个返回值是`boolean`类型的状态码。如果`f`内部没有发生错误，那么`pcall`返回`true`加调用`f(arg, ...)`返回的所有值，否则返回`nil`加错误信息
* `xpcall (f, err, ...)`：与`pcall`类似，但是可以设置一个错误处理函数。`xpcall`在保护模式下，用给定的参数调用函数`f`，使用`err`作为错误处理函数。在`f`内部发生的任何错误，都会被`xpcall`捕获，而不会传播出去。当函数`f`内部发生错误时，会使用原始的错误信息调用`err`函数，`xpcall`返回`false`加`err`函数的第一个返回值；否则，返回`true`加调用`f(...)`返回的所有值

## 雷火

### 动画资源是如何加载的

### Animator 和 Animation 区别

### GPU Instance

### 材质相同，材质的参数不同可以进行动态合批吗

### 状态机和行为树的区别

### Playable 的使用

### 顶点动画

### 多个实体如何处理动画

## 快手

### Unity 中 C# 与 Lua 的交互

Lua 与宿主语言是通过栈进行交互的。在 c 中通常以`lua_State* L`的形式表示指向栈的一个指针，在 C# 中以`System.IntPtr L`的形式存在。栈的元素用过`index`进行索引。以负数表示从顶向底索引，以正数表示由底向顶索引

#### Lua 是获取一个 C# 对象

主要是通过`PushUserObject`来获取

```c#
static void PushUserObject(IntPtr L, object o)
{
    Type type = o.GetType();
    int reference = LuaStatic.GetMetaReference(L, type);

    if (reference <= 0)
    {
        reference = LoadPreType(L, type);
    }
                
    PushUserData(L, o, reference);
}
```

通过一个`GetMetaReference`方法获取了一个`reference`值，这个是 C# 类导出 Wrap 文件时创建的 Wrap 类对应的元表引用（因为元表是 Lua 的东西，C#里不能直接获取元表，所以这里只能拿到元表在内存中的引用 Id)

```c#
public static void PushUserData(IntPtr L, object o, int reference)
{
    int index;
    ObjectTranslator translator = ObjectTranslator.Get(L);

    if (translator.Getudata(o, out index))
    {
        if (LuaDLL.tolua_pushudata(L, index))
        {
            return;
        }

        translator.Destroyudata(index);
    }

    index = translator.AddObject(o);
    LuaDLL.tolua_pushnewudata(L, reference, index);
}
```

Lua 从 C# 获取对象的时候，实际上获取的是一个 userdata，这个 userdata 以 C# 导出的 Wrap 类为元表，以实现 Lua 对 C#方法的调用。Lua 从 C#这边获取的对象，都将被缓存到`ObjectTranlator`中的`LuaObjectPool`中

当 Lua 调用 C# 方法的时候，C# 需要获得对象的实例。通过调用 C API `tolua_rawnetobj`，从 Lua 调用栈中拿到 userdata 的值，也就是前面说的`LuaObjectPool`中缓存的索引值，根据这个索引值从`ObjectTranslator`中拿回缓存的 C# 对象

#### C# 执行 Lua 代码

C# 从 Lua 获取的对象主要是 Lua 方法和`table`。获取 Lua 方法一般都是 Lua 这边绑定一个方法到 C# 的委托。通过`CheckDelegate`方法获取到 Lua 方法对象。调用`ToLuaFunction`从 Lua 栈中获取到方法引用并创建一个对应 C# 的`LuaFunction`

```c#
public static LuaFunction ToLuaFunction(IntPtr L, int stackPos)
{
    LuaTypes type = LuaDLL.lua_type(L, stackPos);
    if (type == LuaTypes.LUA_TNIL)
    {
        return null;
    }
    stackPos = LuaDLL.abs_index(L, stackPos);
    LuaDLL.lua_pushvalue(L, stackPos);
    int reference = LuaDLL.toluaL_ref(L);
    return LuaStatic.GetFunction(L, reference);
}
```

`ToLuaFunction`会创建一个当前栈顶的对象的引用并返回`reference`，`lua_pushvalue`接口调过之后，将 Lua 方法的栈索引重新压栈，也就是说创建的当前栈顶的引用，这个`reference`现在是指向的是 Lua 方法的栈索引。之后再以这个`reference`调用`GetFunction`方法，获取`LuaFunction`

```c#
public LuaFunction GetFunction(int reference)
{
    LuaFunction func = TryGetLuaRef(reference) as LuaFunction;
    if (func == null)
    {                
        func = new LuaFunction(reference, this);
        funcRefMap.Add(reference, new WeakReference(func));
        if (LogGC)
            Debugger.Log("Alloc LuaFunction name , id {0}", reference);      
    }
    RemoveFromGCList(reference);
    return func;
}
```

若当前 Lua 方法没有缓存，这里就会以这个 Lua 方法的栈索引引用创建一个`LuaFunction`对象。并缓存到`funcRefMap`中。注意这里缓存的是`LuaFunction`的弱引用对象，这样`LuaFunction`对象就不会因为被`funcRefMap`持有引用而导致无法被 C# GC 回收，也就是说这个`funcRefMap`纯粹是用来做一个缓存，避免同一个`LuaFunction`的反复创建用，不会干扰`LuaFunction`的内存释放。

#### GC 的处理

当 Lua 从 C# 获取一个对象的时候，C# 会把这个对象缓存到`ObjectTranslator`中的`LuaObjectPool`中，从而实现 C#端可以根据 Lua 传递的 Wrap 对应的 userdata 拿回对应的 C#对象。并且也保证了当 Lua 端持有 userdata 引用的时候 C# 对象不会因为在 C# 端无其它引用而被 C# GC 回收掉。缓存在 ObjectPool 中的引用将会在 lua 端 GC 清理了 userdata 之后，由 userdata 的元方法`__gc`触发移除缓存，从而释放 C#对象的内存

当 C# 获取一个 Lua 对象的时候， 将会在 C# 端建立一个`LuaBaseRef`对象，并调用 C API 在 Lua 端创建一个对象引用，并持有在 C 环境，从而保证了在 C# 端持有 Lua 对象的时候，Lua 对象不会因为在 Lua 端无其它引用而被 Lua GC 回收掉。 C API 创建的引用将在 C# 端 GC 清理了`LuaBaseRef`引用或手动调用`Dispose()`方法之后解除，从而释放 Lua 对象的内存
