---
title: 现代 C++ 核心特性解析
toc: true
date: 2024-07-18 18:10:24
index_img: img/teasers/65-teaser.png
categories: C++
tags:
- C++
- Modern C++
- 笔记
---

本书是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++ 11 到 C++ 20 引入的核心特性。书中不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理

<!-- more -->

## 新基础类型

### 整数类型`long long`

* `long long`**至少**表示 64 位的整数
* `long`不能比`int`短，所以可以相等
* `long`就是`long int`，同理`long long`就是`long long int`
* 初始化可以添加`l`或`L`后缀，`long long x = 65536LL;`
* 可以用于枚举类型或位域
  
  ```c++
  enum longlong_enum : long long {
      x1,
      x2
  };

  struct longlong_struct { // 位域可以用来解析协议
      long long x1 : 8,
      long long x2 : 24,
      long long x3 : 32
  }
  ```

{% note secondary %}
`long long`格式化输出可以使用`%lld`、`%llu`，`int`格式化输出可以使用`%d`，`short`格式化输出可以使用`%h`，应该是 half 的意思
{% endnote %}

### 新字符串类型`char16_t`和`char32_t`

* 分别对应 Unicode 的 UTF-16 和 UTF-32
* UTF-32 编码简单但是占用内存多
  * 所有字符都映射
* UTF-16 占用内存少但是不够用
  * 常用字符做唯一映射
  * 其余字符采用了一种特殊的方法表示 Unicode 字符
* UTF-8 一般序列化到磁盘中，不存在内存中
  * 变长编码
  * 查找和获取大小比较麻烦
* `wchar_t`存在的问题
  * 在 Windows 上`wchat_t`是 16 位，而在 Linux 和 macOS 上`wchat_t`是 32 位的
  * 无法保证相同的代码在不同平台上有相同的行为
  * `char16_t`和`char32_t`解决了这个问题
* `char8_t`字符类型 {% label primary @C++ 20 %}
  * 使用`char`类型来处理 UTF-8 字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称，以区分普通字符和 UTF-8 字符
  * `char8_t`可以代替`char`作为 UTF-8 的字符类型

## 内联和嵌套命名空间

C++11 标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了

```c++
#include <iostream>

namespace Parent {
    namespace Child1 {
        void foo() { std::cout << "Child1: foo()" << std::endl; }
    }
    inline namespace Child2 {
        void foo() { std::cout < "Child2: foo()"<< std::endl; }
    }
}
int main() {
    Parent::Child1::foo();
    Parent::foo(); // 兼容老代码，删掉 Child2 命名空间效果是一样的
} 
```

* 嵌套命名空间的简化语法 {% label success @C++ 17 %}

  ```c++
  namespace A::B::C {
      int foo () { return 5; }
  }
  ```

* 内联命名空间 {% label primary @C++ 20 %}
  
  ```c++
  namespace A::B::inline C {
      int foo () { return 5; }
  }
  // 或者
  namespace A::inline B::C {
      int foo () { return 5; }
  }
  ```

## `auto`占位符

* C++ 98 开始就有了，平常定义的变量都是`auto`的，也可以不写
* C++ 11 开始赋予了新的含义
* 声明多个变量时，从左往右推导，必须一致
* 条件表达式推导出更强的类型 e.g. `auto i = true ? 5 : 8.8` `i`的类型为`double`
* 初始化静态成员变量必须加`const` {% label info @C++ 11 %}
  
  ```c++
  struct sometype {
      static const auto i = 5;
  }
  ```

  * C++ 17 标准中，`auto`可以在没有`const`的情况下使用 {% label success @C++ 17 %}

    ```c++
    struct sometype {
        static inline auto i = 5;
    }
    ```

* C++ 20 之前，无法在函数形参列表中使用`auto`声明形参 e.g. `void echo(auto str) { ... }`
  * `auto`可以为 lambda 表达式声明形参 {% label warning @C++ 14 %}
* 如果`auto`声明的变量时按值初始化，则推导出的类型会忽略 cv 限定符
  
  ```c++
  const int i = 5;
  auto j = i;       // auto 推导类型为 int，而非 const int
  auto &m = i;      // auto 推导类型为 const int，m 推导类型为 const int&
  auto *k = &i;     // auto 推导类型为 const int，k 推导类型为 const int*
  const auto n = j; // auto 推导类型为 int，n 的类型为 const int
  ```

  * 对于值类型的推导只是值上的关系，没有内存的关联
  * 但是对于引用或指针涉及到了内存的关联，需要保留 cv 限定符
* 使用`auto`声明变量初始化时，目标对象如果是引用，则引用属性会被忽略
  
  ```c++
  int i = 5;
  int &j = i;
  auto m = j; // auto 推导类型为 int，而非 int&
  ```

* 使用`auto`和万能引用声明变量时，对于左值会将`auto`推导为应用类型

  ```c++
  int i = 5;
  auto&& m = i; // auto 推导类型为 int&，这里涉及引用折叠的概念（遇左则左）
  auto&& j = 5; // auto 推导类型为 int
  ```

* 使用`auto`声明变量，如果对象目标是一个数组或者函数，则`auto`会被推导为对应的指针类型
* 当`auto`关键字与列表初始化组合时  {% label success @C++ 17 %}
  * 直接使用列表初始化，列表中必须为单元素，否则无法编译，`auto`类型被推导为单元素的类型
  * 用等号加初始化列表，列表中可以包含单个或多个元素，`auto`类型别推导为`std::initializer_list<T>`，其中`T`是元素类型
  
  ```c++
  auto x1 = { 1, 2 };   // x1 类型为 std::initializer_list<int>
  auto x2 = { 1, 2.0 }; // 编译失败，花括号中元素类型不同
  auto x3{ 1, 2 };      // 编译失败，不是单个元素
  auto x4 = { 3 };      // x4 类型为 std::initializer_list<int>
  auto x5{ 3 };         // x5 类型为 int
  ```

{% note info %}

```c++
class Base {
public:
    virtual void f() {
        std::cout << "Base::f()" << std::endl;
    }
};

class Derived : public Base {
public:
    virtual void f() {
        std::cout << "Derived::f()" << std::endl;
    }
}

Base* d = new Derived();
auto b = *d;
b.f();
```

由于`auto b = *d;`是按值赋值的，因此`auto`会直接推导为`Base`。代码自然会调用`Base`的复制构造函数，也就是说`Derived`被切割（Sliced）成了`Base`，如果是`auto &b1 = *d`或者`auto *b2 = d`则会触发多态的性质

{% endnote %}

* 返回类型声明为`auto`的推导 e.g. `auto sum(int a, int b) { return a + b; }` {% label warning @C++ 14 %}
  * 如果有多重返回值，那么需要保证返回值类型是相同的，否则会编译失败

    ```c++
    auto sum(long a, long b) {
        if (a < 0) {
            return 0; // 返回 int 类型
        }
        else {
            return a + b; // 返回 long 类型
        }
    }
    ```

* 可以把`auto`写到 lambda 表达式的形参中，这样就得到了一个泛型的 lambda 表达式 {% label warning @C++ 14 %}
* 非类型模板形参占位符 {% label success @C++ 17 %}

   ```c++
   #include <iostream>
   template<auto N>
   void f() {
      std::cout << N << std::endl;
   }
   int main() {
      f<5>();   // N 为 int 类型
      f<'c'>(); // N 为 char 类型
      f<5.0>(); // 编译失败，模板参数不能为 double
   }
   ```

## `decltype`说明符

* 使用`decltype`说明符可以获取对象或者表达式的类型，其语法与`typeof`类似 {% label info @C++ 11 %}

```c++
auto sum(int a1, int a2) -> int {
    return a1 + a2;
}
```

C++ 11 标准中，`auto`作为占位符不能是编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型，如果想泛化这个函数，需要使用到函数模板

```c++
template<class T>
T sum(T a1, T a2) {
    return a1 + a2;
}
auto x1 = sum(5, 10);
```

但是如果传递不同类型的实参，则无法编译通过 e.g. `auto x2 = sum(5, 10.5);`，只能增加模板类型来解决了

```c++
template<class R, class T1, class T2>
R sum(T1 a1, T2 a2) {
    return a1 + a2;
}
auto x3 = sum<double>(5, 10.5);
```

这时可以使用`decltype`进行优化 {% label info @C++ 11 %}

```c++
template<class T1, class T2>
auto sum(T1 a1, T2 a2) -> decltype(a1 + a2) {
    return a1 + a2;
}
```

{% note warning %}

* `decltype(a1 + a2)`的作用域是这个函数，也就是说表达式里面的变量必须是在函数中的形参
* 编译阶段进行推导

{% endnote %}

C++ 14 标准已经支持对`auto`声明的返回类型进行推导了 {% label warning @C++ 14 %}
  
```c++
template<class T1, class T2>
auto sum(T1 a1, T2 a2) { // 直接去掉 decltype 说明符即可
    return a1 + a2;
}
```

`auto`作为返回类型的占位符还存在一些问题

```c++
template<class T>
auto return_ref(T& t) {
    return t;
}
int x1 = 0;
static_assert(std::is_reference_v<decltype(return_ref(x1))>); // 编译错误，返回值不为引用类型
```

这里`auto`被推导为值类型，参考`auto`占位符规则，如果想正确地返回引用类型，则需要使用`decltype`说明符

```c++
template<class T>
auto return_ref(T& t) -> decltype(t) {
    return t;
}
int x1 = 0;
static_assert(std::is_reference_v<decltype(return_ref(x1))>); // 编译成功
```

* 推导规则 `decltype(e)`，`e`的类型为`T`
  * 如果`e`是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则`decltype(e)`推断出的类型是`e`的类型`T`。如果并不存在这样的类型，或者`e`是一组重载函数，则无法进行推导 {% label light @没有候选或者候选太多 %}
    * 如果加上括号则推断出的是引用类型
  * 如果`e`是一个函数调用或者仿函数调用，那么`decltype(e)`推断出的类型是其返回值的类型
  * 如果`e`是一个类型为`T`的左值，则`decltype(e)`是`T&`
  * 如果`e`是一个类型为`T`的将亡值，则`decltype(e)`是`T&&`
  * 除去以上情况，则`decltype(e)`是`T`
* cv 限定符的推导
  * 通常情况下，`decltype(e)`所推导的类型会同步`e`的 cv 限定符
  * 当`e`是未加括号的成员变量时，父对象表达式的 cv 限定符会被忽略，不能同步推导结果，只有加括号时 cv 限定符会同步到推断结果
  
    ```c++
    struct A {
        double x;
    }
    const A* a = new A();
    decltype(a->x); //  decltype(a->x) 推导类型为 double，const 属性被忽略
    ```

* `decltype(auto)` {% label warning @C++ 14 %}
  * 告诉编译器用`decltype`推导表达式规则来推导`auto`
  * `decltype(auto)`必须单独声明，不能结合指针、引用以及 cv 限定符
  
  ```c++
  int i;
  int&& f();
  auto x1a = i;                     // x1a 推导类型为 int
  decltype(auto) x1d = i;           // x1d 推导类型为 int
  auto x2a = (i);                   // x2a 推导类型为 int
  decltype(auto) x2d = (i);         // x2d 推导类型为 int&
  auto x3a = f();                   // x3a 推导类型为 int
  decltype(auto) x3d = f();         // x3d 推导类型为 int&&
  auto x4a = { 1, 2 };              // x 推导类型为 std::initializer_list<int>
  decltype(auto) x4d = { 1, 2 };    // 编译失败，{ 1, 2 }不是表达式
  auto *x5a = &i;                   // x5a 推导类型为 int*
  decltype(auto) *x5d = &i;         // x 编译失败，decltype(auto) 必须单独声明
  ```

  * `auto`和`decltype(auto)`的用法几乎相同，只是在推导规则上遵循`decltype`而已
  * 之前代码`return_ref`想返回一个引用类型，但是如果直接使用`auto`，则一定会返回一个值类型，解决方案是采用后置的方式声明返回类型，现在可以通过`decltype(auto)`也可以解决
  
    ```c++
    template<class T>
    decltype(auto) return_ref(T& t) {
        return t;
    }
    int x1 = 0;
    static_assert(std::is_reference_v<decltype(return_ref(x1))>); // 编译成功
    ```

  * `decltype(auto)`作为非理性模板形参占位符
  
  ```c++
  #include <iostream>
   template<decltype(auto) N>
   void f() {
      std::cout << N << std::endl;
   }
   static const int x = 11;
   static int y = 7;
   int main() {
      f<x>();   // N 为 const int 类型
      f<(x)>(); // N 为 const int& 类型
      f<y>();   // 编译失败，因为 y 不是一个常量，编译器无法对函数模板进行实例化
      f<(y)>(); // N 为 int& 类型，恰好对于静态对象而言内存地址时固定的，所以可以通过编译
   }
  ```

## 函数返回类型后置 {% label info @C++ 11 %}

* 返回类型比较复杂的是时候，比如返回一个函数指针类型，使用返回类型后置

  ```c++
  int bar_impl(int x) {
      return x;
  }

  typedef int(*bar)(int);
  bar foo1() {
      return bar_impl;
  }

  auto foo2() -> int (*)(int) {
      return bar_impl;
  }
  ```

  有了返回类型后置，返回类型就可以用`auto`占位符，再后置函数指针类型，不需要写`typedef`
* 推导函数模板返回类型

## 右值引用

### 左值和右值

* `i++`：先把`i`的值取出来存到临时变量中，再把`i`加一，最后返回的是临时变量的值，属于右值（将亡值）
* `++i`：自增后将自己返回，属于左值
* 但凡能取地址`&`，就是左值
* 通常字面量都是一个右值，除了字符串字面量以外
  * 字符串是一块连续的内存，通常存在静态数据去里面

### 左值引用

{% note warning %}

* 指针最危险的地方在于可以运算
* C++ 是弱类型语言，类型之前可以随意转换

{% endnote %}

```c++
int &x1 = 7; // 编译错误
const int &x2 = 11; // 编译成功
```

* 非常量左值的引用对象必须是一个左值
  * {% label warning @引用一块内存首先要有一块内存，如果引用右值，内存都不知道在哪，肯定就有问题了 %}
* 常量左值引用的对象可以是左值，也可以是右值
* 在函数形参列表中有着很大的作用

```c++
class X {
public:
    X() {}
    X(const X&) {}
    X& operator = (const X&) { return *this; }
};

X make_X() {
    return X();
}

int main() {
    X x1;
    X x2;
    X x3(make_X());
    x3 = make_X();
}
```

* 如果将类`X`的复制构造函数和复制赋值构造函数形参类型的常量性删除，则`X x3(make_X());`和`x3 = make_X();`会报错，因为非常量左值引用无法绑定到右值上
* 缺点是一旦使用了常量左值应用，就无法在函数内部修改该对象的内容

{% note warning %}

```c++
X make_X() {
    return X(); 
}
```

C++ 17 之后编译器有做拷贝优化，虽然返回值是右值，函数返回类型是左值，因为做了拷贝优化所以不会报错

{% endnote %}

### 右值引用

* 右值引用可以延长右值的声明周期
* 右值引用可以减少对象复制，提升程序性能

```c++
#include <iostream>
class BigMemoryPool {
public:
    static const int PoolSize = 4096;
    BigMemoryPool() : pool_(new char[PoolSize]) {}
    ~BigMemoryPool()
    {
        if (pool_ != nullptr) {
            delete[] pool_;
        }
    }
    // 移动构造器
    BigMemoryPool(BigMemoryPool&& other)
    {
        std::cout << "move big memory pool." << std::endl;
        pool_ = other.pool_;
        other.pool_ = nullptr;
    }
    // 复制构造器
    BigMemoryPool(const BigMemoryPool& other) : pool_(new char[PoolSize])
    {
        std::cout << "copy big memory pool." << std::endl;
        memcpy(pool_, other.pool_, PoolSize);
    }
private:
    char *pool_;
};

BigMemoryPool get_pool(const BigMemoryPool& pool)
{
    return pool;
}

BigMemoryPool make_pool()
{
    BigMemoryPool pool;
    return get_pool(pool);
}

int main()
{
    BigMemoryPool my_pool = make_pool();
}
```

* 调用复制构造函数会严重影响运行性能
* 对于复制构造函数而言形参是一个左值引用，函数的实参必须是一个具名的左值，不能破坏实参对象的前提下复制目标对象
* 移动构造函数接受的是一个右值，通过转移实参对象的数据以达成构造目标对象的目的，也就是说实参对象是会被修改的
  * 传过来的参数用过之后就没有用了
* 编译器生成的移动构造函数和复制构造函数并没有什么区别
* 编写移动语义的函数时建议确保函数不会抛出异常
* 如果无法保证移动构造函数不会抛出异常，可以使用`noexcept`说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用`std::terminate`中止执行

### 值类别

{% gi total  %}
    ![](/65/lvalue-rvalue.png)
{% endgi %}

* 左值和右值实际上指的是表达式，表达式的结果就是值
* 将亡值产生
  * 使用类型转换将泛左值转换为该类型的右值引用
  * 临时量实质化 {% label success @C++ 17 %}

    ```c++
    struct X {
        int a;
    };
    
    int main() {
        int b = X().a;
    }
    ```

    * 纯右值转换到临时对象的过程
    * 每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生——创建一个临时对象并且使用纯右值对其进行初始化
    * 只要返回的是纯右值就不会调用类的构造函数了
* 在C++11标准中可以在不创建临时值的情况下显式地将左值通过`static_cast`转换为将亡值
  
  ```c++
  int i = 0;
  int &&k = static_cast<int&&>(i);
  ```

* 这个转换既不改变生命周期也不改变内存地址，最大作用是让左值使用移动语义
* 正确的使用场景是在一个右值被转换为左值后需要再次转换为右值

```c++
void move_pool(BigMemoryPool &&pool)
{
    std::cout << "call move_pool" << std::endl;
    BigMemoryPool my_pool(pool);
}

int main()
{
    move_pool(make_pool());
}
```

* 无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用
* `BigMemoryPool my_pool(pool);` 还是会调用复制构造函数而非移动构造函数
* `BigMemoryPool my_pool(static_cast<BigMemoryPool&&>(pool));`则会调用移动构造函数进行构造
* 在 C++ 11 的标准库中还提供了一个函数模板`std::move`将左值转换为右值 e.g. `BigMemoryPool my_pool(std::move(pool));`

### 万能引用和引用折叠

```c++
void foo(int &&i) {} // i 为右值引用

template<class T>
void bar(T &&t) {} // t 为万能引用
```

* `&&i`就是定义出来具体的参数，字面意思
* 而模板有实例化的过程，所以就是万能引用
* 所谓的万能引用就是发生类型推导

| 模板类型 | `T`实际类型 | 最终类型 |
|----------|-------------|----------|
| `T&`     | `R`         | `R&`     |
| `T&`     | `R&`        | `R&`     |
| `T&`     | `R&&`       | `R&`     |
| `T&&`    | `R`         | `R&&`    |
| `T&&`    | `R&`        | `R&`     |

{% note warning %}

“遇左则左”

* 只要有左值引用参与进来，最后推导的结果就是一个左值引用
* 只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用

{% endnote %}

```c++
#include <iostream>
#include <string>

template<class T>
void show_type(T t)
{
    std::cout << typeid(t).name() << std::endl;
}

template<class T>
void normal_forwarding(T t)
{
    show_type(t);
}

std::string get_string()
{
    return "hi world";
}

int main()
{
    std::string s = "hello world";
    normal_forwarding(s);
    normal_forwarding(get_string()); // 编译失败
}
```

* `normal_forwarding(get_string());`因为`normal_forwarding`接受的是左值，而传入的是右值
* 可以将`void normal_forwarding(T &t)`替换为`void normal_forwarding (const T &t)`来解决这个问题
  * 常量左值引用是可以引用右值的
  * 但是不能修改传入进来的数据了
* 可以用引用折叠规则来处理
  
  ```c++
  template<class T>
  void perfect_forwarding(T &&t)
  {
      show_type(static_cast<T&&>(t));
  }
  ```

* 在C++ 11 的标准库中提供了一个`std::forward`函数模板，在函数内部也是使用`static_cast`进行类型转换
