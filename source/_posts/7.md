---
title: 高质量实时渲染
date: 2021-11-08 09:49:59
categories: 
- 图形学
tags:
- Graphics
- GAMES
mathjax: true
toc: true
---

### OpenGL

#### Vertex Shader & Fragment Shader

* For each vertex in parallel 每一个顶点都要做
  * 在OpenGL中调用程序定义的vertex shader：做顶点变换，包括MVP变换、需要插值的属性输出给fragment shader
* For each primitive, OpenGL rasterizes 对每一个片元，OpenGL进行{%hint '打成一堆像素' '光栅化'%}
  * Generates a fragment for each pixel the fragment covers
* For each fragment in parallel 每一个片段都要做
  * 在OpenGL中调用程序定义的fragment shader：做着色和光照计算

### Shadow Mapping

#### Render from Light & Eye

* Pass 1: Output a "depth texture" from the light source 从光源的角度出发生成一幅深度图
* Pass 2: Render a standard image from eye

#### Project to light for shadows

* Project visible points in eye view back to light source 连向光源，比较场景上的深度和Shadow Map中的深度的大小

#### Issues in Shadow Mapping

##### Self Occlusion

<center>
    <img src="7/shadow-mapping-acne-diagram.png" />
</center>

从光源的角度看场景所形成的shadow map是一个离散的图，shadow map上一个像素所覆盖的区域是的**深度值**则为一个**常数**，也就是说shadow map记录的深度不是连续的，与实际场景不符。当进行第二次Pass时，从场景某一点出发看向光源，就会被遮挡住，如图中黑色部分

> 如果光源方向从上往下垂直照向平面的时候没有自遮挡的问题，如果光源方向几乎平行与平面时自遮挡的问题最严重

* Adding a (variable) bias to reduce self occlusion

  如果实际的深度与{%hint '光源深度' '对应到Shadow  Map的值'%}的差值小于某个阈值就不算遮挡，相当于遮挡物距场景长的点足够小就忽略这个遮挡物。这个阈值可以不是一个常数，可以根据光源的角度变化。也可以从下图去理解这个Shadow Bias。

  <center>
      <img src="7/shadow-mapping-acne-bias.png" />
  </center>

  但是可能回造成悬浮（{%hint 'Peter Panning' '译注Peter Pan就是童话彼得潘，而panning有平移、悬浮之意，而且彼得潘是个会飞的男孩……'%}）的问题，因为物体看起来轻轻悬浮在表面之上。

  **解决方案**（目前没有完美的解决方案）：

  * 找到一个合适的Shadow Bias——工业界的解决方法

  * Second-dpeth shadow mapping——实际中没有人用
    * Using the midpoint between first and second depths in shadow map
    * requires objects to be {%hint 'waterlight' '水密的；[建]不漏水的；无懈可击的'%}
    * the overhead may not worth it

##### Alias

###### 实时渲染中阴影背后的数学知识

There are a lot of useful inequalities in {% hint 'caculus' '微积分' %}

设$f(x)$和$g(x)$在$[a, b]$上都可积，则：

* Schwarz不等式
  $$
  \left[\int_a^b{f(x)g(x)dx}\right]^2 \le \int_a^b{f^2(x)dx} \cdot \int_a^b{g^2(x)dx}
  $$

* Minkowksi不等式
  $$
  \left\\{\int_a^b{\left[f(x) + g(x)\right]^2dx}\right\\}^{\frac{1}{2}} \le \left[\int_a^b{f^2(x)dx}\right]^{\frac{1}{2}} + \left[\int_a^b{g^2(x)dx}\right]^{\frac{1}{2}}
  $$

在实时渲染中不太关心不等，关心的是近似相等，贯穿整个实时渲染的一个重要的不等式如下：
$$
\int_\Omega{f(x)g(x)dx} \approx \frac{\int_\Omega{f(x)dx}}{\int_\Omega dx} \cdot \int_\Omega{g(x)dx}
$$
什么时候上述不等式更加准确：

* $g(x)$的{% hint 'support' '支撑集' %}足够小
* $g(x)$是足够光滑的

###### Percentage Closer Soft Shadows

* Percentage Closer Filtering

  * Perform multipule(e.g. $7 \times 7$) depth comparisons for each fragment
  * Then, averages **result of** comparisons

  > **过滤或平均的是什么？**
  >
  > 平均的是任意shading point做的很多次阴影深度比较的结果，既不是对shadow map做模糊操作，也不是对最后的阴影图做模糊操作

* Filter size <-> blocker distance 如何确定filter的大小

<center>
    <img src="7/pcss-blocker.png" />
</center>

$$
w_{Penumbra} = \frac{(d_{Receiver} - d_{Blocker})\cdot w_{Light}}{d_{Blocker}}
$$

###### <span id="steps"></span>The complete algorithm of PCSS

* Step 1: Blocker search (getting the average blocker depth in a certain region)
* Step 2: {%hint 'Penumbra' '半影；半暗带；半阴影' %} estimation (using the average blocker depth to determine the filter size)
* Step 3: Percentage Closer Filtering

###### Which region to perform blocker search? 如何确定blocker的大小

<center>
    <img src="7/blocker-search.png" />
</center>

光源看去生成一个shadow map，假设shadow map放在视锥体的近平面上，从shading point连向光源，计算在shadow map上覆盖的区域即为blocker size

### Variance Soft Shadow Mapping

#### A Deeper Look at PCF

* Filter / Convolution
  $$
  \[w * f\](p) = \sum_{q \in \aleph(p)}{w(p, q)f(q)}
  $$

* In PCSS
  $$
  V(x) = \sum_{q \in \aleph(p)}{w(p, q) \cdot \chi^+[D_{SM}(q) - D_{scene}(x)]}
  $$
  每一个shadow map上$q$点的深度和场景上$x$点的深度比较，按照某种形式加权平均起来

* Therefore, PCF is not filtering the shadow map then compare 并不是对shadow map做模糊然后比较
  $$
  V(s) \neq \chi^+\left\\{\[w * D_{SM}\](q) - D_{scene}(x)\right\\}
  $$
  
* And PCF is not filtering the resulting image with binary visibilities 也不是最后的阴影图做模糊操作
  $$
  V(s) \neq \sum_{y \in \aleph(x)}{w(x, y)V(y)}
  $$

#### Variance Soft Shadow Mapping

##### Which step(s) can be slow?

* [Step 1](#steps)
* [Step 3](#steps)

#####  Variance Soft Shadow Mapping

> **PCF**可以理解为在一场考试中知道自己多少分，想知道自己的排名在百分之几，就需要把所有的人的成绩都统计出来，VSSM则不需要知道所有人的成绩，就好比知道成绩的分布，然后根据自己的成绩就知道所在位置了

* Key Idea: Quickly compute the **mean** and **variance** of depths in an area

* Mean

  * Hardware MIPMAPing
  * Summed Area Tables(SAT)

* Variance

  * $Var(x) = E(X^2) - E^2(X)$ 利用期望和方差关系的公式，$E(X^2)$可以由另外一个shadow map，这个shadow map记录的时所有深度值的平方，在OpenGL中可以将这个深度平方的值记录在其他通道中（纹理由R、G、B、A四个通道，shadow map占用一个通道）
  * Just generate a "square-depth map" along with the shadow map

* Percentage of texels that are closer than the shading point 知道了期望和方差如何计算深度比shading point更近点的占比

  可由单边切比雪夫不等式更快的算出来：
  $$
  P(x > t) \le \frac{\sigma^2}{\sigma^2 + (t - \mu)^2}
  $$
  $\mu$是均值，$\sigma^2$是方差，只要知道均值和方差即可带入上述公式，但是必须满足$t > \mu$，可以直观感受切比雪夫不等式

  <center>
      <img src="7/Chebyshev-Inequality.gif" />
  </center>

###### Blocker search

<center>
    <img src="7/blocker-search-acc.png" />
</center>

假设shading point的深度是7，已经知道了$5 \times 5$区域大小的平均深度$z_{avg}$，但是小于7的遮挡物的平均深度是未知的

* Key idea
  * Blocker（$z < t$的部分，蓝色部分）的平均值记为$z_{occ}$
  * Non-blocker（$z > t$的部分，红色部分）的平均值记为$z_{unocc}$
  * 满足$\frac{N_1}{N}z_{unocc} + \frac{N_2}{N}z_{occ} = z_{avg}$
  * 根据切比雪夫可以估计：$\frac{N_1}{N} = P(x > t)$，$\frac{N_2}{N} = 1 - P(x > t)$
  * 又做了个假设：$z_{unocc} = t$，例如大多数的阴影接受物体是一个平面
* [Step 1](#steps) solved with {% hint 'negligible' '微不足道的，不值一提的' %} additional cost

#### SAT for Range Query

> Need to quickly grab $\mu$ and $\sigma$ from an arbitrary range (rectangular) 需要快速计算出任意矩形范围内的均值和方差
> $$
> P(x > t) \le \frac{\sigma^2}{\sigma^2 + (t - \mu)^2}
> $$

对于均值$\mu$，**MIPMAP**和Summed Area Table都可以来计算，**MIPMAP**存在误差的问题，并且不能查询非正方形的区域

##### Classic data structure and algorithm (prefix sum) 经典数据结构——前缀和

###### 一维：

<center>
    <img src="7/sat-1-d.png" />
</center>

###### 二维：

<center>
    <img src="7/sat-2-d.png" />
</center>

### Environment Mapping

#### Distance Field Soft Shadow

* Distance function: At any point, giving the minimun distance (could be signed distance) to the closest location on an object

**The Usages of Distance Fields**

* Ray marching (Sphere tracing) to perform ray-SDF intersection
* Use SDF to determine the (approx.) percentage of occlusion
