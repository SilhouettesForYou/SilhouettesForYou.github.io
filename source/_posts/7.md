---
title: 高质量实时渲染
date: 2021-11-08 09:49:59
categories: 
- 图形学
tags:
- Graphics
- GAMES
mathjax: true
toc: true
---

### OpenGL

#### Vertex Shader & Fragment Shader

* For each vertex in parallel 每一个顶点都要做
  * 在OpenGL中调用程序定义的vertex shader：做顶点变换，包括MVP变换、需要插值的属性输出给fragment shader
* For each primitive, OpenGL rasterizes 对每一个片元，OpenGL进行{%hint '打成一堆像素' '光栅化'%}
  * Generates a fragment for each pixel the fragment covers
* For each fragment in parallel 每一个片段都要做
  * 在OpenGL中调用程序定义的fragment shader：做着色和光照计算

### Shadow Mapping

#### Render from Light & Eye

* Pass 1: Output a "depth texture" from the light source 从光源的角度出发生成一幅深度图
* Pass 2: Render a standard image from eye

#### Project to light for shadows

* Project visible points in eye view back to light source 连向光源，比较场景上的深度和Shadow Map中的深度的大小

#### Issues in Shadow Mapping

* Self occlusion

  <center>
      <img src="7/shadow-mapping-acne-diagram.png" />
  </center>

  从光源的角度看场景所形成的shadow map是一个离散的图，shadow map上一个像素所覆盖的区域是的**深度值**则为一个**常数**，也就是说shadow map记录的深度不是连续的，与实际场景不符。当进行第二次Pass时，从场景某一点出发看向光源，就会被遮挡住，如图中黑色部分

  > 如果光源方向从上往下垂直照向平面的时候没有自遮挡的问题，如果光源方向几乎平行与平面时自遮挡的问题最严重

* Adding a (variable) bias to reduce self occlusion

  如果实际的深度与{%hint '光源深度' '对应到Shadow  Map的值'%}的差值小于某个阈值就不算遮挡，相当于遮挡物距场景长的点足够小就忽略这个遮挡物。这个阈值可以不是一个常数，可以根据光源的角度变化。也可以从下图去理解这个Shadow Bias。

  <center>
      <img src="7/shadow-mapping-acne-bias.png" />
  </center>

  但是可能回造成悬浮（{%hint 'Peter Panning' '译注Peter Pan就是童话彼得潘，而panning有平移、悬浮之意，而且彼得潘是个会飞的男孩……'%}）的问题，因为物体看起来轻轻悬浮在表面之上。

  解决方案（目前没有完美的解决方案）：

  * Second-dpeth shadow mapping
    * 



#### The complete algorithm of PCSS

* Blocker search (getting the average blocker depth in a certain region)
* Penumbra estimation (using the average blocker depth to determine the filter size)
* Percentage Closer Filtering

### Variance Soft Shadow Mapping

### Environment Mapping

#### Distance Field Soft Shadow

* Distance function: At any point, giving the minimun distance (could be signed distance) to the closest location on an object

**The Usages of Distance Fields**

* Ray marching (Sphere tracing) to perform ray-SDF intersection
* Use SDF to determine the (approx.) percentage of occlusion
