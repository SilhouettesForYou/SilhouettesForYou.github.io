---
title: Unity 面试
toc: true
date: 2022-08-19 17:20:05
categories:
- 面试
tags:
- unity
- 面试
- 2022
---

## 业务

### ProtoBuf 的基本原理是什么

### 项目中断线重连是如何实现的

## C#

### List 的底层原理、Dictionary 的底层原理

### 装修拆箱

### 事件委托

### XLua 如何与 C#进行交互

### Lua 如何与 C#进行交互

### C#的异步和 Unity 的协程

## 渲染

### DrawCall 是什么、DrawCall 过高会有什么影响

## 工具

### TextMeshPro 

## 动画系统

### 骨骼动画的原理

#### 基础概念

给一个模型加上骨骼前，一般要求这个模型摆成 **T** 字型，才方便动作师加骨骼和做动作。此时，**加骨骼**操作被称为**骨骼绑定 (Skeleton Binding)**；或者从模型角度讲叫做，模型**蒙皮 (Model Skinning) **到骨骼

这个初始骨骼摆位，就是**绑定姿势 (Bind Poses)**。但要注意，绑定姿势本身只记录了骨骼各个关节的姿势信息，并不包括**蒙皮信息**。蒙皮信息是存储于模型数据里的，因为所谓蒙皮，即是让每一个顶点绑定至$1 \cdots n$个关节，这$n$个关节运动的时候，会影响到该顶点的当前位置

#### 局部关节姿势 Local Joint Poses

关节姿势分为**局部**关节姿势和**全局**关节姿势，局部关节姿势是相对直属父关节而言的，可以用一个结构体表示：

```c++
struct JointPose {
    Quaternion rot; // R 关节旋转信息
    Vector3 trans; // T 关节位移信息
    Vector3 scale; // S 关节缩放信息
}
```

一个关节只需要存一组 **RTS** 信息。这 3 个信息可分别转换成 3 个矩阵，并且可以合并成一个矩阵。合并后的矩阵就被称为关节仿射变换矩阵$P_j$：
$$
P_j =
\begin{bmatrix}
S_jR_j & 0 \\\\
T_j &1
\end{bmatrix}
$$
一个骨骼，就是所有关节仿射变换的集合：
$$
P^{skeleton} = P_j|_{j=0}^{N - 1}
$$
即：

```c++
struct Skeleton {
    size_t jointCount; // 关节数量
    JointPose* local Poses; // 多个局部关节姿势
}
```

把$P_j$应用到关节$j$的局部坐标系的某个点或向量$v_j$，就能把它变换到父关节$p$的坐标系：
$$
v_p = v_jP_j
$$

> 假设有$v_j=(0, 0, 0)$，表示关节$j$的局部坐标系的圆点，$P_j$是一个平移矩阵$(100, 0, 0)$，那么$P_jv_j$的结果就是$(100, 0, 0)$，即$v_p$表示父关节$p$坐标系下的坐标$(100, 0, 0)$
>
> 可以定义子关节$j$到父关节的变换为$(P_{C \rightarrow P})_j$。这样形式不太好看，可以换一种，先定义一个函数$p(j)$，$p(j)$返回关节$j$的父关节索引。那么$(P_{C \rightarrow P})_j$可以写成$P_{j \rightarrow p(j)}$

#### 全局关节姿势 Global Joint Poses

局部关节姿势是一种原始信息，实际上再渲染蒙皮动画前，需要做预处理，把局部关节姿势转换成全局关节姿势。全局关节姿势变换，指的是把关节姿势，用**模型空间坐标系**表示。首先定义$p(0) \equiv M$，即根关节的父节点为模型空间

每个关节$j$的全局关节姿势变换$P$，可以用刚才的$P_{j \rightarrow p(j)}$来表示：

> $$
> P_{2 \rightarrow M} = P_{2 \rightarrow 1}P_{1 \rightarrow 0}P_{0 \rightarrow M}
> $$

$$
P_{j \rightarrow M} = \prod^0_{i = j}{P_{i \rightarrow p(i)}}
$$

对每个关节都做一遍这个公式，就能得到一个全局关节姿势数组。然后可以写入`SkeletonPose`：

```c++
struct SkeletonPose {
    size_t jointCount; // 关节数量
    JointPose* localPoses; // 多个局部关节姿势
    Matrix4x4* globalPoses; // 多个全局关节姿势
}
```

全局关节姿势的存储，并不只限定于用 **RTS**，而是既可以用 **RTS** 也可以用矩阵。因为实时渲染里矩阵更通用快速，所以得存成矩阵

#### 绑定姿势矩阵（Bind Poses Matrix）、绑定姿势逆矩阵（Inversed Bind Poses Matrix）

定义矩阵$B_{j \rightarrow M}$为关节$j$在模型空间的**全局绑定姿势矩阵**。根据上文，$vB_{j \rightarrow M}$可以把$v$从关节$j$的局部空间变换到模型空间

反过来，要把一个点（模型的任意一个顶点）或向量，变换到关节$j$的空间，就是：
$$
v \prime(B_{j \rightarrow M})^{-1}
$$
$v \prime(B_{j \rightarrow M})^{-1}$就是**绑定姿势逆矩阵**，也可以写成：
$$
(B_{j \rightarrow M})^{-1} = B_{M \rightarrow j}
$$
再定义$v^B_M$为模型任意顶点$v$在**绑定姿势**的模型空间坐标，而$v^C_M$为**当前姿势**的模型空间坐标。如果要求$v^B_M$在关节$j$的局部空间坐标$v_j$，则公式为：
$$
v_j = v^B_MB_{M \rightarrow j} = v^B_M(B_{j \rightarrow M})^{-1}
$$
然后再乘以当前姿势的姿势矩阵$C$（不是绑定姿势），得到当前姿势的模型空间坐标$v^C_M$：
$$
v^C_M = v_jC_{j \rightarrow M}
$$

#### 蒙皮矩阵 Skinning Matrix

$$
v^C_M = v_jC_{j \rightarrow M} = v^B_M(B_{j \rightarrow M})^{-1}C_{j \rightarrow M} = v^B_MK_j \\\\
K_j = B_M(B_{j \rightarrow M})^{-1}C_{j \rightarrow M}
$$

$K_j$就是关节$j$的蒙皮矩阵了：把绑定姿势模型空间下的顶点，先转换到绑定姿势关节空间，然后再转换到当前姿势模型空间

ozz-animation 中算$K$矩阵的代码片段：

```c++
for (size_t j = 0; j < models.Count(); ++j) {
    skinning_matirces[j] = models[j] * mesh.inverse_bind_poses[j];
}
```

`models[j]`就是当前姿势当前时刻第$j$的关节的$C_{j \rightarrow M}$；`mesh.inverse_bind_poses[j]`就是$(B_{j \rightarrow M})^{-1}$，这个逆矩阵是预先算好的，比运行时再算逆矩阵要快得多，一般的蒙皮动画引擎都是这样做

## Lua

### Lua 如何实现面向对象的三大特性

## UI

### 什么是图集、图集的作用

* 所谓图集就是将很多零碎的 2 维小图整合成一张大图

* 图集的作用

  * 提升效率：图片尺寸为 2 的次幂时，GPU 处理起来会快很多，小图自己是做不到每张图都是 2 的次幂的，但打成一张大图就可以

  * UI 的合批理减少 DrawCall：打成图集后，CPU 在传送资源信息给 GPU 时，只需要传一张大图就可以了，因为 GPU 可以在这张图中的不同区域进行采样，然后拼出对应的界面

    > 这就是为什么一个 UI 界面需要用同一个图集的原因

  * 避免浪费资源：打成图集后把图片上的空间尽量利用得充实一点

### 老版的 Sprite Packer 和新版的 Sprite Altas 的区别

* Sprite Packer：2017.3 及之前使用的图集方案，通过对 Sprite 打 Tag 的方式，来自动生成图集。可以自定义打图集的策略
* Sprite Altas：2017.4 新出的图集方案，用来替代 Sprite Packer。Sprite Packer 和 Sprite Atlas 不能共存，Unity 的 Sprite Packer Mode 中的单选性决定了这个不能共存的性质
* Sprite Atlas 针对 Sprite Packer 图集打包系统在性能和易用性上的不足，进行了全面改善

### 项目中 UI 框架的实现思路

### 资源管理模块

* AssetBundle 的原理
* 如何从 Bundle 加载一份资源到 Game 里面，需要经过几次或者几个内存区
* 如何管理 AB 包
* 如何安全卸载 AB 包或者 Asset
* 如何解决依赖

### UI 使用动静分离的原因，为什么这样子做可以防止重刷，重刷是什么机制造成等

### UGUI 的优化、实现过最复杂的 UI 面板是什么、简述一下自己项目中实现的 UI 框架

### Coroutine 的原理、Coroutine 在哪些场景会被用到

### Struct 和 Class 的区别，分别存放在哪个内存区

### 对象池重复依赖和循环依赖的话怎么处理

### 值类型和引用类型

### Animation 和 Animator

### Unity 垃圾回收机制

### DC 是什么

### 合批的原理，合批有哪些，区别是什么

### LOD 是什么，优缺点是什么

### MipMap 是什么，优缺点是什么

### OverDraw 是什么，过高会有什么影响，怎么优化 OverDraw

### Animator 的性能缺陷

### UGUI 的理解，简单聊聊你对 Image 和 RawImage 的理解

### UGUI 的重绘顺序是怎样的

### .Net 与 Mono 的关系

### 对 UI 进行 SetActive 这个操作为什么要避免频繁进行，具体做了些什么内容，有什么方法可以代替它

### UI 上显示 3D 模型的方法有哪些

### 简单讲下光照烘焙哪些参数会影响烘焙速度

### Canvas 的三种模式

### Unity 数据持久化你使用过哪些、说说它们之间的优缺点

### Unity 中碰撞器 Collider 和触发器 Trigger 的区别

## 资源管理

## 性能优化

### 使用过哪些性能分析工具、性能主要是在考虑哪方面的因素影响

#### Unity Profiler

**Unity Profiler** 是 Unity 中最常用的官方性能分析工具，在使用 Unity 开发游戏的过程中，借助 Profiler 来分析 CPU、GPU 及内存使用状况是至关重要的

![image-20221021152916209](45/profiler.png)

## URP

### SetPassCall 和 DrawCall

要想 CPU 和 GPU 既可以并行又可以独立工作，要使用一个命令缓冲区（Command Buffer）。命令缓冲区包含了一个命令队列，当 CPU 需要渲染一些对象时，它会通过图像编程接口向命令缓冲区添加命令，当 GPU 完成上次的渲染任务后，它会从命令队列读取一个命令并执行它，添加和读取的过程是相互独立的

命令缓冲区有很多种类型，而 Draw Call 就是其中一种，其它命令还有 Set Pass Call 等等。Set Pass Call 代表了常说的改变渲染状态，当切换材质或者切换同一材质中 Shader 的不同 Pass 进行渲染时都会触发一次 Set Pass Call。比如渲染 1000 个相同的物体和渲染 1000 个不同的物体，虽然两者 Draw Call 都是 1000，但是前者的 Set Pass Call 为 1，后者还是 1000。切换渲染状态往往比 Draw Call 更耗时，所以这也是 URP 不再支持多 Pass 的原因

每次调用 Draw Call 之前，CPU 都要向 GPU 发送很多内容，包括数据、状态和命令等。在这一阶段 CPU 需要完成很多工作，例如检查渲染状态等。一旦 CPU 完成了这些准备工作，GPU 就可以开始本次渲染，GPU 的渲染能力很强，渲染速度往往比 CPU 的提交命令速度快，如果 Draw Call 数量过多，CPU 就会把机会把大量时间花费在提交 Draw Call 上，造成 CPU 过载，游戏帧率变低

早期 Unity 只支持动态批处理和静态批处理，后来有支持了 GPU Instancing，最后 SRP 出现时支持了一种新的批处理方式——SRP Batcher

### SRP Batcher

SRP Batcher 中将 CPU 收集与提交 GPU 部分省略，并不是完全省略而是不需要每帧都给 GPU 传递数据，如果数据没有发生变化它们将被保存在 GPU 内存中，这样每帧只需要惊醒绑定数据就行，从而节省了效率。
> SRP Batcher 是否发生打断合传统方式是不同的：传统方式即使两个材质使用了**相同的着色器**也会产生 Set Pass Call，而 SRP Batcher 却不会，它判断打断并不是按材质是否变化，二十着色器变种是否发生变化，只要变种相同即使是用了不同的材质也能有效 SRP Batcher

### Constant Buffer

Unity 没有直接提供 MVP 矩阵，而是拆开成两个举证 M 和 VP，因为 VP 矩阵**在一帧中不会改变**，可以重复利用。Unity 将 M 矩阵和 VP 矩阵存入 Constant Buffer 中以提高运算效率，M 矩阵存入的 Buffer 为`UnityPerDraw Buffer`，也就是针对每个物体的绘制不会改变。VP 矩阵则存入的是`UnityPerFrame Buffer`，即每一帧 VP 矩阵并不会改变。Constant Buffer 并不是所有平台都支持，目前 OpenGL 就不支持

使用`cbuffer`关键字来引入 Constant Buffer，Constant Buffer 中还有很多其他的数据

```glsl
cbuffer UnityPerFrame {
    float4x4 unity_MatirxVP;
};
cbuffer UnityPerDraw {
    float4x4 unity_ObjectToWorld;
};
cbuffer UnityPerMaterial {
        
}
```

#### `UnityPerMaterial`

所有材质相关数据都应该在名为`UnityPerMaterial`的单个 CBUFFER 中声明

> 什么是** Per Material**
>
> 通常是在着色器属性部分声明的所有变量，不能把这些数据漏写或者写道别的 CBUFFER 中

#### `UnityPerDraw`

该 CBUFFER 应该包含所有 Unity 的内置引擎变量。`UnityPerDraw`的 CBUFFER 内部变量声明顺序也很重要，所有变量都应该遵顼名为 **Block Feature** 的布局——如果不需要，则不必声明部分块功能。`UnityPerDraw`中的所有内置引擎变量都应该为`float4`或`float4x4`类型

> 在移动平台上，开发者可能想使用`real4`类型，以节省部分 GPU 带宽。不是所有`UnityPerDraw`变量都可以使用`real4`类型

#### SRP Batcher 原理

SRP Batcher 会在主存中将模型的坐标信息、材质信息、主光阴影参数、非主光阴影参数分别保存成不同的`CBUFFER`中，只有`CBUFFEER`产生变化才会重新提交到 GPU 中。如下图所示，将模型信息、位置信息、变换信息与材质信息分开，模型可能每帧都会移动坐标，但不会每帧都修改材质参数信息，材质信息每次变化后都通过`CBUFFER`传到 GPU 中并且保存（只要没有变化就不需要重新提交），最终 Shader 在显存中通过每帧变化的坐标信息和不一定每帧变化的材质信息渲染出模型来

<center>
    <img src="45/c-buffer.png" />
</center>

* `CBUFFER_START(UnityPerDraw)`：每个物体绘制共享的`CBUFFER`，包括模型控件转世界空间矩阵、世界空间转模型空间矩阵、LOD 参数、**世界变换参数**、灯光参数、环境贴图参数、烘焙参数、球谐光照信息
* `CBUFFER_START(UnityPerMaterial)`：同一材质只能些一个`CBUFFER_START(UnityPerMaterial)`，如果写多个会报错。由于这个`CBUFFER`是自己写的，所以所以数据的赋值在 Shader 代码的属性框架中，在材质面板中就可以设置参数了
  * 每个材质的内容持久化在 GPU 的内存上
  * 一个专用的代码路径来管理一个大的“Per Object”的`CBUFFER`

#### 着色器标识 [`Shader.PropertyToID`](https://docs.unity3d.com/cn/2022.1/ScriptReference/Shader.PropertyToID.html)

获取着色器**属性名称**的唯一标识符。使用属性标识符比将字符串传递到所有材质属性函数更有效。例如，如果要多次调用 [`Material.SetColor`](https://docs.unity3d.com/cn/2022.1/ScriptReference/Material.SetColor.html) 或者使用 [`MaterialPropertyBlock`](https://docs.unity3d.com/cn/2022.1/ScriptReference/MaterialPropertyBlock.html)，则最好只获取一次所需属性的标识符。在 Unity 中，着色器属性的每个名称（例如 `_MainTex` 或 `_Color`）均分配有唯一 整数，在整个游戏中，该整数均保持相同。在游戏的不同次运行之间或在不同机器之间，这些数字不同，因此不要存储或通过网络发送这些数字
