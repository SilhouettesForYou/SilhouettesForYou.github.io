---
title: 日常开发笔记
categories: 
- 日常
tags:
- git
- unity
- c#

---

## Git相关

![](/3/git-framework.png)

* ⏳git回退本地修改

```powershell
git checkout <filename>
git checkout.
```

* * *

## Unity相关

### 几种`Update`方法的区别

#### Update

`Update`是在每次渲染新的一帧的时候才会调用

#### FixedUpdate

该函数用于固定更新，在游戏运行的过程中，每一帧的处理时间是不固定的，当需要固定间隔时间执行某些代码时，就会用到`FixedUpdate()`函数

#### LastUpdate

该函数是延迟更新函数，处于激活状态虾的脚本在每一帧里都会在`Update()`函数执行后调用该函数，通常用来调正代码执行的顺序。比如玩家的角色需要一个摄像机来跟随，那么通常角色的移动逻辑会写在`Update()`里，而摄像机跟随写在`LastUpdate()`里。这样可以确保在角色的位置计算完毕后，再根据角色位置确定摄像机的位置和视角

### Unity3D内存管理——对象池（Object Pool）

``` C
using System.Collections.Generic;
using UnityEngine.Events;

namespace UnityEngine.UI
{
    internal class ObjectPool<T> where T : new()
    {
        private readonly Stack<T> m_Stack = new Stack<T>();
        private readonly UnityAction<T> m_ActionOnGet;
        private readonly UnityAction<T> m_ActionOnRelease;

        public int countAll { get; private set; }
        public int countActive { get { return countAll - countInactive; } }
        public int countInactive { get { return m_Stack.Count; } }

        public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)
        {
            m_ActionOnGet = actionOnGet;
            m_ActionOnRelease = actionOnRelease;
        }

        public T Get()
        {
            T element;
            if (m_Stack.Count == 0)
            {
                element = new T();
                countAll++;
            }
            else
            {
                element = m_Stack.Pop();
            }
            if (m_ActionOnGet != null)
                m_ActionOnGet(element);
            return element;
        }

        public void Release(T element)
        {
            if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))
                Debug.LogError("Internal error. Trying to destroy object that is already released to pool.");
            if (m_ActionOnRelease != null)
                m_ActionOnRelease(element);
            m_Stack.Push(element);
        }
    }
}

```

`ObjectPool`使用了一个栈（后进先出的数据结构），当需要新建（Get）一个新的对象的时候先从栈顶取出第一个，当使用结束的时候将其释放掉（Relaease），就是将其重新放回栈里面，而不是每次都实例化一个新的对象。

### 协程

协程不是线程，不是异步执行。协程和`MonoBehaviour`的`Update`函数一样在主线程中执行，Unity在每一帧都会处理对象上的协程。

#### 协程的执行原理

##### `IEnumberator`

协程函数的返回值时`IEnumberator`，它是一个迭代器，可以把它当成执行一个序列的某个节点的指针。它3个方法，分别是

* `Current`：返回当前指向的元素
* `MoveNext`：将指针向后移动一个单位，如果移动成功，则返回`true`
* `Reset`：把位置重置为初始状态

##### `yield`

`yield`关键字用来声明序列中的下一个值或者是一个无意义的值。

当用`yield return x`（`x`是指一个具体的对象或数值）挂起协程：`MoveNext`返回为`true`，`Current`被赋值为`x`；当用`yield break`挂起协程，`MoveNext`返回为`false`。**如果`MoveNext`函数返回为`true `意味着协程的执行条件被满足，则能够从当前位置继续往下执行，否则不能从当前位置继续往下执行。只有当`MoveNext`返回`false`时，才会执行`yield return`后面的语句。**

#### 中断函数类型

| 语句                                  | 含义                                                        |
| :------------------------------------ | ----------------------------------------------------------- |
| `yield return null`/`yield return 0;` | 程序在下一帧中从当前位置继续执行                            |
| `yield return new WaitForSeconds(N);` | 程序等待N秒后从当前位置继续执行                             |
| `yield new WaitForEndOfFrame();`      | 在所有的渲染以及GUI程序执行完成后从当前位置继续执行         |
| `yield new WaitForFixedUpdate();`     | 所有脚本中的`FixedUpdate()`函数都被执行后从当前位置继续执行 |
| `yield return WWW;`                   | 等待一个网络请求完成后从当前位置继续执行                    |
| `yield return StartCoroutine(xxx);`   | 等待一个xxx的协程执行完成后从当前位置继续执行               |
| `yield break;`                        | 跳出协程                                                    |



* * *

## C#相关

### C#泛型约束

在定义泛型类时。可以对代码能够在实例化类时用于类型参数的类型种类加限制。如果代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译错误。这些限制成为约束，约束是使用`where`上下文关键字指定的。

| 约束           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| `T : struct`   | 类型参数碧血是值类型，可以指定除`Nullable`以外的任何值类型   |
| `T : class`    | 类型参数必须是引用类型，包括任何类、接口、委托或数组类型     |
| `T : new()`    | 类型参数必须具有无参数的公共构造函数，当与其他约束一起使用时，`new()`约束必须最后指定 |
| `T : <基类名>` | 类型参数必须是指定的基类或派生自指定的基类                   |
| `T : <接口名>` | 类型参数必须是指定的接口或实现指定的接口，可以指定多个接口约束，接口约束也可以是泛型的 |
| `T : U`        | 为`T`提供的类型参数必须是为`U`提供的参数或派生自为`U`提供的参数，这成为裸类型约束 |

### `default`函数

`default(T)`可以得到该类型的默认值，C#在初始化时，会给未显示肤质的字段、属性赋上默认值，但值变量却不会，值变量可以使用默认构造函数赋值，或者使用`default(T)`赋值。

| 值类型                                                   | 默认值                                                       |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| `bool`                                                   | `false`                                                      |
| `byte`/`int`/`sbyte` /`short` /`uint` /`ulong` /`ushort` | 0                                                            |
| `decimal`                                                | `0.0M`                                                       |
| `double`                                                 | `0.0D`                                                       |
| `float`                                                  | `0.0F`                                                       |
| `long`                                                   | `0L`                                                         |
| `enum`                                                   | 表达式`(E)0`产生的值，其中`E`为`enum`标识符                  |
| `struct`                                                 | 将所有的值类型字段设置为默认值并将所有的引用类型字段设置为`null`时产生的值 |
| 引用类型                                                 | `null`                                                       |

### C#中`is`，`as`，`using`关键字的使用

* `is`：用于检查对象是否与给定类型兼容，不会抛出异常
* `as`：用于引用类型之间转换，直接进行转换，若转换成功，则返回转换后的对象，若转换失败则返回`null`，不会抛出异常
* `using`：引用命名空间，有效回收资源，`using`关键字可以回收多个对象的资源，关键字后面的小括号内创建的对象必须实现`IDisposanble`接口，或者该类的基类已经实现了`IDisposable`接口。回收资源的时机是在`using`关键字下面的代码块执行完成之后自动调用接口方法`Dispose()`销毁对象

### `ref`和`out`关键字

C#的数据类型有两种：一种是值类型（value type），一种是引用类型（reference type）。

* 值类型：结构体（数值类型，`bool`，用户自定义结构体）、枚举和可空类型。
* 引用类型：数组、用户定义的类、接口、委托、`object`、字符串。

值类型和引用类型的区别在于：函数传递的时候，值类型把自己的值复制一份传递给别的函数；引用类型则是把自己的地址传递给函数。

`ref`和`out`都是按地址传递的，使用后都将改变原来参数的数值。`ref`可以把参数的数值传递进函数，传递到`ref`参数必须初始化，否则会报错；但是`out`是要把参数清空，无法把一个数值从`out`传递进去，传递进去后必须初始化一次。

### C#特性标签（Attribute）

公共语言运行时能够添加类似于关键字的描述性声明称为特性，以便批注编程元素（如类型、字段、方法和属性）。将特性与程序实体相关联后，可以在运行时使用**反射**查询特性。

可以将特性附加到几乎任何声明中。在C#中，通过用方括号（`[]`）将特性名称括起来，并置于应用该特性的实体的声明上方以指定特性。

#### 创建自定义特性

可以通过定义特性类创建自定义特性，特性类是直接或间接派生自`Attribute`的类，可快速轻松地识别元数据中的特性定义。

```c
[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct)]
public class AuthorAttribute : System.Attribute
{
    private string name;
    public double version;
    public AuthorAttribute(string name)
    {
        this.name = name;
        version = 1.0;
    }
}
```

#### 访问特性

对于自定义特性，可以用`Type`中的`IsDefined`和`GetCustomAttributes`方法来获取。

* `IsDefined`：`public abstract bool IsDefined(Type attributeType, bool inherit)`，用来加测某个特性是否应用到某个类上
* `GetCustomAttributes`：`public abstract object[] GetCustomAttributes(bool inherit)`，调用它后，会创建一个与目标相关联的特性的实例

#### 特性与注释的区别

注释是对程序源代码的一种说明，程序编译的时候会忽略它，而特性是代码的一部分，它会被编译器编译进程序的元数据里，在程序运行的时候，随时可以从元数据中提取出这些附加信息。

###  `Action`委托与`Func`委托

`Action`不能指向有返回值的方法，不能有返回值。`Func`可以指向有一个返回值的方法，且必须有返回值。

### `Activator.CreateInstance<T>`与`new`

`new`和`Activator.CreateInstance`都用于实例化一个类，`Activator.CreateInstance`使用与指定参数匹配程度最高的构造函数来创建指定类型的实例。

```c
public static T Factory<T>() where T : new()
{
    return new T();
}
```

编译器会将`return new T()`转换调用`Actuvator.CreateInstance`方法。

### C#资源回收和`IDisposable`接口的使用

* 托管资源和非托管资源

  * 托管资源由CLR来维护，自动进行垃圾回收，比如数组
  * 非托管资源不会进行自动垃圾回收，需要手动释放，比如句柄。但在c#中的非托管资源很多都被封装到.NET类中，当对象释放时内部方法同时释放非托管资源

  在C#中创建的对象，数组，列表等等都不需要考虑资源释放的问题，因为它会被CLR的垃圾回收机制自动回收。创建的对象释放时是随机的不确定时长的等待自动回收机制进行收回，有没有办法主动回收这些资源呢，比如对象占用内存较大，想主动立即释放而不等待主动回收。可以写一个方法，在这个方法里释放引用的资源就可以了，这个方法可以随便起名，当然更规范的是继承IDisposable来实现Disposable方法。
