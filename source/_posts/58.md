---
title: OpenGL with Xmake
toc: true
date: 2024-06-20 21:32:21
categories: Learning OpenGL 
tags:
- OpenGL
- å›¾å½¢å­¦
---

<center>
    <img src="58/opengl-libraries.png" />
</center>

<!-- more -->

### ç›®å½•ç»“æ„

ğŸ”½dependence </br>
&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸glew-2.1.0 </br>
&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸glfw-3.4.bin.WIN32 </br>
&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸glfw-3.4.bin.WIN64 </br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸include </br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸... </br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸lib-static-ucrt </br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸glfw3.dll </br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸glfw3dll.dll </br>
ğŸ”½src </br>
 &nbsp;&nbsp;&nbsp;&nbsp;â–¶ï¸main.cpp </br>
â–¶ï¸xmake.lua </br>

### xmake é…ç½®

```lua
set_project("OpenGL Tutorial")
add_rules("mode.debug", "mode.release")

target("HelloOpenGL")
    set_kind("binary")
    add_files("src/*.cpp")
    add_includedirs("/dependence/glfw-3.4.bin.WIN64/include") -- include æ–‡ä»¶
    add_includedirs("/dependence/glew-2.1.0/include")
    add_linkdirs("/dependence/glfw-3.4.bin.WIN64/lib-static-ucrt") -- gcc ç¼–è¯‘çš„é™æ€é“¾æ¥åº“ç›®å½•
    add_linkdirs("/dependence/glew-2.1.0/lib/Release/Win32")
    add_linkdirs("/dependence/glew-2.1.0/bin/Release/x64")
    add_links("glfw3dll", "glew32") -- é“¾æ¥ glfw å’Œ glew
    add_syslinks("opengl32") -- é“¾æ¥ç³»ç»Ÿåº“
```

### Notes

* é¡¶ç‚¹ç€è‰²å™¨
  * æ¯ä¸ªé¡¶ç‚¹è¿è¡Œä¸€æ¬¡
  * ç¡®å®šä½ç½®
* ç‰‡æ®µ/åƒç´ ç€è‰²å™¨
  * å¡«å……ä¸‰è§’å½¢çš„æ¯ä¸ªåƒç´ è®¡ç®—ä¸€æ¬¡
* ä¸ºä»€ä¹ˆç´¢å¼•ç¼“å†²æ˜¯`unsigned int`æ— ç¬¦å·çš„
* é”™è¯¯å¤„ç†
  * `glGetError`
  * å®å®šä¹‰
* uniform å˜é‡
* VAO vertex array object
  * å½“ç©ºé—´ä¸­æœ‰å¤šä¸ªå¯¹è±¡ã€ç½‘æ ¼ã€é¡¶ç‚¹ç¼“å†²åŒºç­‰ï¼Œæ¯ä¸ªéƒ½è¦è¿›è¡Œç»‘å®šç€è‰²å™¨ã€**ç»‘å®šé¡¶ç‚¹ç¼“å†²åŒº**ã€**è®¾ç½®é¡¶ç‚¹å¸ƒå±€**ã€**ç»‘å®šç´¢å¼•ç¼“å†²åŒº**ã€è°ƒç”¨ DrawCall è¿›è¡Œç»˜åˆ¶
  * ç»‘å®šé¡¶ç‚¹ç¼“å†²åŒºä¹‹åè¿˜è¦å£°æ˜é¡¶ç‚¹ç¼“å†²åŒºçš„å¸ƒå±€ï¼Œä¸åŒçš„é¡¶ç‚¹ç¼“å†²åŒºæœ‰ä¸åŒçš„å¸ƒå±€
  * å®é™…ä¸Šéƒ½æ˜¯å’Œ VAO æœ‰å…³ç³»
  * VAO å®ƒå°†æ‰€æœ‰é¡¶ç‚¹ç»˜åˆ¶è¿‡ç¨‹ä¸­çš„è¿™äº›è®¾ç½®å’Œç»‘å®šè¿‡ç¨‹é›†ä¸­å­˜å‚¨åœ¨ä¸€èµ·
  * VAO æ˜¯å¦ç”Ÿæ•ˆç”±é…ç½®æ–‡ä»¶ç±»å‹å†³å®šçš„ The compalibility profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all
  * ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ VAO
    * å¦‚æœä½¿ç”¨æ ¸å¿ƒé…ç½®ï¼Œå°±å¿…é¡»ä½¿ç”¨è‡ªå®šä¹‰çš„ VAO
    * å¦‚æœåªä½¿ç”¨å…¼å®¹æ€§é…ç½®ï¼Œæœ‰ä¸€ä¸ªé»˜è®¤çš„ VAO
* ç€è‰²å™¨å¤„ç†çš„æ­¥éª¤
  * ä¼ å…¥æ–‡ä»¶æˆ–è€…å­—ç¬¦ä¸²ï¼Œå¯ä»¥ç¼–è¯‘ä¸ºç€è‰²å™¨
  * ç»‘å®šå’Œè§£ç»‘ç€è‰²å™¨
  * å¯ä»¥è®¾ç½®ç€è‰²å™¨ä¸­çš„ä¸åŒçš„`uniform`
* æ¸²æŸ“å™¨ç±»
  * è°ƒç”¨ Draw Call æ—¶éœ€è¦é¡¶ç‚¹æ•°ç»„ã€ç´¢å¼•ç¼“å†²åŒºã€ç€è‰²å™¨
  * è§£ç»‘ä¸æ˜¯å¿…è¦çš„ï¼Œè§£ç»‘åªä¼šæµªè´¹æ€§èƒ½
  * æ­£å¸¸ä¼šç”¨æè´¨æ›¿æ¢ç€è‰²å™¨
* å¦‚ä½•é€šè¿‡ OpenGL å°†ç¡¬ç›˜ä¸­çš„ png å›¾ç‰‡æ˜¾ç¤ºåˆ°å±å¹•ä¸Šï¼ˆpng å¹¶ä¸æ˜¯å¼•æ“ç›´æ¥ä½¿ç”¨çš„æ ¼å¼ï¼Œå¤§å¤šæ•°å¼•æ“éƒ½æœ‰è‡ªå·±çš„çº¹ç†æ ¼å¼ï¼‰
  * å°†å›¾åƒåŠ è½½åˆ°å†…å­˜ä¸­â€”â€”`stb_image`
  * è·å–åƒç´ çš„æ•°ç»„ï¼Œç„¶åä¼ åˆ°æ˜¾å­˜ä¸­â€”â€”OpenGL
  * é€šè¿‡ç€è‰²å™¨æ¥è¯»å–çº¹ç†ï¼Œå¹¶è®¡ç®—å‡ºçœŸæ­£çš„åƒç´ å€¼â€”â€”åƒç´ /ç‰‡æ®µç€è‰²å™¨ï¼ˆç»‘å®šçº¹ç†ï¼‰
  * åœ¨ OpenGL ä¸­ï¼Œç”¨ slots æ¥ç»‘å®šçº¹ç†ï¼Œå¯ä»¥ä¸€æ¬¡æ€§ç»‘å®šå¤šä¸ªçº¹ç†
    * åœ¨ Windows ä¸Šæœ‰ 32 ä¸ª slots
    * åœ¨ç§»åŠ¨è®¾å¤‡ï¼ŒAndroid æˆ– IOS ä¸Šå¯èƒ½ä¼šæœ‰ 8 ä¸ª slots
  * OpenGL åŠ è½½çº¹ç†æ˜¯ä»å·¦ä¸‹è§’å¼€å§‹ï¼Œå³å·¦ä¸‹è§’çš„åæ ‡æ˜¯`(0, 0)`ï¼Œæ­£å¸¸åŠ è½½çš„å›¾ç‰‡æ˜¯ä»å·¦ä¸Šè§’å¼€å§‹éå†ï¼Œæ‰€ä»¥åŠ è½½å›¾ç‰‡åéœ€è¦å‚ç›´ç¿»è½¬
  * çº¹ç†åæ ‡
    * æŒ‡å®šæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„çº¹ç†æ˜¯ä»€ä¹ˆï¼Œæ ¹æ®é¡¶ç‚¹å¯¹åº”çš„**çº¹ç†åæ ‡**è¿›è¡Œé‡‡æ ·
    * ç‰‡æ®µç€è‰²å™¨ä¼šæ ¹æ®è¦æ¸²æŸ“çš„åƒç´ çš„ä½ç½®ï¼Œè¿›è¡Œæ’å€¼è®¡ç®—å…·ä½“çš„é¢œè‰²å€¼
* æ··åˆ
  * Blending determies how we combine our output color with what is already in our target buffer
    * Output: the color we output from our fragment shader ä»ç‰‡æ®µç€è‰²å™¨ä¸­è¾“å‡ºçš„é¢œè‰² **SRC**
    * Target buffer: the buffer our fragment shader is drawing to å·²ç»å­˜åœ¨çš„ç¼“å†²åŒºä¸Šçš„é¢œè‰² **DEST**
  * å¦‚ä½•æ§åˆ¶æ··åˆ
    * `glEnable`ã€`glDisable`
    * `glBlendFunc(src, dest)`
      * src: how the src RGBA factor is computed (default is `GL_ONE`) é»˜è®¤æ˜¯ 1ï¼Œæ¯ä¸ªé€šé“éƒ½æ˜¯å•ç‹¬è®¡ç®—çš„
      * dest: how the dest RGBA factor is computed (default is `GL_ZERO`) é»˜è®¤æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´ src ä¼šè¦†ç›–åˆ° dest ä¸Šé¢
    * `glBlendEquation(mode)`
      * mode: how we combine the src and dest colors
      * Default value is `GL_FUNC_ADD`
* æŠ•å½±çŸ©é˜µ
  * æŠ•å½±å°±æ˜¯åœ¨å¤šç»´ç©ºé—´ä¸­ç¡®å®šåæ ‡ç³»
  * å°†åœºæ™¯ä¸­ä¸‰ç»´ç©ºé—´ä¸­çš„åæ ‡è½¬æ¢åˆ° NDCï¼ˆNormalized Device Coordinatesï¼‰ï¼Œå³æ ‡å‡†ç©ºé—´
  * åœ¨çª—å£ä¸­æ¸²æŸ“çš„å†…å®¹çš„åæ ‡èŒƒå›´å¿…é¡»ä»å·¦åˆ°å³åœ¨`[-1, 1]`ä¹‹é—´ï¼Œä»ä¸Šåˆ°ä¸‹åœ¨`[-1, 1]`ä¹‹é—´
  * æŠ•å½±çŸ©é˜µçš„ä½œç”¨å°±æ˜¯å†³å®šåæ ‡ç©ºé—´æ˜¯ä»€ä¹ˆæ ·çš„
    * æ— è®ºæ˜¯æ­£äº¤ï¼ˆOrthographicï¼‰å¤„ç†åçš„é¡¶ç‚¹ï¼Œè¿˜æ˜¯é€è§†ï¼ˆPerspectiveï¼‰å¤„ç†åçš„é¡¶ç‚¹ï¼Œæœ€ç»ˆéƒ½ä¼šæ˜ å°„åˆ°æ ‡å‡†ç©ºé—´ä¸­
* è§†å›¾çŸ©é˜µ ç›¸æœºçš„å˜æ¢ï¼ˆä½ç§»å’Œæ–¹å‘ï¼‰
* æ¨¡å‹çŸ©é˜µ å¯¹è±¡çš„å˜æ¢ï¼ˆä½ç§»ã€æ—‹è½¬ã€ç¼©æ”¾ï¼ŒTRSï¼‰
* ImGui
  * æµ‹è¯•æ¡†æ¶
    * å£°æ˜å‘¨æœŸ
    * å°è£… ImGui
* æ‰¹æ¸²æŸ“
  * åœ¨ä¸€æ¬¡ DrawCall ä¸­æ¸²æŸ“å¤šä¸ªå¯¹è±¡

<center>
    <img src="58/batch-rendering.jpg" />
</center>

#### çº¹ç†çš„æ‰¹æ¸²æŸ“

* é¢œè‰²æ˜¯ uniform å˜é‡å¯ä»¥æ”¾åˆ°é¡¶ç‚¹ç¼“å†²ä¸­ï¼Œä½†æ˜¯ä¸èƒ½æŠŠçº¹ç†æ”¾åˆ°é¡¶ç‚¹ç¼“å†²åŒºä¸­
* ä½†æ˜¯å¯ä»¥åƒé¢œè‰²ä¸€æ ·æä¾›çº¹ç†ç´¢å¼•ï¼Œè¿™ä¸ªç´¢å¼•åœ¨æ¸²æŸ“ Quad æ—¶ï¼Œä»é¡¶ç‚¹ç€è‰²å™¨ä¼ åˆ°ç‰‡æ®µç€è‰²å™¨
* ç‰‡æ®µç€è‰²å™¨ç”¨ä½œçº¹ç†æ•°ç»„å’Œé‡‡æ ·æ•°ç»„è¿™äº› uniform çš„ç´¢å¼•

C++ ä»£ç ä¸­å®šä¹‰

```C++
// (x, y, x) è¡¨ç¤ºåæ ‡
// (r, g, b, a) è¡¨ç¤ºé¢œè‰²
// (u, v) è¡¨ç¤ºçº¹ç†
// texture_index å°±æ˜¯ä¸Šé¢è¯´çš„çº¹ç†ç´¢å¼•ï¼Œå¯¹åº”çº¹ç†æ§½ä½
float vertices[] = {
  x, y, z, r, g, b, a, u, v, texture_index_1,
  ...
  x, y, z, r, g, b, a, u, v, texture_index_2,
}
```

Shader ä¸­çš„å®šä¹‰

```glsl
// vertex.shader
layout (location = 0) in vec3 position;
layout (location = 1) in vec4 color;
layout (location = 2) in vec2 texCoord;
layout (location = 3) in float texIndex;

...

out vec4 _color;
out vec2 _texCoord;
out float _texIndex;

// fragment.shader
layout (location = 0) out vec4 color;

uniform sampler2D textureSamplers[2];

in vec4 _color;
in vec2 _texCoord;
in float _texIndex;

void main()
{
  int index = int(_texIndex);
  color = texture(textureSamplers[index], _texCoord); // æ ¹æ®ç´¢å¼•è¿›è¡Œé‡‡æ ·
}
```

å°†çº¹ç†å’Œæ§½ç»‘å®šï¼Œåˆ©ç”¨ uniform ä¼ é€’æ•°æ®åˆ° shader

```c++
glBindTextureUnit(0, texture1);
glBindTextureUnit(1, texture2);

auto loc = glGetUniformLocation(shader->GetRenderId(), "textureSamplers");
int samplers[2] = { 0, 1 };
glUniform1iv(loc, 2, samplers);
```

#### åŠ¨æ€é¡¶ç‚¹ç¼“å†²

é¢„å…ˆåˆ†é…å¥½æœ€å¤§çš„é¡¶ç‚¹ç¼“å†²åŒºçš„å¤§å°ï¼ˆæ¯”å¦‚ 1KBï¼‰

* å°†é¡¶ç‚¹æ•°ç»„ç”¨ç»“æ„åŒ–çš„æ–¹å¼è¡¨ç¤º

```c++
struct Vertex
{
  float Position[3];
  float Color[4];
  float TexCoords[2];
  float TexId;
}
```

* ç»‘å®šç¼“å†²æ•°æ®æ—¶ä½¿ç”¨`GL_DYNAMIC_DRAW`ç±»å‹
* ç»‘å®šé¡¶ç‚¹å±æ€§æ—¶`offset`ä½¿ç”¨å†…ç½®å‡½æ•°`offsetof`æ¥ç¡®å®šæ¯ç§æ•°æ®ç±»å‹çš„åç§»é‡

```c++
glBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * 1000, nullptr, GL_DYNAMIC_DRAW);
...
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Position));
glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Color));
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexCoords));
glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexId));
```

* åŠ¨æ€ç»‘å®šé¡¶ç‚¹ç¼“å†²

```c++
// ä¸€ä¸ª quad éœ€è¦å››ä¸ªç‚¹
std::array<Vertex, 4> CreateQuad(float x, float y, float texId)
{
  Vertex v0;
  ...
  Vertex v1;
  ...
  Vertex v2;
  ...
  Vertex v3;
  ...
  return { v0, v1, v2, v3 };
}

auto q0 = CreateQuad(-1.5f, -0.5f, 0.0f);
auto q1 = CreateQuad(0.5f, -0.5f, 1.0f);

// é€šè¿‡å†…å­˜æ‹·è´çš„æ–¹å¼ç›´æ¥å°†`std::array`ä¸­çš„å†…å®¹æ‹·è´åˆ°ä¸€ç»´æ•°ç»„ä¸­
Vertex vertices[8];
memcpy(vertices, q0.data(), q0.size() * sizeof(Vertex));
memcpy(vertices + q0.size(), q1.data(), q0.size() * sizeof(Vertex));
...
glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);
```

#### åŠ¨æ€ç´¢å¼•ç¼“å†²

* é¦–å…ˆç¡®å®šç»˜åˆ¶çš„æœ€å¤§çš„ Quad çš„æ•°é‡`maxQuadCount`
* ç”±`maxQuadCount`ç¡®å®šé¡¶ç‚¹æ•°é‡ï¼ˆ`maxQuadCount * 4`ï¼‰å’Œç´¢å¼•æ•°é‡ï¼ˆ`maxQuadCount * 6`ï¼‰

```c++
uint32_t indices[maxQuadCount * 6];
uint32_t offset = 0;
for (size_t i = 0; i < maxQuadCount * 6; i += 6)
{
  indices[i + 0] = 0 + offset;
  indices[i + 1] = 1 + offset;
  indices[i + 2] = 2 + offset;

  indices[i + 3] = 2 + offset;
  indices[i + 4] = 3 + offset;
  indices[i + 5] = 0 + offset;

  offset += 4;
}
```

* æ›´æ”¹`CreateQuad`å‡½æ•°ï¼Œä¼ å…¥é¢„å…ˆå®šä¹‰å¥½å¤§å°çš„é¡¶ç‚¹æ•°æ®ç»“æ„æ•°ç»„ï¼Œå¦‚`std::array<Vertex, 1000>`ï¼ŒåŒæ—¶å¢åŠ é¡¶ç‚¹ç´¢å¼•æ•°é‡

```c++
Vertex* CreateQuad(Vertex* target, float x, float y, float textureId)
{
  target->Position = { x, y, 0.0f };
  target->Color = { 0.18f, 0.6f, 0.96f, 1.0f };
  target->TexCoors = { 0.0f, 0.0f };
  target->TexId = textureId;
  target++;
  ...

  return target;
}

size_t indexCount = 0
std::array<Vertex, 1000> vertices;
Vertex* buffer = vertices.data();

for (int y = 0; y < 5; y++)
{
  for (int x = 0; x < 5; x++)
  {
    buffer = CreateQuad(buffer, x, y, (x + y) % 2);
    indexCount += 6;
  }
}

glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size() * sizeof(Vertex), vertices.data());
...
glDrawElements(GL_TRIANGLE, indexCount, GL_UNSIGNED_INT, nullptr);
```

### APIs

* `glGenBuffers`: Generate buffer object names ç”Ÿæˆç¼“å†²åŒºçš„æ ‡è¯†
  * `n`: Specifies the number of buffer object names to be generated éœ€è¦ç¼“å†²åŒºæ ‡è¯†çš„æ•°é‡
  * `buffers`: Specifies an array in which the generated buffer object names are stored ç”¨äºå­˜æ”¾ç¼“å†²åŒºæ ‡è¯†
* `glBindBuffer`ï¼š Bind a named buffer object ç»‘å®šç¼“å†²åŒºæ ‡è¯†çš„å¯¹è±¡ç±»å‹

  `glBindBuffer` binds a buffer object to the specified buffer binding point. Calling `glBindBuffer` with target set to one of the accepted symbolic constants and buffer set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name buffer exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.
  `glBindBuffer`å‡½æ•°å°†ç¼“å†²å¯¹è±¡ç»‘å®šåˆ° OpenGL ä¸Šä¸‹æ–‡ç¯å¢ƒä¸­ï¼Œè°ƒç”¨`glBindBuffer`å‡½æ•°ï¼Œéœ€è¦å°† target è®¾ç½®ä¸ºä¸€ä¸ªç¬¦å·å¸¸é‡ï¼ˆæŒ‡å®šç¼“å†²å¯¹è±¡çš„ç±»å‹ï¼‰ï¼Œå°† buffer è®¾ç½®ä¸ºç¼“å†²å¯¹è±¡çš„æ ‡è¯†ç¬¦ï¼Œè¿™æ ·å°±å°†ç¼“å†²å¯¹è±¡å’Œæ ‡è¯†ç¬¦è¿›è¡Œç»‘å®šäº†ã€‚å¦‚æœæ ‡è¯†ç¬¦æ²¡æœ‰å…³è”ç¼“å†²å¯¹è±¡ï¼Œå°±åˆ›å»ºä¸€ä¸ªç¼“å†²å¯¹è±¡ã€‚å½“ç¼“å†²å¯¹è±¡å·²ç»ç¡®å®šå¥½å¯¹è±¡ç±»å‹ï¼Œä¹‹å‰ç»‘å®šçš„ç±»å‹å°±ä¼šå¤±æ•ˆ

  Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.
  å› ä¸ºç¼“å†²åŒºå¯¹è±¡æ ‡è¯†ç¬¦æ˜¯æ— ç¬¦å·ç±»å‹çš„æ•´æ•°ï¼ˆéè´Ÿæ•´æ•°ï¼‰ï¼Œå¦‚æœæ ‡è¯†ç¬¦æ˜¯ 0 æ„å‘³ç€ç¼“å†²åŒºå¯¹è±¡ç±»å‹æ²¡æœ‰ç»‘å®šä»»ä½•ç¼“å†²åŒºå¯¹è±¡ï¼Œè¿™æ ·å¯ä»¥å°† buffer å‚æ•°è®¾ç½®ä¸º 0 è¡¨ç¤ºä»ç¼“å†²åŒºå¯¹è±¡ç±»å‹å’Œç¼“å†²åŒºè§£ç»‘ï¼ŒåŒæ—¶ä¹Ÿä¼šæ¸…é™¤åŸæ¥ç¼“å†²åŒºä¸­çš„å†…å®¹ã€‚
  * `target`: Specifies the target to which the buffer object is bound
    * `GL_ARRAY_BUFFER`: Vertex attributes
    * `GL_ATOMIC_COUNTER_BUFFER`: Atomic counter storage
    * `GL_COPY_READ_BUFFER`: Buffer copy source
    * `GL_COPY_WRITE_BUFFER`: Buffer copy destination
    * `GL_DISPATCH_INDIRECT_BUFFER`: Indirect compute dispatch commands
    * `GL_DRAW_INDIRECT_BUFFER`: Indirect command arguments
    * `GL_ELEMENT_ARRAY_BUFFER`: Vertex array indices
    * `GL_PIXEL_PACK_BUFFER`: Pixel read target
    * `GL_PIXEL_UNPACK_BUFFER`: Texture data source
    * `GL_QUERY_BUFFER`: Query result buffer
    * `GL_SHADER_STORAGE_BUFFER`: Read-write storage for shaders
    * `GL_TEXTURE_BUFFER`: Texture data buffer
    * `GL_TRANSFORM_FEEDBACK_BUFFER`: Transform feedback buffer
    * `GL_UNIFORM_BUFFER`: Uniform block storage
  * `buffer`: Specifies the name of a buffer object
* `glBufferData`: ç”¨æ¥æŠŠç”¨æˆ·å®šä¹‰çš„æ•°æ®å¤åˆ¶åˆ°å½“å‰ç»‘å®šç¼“å†²çš„å‡½æ•°
  * `GLenum target`: ç›®æ ‡ç¼“å†²çš„ç±»å‹
  * `GLsizeiptr size`: ä¼ è¾“æ•°æ®çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ï¼Œä¸€èˆ¬ç”¨`sizeof()`å‡½æ•°
  * `const void * data`: å®é™…æ•°æ®
  * `GLenum usage`: æ˜¾å¡å¦‚ä½•ç®¡ç†ç»™å®šçš„æ•°æ®
    * `GL_STATIC_DRAW`: æ•°æ®ä¸ä¼šæˆ–å‡ ä¹ä¸ä¼šæ”¹å˜
    * `GL_DYNAMIC_DRAW`: æ•°æ®ä¼šè¢«æ”¹å˜å¾ˆå¤š
    * `GL_STREAM_DRAW`: æ•°æ®æ¯æ¬¡ç»˜åˆ¶æ—¶éƒ½ä¼šæ”¹å˜
* `glVertexAttribPointer`: å°† CPU çš„æ•°ç»„ç¼“å†²åŒºç»‘å®šåˆ° GPU çš„é¡¶ç‚¹ç¼“å†²åŒº
  * `GLuint index`: Specifies the index of the generic vertex attribute to be modified é¡¶ç‚¹å±æ€§çš„ä½ç½®
  * `GLint size`: Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant `GL_BGRA` is accepted by `glVertexAttribPointer`. The initial value is 4 é¡¶ç‚¹æ¯ä¸ªå±æ€§çš„å…ƒç´ æ•°é‡ï¼Œä¸€å®šæ˜¯ 1ï¼Œ2ï¼Œ3ï¼Œ4 ä¸­çš„ä¸€ä¸ªæ•°ã€‚~~å½“`type`ä¸º`GL_BGRA`æ—¶ï¼Œåˆå§‹å€¼æ˜¯ 4~~
  * `GLenum type`: Specifies the data type of each component in the array. é¡¶ç‚¹æ¯ä¸ªå±æ€§çš„å…ƒç´ çš„æ•°æ®ç±»å‹æšä¸¾
  * `GLboolean normalized`: Specifies whether fixed-point data values should be normalized (`GL_TRUE`) or converted directly as fixed-point values (`GL_FALSE`) when they are accessed å¦‚æœè®¾ç½®ä¸º`GL_TRUE`ï¼Œæ‰€æœ‰æ•°æ®éƒ½ä¼šè¢«æ˜ å°„åˆ°`[0, 1]`ä¹‹é—´ï¼ˆå¯¹äºæœ‰ç¬¦å·ç±»å‹çš„æ•°æ®æ˜¯`[-1, 1]`ä¹‹é—´ï¼‰
  * `GLsizei stride`: Specifies the byte offset between consecutive generic vertex attributes. If strideâ€‹ is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0 åœ¨é¡¶ç‚¹è‹¥å¹²å±æ€§ä¸­ä¸¤ä¸ªç›¸åŒå±æ€§ä¹‹é—´çš„æ­¥é•¿ï¼Œå¦‚æœæ­¥é•¿æ˜¯ 0
  * `const void * pointer`: Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the `GL_ARRAY_BUFFER` target. The initial value is 0. æ¯ä¸ªé¡¶ç‚¹å±æ€§ç›¸å¯¹äºèµ·å§‹å±æ€§çš„åç§»é‡çš„æŒ‡é’ˆçš„ä½ç½®
* `glGetError`: è¿”å›é”™è¯¯æ ‡å¿—çš„å€¼ã€‚æ¯ä¸ªå¯æ£€æµ‹çš„é”™è¯¯éƒ½åˆ†é…æœ‰æ•°å­—ä»£ç å’Œç¬¦å·åç§°ã€‚å‘ç”Ÿé”™è¯¯æ—¶ï¼Œé”™è¯¯æ ‡å¿—å°†è®¾ç½®ä¸ºç›¸åº”çš„é”™è¯¯ä»£ç å€¼ã€‚åœ¨è°ƒç”¨`glGetError`ï¼ˆè¿”å›é”™è¯¯ä»£ç ï¼‰ä¹‹å‰ï¼Œä¸ä¼šè®°å½•å…¶ä»–é”™è¯¯ï¼Œå¹¶å°†æ ‡å¿—é‡ç½®ä¸º`GL_NO_ERROR`ã€‚å¦‚æœå¯¹`glGetError`çš„è°ƒç”¨è¿”å›`GL_NO_ERROR`ï¼Œåˆ™è‡ªä¸Šæ¬¡è°ƒç”¨`glGetError`æˆ–è‡ª GL åˆå§‹åŒ–ä»¥æ¥ï¼Œæ²¡æœ‰å¯æ£€æµ‹åˆ°çš„é”™è¯¯
* `glGenTextures`: generate texture names

  `glGenTextures` returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to `glGenTextures` èƒ½å¤Ÿä¿è¯åœ¨è°ƒç”¨`glGenTextures`å‰è¿”å›çš„æ ‡è¯†ç¬¦æ˜¯æ²¡æœ‰è¢«ç”¨è¿‡çš„

  The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound ç”Ÿæˆçš„çº¹ç†æ˜¯æ²¡æœ‰ç»´åº¦çš„ï¼Œå‡å®šçº¹ç†çš„ç»´åº¦æ˜¯ç¬¬ä¸€æ¬¡ç»‘å®šçš„ç»´åº¦ï¼ˆä¸æ˜¯å¾ˆç†è§£ï¼‰

  Texture names returned by a call to `glGenTextures` are not returned by subsequent calls, unless they are first deleted with `glDeleteTextures` è¿ç»­è°ƒç”¨`glGenTextures`ä¸ä¼šè¿”å›è¡¨ç¤ºç¬¦äº†ï¼Œé™¤éå…ˆè°ƒç”¨`glDeleteTextures`åˆ é™¤çº¹ç†
* `glBindTexture`ï¼š å°†ä¸€ä¸ªçº¹ç†æ ‡è¯†ç¬¦ç»‘å®šåˆ°ä¸€ä¸ªçº¹ç†å¯¹è±¡ä¸Š
  Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. å¯¹äºå½“å‰çš„ GL æ¸²æŸ“ä¸Šä¸‹æ–‡ä¸­çš„å…±äº«å¯¹è±¡ç©ºé—´ï¼Œçº¹ç†åç§°ä»¥åŠå®ƒä»¬å¯¹åº”çš„çº¹ç†å†…å®¹æ˜¯å±€éƒ¨çš„ï¼›åªæœ‰åœ¨æ˜¾å¼å¼€å¯ä¸Šä¸‹æ–‡ä¹‹é—´çš„å…±äº«ï¼Œä¸¤ä¸ªæ¸²æŸ“ä¸Šä¸‹æ–‡æ‰å¯ä»¥å…±äº«çº¹ç†åç§°
* `glTexParameteri`
* `glTexImage2D`
* `glActiveTexture`
* `glClear`
  * ä¸è°ƒç”¨`glClear`çš„è¯ï¼Œä¸‹ä¸€å¸§çš„å†…å®¹ä¼šå’Œä¸Šä¸€å¸§çš„å†…å®¹é‡å åœ¨ä¸€èµ·ï¼Œä¸Šä¸€å¸§çš„ç‰©ä½“è¿˜åœ¨åŸæ¥çš„åœ°æ–¹
  * `glClearColor`
    * æŒ‡å®šåˆ·æ–°é¢œè‰²ç¼“å†²åŒºæ—¶æ‰€ç”¨çš„é¢œè‰²
    * `glClearColor`åªæ˜¯è®¾ç½®ç¼“å†²åŒºé¢œè‰²ï¼Œå¹¶ä¸ä¸ä¼šæ¸…é™¤ç¼“å†²åŒºçš„é¢œè‰²ï¼Œéœ€è¦åœ¨è®¾ç½®å¥½é¢œè‰²ä¹‹åè°ƒç”¨`glClear`æ‰ä¼šåˆ·æ–°ç¼“å†²åŒºçš„é¢œè‰²
    * `glClearColor`å¹¶ä¸æ˜¯å¿…é¡»çš„
* `glUniform1iv`
