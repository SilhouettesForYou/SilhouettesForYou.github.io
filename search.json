[{"title":"现代图形学入门","url":"/2021/11/04/2890ce8fb84c/","content":"\n    \n\n\n\n\nRasterizationWhat’s After MVP?\nModel transformation (placing objects)\nView transformation (placing camera)\nProjection transformation\nOrthographic projection (cuboid to “canonical” cube)\nPerspective projection (frustun to “canonical” cube)\n\n\n\nSampling Artifacts in Computer Graphics\nSignal are changing too fast (high frequency), but sampled too slowly\n\nSampling = Repeat Frequency Contents\n\nAliasing = Mixed Frequency Contents\n\nAntialiasing = Limit, then repeating\n\nMSAA (Multi-Sample AA)\nFXAA (Fast Approximate AA 图像的后处理方法）\nTAA (Temporal AA 利用上一帧的信息）\n\n\n\nVisibility / OcclusionPainter’s AlgorithmPaint from back to front, overwirte in the framebuffer\nZ-Buffer\nStore current min. z-value for each sample (pixel)\nNeed an additional buffer for depth values\nframe buffer stores color values\ndepth buffer stores (z-buffer) depth\n\n\nz is always positive value\nsamller z -&gt; closer\nlarger z -&gt; further\n\n\n\nZ-Buffer Algorithm\nInitialize depth buffer to \nDuring rasterization:\n\nfor (each triangle T)    for (each sample (x, y, z) in T)        if (z &lt; zbuffer[x, y])            framebuffer[x, y] = rgb;            zbuffer[x, y] = z        else            ...\n\nShadingDefinition\nIn Merriam-Webster Dictionary\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n\nIn Compute Graphics\nThe process of applying a material to an object.不同物体应用不用的材质。\n\n\nLambertian (Diffuse) Shading\n\n: diffusely reflected light: diffuse coefficient (color) 如果  是一个表示颜色的向量，可以表示在 shading point 上吸收 / 反射的颜色: engry arrived at the shading point: engry received by the shading point\n\n漫反射方向和视角方向没有关系\n\nSpecular Term (Blinn-Phong)\n观察方向和镜面反射的方向接近的时候，就能得到高光\n close to mirror direction  half vector near normal\n\n\n\n给定入射方向和法线方向，也可以算出反射方向进而计算出高光项，但计算量上要比半程向量复杂\n指数：点乘向量能体现两个向量是否足够接近，用来控制高光的大小\n\nAmbient Term\nAdd constant color to account for disregarded illumination and fill in black shadows\nThis is approximate\n\nGraphics Pipeline\nInterpolation Across Triangles\nWhy do we want to interpolate?\n\nSpecify values at vertices\nObtain smoothly varying values across triangles –希望在三角形内部实现平滑过渡\n\n\nWhat do we want to interpolate?\n\nTexture coordinates, colors, normal vectors, … –可以对三角形上任意属性进行插值\n\n\nHow do we interpolate?\n\nBarycentric coordinates\n\n\n\nBarycentric CoordinatesA coordinate system for triangles \n\n\n\n重心坐标：三角形所在平面上任意一点都可以表示三个顶点坐标的线性组合，条件是线性组合的系数之和为 1Inside the triangle if all three coordinates are non-negative\n\nTexture MappingSimple Texture Mappingfor each rasterized screen sample (x, y): // usually a pixel's center    (u, v) = evaluate texture coordinate at (x, y); // using barycentric coordinate（重心坐标）    texcolor = texture.sample(u, v);    set sample's color to texcolor; // using the diffuse albedo Kd\n\n\n一种解释方法  假设需要用的纹理（比如是）渲染左边的两个三角形（比如是），但是纹理平面非常小，那么最后导致的结果就是一个纹素要对应 4 个像素，这样在实际渲染时产生的效果就是纹理被拉伸，视觉上会有模糊的感觉\n另一种解释方法  纹理映射的过程会根据目标点离相机的远近，占用屏幕上不同大小的范围的像素，例如一个三角面在距离相机 20m 时占用 100 个屏幕像素，当三角面离相机更远时会看起来更小，此时可能占用 20 个屏幕像素，但是在两种情况下这个三角面使用的纹理贴图的大小是不变的。换句话说，由于纹理化表面可以相对于观察者处于任意距离和朝向，因此一个像素通常不直接对应于一个纹理像素。必须应用某种形式的滤波来确定像素的最佳颜色\n\nTexture Magnification 纹理放大 What if the texture is too small? 就是说相对于要渲染的物体，纹理的分辨率不太高\n由于要渲染的物体大于纹理平面，所以物体中的一些部分对应到纹理平面坐标可能就不是整数了，而是小数\n\n\nNearest\n\nBilinear\n\nLinear interpolation(1D)\nTwo helper lerps\n\n\n双线性插值其实就是横向和纵向两个方向做插值\n\nBicubic\n\n\nWhat if the texture is too large?另一种情况就是纹理相比于要渲染的物体大，这样就会导致纹理缩小，即一个像素会覆盖多个纹素\n\n除了纹理分辨率大于要渲染的物体，在如下情况中也会出现  纹理缩小  的问题（通过透视投影将物体映射到平面，会造成近处纹理大，远处纹理小的视觉效果）。换句话说就是近处的一个像素可能只覆盖一个纹素，或者一个纹素覆盖多个像素（这种情况可用双线性插值解决），但对于远处的像素而言，一个像素会覆盖多个纹素，如下图所示（蓝点表示一个像素点，框表示该像素点所能覆盖的纹素数量）\n\nMipmapAllowing (fast, approx., square) range quries.\n“Mip” comes from the Latin “multum in parvo”, meaning a multitude in a small space.\nComputing Mipmap Level D\n\n利用重心坐标映射到纹理坐标\n计算出纹理上近似正方区域的边长\n\n\nTrilinear Interpolation\nLinear interpolation based on continuous D value\nMipmap limitations: overblur\nGeometryImplicit Geometry\nPoints satisfy some specified relationshipE.g. sphere: all points in 3D, where . More generally, .\n\nConstructive Solid GeometryCombine implict geometry via Boolean operations.\n\nDistance Functions\n\nFractals\n\n\nExplict GeometryAll points are given directly or via parameter mapping.\n\nPoint Cloud\n\n Curvede Castekjau AlgorithmEvaluating  Curves Algebraic Formula\nExample: quadratic  curve from three points\n\n\nt可以理解为某一时刻\n\n\nBernstein form of a  curve of order n:\n\n:  control points: Bernstein polynomial\n\n\n SurfacesShadow MappingRender from light\ndepth image from light source （只需要深度图）\n\nRender from eye\nStandard image (with depth) from eye\n\nProject to light\nProject visible points in eye view back to light source\nCompare the depths from light and eye\n\nRay TracingRecursive (Whitted-Style) Ray TracingRay-Surface Intersection\nRay equation:\n\nRay intersection with sphere\nSphere: \n\nRay intersection with implicit surface\nGeneral implicit surface: Solve for real, positive roots\n\nRay intersection with triangle mesh\nPlane equation (if  satisfies it, then  is on the plane):\nSolve for intersection\n\n\n\nA faster approach, giving barycentric coordinate（重心坐标） directly\n\n\nRay Intersection with Axis-Aligned Bounding Box\nThe ray enters the box only when it enters all pairs of slabs\nThe ray exits the box as long as it exits any pair of slabs\nFor each pair, calcute the  and  (negative is fine)\nFor the 3D box, , \nif , we know ray stays a while in the box.\n\n\n\nSpatial Partitions（空间划分）\nOct-Tree\nKD-Tree\nBSP-Tree\n\nObject Partitions（物体划分） &amp; Bounding Volume Hierarchy (BVH)Radiometry（辐射度量学）\nRadiant Energy and Flux (Power)\n\n强度\n能量\n\n\nImport Light Measurements of Interest\n\nRadiant Intensity: power per solid angle\nSolid Angle（立体角）\nIrradiance（辐射照度）: power per unit area\nRadiance（辐射亮度）: power per unit solid angle, per projected unit area.\n\n\nIrradiance vs.Radiance\n\nIrradiance: total power received by area \nRadiance: power received by area  from “direction” \n\n\n\nradiance 是来自四面八方的 irradiance 的和（积分）\n\n\n\nBidirectional Reflectance Distribution Function (BRDF)Refection at a point\n如果有一束光线进入，不同的反射方向上的能量分布。\n\nThe BRDF represents how much light is reflected into each outgoing direction  from each incoming direction\nThe Reflection Equation\nThe Rendering Equationby adding an Emission term ot make it general\n\n\n: Reflected Light\n: Emission（自发光）\n: Incident Light\n: BRDF\n: Cosine of Incident angle\n\nRendering Equation as Intergral Equation\n\n: Emission directly from light sources  Shading in Rasterization\n: Direct Illumination on surfaces  Shading in Rasterization\n: Indirect Illumination(one bounce indirect: mirrors, refraction)\n: Two bounce indirect illum.\n\nPath TracingMaterials and AppearancesDiffuse / Lambertian Material\n漫反射系数\n\n\n\nDiffuse’s BRDF:  为反射率 (albedo)\n\nGlossy MaterialPerfect Specular Reflection\n\n\n\n两个向量  和的和一定沿着法向量的方向，长度是 2 倍的红颜色的长度，即入射方向投影到法线方向的长度（）的 2 倍\n\nSpecular Refraction\nSnell’s Law\n\nFresnel Reflection / TermMicroFacet MaterialMicrofacet Theory\nMacroscale: flat &amp; rough\nMicroscale: bumpy（凹凸的） &amp; specular\n\nMicroface BRDF\n\n: Frenel term\n: shadowing-masking term（微表面的自遮挡、自投影处理）\n: distribution of normals\n\nProperties of BRDFs\nNon-negativity\nLinearity\nReciprocity principle（可逆性）\nEnergy conservation（能量守恒）\nIsotropic（各项异性） &amp; Anisotropic（各项同性）\n\nMeasuring BRDFsCameras, Lenses（棱镜） and Light Fields（光场）\nField of View\n\nIt it common to refer to angular field of view by focal length（焦距） of a lens used on a 35mm-format film(36  24mm)\n\n\nExposure\n\n\nExposure = time  irradiance\nExposure time:\nControl by shutter\n\n\nIrradiance:\nPower of light falling on a unit area of sensor\nControlled by lens aperture（光圈） and focal length\n\n\n\n\nExposure Controls in Photography\nAperture size: Change the f-stop by opening / closing the aperture\nf-stop 数越大光圈越小\nF-Number definiton: the focal length divided by the diameter of the aperture\n\n\nShutter speed\nIOS gain（感光度）\n\n\n\n\nDepth of Field（指成像清晰的一段范围）\n\n\nColor and PerceptionAddtive Color（加色系统）\nGiven a set of primary lights, each with its own spectral distribution\n, , \n\n\nAdjust the brightness of these lights and add them together\n\n\n\n\nColor Spaces\nStandardized RGB(sRGB)\n\nPerceptually Organized Color Spaces\n\nHSV Color Space(Hue-Saturation-Value)\nHue: 色调\nSaturation: 饱和度\nValue: 亮度\n\n\nL*a*b*\nL* is lightness\na* and b* are color-opponent（互补色） pairs\na* is red-green\nb* is blue-yellow\n\n\n\n\nCMYK: A Subtractive Color Space\n\nCyan, Magenta, Yellow and Key Widely\n\n\n\n","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"Pipeline and Shading","url":"/2021/11/12/59d944903050/","content":"光栅化  与 Triangles and Z-Buffer 一样的流程\n\n计算三角形的包围盒（bounding box）\n遍历包围盒判断点是否在三角形内\n求解重心坐标并进行插值校正\n更新深度值\n\n这里需要计算颜色插值（color）、向量插值（normal）、纹理坐标插值（texcoords）和着色点坐标插值（shadingcoords）\nshadingcoordsGPU 先进行观测变换（Viewing Transformation），再进行光栅化。由于增加了光照，同一物体的不同位置的颜色不一样，需要结合法线等因素去计算，所以需要考虑物体在原本空间的位置。\n在进行光栅化时只有像素的  坐标是已知的，经过深度插值，才得到了  屏幕空间  中对应的某点的坐标 。而这个坐标也不是 观察空间 （View Space 或者 Camera Space）里面的点，因为投影矩阵本质上是把视锥压缩成了长方体，这个坐标是经历了压缩之后的。只有利用，， 结合 rasterize_triangle 传进来的参数 viewspace_pos 插值才能算出对应  观察空间  中的像素点。得到了这个所谓的 interpolated_shadingcoords，其实就是 观察空间  中你真正在着色的那个点。\n光线作用是  观察空间 （View Space 或者 Camera Space）中进行的，经过了 MV 变换（Model 和 Viewpoint）的空间就是 观察空间 ，这时所有空间点之间的相对位置都还是正常的，所以要在这个 观察空间  来做着色，计算光的入射和空间点的作用。经过了 MVP 变换的空间还是三维空间，但已经是被透视变换压缩的三维空间，因为  被压缩了，所以不能用这个空间来做光线作用。经过了 MVP 变换和 Viewport 变换的空间叫做  屏幕空间（Screen Space），已经是二维空间点了，准备好成为像素了。\n//Screen space rasterizationvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos) {    // TODO: From your HW3, get the triangle rasterization code.    // TODO: Inside your rasterization loop:    //    * v[i].w() is the vertex view space depth value z.    //    * Z is interpolated view space depth for the current pixel    //    * zp is depth between zNear and zFar, used for z-buffer    // float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());    // float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();    // zp *= Z;    // TODO: Interpolate the attributes:    // auto interpolated_color    // auto interpolated_normal    // auto interpolated_texcoords    // auto interpolated_shadingcoords    // Use: fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);    // Use: payload.view_pos = interpolated_shadingcoords;    // Use: Instead of passing the triangle's color directly to the frame buffer, pass the color to the shaders first to get the final color;    // Use: auto pixel_color = fragment_shader(payload);    auto v = t.toVector4();    auto minX = std::min(v[0].x(), std::min(v[1].x(), v[2].x()));    auto minY = std::min(v[0].y(), std::min(v[1].y(), v[2].y()));    auto maxX = std::max(v[0].x(), std::max(v[1].x(), v[2].x()));    auto maxY = std::max(v[0].y(), std::max(v[1].y(), v[2].y()));        for (int i = minX; i &lt;= maxX; i++) {        for (int j = minY; j &lt;= maxY; j++) {            if (insideTriangle(i + 0.5, j + 0.5, t.v)) {                auto tup = computeBarycentric2D(i, j, t.v);                float alpha, beta, gamma;                std::tie(alpha, beta, gamma) = tup;                float wReciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());                float zInterpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();                zInterpolated *= wReciprocal;                auto index = get_index(i, j);                                if (depth_buf[index] &gt; zInterpolated) {                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);                    payload.view_pos = interpolated_shadingcoords;                    auto pixel_color = fragment_shader(payload);                    set_pixel(Eigen::Vector2i(i, j), pixel_color);                    depth_buf[index] = zInterpolated;                }            }        }    }}\n\nNormal法向贴图不考虑光照直接将着色点的法向量的值映射为颜色值即可\nEigen::Vector3f normal_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f return_color = (payload.normal.head&lt;3&gt;().normalized() + Eigen::Vector3f(1.0f, 1.0f, 1.0f)) / 2.f;    Eigen::Vector3f result;    result &lt;&lt; return_color.x() * 255, return_color.y() * 255, return_color.z() * 255;    return result;}\n\n\n    \n\n\nBlinn-Phong漫反射（Diffuse Term）\n高光（Specular Term）\n    \n\n\n\n其中  是半程向量\n环境光（Ambient Term）\nBlinn-Phong Refection Model\n    \n\n\n\nEigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color / 255.f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;    Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);        //std::cout &lt;&lt; \"(\" &lt;&lt; result_color.x() &lt;&lt; \",\" &lt;&lt; result_color.y() &lt;&lt; \",\" &lt;&lt; result_color.z() &lt;&lt; \")\" &lt;&lt; std::endl;    }    return result_color * 255.f;}\n\n\n    \n\n\nTexture Shader FragmentTexture 的实现只需要将纹理坐标对应的颜色传给 kd 即可，纹理坐标会出现负值，所以把 ， 坐标限定在  范围内\nEigen::Vector3f getColor(float u, float v){    // 坐标限定    if (u &lt; 0) u = 0;    if (u &gt; 1) u = 1;    if (v &lt; 0) v = 0;    if (v &gt; 1) v = 1;    auto u_img = u * width;    auto v_img = (1 - v) * height;    auto color = image_data.at&lt;cv::Vec3b&gt;(v_img, u_img);    return Eigen::Vector3f(color[0], color[1], color[2]);}\n\nEigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f return_color = {0, 0, 0};    if (payload.texture)    {        // TODO: Get the texture value at the texture coordinates of the current fragment        auto texcoord = payload.tex_coords;        return_color = payload.texture-&gt;getColor(texcoord.x(), texcoord.y());    }    Eigen::Vector3f texture_color;    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = texture_color / 255.f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = texture_color;    Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);    }    return result_color;}\n\n\n    \n\n\nBump Mapping法线贴图原理  如果法线处于世界坐标中的（World Space），那称为 World Space Normal。如果是处于物体本身局部坐标中的，那称为 Object Space Normal。\nWorld Space Normal 一旦从贴图里解压出来后，就可以直接用了，效率很高。但是有个缺点，这个 World Space Normal 是固定了，如果物体没有保持原来的方向和位置，那原来生成的法线贴图就作废了。\n因此保存了 Object Space Normal。它从贴图里解压，还需要乘以模型 - 视图（Model-View）矩阵转换到世界坐标，或者转换到其他坐标取决于计算过程及需求。Object Space Normal 生成的贴图，物体可以被旋转和位移。但仍有一个缺点。就是 ** 一张贴图只能对应特定的一个模型，模型不能有变形 (deform)**。\n变形时，顶点关系改变了，即面的形状，方向改变了。如果面上存在一个固定的坐标系，那当物体变形、移动、旋转时，这个坐标系必定跟着面一起运动，那么在这个坐标系里的某个点或向量，不需要变动。当整个面发生变化时，只需要计算面上的坐标系到世界坐标系的转换矩阵，那么定义在这个面上的点或坐标（固定的）, 乘以这个矩阵即可得到在世界中的坐标。这个坐标系术语里称为切线空间（Tangent Space）。\nUV 与 TB 的关系  一个顶点结构中包含很多信息，其中就有顶点在三维空间中的位置信息，以及顶点在展开的 UV 中的 UV 坐标，且三维空间下三角形中的每一个点都必能在 UV 上找到对应的点，反之亦然。\n\n    \n\n\n假设  的三个顶点以逆时针排列，则对于点 ，将 记为 、 记为 ， 代表 Tangent（切线），代表Bitangent（副切线）。若设，UV 坐标为、，UV 坐标为、，UV 坐标为，对应的纹理坐标插值：\n则有如下公式（，分别和纹理坐标轴 ， 是平行的，根据向量加法可得）：\n用矩阵来表示：\n继而得出：\n\n    \n\n在这种特殊情况下，此时的  显然恰好与 U 在三维空间上的映射方向相同、同理  也与  方向相同。直观上，该公式描述的数学意义是，如何将一个点从 UV 空间映射到三维空间，其中 TB 作为基矢，以 UV 空间中的 U 和 V 的增长作为控制参数。假设三角形中存在一点 ，则向量，只要知道 点的 UV 坐标值，即可得到  点的三维坐标值。\n\n如果在三维空间下将三角形做一点拉伸，变成如下图所示，则 UV 向量在三维空间的方向将不再垂直，但依然可以很方便的辨认出纹理坐标映射的位置。\n\n    \n\n\n目前算出来的  还不是真正的切线与副切线，需要经过正交化得到  矩阵：\nEigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload){        Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;     Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    float kh = 0.2, kn = 0.1;    // TODO: Implement bump mapping here    // Let n = normal = (x, y, z)    // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))    // Vector b = n cross product t    // Matrix TBN = [t b n]    // dU = kh * kn * (h(u+1/w,v)-h(u,v))    // dV = kh * kn * (h(u,v+1/h)-h(u,v))    // Vector ln = (-dU, -dV, 1)    // Normal n = normalize(TBN * ln)    auto n = normal.normalized();    Eigen::Vector3f t;    t &lt;&lt; n.x() * n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z()),        std::sqrt(n.x() * n.x() + n.z() * n.z()),        n.z()* n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z());    auto b = n.cross(t);    Eigen::Matrix3f TBN;    TBN &lt;&lt; t, b, n;        float w = payload.texture-&gt;width;    float h = payload.texture-&gt;height;    auto texcoord = payload.tex_coords;    auto dU = kh * kn * (payload.texture-&gt;getColor(texcoord.x() + 1 / w, texcoord.y()).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    auto dV = kh * kn * (payload.texture-&gt;getColor(texcoord.x(), texcoord.y() + 1 / h).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    Eigen::Vector3f ln;    ln &lt;&lt; -dU, -dV, 1.0f;    normal = TBN * ln;    normal = normal.normalized();    Eigen::Vector3f result_color = {0, 0, 0};    result_color = normal;    return result_color * 255.f;}\n\n\n    \n\n\nDisplacement Mapping在 Bump 的基础上应用了 Blinn-Phong 模型\nEigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload){        Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color / 255.0f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;     Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    float kh = 0.2, kn = 0.1;        // TODO: Implement displacement mapping here    // Let n = normal = (x, y, z)    // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))    // Vector b = n cross product t    // Matrix TBN = [t b n]    // dU = kh * kn * (h(u+1/w,v)-h(u,v))    // dV = kh * kn * (h(u,v+1/h)-h(u,v))    // Vector ln = (-dU, -dV, 1)    // Position p = p + kn * n * h(u,v)    // Normal n = normalize(TBN * ln)        auto n = normal.normalized();    Eigen::Vector3f t;    t &lt;&lt; n.x() * n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z()),        std::sqrt(n.x() * n.x() + n.z() * n.z()),        n.z()* n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z());    auto b = n.cross(t);    Eigen::Matrix3f TBN;    TBN &lt;&lt; t, b, n;    float w = payload.texture-&gt;width;    float h = payload.texture-&gt;height;    auto texcoord = payload.tex_coords;    auto dU = kh * kn * (payload.texture-&gt;getColor(texcoord.x() + 1 / w, texcoord.y()).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    auto dV = kh * kn * (payload.texture-&gt;getColor(texcoord.x(), texcoord.y() + 1 / h).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    Eigen::Vector3f ln;    ln &lt;&lt; -dU, -dV, 1.0f;    point = point + kn * n * payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm();    normal = TBN * ln;    normal = normal.normalized();        Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);    }    return result_color * 255.f;}\n\n\n    \n\n","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"顶点着色器和片元着色器","url":"/2021/11/12/52b937df3194/","content":"\n\n顶点着色器\n顶点着色器负责的功能是把输入的数据进行  坐标变换，计算光照公式生成每个点颜色，计算纹理坐标。并且把位置和纹理坐标发送到片元着色器。\n输入参数\nattribute：空间坐标、法向量、纹理坐标及顶点颜色。\nuniform：uniform保存由应用程序传递给着色器的只读常量数据。在顶点着色器中，这些数据通常是变换矩阵、光照参数、颜色等。由 uniform 修饰符修饰的变量属于全局变量。\nsampler：一种特殊的 uniform，用于呈现纹理。sampler 可用于顶点着色器和片元着色器。\n\n输出参数\nvarying：用于存储顶点着色器的输出数据，varying变量会在光栅化处理阶段被线性插值。\ngl_Position：位置信息\ngl_PointSize：点大小\n\n片元着色器\n片元着色器的作用是处理由光栅化阶段生成的每个片元，最终计算出每个像素的最终颜色。归根结底，实际上就是数据的集合。这个数据集合包含每个像素的各个颜色分量和像素透明度的值。\n输入参数\nshader program：由 main 声明的一段程序源码，描述在片元上执行的操作。\nvarying：顶点着色器阶段输出的 varying 变量在光栅化阶段被线性插值后输出到片元着色器作为它的输入。\nuniform：用于片元着色器的常量，如纹理参数等。\nsampler：一种特殊的uniform，用于呈现纹理。\n\n输出参数 gl_FragColor：在顶点着色器阶段只有唯一的varying 输出变量gl_FragColor。\n","categories":["Learning OpenGL"],"tags":["Graphics","OpenGL"]},{"title":"各种数据结构及其底层实现","url":"/2021/11/12/6b21d140a633/","content":"\nvector：底层数据结构为数组，支持快速随机访问。\n扩容规则为：当新建一个 vector 时，会首先分配一块连续的内存空间，当向其中增加元素是，如果初始分配空间已满，就会引起 vector 扩容。首先重新申请一个 2 倍大的内存空间；然后将原空间的内容拷贝过来；最后将原空间内容进行释放，将内存交还给操作系统。\n在插入位置和删除位置之后的多有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。\n\n\nlist：双向链表，支持快速增删。\ndeque：底层为一个中央控制器和多个缓冲区，支持收尾快速增删，也支持随机访问。deque是一个双端队列（double-ended queue），看起来像是 list 和vector的结合品。\nstack：底层一般用 list 或deque实现，封闭头部即可，不用 vector 的原因是容量大小有限制，扩容耗时。\nqueue：单向队列，为先入先出原则。\nproority_queue：根据堆的处理规则来调整元素之间的位置，优先级队列相当于一个有权值的单向队列 queue，在这个队列中，所有元素是按照优先级排列的。根据堆的特性，优先级队列实现了  取出最大最小元素  时间复杂度为 , 对于 插入和删除，其最坏情况为。\nset：红黑树，有序，不重复。\nmultiset：红黑树，有序，可重复。\nmap：红黑树，有序，不重复，可以实现  的查找，插入和删除。\nmultimap：红黑树，有序，可重复，可以实现  的查找，插入和删除。\nunordered_set：hash 表，无序，不重复。\nunordered_multiset：hash 表，无序，不重复。\nunordered_map：hash 表，无序，不重复，查找  时间复杂度理论上达到了。\nunordered_multimap：hash 表，无序，不重复，查找  时间复杂度理论上达到了。\n\n","categories":["数据结构"],"tags":["数据结构"]},{"title":"山势郁崔嵬，之罘入海来","url":"/2021/11/15/28e737a531d3/","content":"\n","categories":["相册"],"tags":["烟台"]},{"title":"蔬食戏书","url":"/2021/11/15/fcde3a91bc0f/","content":"新津韭黄天下无，色如鹅黄三尺余。东门  彘肉更奇绝，肥美不减胡羊酥。贵珍  讵敢杂常  馔，桂炊薏米圆比珠。还吴此味那复有，日饭脱粟焚枯鱼。人生口腹何足道，往往坐役七尺躯。膻荤从今一扫除，夜煮白石笺阴符。\n\n\n\n    .cd-timeline.svelte-1t2uafz .svelte-1t2uafz,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::after,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::before{-webkit-box-sizing:border-box;box-sizing:border-box}.cd-timeline.svelte-1t2uafz{font-size:1.6rem;font-family:\"Droid Serif\", serif;color:#7f8c97;background-color:#e9f0f5}.cd-timeline.svelte-1t2uafz a{color:#acb7c0;text-decoration:none}.cd-timeline.svelte-1t2uafz img{max-width:100%}.cd-timeline.svelte-1t2uafz h1,h2{font-family:\"Open Sans\", sans-serif;font-weight:bold}.cd-timeline.svelte-1t2uafz{overflow:hidden;margin:2em auto}.cd-timeline__container.svelte-1t2uafz{position:relative;width:90%;max-width:1170px;margin:0 auto;padding:2em 0}.cd-timeline__container.svelte-1t2uafz::before{content:'';position:absolute;top:0;left:18px;height:100%;width:4px;background:#d7e4ed}@media only screen and (min-width: 1170px){.cd-timeline.svelte-1t2uafz{margin-top:3em;margin-bottom:3em}.cd-timeline__container.svelte-1t2uafz::before{left:50%;margin-left:-2px}}.cd-timeline__block.svelte-1t2uafz{position:relative;margin:2em 0}.cd-timeline__block.svelte-1t2uafz:after{content:\"\";display:table;clear:both}.cd-timeline__block.svelte-1t2uafz:first-child{margin-top:0}.cd-timeline__block.svelte-1t2uafz:last-child{margin-bottom:0}@media only screen and (min-width: 1170px){.cd-timeline__block.svelte-1t2uafz{margin:4em 0}}.cd-timeline__img.svelte-1t2uafz{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;-webkit-box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05);box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05)}.cd-timeline__img.svelte-1t2uafz{background:#75ce66}@media only screen and (min-width: 1170px){.cd-timeline__img.svelte-1t2uafz{width:60px;height:60px;left:50%;margin-left:-30px;-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}.cd-timeline__content.svelte-1t2uafz{position:relative;margin-left:60px;background:white;border-radius:0.25em;padding:1em;-webkit-box-shadow:0 3px 0 #d7e4ed;box-shadow:0 3px 0 #d7e4ed}.cd-timeline__content.svelte-1t2uafz:after{content:\"\";display:table;clear:both}.cd-timeline__content.svelte-1t2uafz::before{content:'';position:absolute;top:16px;right:100%;height:0;width:0;border:7px solid transparent;border-right:7px solid white}.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{color:#303e49}.cd-timeline__content.svelte-1t2uafz p,.cd-timeline__date.svelte-1t2uafz{font-size:1.3rem}.cd-timeline__content.svelte-1t2uafz p{margin:1em 0;line-height:1.6}.cd-timeline__date.svelte-1t2uafz{display:inline-block}.cd-timeline__date.svelte-1t2uafz{float:left;padding:.8em 0;opacity:.7}@media only screen and (min-width: 768px){.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{font-size:2rem}.cd-timeline__content.svelte-1t2uafz p{font-size:1.6rem}.cd-timeline__date.svelte-1t2uafz{font-size:1.4rem}}@media only screen and (min-width: 1170px){.cd-timeline__content.svelte-1t2uafz{margin-left:0;padding:1.6em;width:45%;-webkit-transform:translateZ(0);transform:translateZ(0)}.cd-timeline__content.svelte-1t2uafz::before{top:24px;left:100%;border-color:transparent;border-left-color:white}.cd-timeline__date.svelte-1t2uafz{position:absolute;width:100%;left:122%;top:6px;font-size:1.6rem}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz{float:right}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz::before{top:24px;left:auto;right:100%;border-color:transparent;border-right-color:white}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__date.svelte-1t2uafz{left:auto;right:122%;text-align:right}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}\n    \n\n    \n        \n    \n\n","categories":["相册"],"tags":["美食祭"]},{"title":"包围盒","url":"/2021/11/17/ce5b10922e00/","content":"轴对齐包围盒（Axis-Aligned Bounding Box，AABB）三维的 AABB 就是一个简单的六面体，每一边都平行于一个坐标平面，矩形边界框不一定都是立方体，它的长、宽、高可以彼此不同。AABB 内的点满足以下条件：优点是简单；缺点是紧密型较差。\n有向包围盒（Oriented Bounding Box，OBB）OBB 包围盒根据物体本身的几何形状来决定包围盒的大小和方向，包围盒无须和坐标轴垂直。这样可以选择最适合、最紧凑的包围盒。一般通过物体模型所有顶点在空间的分布求得。\nOBB 的生成思路简单来说就是分局物体表面的顶点，通过 PCA（主成分分析）获得特征向量。主成分分析是一种通过正交变换，将一组可能相关的变量集合变换成一组线性不相关的变量集合。\n引入协方差的概念，协方差表示两个变量之间的线性相关程度。协方差越小则两个变量之间越独立，相关性越小。通过协方差的计算公式，可以得到协方差矩阵  再将协方差矩阵  对角化为 ，得到由 个特征向量组成的特征矩阵。 个特征向量表示 OBB 包围盒的方向。\n","categories":["图形学"],"tags":["Graphics"]},{"title":"Lua GC 机制","url":"/2021/11/22/92307bbcfe44/","content":"垃圾回收  采用了自动内存管理。 这意味着你不用操心新创建的对象需要的内存如何分配出来， 也不用考虑在对象不再被使用后怎样释放它们所占用的内存。\nLua 运行了一个垃圾收集器来收集所有死对象 （即在 Lua 中不可能再访问到的对象）来完成自动内存管理的工作。 Lua 中所有用到的内存，如：字符串、表、用户数据、函数、线程、 内部结构等，都服从自动管理。\n垃圾回收器函数-- collectgarbage(&quot;collect&quot;): 做一次完整的垃圾收集循环。通过参数 opt 它提供了一组不同的功能-- collectgarbage(&quot;count&quot;): 以 K 字节数为单位返回 Lua 使用的总内存数。 这个值有小数部分，所以只需要乘上 1024 就能得到 Lua 使用的准确字节数（除非溢出）。-- collectgarbage(&quot;restart&quot;): 重启垃圾收集器的自动运行。-- collectgarbage(&quot;setpause&quot;): 将 arg 设为收集器的 间歇率。 返回 间歇率 的前一个值。-- collectgarbage(&quot;setstepmul&quot;): 返回 步进倍率 的前一个值。-- collectgarbage(&quot;step&quot;): 单步运行垃圾收集器。 步长 &quot; 大小 &quot; 由 arg 控制。 传入 0 时，收集器步进（不可分割的）一步。 传入非 0 值， 收集器收集相当于 Lua 分配这些多（K 字节）内存的工作。 如果收集器结束一个循环将返回 true 。-- collectgarbage(&quot;stop&quot;): 停止垃圾收集器的运行。 在调用重启前，收集器只会因显式的调用运行。test = &#123;&quot;W&quot;,&quot;L&quot;,&quot;Q&quot;&#125;print(collectgarbage(&quot;count&quot;))test = nilprint(collectgarbage(&quot;count&quot;))print(collectgarbage(&quot;collect&quot;))print(collectgarbage(&quot;count&quot;))\n\ngc 算法分析 Lua gc 采用的是 标记 - 清除  算法，即一次 gc 分两步：\n\n在标记阶段，从根集对象开始标记，把整个对象层级都标记完，这些被标记到的对象称为可达到的对象。\n在清除阶段，遍历上面提到的对象链表，如果对象被标记过则擦除标记并跳过，如果对象没有被标记说明他不可达到，那就把它释放掉。\n\nlua5.1 开始采用了一种三色回收的算法\n\n白色：表示对象未被标记，在 GC 周期开始之前对象为白色，如果到清除阶段还是白色，那就说明该对象不可到达，要被清除掉。\n灰色：表示对象本身已标记，但它引用的对象未被标记，比如一个表已被标记，它的键值对象还未被标记。这表示对象标记的一个中间状态。\n黑色：表示对象和它引用的对象都已被标记，在清除阶段黑色对象为可到达对象。\n\n对象链表 global_State 有好多和 GC 相关的字段，其中有一些重要链表。所有 GC 对象总是在下面的链表中：\n\nallgc：所有未被标记为终结的对象\nfinobj：所有标记为终结的对象\ntobefnz：所有准备终结的对象（准备调用 __gc 的对象）\nfixedgc：不会被回收的对象\n\n正常情况下，新建对象都会进入 allgc 链表。\n如果对象设置一个元表，且元表有 __gc 元方法，那么它会从 allgc 取出，加入到 finobj 去，并设置对象的 FINALIZEDBIT 标记为。\n在标记阶段，finobj中的白对象会移到 tobefnz 链表去，然后标记这些对象，这样当前周期不会释放这些对象；清除完之后会进入 GCScallfin 阶段，在这里调用 tobefnz 对象的 gc 方法，同时把对象移回 allgc 链表；如果 gc 中使对象重新变成可到达，则对象复活过来；否则下个周期这个对象就会被正常清除。\nfixedgc是那些不会被回收的对象，在新建完对象后，必须马上调用 luaC_fic 把对象从 allgc 移到 fixedgc 去。GC 的过程不会对 fixedgc 进行清除。\n\nluajit 使用状态机来执行 gc 算法，共有 6 中状态：\n\nGCSpause： gc 开始阶段，初始化一些属性，将一些跟节点（主线程对象，主线程环境对象，全局对象等）push 到灰色链表中\nGCSpropagate： 分步进行扫描，每次从灰色链表 pop 一个对象，遍历该对象的子对象，例如如果该对象为 table，并且 value 没有设置为 week，则会遍历 table 所有 table 可达的 value，如果 value 为 gc 对象且为白色，则会被 push 到灰色链表中，这一步将一直持续到灰色链表为空的时候\nGCSatomic： 原子操作，因为 GCSpropagate 是分步的，所以分步过程中可能会有新的对象创建，这时候将再进行一次补充遍历，这遍历是不能被打断的，但因为绝大部分工作被 GCSpropagate 做了，所以过程会很快。新创建的没有被引用的 userdata，如果该userdata 自定义了 gc 元方法，则会加入到全局的 userdata 链表中，该链表会在最后一步 GCSfinalize 处理\nGCSsweepstring： 遍历全局字符串 hash 表，每次遍历一个 hash 节点，如果 hash 冲突严重，会在这里影响 gc。如果字符串为白色并且没有被设置为固定不释放，则进行释放\nGCSsweep： 遍历所有全局 gc 对象，每次遍历 40 个，如果 gc 对象为白色，将被释放\nGCSfinalize： 遍历 GCSatomic 生成的 userdata 链表，如果该 userdata 还存在 gc 元方法，调用该元方法，每次处理一个\n\n什么时候会导致 gcglobal_state有两个字段是关于 Lua 的内存统计的：\nl_mem totalbytes;l_mem GCdebt;\n\n在 lua_newstate 函数里，这两个字段初始为：\ng-&gt;totalbytes = sizeof(LG);g-&gt;GCdebt = 0;\n\n在内存分配函数 luaM_realloc_ 里，会根据分配或释放内存调整 GCdebt 的值：\nvoid *luaM_realloc_(lua_State* L, void* block, size_t osize, size_t, nsize) &#123;    ...    g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;    ...&#125;\n\n判断是否触发 GC 的宏是：\n#define lauC_condGC(L, pre, pos) \\    &#123; if (G(L)-&gt;GCdebt &gt; 0) &#123; pre; luaC_step(L); pos; &#125;; \\        condchangemem(L, pre, pos); &#125;\n\ng-&gt;GCdebt如果大于 0，就执行一次luaC_step。\n回收控制 luaC_step 执行一步 GC：\nvoid luaC_step(lua_State* L) &#123;    global_State* g = G(L);    // 1. 计算 GC 的内存债务    l_mem debt = getdebt(g);    ...    // 2. 循环执行 singlestep，知道 GC 周期完毕，或 debt 小于某个值    do &#123;        lu_mem work = singlestep(L);        debt -= work;    &#125; while (debt &gt; -GCSTEPSIZE &amp;&amp; g-&gt;gcstate != GCSpause);        // 3. 如果 GC 结束，计算下一个阈值    if (g-&gt;gcstate == GCSpause)        setpause(g);    else &#123;    // 4. 否则计算下一次触发的时机        debt = (debt / g-&gt;gcstepmul) * STEPMULADJ;        luaE_setdebt(g, debt);        runafewinalizers(L);    &#125;&#125;\n\n\nGC 的过程Lua 会自动管理内存，它通过垃圾收集器回收掉不再使用的对象，所谓不再使用，可以简单理解为没有其他对象引用的对象。\nLua 使用简单的标记和清除的垃圾回收容器，每次完整的 GC 分为 4 个阶段：\n\n标记（mark）：Lua 将根集对象标记为活的，根集对象实际上就是 C 注册表，像主线程和全局环境都是注册表的预定义项。从根集对象一直往下标记，任何存在于活对象中的对象，只要程序可达（弱表除外），也会被标记为活的。\n清理（cleaning）：这一阶段，Lua 遍历那些未标记的对象，如果它们有终结函数，将它们移出到另一个列表中，后面第 4 个阶段会用到。接着遍历 Lua 弱表，把其中 key 或 value 未被标记的对象从弱表移除。\n清除（sweep）：Lua 遍历所有对象，如表未被标记则回收掉，如果有标记则清除标记。\n终结（finalization）：在清理阶段将有终结函数，且未被标记的对象都移到一个独立的列表中，这阶段就是遍历这个列表，并调用它们的终结函数。而这些未活的对象，实际上应该会在下一个 GC 周期才被回收掉。\n\n在 Lua5.1 以上的版本，GC 被优化成增量式的，它和解释器交错运行，即每一个 GC 只执行一部分，这样就有效避免 GC 的时候解释器停顿太久。\n弱表  下面的例子能说明弱表的行为：\na = &#123;&#125;mt = &#123;__mode = &#x27;k&#x27;&#125; -- 设置为 k 表示 a 的 key 是弱引用；设置为 v 表示 value 是弱引用；设置为 kv 表示 key 和 value 都是弱引用setmetatable(a, mt)k1 = &#123;&#125;a[k1] = 1k2 = &#123;&#125;a[k2] = 2k1 = nil -- 将 k1 删除，k1 引用的那个表只存在于 a，但 a 是 key 的弱引用，所以这个表被 GCcollectgarbage()for k, v in pairs(a) do print(v) end-- &gt; 2\n\n终结函数  就是元表有指定 __gc 元方法，如：\no = &#123;x = &#x27;hi&#x27;&#125;setmetatable(o, &#123;__gc = function(o) print(o.x) end&#125;)o = nilcollectgarbage() -- &gt; hi\n\n如果一个对象（有终结函数）在程序结束的时候还未被回收，Lua 会在结束的时候调用该对象的终结函数，可以利用这个特性来监控程序结束。\n","categories":["Lua"],"tags":["lua"]},{"title":"红黑树","url":"/2021/11/22/7ac3af061ccd/","content":"红黑树  虽然平衡树解决了二叉查找树退化为近似链表的缺点，不过不是最佳方案。因为平衡树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在是太严了，导致每次进行插入 / 删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树。 #f8dcf8\n红黑树的性质\n每个节点要么是黑色，要么是红色\n根节点是黑色\n每个叶子节点（NIL）是黑色\n每个红色节点的两个子节点一定都是黑色，不能有两个红色结点相连\n任意一结点到每个叶子节点的路径都包含数量相同的黑节点\n\n\n红黑树的数据结构enum Color{    RED = 0,    BLACK = 1};struct RBTreeNode{    RBTreeNode * parent;    RBTreeNode * left;    RBTreeNode * right;    int key;    int data;    Color color;}\n\n红黑树的时间复杂度  红黑树时间复杂度显然不会为最糟糕的，其操作时间复杂度最糟糕是，这是因为它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡。对于红黑树，插入，删除，查找的平均复杂度都是，且不会随着节点数的增加而恶化。能保证在最坏情况下，基本的动态几何操作的时间均为。\n红黑树保持平衡的三种操作\n左旋：以某个节点作为指点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为选装节点的右子节点，左子节点保持不变。\n右旋：以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变。\n变色：节点的颜色由红变黑或由黑边红。\n\n左旋\n右旋\n","categories":["数据结构"],"tags":["数据结构","红黑树"]},{"title":"Vulkan Note","url":"/2021/11/22/e3962b6a90fd/","content":"Vulkan 的优势 \n\n 显式的 GPU 控制 \nVulkan 把 API 验证、内存管理、多线程管理等工作交由开发者负责。一旦 API 使用出错，应用就会出现 crash\n\nCPU 多线程的效率提升 \nVulkan 中引入了 Command Buffer 的概念，每个线程都可以往 Command Buffer 提交渲染命令，给开发者提供了充分发挥 CPU 多核多线程的优势。在复杂场景下，性能的提升非常客观 \n\n 可移植性 \n\nVulkan 和 OpenGL 性能对比 \n\n\n\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n","categories":["游戏开发"],"tags":["Vulkan","API"]},{"title":"Latex 公式","url":"/2021/11/22/fb3d063fd7fd/","content":"\n    \n\n\n# 希腊字母# 操作符# 关系运算符# 箭头# 重音符号# 数学公式# 括号# 方程组# 矩阵\n\n\n希腊字母\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\alpha\n\n\\theta\n\no\n\n\\upsilon\n\n\n\n\\beta\n\n$\\vartheta\n\n\\pi\n\n\\phi\n\n\n\n\\gamma\n\n\\iota\n\n\\varpi\n\n\\varphi\n\n\n\n\\delta\n\n\\kappa\n\n\\rho\n\n\\chi\n\n\n\n\\epsilon\n\n\\lambda\n\n\\varrho\n\n\\psi\n\n\n\n\\varepsilon\n\n\\mu\n\n\\sigma\n\n\\omega\n\n\n\n\\zeta\n\n\\nu\n\n\\varsigma\n\n\n\n\n\n\\eta\n\n\\xi\n\n\\tau\n\n\n\n\n\n\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\Ggamma\n\n\\lambda\n\n\\Sigma\n\n\\Psi\n\n\n\n\\Delta\n\n\\Xi\n\n\\Upsilon\n\n\\Omega\n\n\n\n\\Theta\n\n\\Pi\n\n\\Phi\n\n\n\n\n二元操作符\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\pm\n\n\\cap\n\n\\diamond\n\n\\oplus\n\n\n\n\\mp\n\n$\\cup\n\n\\bigtriangleup\n\n\\ominus\n\n\n\n\\times\n\n\\uplus\n\n\\bigtriangledown\n\n\\otimes\n\n\n\n\\div\n\n\\sqcap\n\n\\triangleleft\n\n\\oslash\n\n\n\n\\ast\n\n\\sqcup\n\n\\triangleleft\n\n\\odot\n\n\n\n\\star\n\n\\vee\n\n\\lhd\n\n\\bigcirc\n\n\n\n\\circ\n\n\\wedge\n\n\\rhd\n\n\\dagger\n\n\n\n\\bullet\n\n\\setminus\n\n\\unlhd\n\n\\ddagger\n\n\n\n\\cdot\n\n\\wr\n\n\\unrhd\n\n\\amalg\n\n\n\n+\n\n-\n\n\n\n\n\n\n关系运算符\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\leq\n\n\\geq\n\n\\equiv\n\n\\models\n\n\n\n\\prec\n\n\\succ\n\n\\sim\n\n\\perp\n\n\n\n\\preceq\n\n\\succeq\n\n\\simeq\n\n\\mid\n\n\n\n\\ll\n\n\\gg\n\n\\asymp\n\n\\parallel\n\n\n\n\\subset\n\n\\supset\n\n\\approx\n\n\\bowtie\n\n\n\n\\subseteq\n\n\\supseteq\n\n\\cong\n\n\\Join\n\n\n\n\\sqsubsete\n\n\\sqsupset\n\n\\neq\n\n\\smile\n\n\n\n\\sqsubseteq\n\n\\sqsupseteq\n\n\\doteq\n\n\\frown\n\n\n\n\\in\n\n\\ni\n\n\\propto\n\n=\n\n\n\n\\vdash\n\n\\dashv\n\n&lt;\n\n&gt;\n\n\n\n:\n\n\n\n\n\n\n\n\n标点符号\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n,\n\n;\n\n\\colon\n\n\\ldotp\n\n\\cdotp\n\n\n箭头\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\leftarrow\n\n\\longleftarrow\n\n\\uparrow\n\n\n\n\\Leftarrow\n\n$\\Longleftarrow\n\n\\Uparrow\n\n\n\n\\rightarrow\n\n\\longrightarrow\n\n\\downarrow\n\n\n\n\\Rightarrow\n\n\\Longrightarrow\n\n\\Downarrow\n\n\n\n\\leftrightarrow\n\n\\longleftrightarrow\n\n\\updownarrow\n\n\n\n\\Leftrightarrow\n\n\\Longleftrightarrow\n\n\\Updownarrow\n\n\n\n\\mapsto\n\n\\longmapsto\n\n\\nearrow\n\n\n\n\\hookleftarrow\n\n\\hookrightarrow\n\n\\searrow\n\n\n\n\\leftharpoonup\n\n\\rightharpoonup\n\n\\swarrow\n\n\n\n\\leftharpoondown\n\n\\rightharpoondown\n\n\\nwarrow\n\n\n\n\\rightleftharpoons\n\n\\leadsto\n\n\n\n\n其他符号\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\ldots\n\n\\cdots\n\n\\vdots\n\n\\ddots\n\n\n\n\\aleph\n\n$\\prime\n\n\\forall\n\n\\infty\n\n\n\n\\hbar\n\n\\emptyset\n\n\\exists\n\n\\Box\n\n\n\n\\imath\n\n\\nabla\n\n\\neg\n\n\\Diamond\n\n\n\n\\jmath\n\n\\supset\n\n\\flat\n\n\\triangle\n\n\n\n\\ell\n\n\\top\n\n\\natural\n\n\\clubsuit\n\n\n\n\\wp\n\n\\bot\n\n\\sharp\n\n\\diamondsuit\n\n\n\n\\Re\n\n|\n\n\\backslash\n\n\\heartsuit\n\n\n\n\\Im\n\n\\angle\n\n\\partial\n\n\\spadesuit\n\n\n\n\\mho\n\n.\n\n\n\n\n\n\n大小可变符号\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\sum\n\n\\bigcap\n\n\\bigodot\n\n\n\n\\prod\n\n$\\bigcup\n\n\\bigotimes\n\n\n\n\\coprod\n\n\\bigsqcup\n\n\\bigoplus\n\n\n\n\\int\n\n\\bigvee\n\n\\biguplus\n\n\n\n\\oint\n\n\\bigwedge\n\n\n\n\n分隔符\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n(\n\n)\n\n\\uparrow\n\n\\Uparrow\n\n\n\n[\n\n]\n\n\\downarrow\n\n\\Downarrow\n\n\n\n\\{\n\n\\}\n\n\\updownarrow\n\n\\Updownarrow\n\n\n\n\\lfloor\n\n\\rfloor\n\n\\lceil\n\n\\rceil\n\n\n\n\\langle\n\n\\rangle\n\n\\arrowvert\n\n\\Arrowvert\n\n\n\n\\rmoustache\n\n\\lmoustache\n\n\\rgroup\n\n\\lgroup\n\n\n⎪\n\\bracevert\n\n\n\n\n\n\n\n\n重音符号\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\hat{a}\n\n\\acute{a}\n\n\\bar{a}\n\n\\dot{a}\n\n\n\n\\check{a}\n\n\\grave{a}\n\n\\vec{a}\n\n\\ddot{a}\n\n\n\n\\breve{a}\n\n\\tilde{a}\n\n\n\n\n\n\n数学公式  常用公式\n\n\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\sqrt[5]{ab}\n\n\\sideset{^1_2}{^3_4}\\otimes\n\n\n\n\\${}^{12}_{\\phantom{1}6}\\textrm{C}\n\n1+\\frac{a}{\\frac{b}{c} + 1}\n\n\n\n1+\\cfrac{a}{\\cfrac{b}{c} + 1}\n\n1+\\frac{a}{\\dfrac{b}{c} + 1}\n\n\n\n1+\\frac{a}{\\tfrac{b}{c} + 1}\n\n\\binom{a}{b^2}\n\n\n\n\\dbinom{a}{b^2}\n\n\\tbinom{a}{b^2}\n\n\n\n\\stackrel{a}{b}\n\n{a \\atop b+c}\n\n\n\n{a \\choose b+c}\n\n\n\n\n\n\\sum_{i=1}^{n} c_i\n\n\\sum\\nolimits_{i=1}^{n} c_i\n\n\n\n\\prod_{i=1}^{n} c_i\n\n\\prod\\nolimits_{i=1}^{n} c_i\n\n\n\n\\lim_{i=1}^{n} c_i\n\n\\lim\\nolimits_{i=1}^{n} c_i\n\n\n\n\\int_{i=1}^{n} c_i\n\n\\int\\nolimits_{i=1}^{n} c_i\n\n\n\n\\iint\n\niiint\n\n\n\n\\iiiint\n\n\\idotsint\n\n\n\n\\overrightarrow{x + y}\n\n\\overline{a + b}\n\n\n\n\\overbrace{a \\dots a}^{n}\n\n\\underbrace{a \\dots a}^{n}\n\n\n\n\\widetilde{xyz}\n\n\\widehat{xyz}\n\n\n括号\n\\Bigg(\\bigg( \\Big( \\big( (x) \\big) \\Big) \\bigg) \\Bigg)\n\n\n\\Bigg\\{ \\bigg\\{ \\Big\\{ \\big\\{ \\{x\\} \\big\\} \\Big\\} \\bigg\\} \\Bigg\\}\n\n方程组\naligned\n\n\n\\begin{aligned}f(x) &amp;= \\cos x \\\\f\\prime(x) &amp;= -\\sin x \\\\\\int_{0}^{x} f(y)dy &amp;= \\sin x\\end{aligned}\n\n\narray\n\n\n\\left\\{  \\begin{array}{c}  a_{0}+a_{1}x_{0}+...+a_{n}x_{0}^{n}=y_{0} \\\\  a_{0}+a_{1}x_{1}+...+a_{n}x_{1}^{n}=y_{1} \\\\  \\vdots\\\\  a_{0}+a_{1}x_{n}+...+a_{n}x_{n}^{n}=y_{n}   \\end{array}\\right.\n\n\ncases\n\n\n\\begin{cases}3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\tag{1}\\end{cases}\n\n矩阵\nmatrix、pmatrix、bmatrix、Bmatrix、vmatrix、Vmatrix\n\n\n\\begin{gathered}\\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{matrix}\\quad\\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}\\quad\\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; 0 \\end{bmatrix}\\quad\\begin{Bmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{Bmatrix}\\quad\\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix}\\quad\\begin{Vmatrix} i &amp; 0 \\\\ 0 &amp; -i \\end{Vmatrix}\\end{gathered}\n\n\narray\n\n\n\\left(% 左括号  \\begin{array}{ccc}   % 该矩阵一共 3 列，每一列都居中放置    a11 &amp; a12 &amp; a13\\\\  % 第一行元素    a21 &amp; a22 &amp; a23\\\\  % 第二行元素  \\end{array}\\right)                 % 右括号\n","categories":["Latex"],"tags":["符号","公式"]},{"title":"OpenGL 基础","url":"/2021/11/04/2086c49205f7/","content":"OpenGL 上下文（Context）帧缓冲区 (FrameBuffer）\n所有的运算结果最终都是需要通过图像进行输出的\n帧缓冲区  就是 OpenGL 中的画板\n帧缓冲区  并不是实际存储数据的对象\n实际存储数据的 Attachment 所指向的对应缓冲区\n\nAttachment帧缓冲区中有三种 Attachment，Color Attachment，Depth Attachment，Stencil Attachment。这三种Attachment 对应的缓冲区分别是颜色缓冲区（Color Buffer），深度缓冲区（Depth Buffer），模板缓冲区（Stencil Buffer）。\n纹理（Texture）和渲染缓冲区（Render Buffer）\n纹理和渲染缓冲区都是存储图像的对象\n渲染缓冲区对应操作系统提供的窗口，而纹理代表离屏的图像存储区域\n渲染缓冲区都是 2D 的图像类型\n纹理一般有立方体纹理，1D、2D、3D 纹理等类型\n渲染缓冲区和纹理不能同时挂载在同一个帧缓冲区上\n\n顶点数组（Vertex Array）和顶点缓冲区（Vertex Buffer）OpenGL 中的图像都是由图元组成的，由三种类型的图元：点、线、三角形。\n\n顶点数据以数组的形式存储在内存当中称为  顶点数组\n顶点数据存在显存当中称为  顶点缓冲区\n\n索引数组（Element Array）和索引缓冲区（Element Buffer）\n索引数据的目的主要是为了实现顶点的复用，通过索引数据指示 OpenGL 绘制顶点的顺序，能防止顶点的重复运算\n索引数据以数组的形式存在内存当中成为  索引数组\n索引数据存在显存当中称为  索引缓冲区\nOpenGL 提供了 2 中主要的绘制方法：glDrawArray和glDrawElements，前者对应的时没有索引数据的情况，后者对应的时由索引数据的情况\n\n顶点着色器（Vertex Shader）\n顶点着色其时 OpenGL 中用于计算顶点属性的程序。每个顶点数据都会执行一次顶点着色器（并行的），并且顶点着色器运算过程中无法访问其他顶点的数据\n顶点着色器的数据输入主要有两种：\n统一变量（Uniform）：在所有顶点运算中是一样的\n顶点属性（Vertex Attribute）：从外部输入的顶点数据中获取，一般在每个顶点运算中不同\n\n\n典型的需要计算的顶点属性主要包括顶点坐标变换、逐顶点光照运算等等\n顶点着色器的输出结果也会作为片段着色器的输入\n\n片段着色器（Fragment Shader）\n片段着色器是 OpenGL 中用于计算片段（像素）颜色的程序。每个像素都会执行一次片段着色器。\n片段着色器有三种：\n统一变量（Uniform）：在同一个 OpenGL 着色器程序中顶点着色器和片段着色器是一致的\n顶点着色器输入变量（Varying）：在每个像素运算中一般是不同的，它的值由组成图元顶点的顶点着色器运算输出的值，根据像素位置进行插值的结果而决定\n采样器（Sampler）：从设定好的纹理中获取纹理的像素颜色\n\n\n\n逐片元操作（Per-Fragment Operation）测试（Test）\n测试主要可以分为像素所有者测试（PixelOwnership Test）、裁剪测试（Scissor Test）、模板测试（Stencil Test）和深度测试（Depth Test）\n模板测试：通过模板测试决定最终的像素是否丢弃，根据 OpenGL 的模板覆写状态决定是否更新像素的模板值\n深度测试：主要通过对像素的运算出来的深度进行对比，根据 OpenGL 设定好的深度测试程序，决定是否最终渲染到画布上。\n\n混合（Blending）在混合阶段，像素的颜色和帧缓冲区中颜色 Attachment 上的颜色进行混合，混合的算法可以通过 OpenGL 的函数进行指定。但是 OpenGL 提供的混合算法是有限的，如果需要更加复杂的混合算法，一般可以通过像素着色器进行实现，当然性能回避原生的混合算法差一些\n抖动（Dithering）抖动是一种针对于可用颜色较少的系统，可以以牺牲分辨率为代价，通过颜色值的抖动来增加可用颜色数量的技术\n渲染到纹理  有些 OpenGL 程序并不希望渲染出来的图像立即显示在屏幕上，而是需要多次渲染。可能其中一次渲染的结果是下次渲染的输入。因此，如果帧缓冲区的颜色 Attachment 设置为一张纹理，那么渲染完成之后，可以重新构造新的缓冲区，并将上次渲染出来的纹理作为输入，重新进行前面所述的流程\n渲染上屏 / 交换缓冲区（Swap Buffer）\n渲染缓冲区一般映射的系统资源比如窗口，如果每个窗口只有一个缓冲区，那么在绘制过程中屏幕进行了刷新，窗口可能显示出不完整的图像\n常规的 OpenGL 程序至少都会由两个缓冲区。显示在屏幕上的称为屏幕缓冲区，没有显示的称为离屏缓冲区\n垂直同步：由于显示器刷新一般是逐行进行的，因此为了防止交换缓冲区的时候屏幕上下区域的图像分属两个不同的帧，因此交换一般会等待显示器刷新完成的信号，在显示器两次刷新的间隔中进行交换，这个信号就被称为  垂直同步信号 ，这个技术称为 垂直同步\n使用了双缓冲区和垂直同步技术之后，由于总是要等待缓冲区交换之后在进行下一帧的渲染，使得帧率无法达到硬件允许的最高水平。为了解决这个问题，引入了三缓冲区技术，在等待垂直同步时，来回交替渲染两个离屏的缓冲区，而垂直同步发生时，屏幕缓冲区和最近渲染完成的离屏缓冲区交换，实现充分利用硬件性能的目的\n\n","categories":["Learning OpenGL"],"tags":["Graphics","OpenGL"]},{"title":"Bézier Curve","url":"/2021/11/22/33f4952af08e/","content":"de Castekjau Algorithm\n    \n\n\n如图所示，对于 3 阶的 Bézier 曲线在  时刻需要寻找 3 次插值点：第一次为 ， 和；第二次为  和；第三次为，即曲线上的点。对应的伪代码如下：\nrecursive（插值点 / 控制点 (points)，时刻 (t))：    // 递归终止条件    只有一个插值点：        return 该插值点；    // 进行递归    根据 插值点 / 控制点 (points) 计算下一次的 插值点 / 控制点 (_points);    return recursive（插值点 / 控制点 (_points), 时刻 (t));\n\n相关代码cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, float t){    // TODO: Implement de Casteljau's algorithm    if (control_points.size() == 1)        return control_points[0];    else    {        std::vector&lt;cv::Point2f&gt; points;        for (auto i = 0; i &lt; control_points.size() - 1; i += 1)        {            auto &amp;p0 = control_points[i];            auto &amp;p1 = control_points[i + 1];            points.emplace_back((1 - t) * p0 + t * p1);        }        return recursive_bezier(points, t);    }}\n\nvoid bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, cv::Mat&amp; window){    // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's     // recursive Bezier algorithm.    for (double t = 0.0; t &lt;= 1.0; t += 0.001)    {        auto point = recursive_bezier(control_points, t);        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[2] = 255;    }}\n\n结果\n    \n\n","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"Whitted Style Ray Tracing","url":"/2021/11/22/7bf3e947a32c/","content":"\n从 main 函数开始，定义场景的参数，添加物体（球体或三角形）到场景中，并设置其材质，然后将光源添加到场景中\n调用 Render 函数。在遍历所有像素的循环里，生成对应的光线并将返回的颜色保存在  帧缓冲区  中。在渲染过程结束后，帧缓冲区中的信息将被保存为图像\n在生成像素对应的光线后，调用 CastRay 函数，该函数调用 trace 来查询光线与场景中最近的对象的交点\n\n\n\n从摄像机位置向屏幕像素点发射光线 Render 函数需要为每一个像素生成一条对应的光线，然后调用函数 castRay 来得到颜色，最后将颜色存储在帧缓冲区的相应像素中。 就是为屏幕上的每一个点生成一条由  视点  到屏幕上的点的方向向量，将屏幕上的点与近平面上的点一一对应即可：计算出像素点在近平面坐标系上的位置 ；将 分别乘以近平面在  和方向上的实际长度\n\n    \n\n\n如图，对于屏幕上的一个点 ，如果屏幕长、宽分别占、 个像素，可以计算出它在近平面坐标系上的坐标为：\n\n代码遍历是从 0 开始，需要加上 0.5 使其移动到像素中心，再进行坐标变换\n\n由透视变换中的公式可得\nvoid Renderer::Render(const Scene&amp; scene){    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);    float scale = std::tan(deg2rad(scene.fov * 0.5f));    float imageAspectRatio = scene.width / (float)scene.height;    // Use this variable as the eye position to start your rays.    Vector3f eye_pos(0);    int m = 0;    for (int j = 0; j &lt; scene.height; ++j)    {        for (int i = 0; i &lt; scene.width; ++i)        {            // generate primary ray direction            float x;            float y;            // TODO: Find the x and y positions of the current pixel to get the direction            // vector that passes through it.            // Also, don't forget to multiply both of them with the variable *scale*, and            // x (horizontal) variable with the *imageAspectRatio*                    x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale;            y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;            Vector3f dir = Vector3f(x, y, -1) - eye_pos; // Don't forget to normalize this direction!            dir = normalize(dir);            framebuffer[m++] = castRay(eye_pos, dir, scene, 0);        }        //UpdateProgress(j / (float)scene.height);    }    // save framebuffer to file    FILE* fp = fopen(\"binary.ppm\", \"wb\");    (void)fprintf(fp, \"P6\\n%d %d\\n255\\n\", scene.width, scene.height);    for (auto i = 0; i &lt; scene.height * scene.width; ++i) {        static unsigned char color[3];        color[0] = (char)(255 * clamp(0, 1, framebuffer[i].x));        color[1] = (char)(255 * clamp(0, 1, framebuffer[i].y));    color[2] = (char)(255 * clamp(0, 1, framebuffer[i].z));    //std::cout &lt;&lt; '(' &lt;&lt; color[0] &lt;&lt; \",\" &lt;&lt; color[1] &lt;&lt; \",\" &lt;&lt; color[2] &lt;&lt; \")\" &lt;&lt; std::endl;        fwrite(color, 1, 3, fp);    }    fclose(fp);    }\n\n是否与三角形相交 v0，v1，v2 是三角形的三个 顶点，orig是光线的起点，dir是光线单位化的方向向量，根据 Moller-Trumbore 算法来求解\n\n其中\n、、是重心坐标\nbool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig,                          const Vector3f&amp; dir, float&amp; tnear, float&amp; u, float&amp; v){    // TODO: Implement this function that tests whether the triangle    // that's specified bt v0, v1 and v2 intersects with the ray (whose    // origin is *orig* and direction is *dir*)    // Also don't forget to update tnear, u and v.    auto e1 = v1 - v0;    auto e2 = v2 - v0;    auto s = orig - v0;    auto s1 = crossProduct(dir, e2);    auto s2 = crossProduct(s, e1);    auto coeff = 1 / dotProduct(s1, e1);    auto t = coeff * dotProduct(s2, e2);    auto b1 = coeff * dotProduct(s1, s);    auto b2 = coeff * dotProduct(s2, dir);    if (t &gt;= 0 &amp;&amp; b1 &gt;= 0 &amp;&amp; b2 &gt;= 0 &amp;&amp; (1 - b1 - b2) &gt;= 0)    {        tnear = t;        u = b1;        v = b2;        return true;    }    return false;}\n\n最终结果\n    \n\n","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"时域和频域","url":"/2021/11/24/a6c97dfdbbdd/","content":"傅里叶级数  的频谱\n正弦波\n正弦波就是一个圆周运动在一条直线上的投影。所以频域的基本单元也可以理解为一个始终在旋转的圆\n\n\n\n    \n\n如前两幅图所示，随着正弦波数量逐渐的增长，它们最终会叠加成一个标准的矩形。如果换一个角度来看，便会发现矩形波在频域的样子（即第四幅图）称为频域图像，也成为频谱。完整流程如下：\n\n\n    \n\n\n傅里叶级数  的的相位谱  傅里叶分析的用处  图像处理\n图像增强与图像去噪\n图像分割之边缘检测\n图像特征提取\n图像压缩\n\n工程应用  通过傅里叶变换和反变换，从一个完全杂乱无章的信号里面，可以提取出期望的低频信号，而滤掉了高频信号。\n\n比如，检测到一个信号是这样的\n\n\n可能的曲线方程式为：需要把  从图像中剔除，在时域上很难完成，但是在频域反而很容易\n所以很多在时域看似不可能做到的数学操作，而经过傅里叶变换，在频域相反很容易。尤其是从某条曲线中去除一些特定的频率成分，这在工程上称为滤波，是信号处理最重要的概念之一，只有在频域才能轻松的做到。\n\n求解微分方程  求解微分方程是一件相当麻烦的事情。因为除了要计算加减乘除，还要计算微分积分。而傅里叶变换则可以让微分和积分在频域中变为乘法和除法\n相位谱\n    \n\n\n通过时域到频域的变换，得到了一个从侧面看的频谱，但是这个频谱并没有包含时域中全部的信息。因为频谱只代表每一个对应的正弦波的振幅是多少，而没有提到相位。首先先明确  相位  的含义，在信号与系统中，相位  代表的是正弦量的幅角，这里为初相角（三角函数  中为相位，为初相）。而  相位谱  表示的是  相位  随频率的变化情况，代表每个频率分量在时间原点所具有的  相位。\n\n相位谱的感性理解\n当船在大海中遇到多种波共同作用，由于每一种都可以被分解为多个固定频率波的叠加，故可简化为船只受到多种固定频率波叠加，姑且算做两个吧，如果这两个波的相对相位（若初始相位确定则相对相位也就确定了）不同，那么船的结果就可能完全不同。一维情况时，两个波来自于同一方向，若船恰好处于两个波同相点处，那此时波浪对船的作用最强，可能导致翻船，当然若船处于两个波的反相点处，波浪对船的作用最小，此处安全性最高（以船为分析对象，则对船来说，船的位置处算是零点，此处的相位也就是初相，两个波各自的初相不同时，那么此处综合信号强度不同对船的作用效果不同）[2]。\n\n时间差并不是相位差。如果将全部周期看作  的话，相位差则是时间差在一个周期中所占的比例。将时间差除周期再乘，就得到了相位差。\n\n    \n\n将投影得到的时间差依次除以所在频率的周期，就得到了相位谱。所以，频谱是从侧面看，相位谱是从下面看。\n\n傅里叶变换\n傅里叶变换  是一种线性积分变换，用于信号在时域（或空域）和频域之间的变换，在物理学和工程学中有许多应用。因其基本思想首先由法国学者约瑟夫·傅里叶系统地提出，所以以其名字来命名以示纪念。实际上傅里叶变换就像化学分析，确定物质的基本成分；信号来自自然界，也可对其进行分析，确定其基本成分。\n\n经傅里叶变换生成的函数  称作原函数的  傅里叶变换、亦称频谱。在许多情况下，傅里叶变换是可逆的，即可通过 得到其原函数 。通常情况下， 是实数函数，而   则是复函数，用一个复数来表示振幅和相位。\n“傅里叶变换”一词既指变换操作本身（将函数  进行傅里叶变换），又指该操作所生成的复数函数（  是  的傅里叶变换）。\n\n傅里叶级数 ，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。 傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号。\n\n\n    \n\n\n也可以换一个角度理解：傅里叶变换实际上是对一个周期无限大的函数进行傅里叶变换。\n欧拉公式\n虚数  的意义\n\n\n在数轴上有一个黑色的线段，它的长度是 1。当它乘以 3 的时候，它的长度发生了变化，变成了橙色的线段，而当它乘以 -1 的时候，就变成了红色的线段，或者说线段在数轴上围绕原点旋转了 180°。\n乘 -1 其实就是乘了两次 使线段旋转了 180°，那么乘一次 就是旋转了 90°。\n\n\n实数轴与虚数轴共同构成了一个复数的平面，也称复平面。\n\n有了虚数轴的概念，欧拉公式如下：这个公式关键的作用，是将正弦波统一成了简单的指数形式\n欧拉公式所描绘的，是一个随着时间变化，在复平面上做圆周运动的点，随着时间的改变，在时间轴上就成了一条螺旋线。如果只看它的实数部分，也就是螺旋线在左侧的投影，就是一个最基础的余弦函数。而右侧的投影则是一个正弦函数。\n指数形式的傅里叶变换  有了欧拉公式便知道：正弦波的叠加 ，也可以理解为 螺旋线的叠加  在实数空间的投影。光波  就是螺旋线叠加的形象例子\n\n    \n\n\n但不同的是，傅里叶变换出来的频谱不仅仅是  可见光  这样频率范围有限的叠加，而是频率从 0 到无穷所有频率的组合。\n再次理解正弦波  正弦波可以理解为螺线在实数轴的投影，还可以借助欧拉公式的另一种形式去理解：将俩个式子相加再除 2，可得：可以理解为一条逆时针旋转的螺旋线，那么  可以理解为一条顺时针旋转的螺旋线。而  则是这两条旋转方向不同的螺旋线叠加的一半（因为这两条螺旋线的虚数部分相互抵消掉了）。这里，逆时针旋转的称为正频率，而顺时针旋转的称为负频率。\n图像傅里叶变换和傅里叶逆变换原理及实现  任意信号，包括非周期信号都可以用傅里叶变换转到频域：\n\n连续的：\n\n离散的：\n\n\n对图像进行傅里叶变换的原理如下公式：\n相关代码 [3] 普通图像的傅里叶变换结果  下面的代码显示了如何将输入图像进行傅里叶变换。傅里叶变换的结果是复数数组，展示了如何获取其实部和虚部，并求取其幅度。接下来，由于变换后图像的频谱分布具有中心对称性，将其频谱中心移到了图像的中间并进行显示。\nfrom PIL import Imageimport numpy as npimport matplotlib.pyplot as pltimport cv2from skimage.io import imreadfrom scipy.fftpack import ifftn, fft2, ifft2import matplotlib.pyplot as pltimport matplotlib.cm as cmimport cmathimport warnings%matplotlib inlinewarnings.filterwarnings(action='ignore')\n\ndef fliproi(img,ranges):    roi=img[ranges[0]:ranges[1], ranges[2]:ranges[3]]    roi=np.flip(roi,1)    roi=np.flip(roi,0)    img[ranges[0]:ranges[1], ranges[2]:ranges[3]]=roi        img=cv2.imread('./imgs/lena.png', cv2.IMREAD_GRAYSCALE)def getShiftedFreqSpectrum(img):    fimg=fft2(img, shape=img.shape, axes=tuple((0, 1)))    fimgamp=np.abs(fimg)    fimgphase=np.angle(fimg)    roilen=img.shape[0]//2    for y in [0,1]:        for x in [0, 1]:            ranges=[y*roilen, (y+1)*roilen,x*roilen,(x+1)*roilen]            fliproi(fimgamp,ranges)            fliproi(fimgphase,ranges)    return fimg, fimgamp, fimgphasedef getFreqSpectrum(img):    fimg=fft2(img, shape=img.shape, axes=tuple((0, 1)))    fimgamp=np.abs(fimg)    fimgphase=np.angle(fimg)    return fimg, fimgamp, fimgphasefimg,fimgamp, fimgphase=getShiftedFreqSpectrum(img)\n\nplt.figure(figsize=(20,20))plt.subplot(1,3,1)plt.imshow(img, cmap=\"gray\")plt.title(\"Orignal Image\")plt.subplot(1,3,2)plt.imshow(np.log(fimgamp), cmap=\"gray\")plt.title(\"Frequency Spectrum Amplification (Zero centered)\")plt.subplot(1,3,3)plt.imshow(np.abs(fimgphase), cmap=\"gray\")plt.title(\"Frequency Spectrum Phase Angle (Zero centered)\")plt.show()\n\n\n    \n\n\n\n[1]  傅里叶分析之掐死教程 [2]   关于傅里叶变换中的相位 [3]   图像的傅里叶变换\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }；\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["知识库"],"tags":["信号","时域","频域"]},{"title":"在 Windows 中将 VSCode 添加至右键菜单","url":"/2021/12/09/c52ade1f71c4/","content":"Windows 上面安装 Visual Studio Code 后，将 Open with Code 添加到鼠标右键菜单里\n\n\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%1\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot;\n\n将以上代码复制到后缀为 .reg 的文件中，双击确定即可。\n","categories":["Tools"],"tags":["vscode","右键菜单","注册表"]},{"title":"峨眉山月半轮秋，影入平羌江水流","url":"/2021/11/25/cca6e9a7207d/","content":" 峨眉山月半轮秋，影入平羌江水流。\n 夜发清溪向三峡，思君不见下渝州。\n——李白 \n\n\n\n\n","categories":["相册"],"tags":["重庆"]},{"title":"Accelerate Ray Tracing","url":"/2021/11/24/3bc605bff2f0/","content":"发射光线和与光线三角形求交  发射光线  与 Whitted Style Ray Tracing 中的 Render 函数相同\nfloat x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale;float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\n光线与三角形相交inline Intersection Triangle::getIntersection(Ray ray){    Intersection inter;    //    // Moller-Trumbore 算法     //    // TODO find ray triangle intersection    if (t_tmp &lt; 0)        return inter;    inter.happened = true;    inter.coords = Vector3f(u * v0 + v * v1 + (1 - u - v) * v2);    inter.normal = ray(t_tmp);    inter.distance = t_tmp;    inter.m = this-&gt;m;    inter.obj = this;    return inter;}\n\n\nhappened：光线是否与三角形相交\n\ncoords：交点坐标\n\nRay重载了 () 运算符\nVector3f operator()(double t) const{    return origin + direction * t;}\n\n\nnormal：三角形的法向量\n\ndistance：时间既是距离，即t_tmp\n\nm：材质\n\nobj：代表三角形本身\n\n\n是否与包围盒相交\n    \n\n\n空间中的射线可以由起点  和时间 ，以及方向 组成：考虑二维平面的情况，即  那么针对  和方向上的射线可以用如下方式描述：\n\n在三维空间中，使得光线经过包围盒的条件是：光线再包围盒上的两个点  和在包围盒延展轴的  插槽  里，即：dirIsNeg表示光线在某个方向上的投影是否为反向（例如当 dirIsNeg[1] == 0 时，表示光传播方向在  轴上是负方向的），此时需要将  和交换\ninline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) const{    // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division    // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic    // TODO test if ray bound intersects    // according to the formula : P(t) = origin + direction * t    float tx_min = (pMin.x - ray.origin.x) * invDir.x;    float tx_max = (pMax.x - ray.origin.x) * invDir.x;    float ty_min = (pMin.y - ray.origin.y) * invDir.y;    float ty_max = (pMax.y - ray.origin.y) * invDir.y;    float tz_min = (pMin.z - ray.origin.z) * invDir.z;    float tz_max = (pMax.z - ray.origin.z) * invDir.z;    if (!dirIsNeg[0])    {        float t = tx_min;        tx_min = tx_max;        tx_max = t;    }    if (!dirIsNeg[1])    {        float t = ty_min;        ty_min = ty_max;        ty_max = t;    }    if (!dirIsNeg[2])    {        float t = tz_min;        tz_min = tz_max;        tz_max = t;    }    float t_enter = std::max(tx_min, std::max(ty_min, tz_min));    float t_exit = std::min(tx_max, std::min(ty_max, tz_max));    if (t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0)    {        return true;    }    return false;}\n\nBVH TraversalBVH 本质上是把场景中的三角形用二叉树状的结构进行表示，中间结点包含这个结点所包含几何体的包围盒以及指向叶子结点的指针，叶子节点包含物体列表和包围盒，当判断光线与物体是否相交时，只需要递归的判断包围盒是否与光线相交即可：\n\n    \n\n\nIntersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const{    // TODO Traverse the BVH to find intersection    Vector3f invDir = Vector3f{1.0f / ray.direction.x, 1.0f / ray.direction.y, 1.0f / ray.direction.z };    std::array&lt;int, 3&gt; dirIsNeg = {ray.direction.x &gt; 0, ray.direction.y &gt; 0, ray.direction.z &gt; 0 };    if (!node-&gt;bounds.IntersectP(ray, invDir, dirIsNeg))    {        return {};    }    if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)    {        return node-&gt;object-&gt;getIntersection(ray);    }    Intersection h1 = getIntersection(node-&gt;left, ray);    Intersection h2 = getIntersection(node-&gt;right, ray);        return h1.distance &lt; h2.distance ? h1 : h2;}\n\n结果\n    \n\n","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"树深时见鹿，溪午不闻钟","url":"/2021/12/07/d8f42f90bc92/","content":"\n","categories":["相册"],"tags":["风景","上海"]},{"title":"Path Tracing","url":"/2021/12/02/cc196c391b1c/","content":"在本次实验中，只需要修改这一个函数：\n\ncastRay(const Ray ray, int depth)in Scene.cpp：在其中实现 Path Tracing 算法\n\n可能用到的函数有：\n\nintersect(const Ray ray)in Scene.cpp：求一条光线与场景的交点\nsampleLight(Intersection pos, float pdf) in Scene.cpp：在场景的所有光源上按面积 统一采样一个点，并计算该采样点的概率密度\nsample(const Vector3f wi, const Vector3f N) in Material.cpp：按照该材质的性质，给定入射方向与法向量，用某种分布采样一个出射方向\npdf(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.cpp：给定一对入射、出射方向与法向量，计算 sample 方法得到该出射方向的概率密度\neval(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.cpp：给定一对入射、出射方向与法向量，计算这种情况下的  值\n\n可能用到的变量有：\n\nRussianRoulette in Scene.cpp： P_RR\n\nPath Tracing 伪代码：\nshade(p, wo)    sampleLight(inter , pdf_light)    Get x, ws, NN, emit from inter    Shoot a ray from p to x    If the ray is not blocked in the middle        L_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws, NN) / |x-p| ^2 / pdf_light    L_indir = 0.0    Test Russian Roulette with probability RussianRoulette    wi = sample(wo, N)    Trace a ray r(p, wi)    If ray r hit a non -emitting object at q        L_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N) / pdf(wo, wi, N) / RussianRoulette        Return L_dir + L_indir\n\n\n\nMonte Carlo Integration概率相关知识  设是一个随机变量，是任意实数，则称  为的累计分布函数（Cumulative Distribution Function，CDF）。如果对于随机变量  的累计分布函数 ，存在非负函数，使对任意实数，有 则称  为连续性随机变量，其中函数  称为  的概率密度函数，简称概率密度（Probability Distribution Function，PDF）。概率密度具有以下几个性质：\n\n\n\n对于任意实数，有\n若  在点  处连续，则有\n\n设连续性随机变量  的概率密度函数为 ，若积分 绝对收敛，则称积分  的值为随机变量  的数学期望，记为 ，简称为期望： 设是一个随机变量，若存  在，则称它的值为  的方差，记为 ，即： 同时  的标准差或均方差为 ，记为，方差表示的是随机变量与其均值的偏移程度，随机变量的方差 可按下列公式计算：\n\n几个定理  切比雪夫  不等式 ：设随机变量 具有数学期望 ，方差，则对于任意正数，不等式 成立。这一不等式称为切比雪夫不等式\n辛钦大数定理 ：设 是相互独立，服从同一分布随机变量序列，且具有数学期望 ，作前 个变量的算术平均 ，则对于任意，有： 伯努利大数定理 ：设 是次独立重复试验中事件 A 发生的次数，是事件 A 在每次试验中发生的概率，则对于任意正数 ，有： 辛钦大数定理解释了：在大量重复试验下，样本的平均值约等式总体的平均值。伯努利大数定理解释了：在大量重复试验下，样本的频率收敛于其概率。\n\n蒙特卡洛法积分  采用蒙特卡洛方法来计算函数积分，一般的定义为：设  是相互独立的样本且服从同一分布，概率密度函数表示为 ，则函数的积分可以表示为： 这就是蒙特卡洛法积分的一般等式\n重要性采样  重要性采样  是已知被积函数的一些分布信息而采用的一种缩减方差的策略，还有别的策略像  俄罗斯轮盘切割 ， 分层采样 ， 拉丁超立方体采样  等，是通过控制采样的策略达到缩减方差的目的\n\n考虑一个简单的例子，设一个函数为\n采用蒙特卡洛法估计它的积分，选择区间  之间的均匀分布作为它的随机数，那么存在绝大部分的采样点在区间  之间，但是它对积分估计的贡献只有 0.01，小部分采样点在区间  之间，它对积分估计的贡献却非常的大，这种现象就会导致误差非常的大，简单提高采样数对估计量收敛的影响较小。那么，如果简单的选择一个采样策略：多采样区间  的样本点，少采样  的样本点，这就违背了蒙特卡洛法的本质，产生的统计结果就没有任何意义。蒙特卡洛法的核心，是根据某一概率分布来随机采样。\nGGX（Trowbridge-Reitz）分布 GGX 即 Trowbridge-Reitz 分布，最初由 Trowbridge 和 Reitz[Trowbridge 1975] 推导出，在 Blinn 1977 年的论文 [Blinn 1977]中也有推荐此分布函数，但一直没有受到图形学界的太多关注。30 多年后，Trowbridge-Reitz 分布被 Walter 等人独立重新发现 [Walter 2007]，并将其命名为 GGX 分布。之后，GGX 分布采用风潮开始在电影[Burley 2012] 和游戏 [Karis 2013]，[Lagarde 2014] 行业中广泛传播，成为了如今游戏行业和电影行业中最常用的法线分布函数。\n\n    \n\n\nGGX 分布的公式为：\nPath TracingA Simple Monte Carlo Solution在直接光照的环境下，渲染下图中一个点\n\n    \n\n\n计算  点的在相机方向上的 radiance 有以下渲染方程  对于  蒙特卡洛 ：， 就是 ， 概率密度函数  可以是 （在半球面上进行均匀采样）。所以 点的 radiance 可以表示为：\nIntroducing Global Illumination\n    \n\n\n可以写出如下伪代码：\nshade(p, wo)    Randomly choose N directions wi~pdf    Lo = 0.0    For each wi        Trace a ray r(p, wi)        If ray r hit the light            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)        Else If ray r hit an object at q            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)    Return Lo\n\nProblem 1: Explosion of #rays as #bounces go up但是光线的数量随着弹射的次数增加，以指数的量级增长 #rays = N#bounces，所以假设每一个着色点只有一条光线，随之而来的就是会存在大量的噪音，通过增加经过每个像素的 paths，再做radiance 的均值便可以减少噪音。\n\n    \n\n\n生成 paths 的伪代码如下：\nray_generation(camPos, pixel)    Uniformly choose N sample positions within the pixel    pixel_radiance = 0.0    For each sample in the pixel        Shoot a ray r(camPos, cam_to_sample)        If ray r hit the scene at p            pixel_radiance += 1 / N * shade(p, sample_to_cam)    Return pixel_radiance\n\nProblem 2: The recursive algorithm will never stop可以通过 Russian Roulette（RR）（即以一个固定的概率 决定  路径追踪  是否可以继续——是否发从相机处射射线），来解决递归算法无法结束的问题。如果采用 RR 的方法需要更改每一次  路径追踪  后radiance的值 ，使得该点radiance 与实际相差不大。将  除以概率 ，即。那么可以求出 的期望，可以证明 RR 的合理性：可以写出如下伪代码：\nshade(p, wo)    Manually specify a probability P_RR    Randomly select ksi in a uniform dist. in [0, 1]    If (ksi &gt; P_RR)        return 0.0        Randomly choose N directions wi~pdf    Lo = 0.0    For each wi        Trace a ray r(p, wi)        If ray r hit the light            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) / P_RR        Else If ray r hit an object at q            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR    Return Lo\n\nSampling the Light\n    \n\n\n光源离物体越远，需要从相机发射的射线越多（在半球上采样次数越多）才能到达光源，这样会造成性能上的问题，可以通过对光源的采样来解决在半球上采样次数越多的问题，即对于直接光照，原来是从  点所在的半球进行采样，变成对  所在的光源平面采样。\n\n    \n\n\n此时  概率密度函数  为（），但之前的渲染方程是对立体角进行积分，现在需要对面积进行积分。由上图和立体角的定义（Projected area on the unit sphere）可得  此时渲染方程也可以写为：现在的渲染迭代流程主要考虑以下两个部分：\n\n光源能够直接到达的点，通过对光源采样后计算 radiance 的（需要判断是否存在遮挡），同时不需要考虑 RR\n递归的间接光照，需要考虑 RR\n\n最终的伪代码如下：\nshade(p, wo)    # Contribution from the light source.    Uniformly sample the light at x’ (pdf_light = 1 / A)    Shoot a ray from p to x’    If the ray is not blocked in the middle        L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^2 / pdf_light            # Contribution from other reflectors.    L_indir = 0.0    Test Russian Roulette with probability P_RR    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)    Trace a ray r(p, wi)    If ray r hit a non-emitting object at q        L_indir = shade(q, -wi) * f_r * cos θ / pdf_hemi / P_RR          Return L_dir + L_indir\n\n相关代码// Implementation of Path TracingVector3f Scene::castRay(const Ray &amp;ray, int depth) const{    // TO DO Implement Path Tracing Algorithm here    Vector3f ldir = {0, 0, 0 };    Vector3f lindir = {0, 0, 0 };    Intersection objectInter = intersect(ray);    if (!objectInter.happened)    {        return {};    }       if (objectInter.m-&gt;hasEmission())    {        return objectInter.m-&gt;getEmission();    }    Intersection lightInter;    float lightPdf = 0.0f;    sampleLight(lightInter, lightPdf);    Vector3f obj2light = lightInter.coords - objectInter.coords;    Vector3f obj2lightdir = obj2light.normalized();    float distancePow2 = obj2light.x * obj2light.x + obj2light.y * obj2light.y + obj2light.z * obj2light.z;    Ray obj2lightray = {objectInter.coords, obj2lightdir};    Intersection t = intersect(obj2lightray);    if (t.distance - obj2light.norm() &gt; -EPSILON)    {        ldir = lightInter.emit * objectInter.m-&gt;eval(ray.direction, obj2lightdir, objectInter.normal) * dotProduct(obj2lightdir, objectInter.normal) * dotProduct(-obj2lightdir, lightInter.normal) / distancePow2 / lightPdf;    }    if (get_random_float() &gt; RussianRoulette)    {        return ldir;    }    Vector3f obj2nextobjdir = objectInter.m-&gt;sample(ray.direction, objectInter.normal).normalized();    Ray obj2nextobjray = {objectInter.coords, obj2nextobjdir};    Intersection nextObjInter = intersect(obj2nextobjray);    if (nextObjInter.happened &amp;&amp; !nextObjInter.m-&gt;hasEmission())    {        float pdf = objectInter.m-&gt;pdf(ray.direction, obj2nextobjdir, objectInter.normal);        lindir = castRay(obj2nextobjray, depth + 1) * objectInter.m-&gt;eval(ray.direction, obj2nextobjdir, objectInter.normal) * dotProduct(obj2nextobjdir, objectInter.normal) / pdf / RussianRoulette;    }    return ldir + lindir;}\n\n相关函数 Scene::sampleLight→MeshTriangle::Sample→BVHAccel::Sample 最终结果是通过遍历 BVH 树到子节点，计算子节点光源 Object 的三角形面积，存在疑问？\nMaterial::sample\n首先在局部坐标系下的半球面上进行采样得到localRay，其中，\n服从上图分布，限制了上半球。\n\n然后通过该点的法向量  将localRay转换成世界坐标系中的向量\n\nCoordinate system from a vector\nWe can use the fact that the cross product gives a vector orthogonal to the two vectors to write a function that takes one vector and returns two new vectors so that the three of them form an orthonormal coordiante system. Specifically, all three of the vectors will be perpendicular to each other. Note that the other two vectors returned are only unique up to a rotation about the given vector. This function assumes that the vector passed in, , has already been normalized. We first construct a perpendicular vector by zeroing one of the two components of the original vector and permuting the remaining two. Inspection of the two cases should make clear that  will be normalized and that the dot product  will be equal to zero. Given these two perpendicular vectors, one more cross product wraps things up to give us the third, which by definition of the cross product will be be perpendicular to the first two[1].\ninline void CoordinateSystem(const Vector &amp;v1, Vector *v2, Vector *v3) {    if (fabsf(v1.x) &gt; fabsf(v1.y)) {        Float invLen = 1.f / sqrtf(v1.x*v1.x + v1.z*v1.z);        *v2 = Vector(-v1.z * invLen, 0.f, v1.x * invLen);    }    else {        Float invLen = 1.f / sqrtf(v1.y*v1.y + v1.z*v1.z);        *v2 = Vector(0.f, v1.z * invLen, -v1.y * invLen);    }    *v3 = Cross(v1, *v2);}\n\n\nScene::intersect通过构建的 BVH 寻找射线与场景中物体的交点\nMaterial::pdf计算交点处的  概率密度函数，在半球内的返回常数0.5f / M_PI\nMaterial::eval计算交点处的漫反射系数，在半球内的返回常数Kd / M_PI\n结果\n    \n\n\n\n[1]  Physically&nbsp;Based&nbsp;Image&nbsp;Synthesis:&nbsp;Design&nbsp;and&nbsp;Implementation&nbsp;of&nbsp;A&nbsp;Rendering&nbsp;Sysytem\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }；\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"万户千门气郁葱，汉家城阙画图中","url":"/2021/12/10/35c495ffaa00/","content":"\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }；\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["相册"],"tags":["北京"]},{"title":"Windows Terminal 配置","url":"/2021/12/14/8e8e60e6e1a7/","content":"\n\n\nAppearance profile settings in Windows Terminaldefaults&quot;defaults&quot;:&#123;    &quot;acrylicOpacity&quot;: 0.1, // 背景透明度 (0-1)    &quot;useAcrylic&quot;: true, // 启用毛玻璃    &quot;backgroundImage&quot;: &quot;C:/Users/xxx/Pictures/ella-baxter-EfmG0wTPyvQ-unsplash.jpg&quot;,    // 背景图片    &quot;backgroundImageOpacity&quot;: 0.9, // 图片透明度（0-1）    &quot;experimental.retroTerminalEffect&quot;: false, // 复古的 CRT 效果    &quot;backgroundImageStretchMode&quot;: &quot;uniformToFill&quot;, // 背景图片填充模式    // &quot;icon&quot;: &quot;ms-appx:///ProfileIcons/&#123;9acb9455-ca41-5af7-950f-6bca1bc9722f&#125;.png&quot;, // 图标    &quot;font&quot;: &#123;      &quot;face&quot;:&quot;MesloLGL NF&quot;, // 字体      &quot;size&quot;: 10, // 文字大小      &quot;weight&quot;: &quot;thin&quot; // 文字宽度，可设置加粗    &#125;,    &quot;colorScheme&quot;: &quot;Solarized Dark&quot;, // 主题名字    &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, // 光标颜色    &quot;cursorShape&quot;: &quot;bar&quot;, // 光标形状    &quot;startingDirectory&quot;: &quot;E://Blog//&quot;, // 起始目录    &quot;antialiasingMode&quot;: &quot;cleartype&quot;, // 消除文字锯齿    &quot;adjustIndistinguishableColors&quot;: true,    // &quot;tabColor&quot;: &quot;#000000&quot;,    &quot;background&quot;: &quot;#000000&quot;&#125;,\n\n安装 Scoop# 允许本地脚本的执行 set-executionpolicy remotesigned -scope currentuser#  安装 ScoopInvoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)# 由于某些原因不能加入主软件源的附加源 scoop bucket add &#x27;extras&#x27; # NF 字体源scoop bucket add &#x27;nerd-fonts&#x27; # Scoop 自动补全源scoop bucket add scoop-completion https://github.com/Moeologist/scoop-completion#  加速下载 scoop install aria2 #  自动补全 scoop install scoop-completion #  常用字体scoop install Firacodescoop install Meslo-NF  # 必须安装scoop install Font-Awesomescoop install Source-Han-Serif-SC\n\n美化 Power Shell# 安装相关模块 Install-Module oh-my-posh -Scope CurrentUserInstall-Module posh-git -Scope CurrentUser -AllowClobberInstall-Module Terminal-Icons -Scope CurrentUser #  如需卸载，命令如下Uninstall-Module -Name oh-my-posh -AllVersions -ForceUninstall-Module -Name posh-git -AllVersions -ForceUninstall-Module -Name Terminal-Icons -AllVersions -Force\n\nThemes设置 Themes# code $PROFILEImport-Module posh-gitImport-Module oh-my-poshSet-PoshPromt jblab2021\n","categories":["Tools"],"tags":["windows","terminal","theme"]},{"title":"日常开发笔记","url":"/2021/11/05/3e236ae5c063/","content":"jupyter notebook 格式化title\n---title: ---\n\nscript\n&lt;script src=\"https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.13.3/jquery-ui.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/bootstrap/5.3.3/js/bootstrap.bundle.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.11.8/umd/popper.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.1.10/require.min.js\"&gt;&lt;/script&gt;\n\nmath\n&lt;script&gt;MathJax = {  tex: {    inlineMath: [['$', '$'], ['\\\\(', '\\\\)']]  }};&lt;/script&gt;&lt;script id=\"MathJax-script\" async  src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js\"&gt;&lt;/script&gt;\n\nGit 相关\n相关命令\n分支\n\ngit 回退本地修改\ngit checkout &lt;filename&gt;git checkout .\n切换到分支\ngit checkout &lt;branch&gt; # 切换到 &lt;branch&gt; 分支git checkout -b &lt;branch&gt; # 创建 &lt;branch&gt; 分支并切换到该分支\n删除分支\n\n删除本地分支\ngit branch -d &lt;branch&gt;\n删除远程分支\ngit push origin -d &lt;branch&gt;\n\n\n\n\n清空 git 缓存\ngit rm -r --cached .\n日志\ngit log\n\n\n-&lt;n&gt;：显示日志（q 退出），显示 n 条日志\n--stat：每个提交都列出了修改过的文件，以及其中添加和移除的行数，并在最后列出所有增减行数\nauthor：显示指定作者的提交\n--grep：过滤提交说明中的文字\n--&lt;path&gt;：如果只关心某个文件或者目录的历史提交，可以在 git log 最后指定路径\n\n\n比较工作区和上个提交版本的区别\ngit diff &lt;filename&gt;\n拉取\ngit fetch # 拉取所有分支的变化git fetch -p # 拉取所有分支的变化，并将远端不存在的分支同步移除git fetch &lt;origin master&gt; # 拉取指定分支的变化\n回滚\ngit reset # 将提交记录回滚，代码不回滚git reset --hard # 将提交记录和代码全部回滚\nstash\n\ngit stash # 将当前工作区的状态存储下来git stash list # 查看当前有多少 stashgit stash apply --index # 把某一个 stash 应用回当前的分支git stash -include-untracked # 有些文件没有在 git 的 track 里，可以添加参数来存储对应的文件\n\n\n用 git stash apply 命令恢复，但是恢复后，stash内容并不删除，需要用 git stash drop 来删除\n用 git stash pop 命令，恢复的同时把 stash 存储列表的内容也删除\n\n\n查看某个 hash 所对应的 object 中的内容\ngit cat-file -p &lt;commit_id&gt;\n丢弃本地修改的所有文件（新增、删除、修改）\ngit checkout . # 本地所有修改的。没有的提交的，都返回到原来的状态 git stash # 把所有没有提交的修改暂存到 stash 里面。可用 git stash pop 回复git reset --hard HASH # 返回到某个节点，不保留修改，已有的改动会丢失git reset --soft HASH # 返回到某个节点，保留修改，已有的改动会保留，在未提交中，git status 或 git diff 可看git clean -df # 返回到某个节点，（未跟踪文件的删除）git clean 参数  # -n 不实际删除，只是进行演练，展示将要进行的操作，有哪些文件将要被删除。（可先使用该命令参数，然后再决定是否执行）  # -f 删除文件  # -i 显示将要删除的文件  # -d 递归删除目录及文件（未跟踪的）  # -q 仅显示错误，成功删除的文件不显示 注：git reset # 删除的是已跟踪的文件，将已 commit 的回退git clean # 删除的是未跟踪的文件git clean -nxdf # 查看要删除的文件及目录，确认无误后再使用下面的命令进行删除git checkout . &amp;&amp; git clean -xdf\n\nHexo 部署的博客 Git 提交到 Github 账户错乱的问题  由于通过 SmartGit 设置了  全局的用户名  和全局的邮箱（工作用的 Git 账号和邮箱）导致提交到 Github 上的版本不是自己的账户\n\n\n解决方法  在博客目录下找到 .deploy_git 目录（没有的话用 hexo g 生成一下就可以），然后可以看到当前目录的用户名和邮箱与自己的不一致，通过以下命令可以更改为一致的用户名和邮箱：\ngit config user.name SilhouettesForYougit config user.email mgze.wang@gmail.com\n\n\n之后再进行博客的  发布  便可以用正确的用户提交到 Github\nGit 文件目录结构解析.git |-- COMMIT_EDITMSG  // 提交 commit 时的信息记录|-- FETCH_HEAD  // 记录了上次 fetch 的分支的 commit 的 HASH|-- HEAD   // 记录了当前头指针在。git 存储的地址，如 refs/heads/brancha|-- ORIG_HEAD |-- branches|-- config  // 一些开关 &amp; 记录了所有分支的 fetch&amp;merge 的策略，在 checkout -b 或 --set-upstream-to            // 时将向 config 中添加本地分支对应的远端分支信息|-- description|-- hooks  //hook 脚本的存储位置，里面有一些 sample 脚本|   |-- applypatch-msg.sample|   |-- commit-msg.sample|   |-- post-update.sample|   |-- pre-applypatch.sample|   |-- pre-commit.sample|   |-- pre-push.sample|   |-- pre-rebase.sample|   |-- prepare-commit-msg.sample|   |-- update.sample|-- index|-- info|   `-- exclude|-- logs  // 头指针改变的日志文件|   |-- HEAD  // 对于整个仓库的头指针改变的记录|   `-- refs|       |-- heads  // 对于单个本地仓库头指针改变的记录（会记录包含冲突的状态）|       |   |-- brancha|       |   |-- branchb|       |   `-- main|       `-- remotes   |           `-- origin|               |-- HEAD|               |-- brancha|               `-- branchb|-- objects // 所有 commit、tree、... 的快照，将 commit 的 HASH 值的前两位作为文件夹名，后面的值作为快照名|   |-- 12 //commit 的 HASH 值的前两位|   |   `-- d4b6c73ffad196c6972c93e5ce9e691e5862c0  //commit 的 HASH 值除了前两位|   |-- 1d|   |   `-- b538af883f712194118c2d98eb63422dc62d94|   |-- 21|   |   `-- a23a99b0430e5a7aa5cdd8c56012f89318c9fe|   |-- 2c|   |   `-- 0b785731151d48705e4985aad2520f21c36bbb|   |-- 3b|   |   `-- 18e512dba79e4c8300dd08aeb37f8e728b8dad|   |-- info|   `-- pack|       |-- pack-0aa3e5057acbdff932634f63ea390953828409dd.idx|       `-- pack-0aa3e5057acbdff932634f63ea390953828409dd.pack|-- packed-refs`-- refs  // 头指针等信息的记录    |-- heads  // 记录了每个本地分支当前头指针所在 commit 的 HASH    |   |-- brancha    |   |-- branchb    |   `-- main    |-- remotes  // 记录了每个远程分支当前头指针所在 commit 的 HASH    |   `-- origin    |       |-- HEAD    |       |-- brancha    |       `-- branchb    `-- tags\n\nGit 切换远端分支  查看所有分支git branch -a | grep key-wordgit branch -a | grep skilltestremotes/origin/feature_4it01_skilltesttoolsremotes/origin/feature_ghs_4it01_skilltesttools\n\n\ngit branch不带参数，列出本地已经存在的分支，并且在当前分支的前面用 * 标记，加上 -a 参数可以查看所有分支列表，包括本地和远程，远程分支一般会用红色字体标记出来  如果用 git branch -a 没有显示全部的远程分支，可以通过 git fetch 将本地远程跟踪分支进行更新，与远程分支保持一致\n\n新建分支并切换到指定分支git checkout -b feature_4it01_skilltesttools origin/feature_4it01_skilltesttools\n\n该命令可以将远程 git 仓库里的指定分支拉取到本地，这样就在本地新建了一个 feature_4it01_skilltesttools 分支，并和指定的远程分支 origin/feature_4it01_skilltesttools 关联了起来。\n查看本地分支及追踪的分支git branch -vvdevelop                      98e306d76c5 [origin/develop: behind 1461] [AUTO COMMIT OFFLINES]commit by tools* feature_4it01_skilltesttools c44dbb8584f [origin/feature_4it01_skilltesttools] Merge branch 'all.dev.ep7' into all.ep7.it01\n\n*表示当前所在分支，[远程分支] 表示当前本地分支追踪的远程分支，最后一个是最近一次提交的注释。\ngit cherry-pick用法  对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。如果需要另一个分支的所有代码变动，那么就采用 git merge；如果只需要部分代码变动（某几个提交），这时可以采用git cherry-pick，它的功能是把已经存在的commit 进行挑选，然后重新提交。\n转移一个提交\n先切换到 A 分支git checkout A\n找到这次提交git log，赋值&lt;hash code&gt;\n再切换到 B 分支git chekcou B\n把 A 分支下的至此提交重新提交到 B 分支下git cherrt-pick &lt;hash code&gt;\n\n当执行完 git cherry-pick以后，将会生成一个新的提交，这个新的提交的 hash 值和原来的不同，但标志名称一样。\n转移多个提交git cherry-pick &lt;hash code 1&gt; &lt;hash code 2&gt;git cherry-pick &lt;hash code begin&gt;..&lt;hash code end&gt; # 左开右闭，顺序必须正确git cherry-pick &lt;hash code begin&gt;^..&lt;hash code end&gt; # 左闭右闭\n\nUnity 相关  几种 Update 方法的区别 UpdateUpdate 是在每次渲染新的一帧的时候才会调用\nFixedUpdate该函数用于固定更新，在游戏运行的过程中，每一帧的处理时间是不固定的，当需要固定间隔时间执行某些代码时，就会用到 FixedUpdate() 函数\nLastUpdate该函数是延迟更新函数，处于激活状态虾的脚本在每一帧里都会在 Update() 函数执行后调用该函数，通常用来调正代码执行的顺序。比如玩家的角色需要一个摄像机来跟随，那么通常角色的移动逻辑会写在 Update() 里，而摄像机跟随写在 LastUpdate() 里。这样可以确保在角色的位置计算完毕后，再根据角色位置确定摄像机的位置和视角\nUnity3D 内存管理——对象池（Object Pool）using System.Collections.Generic;using UnityEngine.Events;namespace UnityEngine.UI{    internal class ObjectPool&lt;T&gt; where T : new()    {        private readonly Stack&lt;T&gt; m_Stack = new Stack&lt;T&gt;();        private readonly UnityAction&lt;T&gt; m_ActionOnGet;        private readonly UnityAction&lt;T&gt; m_ActionOnRelease;        public int countAll {get; private set; }        public int countActive {get { return countAll - countInactive; } }        public int countInactive {get { return m_Stack.Count; } }        public ObjectPool(UnityAction&lt;T&gt; actionOnGet, UnityAction&lt;T&gt; actionOnRelease)        {            m_ActionOnGet = actionOnGet;            m_ActionOnRelease = actionOnRelease;        }        public T Get()        {            T element;            if (m_Stack.Count == 0)            {                element = new T();                countAll++;            }            else            {                element = m_Stack.Pop();            }            if (m_ActionOnGet != null)                m_ActionOnGet(element);            return element;        }        public void Release(T element)        {            if (m_Stack.Count &gt; 0 &amp;&amp; ReferenceEquals(m_Stack.Peek(), element))                Debug.LogError(\"Internal error. Trying to destroy object that is already released to pool.\");            if (m_ActionOnRelease != null)                m_ActionOnRelease(element);            m_Stack.Push(element);        }    }}\n\nObjectPool使用了一个栈（后进先出的数据结构），当需要新建（Get）一个新的对象的时候先从栈顶取出第一个，当使用结束的时候将其释放掉（Relaease），就是将其重新放回栈里面，而不是每次都实例化一个新的对象。\n协程  协程不是线程，不是异步执行。协程和 MonoBehaviour 的Update函数一样在主线程中执行，Unity 在每一帧都会处理对象上的协程。\n协程的执行原理 IEnumberator 协程函数的返回值时IEnumberator，它是一个迭代器，可以把它当成执行一个序列的某个节点的指针。它 3 个方法，分别是\n\nCurrent：返回当前指向的元素\nMoveNext：将指针向后移动一个单位，如果移动成功，则返回true\nReset：把位置重置为初始状态\n\nyieldyield关键字用来声明序列中的下一个值或者是一个无意义的值。\n当用 yield return x（x 是指一个具体的对象或数值）挂起协程：MoveNext返回为 true，Current 被赋值为 x；当用yield break 挂起协程，MoveNext返回为 false。 如果 MoveNext 函数返回为 true 意味着协程的执行条件被满足，则能够从当前位置继续往下执行，否则不能从当前位置继续往下执行。只有当 MoveNext 返回 false 时，才会执行 yield return 后面的语句。\n中断函数类型\n\n\n语句\n含义\n\n\n\nyield return null/yield return 0;\n程序在下一帧中从当前位置继续执行\n\n\nyield return new WaitForSeconds(N);\n程序等待 N 秒后从当前位置继续执行\n\n\nyield new WaitForEndOfFrame();\n在所有的渲染以及 GUI 程序执行完成后从当前位置继续执行\n\n\nyield new WaitForFixedUpdate();\n所有脚本中的 FixedUpdate() 函数都被执行后从当前位置继续执行\n\n\nyield return WWW;\n等待一个网络请求完成后从当前位置继续执行\n\n\nyield return StartCoroutine(xxx);\n等待一个 xxx 的协程执行完成后从当前位置继续执行\n\n\nyield break;\n跳出协程\n\n\n\nWhat is the difference between “yield return 0” and “yield return null” in Coroutine\nBoth yield return 0 and yield return null yields for a single frame. The biggest difference is that yield return 0 allocates memory because of boxing and unboxing of the 0 that happens under the hood, but yield return null does not allocate memory. Because of this, it is highly recommended to use yield return null if you care about performance.\n\nUnity EditorWindow 的 OnGUI 刷新  在编辑器模式下，OnGUI只有在窗口激活的状态（即鼠标移动到窗口上、点击事件等）才会刷新，执行OnGUI。如果需要实时刷新的话，可用 OnInspectorUpdate 开启窗口重绘，Unity 会每秒 10 帧重绘窗口。\n\nC# 相关 C# 泛型约束 在定义泛型类时。可以对代码能够在实例化类时用于类型参数的类型种类加限制。如果代码尝试使用某个约束所不允许的类型来实例化类，则会产生编译错误。这些限制成为约束，约束是使用 where 上下文关键字指定的。\n\n\n\n约束\n说明\n\n\n\nT : struct\n类型参数碧血是值类型，可以指定除 Nullable 以外的任何值类型\n\n\nT : class\n类型参数必须是引用类型，包括任何类、接口、委托或数组类型\n\n\nT : new()\n类型参数必须具有无参数的公共构造函数，当与其他约束一起使用时，new()约束必须最后指定\n\n\nT : &lt; 基类名 &gt;\n类型参数必须是指定的基类或派生自指定的基类\n\n\nT : &lt; 接口名 &gt;\n类型参数必须是指定的接口或实现指定的接口，可以指定多个接口约束，接口约束也可以是泛型的\n\n\nT : U\n为 T 提供的类型参数必须是为 U 提供的参数或派生自为 U 提供的参数，这成为裸类型约束\n\n\ndefault函数 default(T) 可以得到该类型的默认值，C# 在初始化时，会给未显示肤质的字段、属性赋上默认值，但值变量却不会，值变量可以使用默认构造函数赋值，或者使用 default(T) 赋值。\n\n\n\n值类型\n默认值\n\n\n\nbool\nfalse\n\n\nbyte/int/sbyte /short /uint /ulong /ushort\n0\n\n\ndecimal\n0.0M\n\n\ndouble\n0.0D\n\n\nfloat\n0.0F\n\n\nlong\n0L\n\n\nenum\n表达式 (E)0 产生的值，其中 E 为enum标识符\n\n\nstruct\n将所有的值类型字段设置为默认值并将所有的引用类型字段设置为 null 时产生的值\n\n\n引用类型\nnull\n\n\nC# 中 is，as，using 关键字的使用\nis：用于检查对象是否与给定类型兼容，不会抛出异常\nas：用于引用类型之间转换，直接进行转换，若转换成功，则返回转换后的对象，若转换失败则返回null，不会抛出异常\nusing：引用命名空间，有效回收资源，using关键字可以回收多个对象的资源，关键字后面的小括号内创建的对象必须实现 IDisposanble 接口，或者该类的基类已经实现了 IDisposable 接口。回收资源的时机是在 using 关键字下面的代码块执行完成之后自动调用接口方法 Dispose() 销毁对象\n\nref和 out 关键字C# 的数据类型有两种：一种是值类型（value type），一种是引用类型（reference type）。\n\n值类型：结构体（数值类型，bool，用户自定义结构体）、枚举和可空类型。\n引用类型：数组、用户定义的类、接口、委托、object、字符串。\n\n值类型和引用类型的区别在于：函数传递的时候，值类型把自己的值复制一份传递给别的函数；引用类型则是把自己的地址传递给函数。\nref和 out 都是按地址传递的，使用后都将改变原来参数的数值。ref可以把参数的数值传递进函数，传递到 ref 参数必须初始化，否则会报错；但是 out 是要把参数清空，无法把一个数值从 out 传递进去，传递进去后必须初始化一次。\nC# 特性标签（Attribute）公共语言运行时能够添加类似于关键字的描述性声明称为特性，以便批注编程元素（如类型、字段、方法和属性）。将特性与程序实体相关联后，可以在运行时使用  反射  查询特性。\n可以将特性附加到几乎任何声明中。在 C# 中，通过用方括号（[]）将特性名称括起来，并置于应用该特性的实体的声明上方以指定特性。\n创建自定义特性  可以通过定义特性类创建自定义特性，特性类是直接或间接派生自 Attribute 的类，可快速轻松地识别元数据中的特性定义。\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct)]public class AuthorAttribute : System.Attribute{    private string name;    public double version;    public AuthorAttribute(string name)    {        this.name = name;        version = 1.0;    }}\n\n访问特性  对于自定义特性，可以用 Type 中的 IsDefined 和GetCustomAttributes方法来获取。\n\nIsDefined：public abstract bool IsDefined(Type attributeType, bool inherit)，用来加测某个特性是否应用到某个类上\nGetCustomAttributes：public abstract object[] GetCustomAttributes(bool inherit)，调用它后，会创建一个与目标相关联的特性的实例\n\n特性与注释的区别  注释是对程序源代码的一种说明，程序编译的时候会忽略它，而特性是代码的一部分，它会被编译器编译进程序的元数据里，在程序运行的时候，随时可以从元数据中提取出这些附加信息。\nAction委托与 Func 委托 Action 不能指向有返回值的方法，不能有返回值。Func可以指向有一个返回值的方法，且必须有返回值。\nActivator.CreateInstance&lt;T&gt;与 newnew 和Activator.CreateInstance都用于实例化一个类，Activator.CreateInstance使用与指定参数匹配程度最高的构造函数来创建指定类型的实例。\npublic static T Factory&lt;T&gt;() where T : new(){    return new T();}\n\n编译器会将 return new T() 转换调用 Actuvator.CreateInstance 方法。\nC# 资源回收和 IDisposable 接口的使用\n托管资源和非托管资源\n\n托管资源由 CLR 来维护，自动进行垃圾回收，比如数组\n非托管资源不会进行自动垃圾回收，需要手动释放，比如句柄。但在 c# 中的非托管资源很多都被封装到 .NET 类中，当对象释放时内部方法同时释放非托管资源\n\n在 C# 中创建的对象，数组，列表等等都不需要考虑资源释放的问题，因为它会被 CLR 的垃圾回收机制自动回收。创建的对象释放时是随机的不确定时长的等待自动回收机制进行收回，有没有办法主动回收这些资源呢，比如对象占用内存较大，想主动立即释放而不等待主动回收。可以写一个方法，在这个方法里释放引用的资源就可以了，这个方法可以随便起名，当然更规范的是继承 IDisposable 来实现 Disposable 方法。\n\n\nC# 中数组、ArrayList和 List 三者的区别  数组  数组在 C# 中最早出现的。在内存中是连续存储的，所以它的索引速度非常快，而且赋值与修改元素也很简单。但是数组存在一些不足的地方。在数组的两个数据间插入数据是很麻烦的，而且在声明数组的时候必须指定数组的长度，数组的长度过长，会造成内存浪费，过段会造成数据溢出的错误。如果在声明数组时我们不清楚数组的长度，就会变得很麻烦。\nArrayListArrayList是命名空间 System.Collections 下的一部分，在使用该类时必须进行引用，同时继承了 IList 接口，提供了数据存储和检索。ArrayList对象的大小是按照其中存储的数据来动态扩充与收缩的。所以，在声明 ArrayList 对象时并不需要指定它的长度。\n//ArrayListArrayList list1 = new ArrayList(); // 新增数据list1.Add(\"cde\");list1.Add(5678);// 修改数据list[2] = 34;// 移除数据list.RemoveAt(0);// 插入数据list.Insert(0, \"qwe\");\n\n在 ArrayList 中，不仅插入了字符串，而且插入了数字。这样在 ArrayList 中插入不同类型的数据是允许的。因为 ArrayList 会把所有插入其中的数据当作为 object 类型来处理，在使用 ArrayList 处理数据时，很可能会报类型不匹配的错误，也就是 ArrayList 不是类型安全的 。在存储或检索值类型时通常发生 装箱  和拆箱  操作，带来很大的性能耗损。\n泛型 List 因为 ArrayList 存在不安全类型与装箱拆箱的缺点，所以出现了泛型的概念。List类是 ArrayList 类的泛型等效类，它的大部分用法都与 ArrayList 相似，因为 List 类也继承了 IList 接口。最关键的区别在于，在声明 List 集合时，同时需要为其声明 List 集合内数据的对象类型。\nLambda 表达式  使用 Lambda 表达式来创建匿名函数。 使用 lambda 声明运算符=&gt; 从其主体中分离 lambda 参数列表。Lambda 表达式可采用以下任意一种形式：\n\n表达式 lambda，表达式为其主体：\n(input-parameters) =&gt; expression\n语句 lambda，语句块作为其主体：\n(input-parameters) =&gt; {&lt;sequence-of-statements&gt;}\n\n若要创建 Lambda 表达式，需要在 Lambda 运算符左侧指定输入参数（如果有），然后在另一侧输入表达式或语句块。\nC# API\n\n\nsyntax\ninterpretation\n\n\n\nIsGenericType\n判断属性类型是否为泛型类型，如：typeof(int).IsGenericType --&gt; Falsetypeof(List&lt;int&gt;).IsGenericType --&gt; Truetypeof(Dictionary&lt;int&gt;).IsGenericType --&gt; True\n\n\nC++ 相关C++ 几个预定义的宏\n__LINE__：源代码行号\n__FILE__：源文件名\n__DATE：编译日期\n__TIME__：编译时间\n__STDC：当要求程序严格遵循 ANSI C 标准时该标识被赋值为 1\n__cplusplus：当编写 C++ 程序时该表示被定义\n\nLua 相关Lua 语法\n定义字符串\na= \"双引号中可直接使用' 单引号 ', 但 \\\" 双引号 \\\"要转义\"b = '单引号中可直接使用\" 双引号 \", 但 \\' 单引号 \\'要转义'c = [[双方括号中  可以直接使用 '单引号'和 \"双引号\"，而且可以  换行]]\n格式字符串可能包含以下的转义码\n%c - 接受一个数字，并将其转化为 ASCII 码表中对应的字符 %d，%i - 接受一个数字并将其转化为有符号的整数格式%o - 接受一个数字并将其转化为八进制数格式%u - 接受一个数字并将其转化为无符号整数格式%x - 接受一个数字并将其转化为十六进制数格式，使用小写字母%X - 接受一个数字并将其转化为十六进制数格式，使用大写字母%e - 接受一个数字并将其转化为科学记数法格式，使用小写字母 e%E - 接受一个数字并将其转化为科学记数法格式，使用大写字母 E%f - 接受一个数字并将其转化为浮点数格式%g/%G - 接受一个数字并将其转化为%e（%E, 对应%G）及%f 中较短的一种格式%q - 接受一个字符串并将其转化为可安全被 Lua 编译器读入的格式（即将该字符串添加了 ``）%s - 接受一个字符串并按照给定的参数格式化该字符串\n\n\nLua 堆栈操作 lua 和 C++ 之间的数据交互通过栈进行，栈中的数据通过索引值进行定位（若 lua 虚拟机堆栈里有 个元素，则可以用  从战地向上索引，也可以用  向下索引），正数表示相对于栈底的位置偏移，负数表示相对于栈顶的位置偏移。\n\nlua_gettop：int lua_gettop (lua_State *L);返回栈顶元素的索引\nlua_settop：void lua_settop (lua_State *L, int index);参数允许传入任何可接受的索引以及 0 。它将把堆栈的栈顶设为这个索引。如果新的栈顶比原来的大，超出部分的新元素将被填为 nil。如果index 为 0，把栈上所有元素移除\n\nLua 中的模式匹配（Pattern Matching）character classes\n\n\n符号\n匹配模式\n\n\n\n%a\n\n\n\n%c\n\n\n\n%d\n\n\n\n%l\n\n\n\n%p\n\n\n\n%s\n空白字符\n\n\n\n\n\n\nmagic characters\n\n\n符号\n描述\n备注\n\n\n\n()\n标记一个子模式，供后续使用，跟正则的用法类似\n\n\n\n.\n匹配所有字符\n类似正则表达式，只不过正则表达式的，不包括回车\\n\n\n\n%\n1. 可用作转义符；2. 声明 character classess;3. 跟() 结合用于子模式匹配：%N，N是一个数字，表示匹配第 N 个子串，例如 %1,%2, ...，跟正则表达式的1，2, ... 类似\n\n\n\n^\n如果处于模式开头，则表示匹配输入字符串的开始位置，如果放在 [] 中，表示取补集\n\n\n\n$\n表示匹配输入字符串的结尾位置，跟正则表达式的用法基本一致\n\n\n\n[]\n表示一个字符集合\n例如 [%w_] 表示匹配字母数字和下划线，[a-f]表示匹配字母 a 到f\n\n\n+\n\n\n\n\n-\n匹配前面的模式 0 次或多次，返回最短的匹配结果，模式匹配中的“非贪婪模式”\n\n\n\n*\n匹配前面的模式 0 次或多次\n\n\n\nfunction or expression needs too many registers\nLua 中的模块与 module 函数  编写模块的基本方法-- test.lualocal M = {}local modelName = ..._G[modelName] = Mfunction M.play()    print('play')endfunction M.quit()    print('quit')endreturn M\n\n模块内函数之间的调用仍然要保留模块名的限定符，如果是  私有变量还需要加 local 关键字 ， 同时不能加模块名限定符。可以把 test.lua 这个模块里的全局环境设置为 M，于是，我们直接定义函数的时候，不需要再带M 前缀。即：\n-- test.lualocal M = {}local modelName = ..._G[modelName] = Mpackage.loaded[modname] = Msetfenv(1, M)function play()    print('play')endfunction quit()    print('quit')endreturn M\n\nmodule函数  在 Lua 5.1 中，可以用module(...) 函数来代替，如：\nmodule(..., package.seeall)function play()    print('play')endfunction M.quit()    print('quit')end\n\n由于在默认情况下，module不提供外部访问，必须在调用它之前，为需要访问的外部函数或模块声明适当的局部变量。然后 Lua 提供了一种更为方便的实现方式，即在调用 module 函数时，多传入一个 package.seeall 的参数，相当于setmetatable(M, {__index = _G})\n抵制使用 module 函数来定义 Lua 模块  旧式的模块定义方式是通过 *module(\"filename\"[,package.seeall])*来显示声明一个包，现在官方不推荐再使用这种方式。这种方式将会返回一个由 filename 模块函数组成的 table，并且还会定义一个包含该table 的全局变量。\n如果只给 module 函数一个参数（也就是文件名）的话，前面定义的全局变量就都不可用了，包括 print 函数等，如果要让之前的全局变量可见，必须在定义 module 的时候加上参数 package.seeall。调用完module 函数之后， print这些系统函数不可使用的原因，是当前的整个环境被压入栈，不再可达。\nmodule(\"filename\", package.seeall)这种写法仍然是不提倡的，官方给出了两点原因：\n\npackage.seeall这种方式破坏了模块的高内聚，原本引入 filename 模块只想调用它的 foobar() 函数，但是它却可以读写全局属性，例如filename.os。\nmodule函数压栈操作引发的副作用，污染了全局环境变量。例如 module(\"filename\") 会创建一个 filename 的table，并将这个 table 注入全局环境变量中，这样使得没有引用它的文件也能调用 filename 模块的方法。\n\n比较推荐的模块定义方法-- square.lua 长方形模块local _M = {}           -- 局部的变量_M._VERSION = '1.0'     -- 模块版本local mt = {__index = _M }function _M.new(self, width, height)    return setmetatable({width=width, height=height}, mt)endfunction _M.get_square(self)    return self.width * self.heightendfunction _M.get_circumference(self)    return (self.width + self.height) * 2endreturn _M\n\n引用示例代码local square = require \"square\" local s1 = square:new(1, 2)print(s1:get_square())          --output: 2print(s1:get_circumference())   --output: 6\n\nPython 相关  生成 requirements.txt 文件  方法一pip freeze &gt; requirements.txt\n\npip freeze命令输出的格式和 requirements.txt 文件内容格式完全一样，因此我们可以将 pip freeze 的内容输出到文件 requirements.txt 中。在其他机器上可以根据导出的 requirements.txt 进行包安装。\n方法二pipreqs . --encoding=utf8 --force\n\n生成指定目录下的依赖类库\n","categories":["日常"],"tags":["git","unity","c#","c++"]},{"title":"激活 Typora","url":"/2022/01/04/0010abaf62d0/","content":"\n    \n\n\n\n\n克隆 GitHub 仓库git clone https://github.com/Mas0nShi/typoraCracker.git\n\n安装依赖环境pip install -r requirements.txt\n\n\n可能报错，运行如下命令\npip install jsbeautifierpip install jsminpip install logurupip install pycryptodome\n\n创建输出目录mkdir \\typoraCracker\\output\\mkdir \\typoraCracker\\out_app_asar\\\n\n生成破解文件python .\\typora.py \\Typora\\resources\\app.asar .\\output\\\n\n\n可能报如下错误\nTraceback (most recent call last):  File &quot;\\typoraCracker\\typora.py&quot;, line 8, in &lt;module&gt;    from Crypto.Cipher import AESModuleNotFoundError: No module named &#x27;Crypto&#x27;\n\n\n打开 \\Python\\Python37\\Lib\\site-packages 这个路径，找到 crypto 这个文件夹\n将 crypto 这个文件夹重命名为Crypto\n\n\n替换 License.js 文件move .\\example\\patch\\License.js .\\output\\dec_app\\\n\n重新生成 app.asar 文件python .\\typora.py -u .\\key\\outfile\\dec_app\\ .\\output\\out_app_asar\\\n\n替换app.asarmove .\\output\\out_app_asar\\app.asar \\Typora\\resources\\app.asar\n\n生成序列号node .\\example\\keygen.js\n","categories":["Tools"],"tags":["typora","crack"]},{"title":"C++ 11 新特性","url":"/2022/01/13/e411984d99f4/","content":"\n    \n\n\n\n\nauto &amp; decltype关于 C++11 新特性，最先提到的肯定是类型推导，C++11 引入了 auto 和decltype关键字，使用他们可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。\nauto让编译器在编译器就推导出变量的类型，可以通过等号右边的类型推导出变量的类型\ndecltype相对于 auto 用于推导变量类型，而 decltype 则用于推导表达式类型，这里只用于编译器分析表达式的类型，表达式实际不会进行运算\n左值和右值\n左值：可以取地址并且有名字的东西就是左值。\n右值：不能取地址的没有名字的东西就是右值。\n纯右值：运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda 表达式等都是纯右值。\n将亡值：可以理解为即将要销毁的值。\n左值引用：对左值进行引用的类型。\n右值引用：对右值进行引用的类型。\n移动语义：转移资源所有权，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用。\n完美转发：可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参。\n返回值优化：当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++ 标准允许省略调用这些复制构造函数。\n\n列表初始化  在 C++11 中可以直接在变量名后面加上初始化列表来进行对象的初始化\n列表初始化的一些规则  聚合类型\n聚合类型可以进行直接列表初始化\n\n\n\n类型是一个普通数组，如 int[5]，char[]，double[] 等\n\n类型是一个类，且满足以下条件\n\n没有用户声明的构造函数\n没有用户提供的构造函数（允许显示预置或弃置的构造函数）\n没有私有或保护的非静态数据成员\n没有基类\n没有虚函数\n没有 {} 和 = 直接初始化的非静态数据成员\n没有默认成员初始化器\n\nstruct A &#123;    int a;    int b;    virtual void func() &#123;&#125; // 含有虚函数，不是聚合类&#125;;struct Base &#123;&#125;;struct B : public Base &#123; // 有基类，不是聚合类      int a;    int b;&#125;;struct C &#123;    int a;    int b = 10; // 有等号初始化，不是聚合类&#125;;struct D &#123;    int a;    int b;private:    int c; // 含有私有的非静态数据成员，不是聚合类&#125;;struct E &#123;      int a;    int b;    E() : a(0), b(0) &#123;&#125; // 含有默认成员初始化器，不是聚合类&#125;;\n\nstd::initializer_liststruct CustomVec &#123;    std::vector&lt;int&gt; data;    CustomVec(std::initializer_list&lt;int&gt; list) &#123;        for (auto iter = list.begin(); iter != list.end(); ++iter) &#123;            data.push_back(*iter);        &#125;    &#125;&#125;;\n\nstd::function &amp; std::bind &amp; lambda表达式 std::function 满足以下条件之一就可称为可调用对象：\n\n是一个函数指针\n是一个具有 operator() 成员函数的类对象（传说中的仿函数），lambda表达式\n是一个可被转换为函数指针的类对象\n是一个类成员（函数）指针\nbind 表达式或其它函数对象\n\n而 std::function 就是上面这种可调用对象的封装器，可以把 std::function 看做一个函数对象，用于表示函数这个抽象概念。std::function的实例可以存储、复制和调用任何可调用对象，存储的可调用对象称为 std::function 的目标，若 std::function 不含目标，则称它为空，调用空的 std::function 的目标会抛出 std::bad_function_call 异常。\nstd::bind使用 std::bind 可以将可调用对象和参数一起绑定，绑定后的结果使用 std::function 进行保存，并延迟调用到任何我们需要的时候。std::bind通常有两大作用：\n\n将可调用对象与参数一起绑定为另一个 std::function 供调用\n将 n 元可调用对象转成 m(m &lt; n) 元可调用对象，绑定一部分参数，这里需要使用std::placeholders\n\nlambda表达式 lambda 表达式可以说是 c++11 引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：\nauto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;\n\n其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture是捕获列表，params是参数表，opt是函数选项 (mutable之类）， ret是返回值类型，func_body是函数体。\nlambda 表达式允许捕获一定范围内的变量：\n\n[]不捕获任何变量\n[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用\n[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用\n[=, &amp;a]值捕获外部作用域所有变量，按引用捕获 a 变量\n[a]只值捕获 a 变量，不捕获其它变量\n[this]捕获当前类中的 this 指针\n\n小结 std::function 和std::bind使得我们平时编程过程中封装函数更加的方便，而 lambda 表达式将这种方便发挥到了极致，可以在需要的时间就地定义匿名函数，不再需要定义类或者函数等，在自定义 STL 规则时候也非常方便，让代码更简洁，更灵活，提高开发效率\n模板的改进  模板的右尖括号C++11 之前是不允许两个右尖括号出现的，会被认为是右移操作符，所以需要中间加个空格进行分割，避免发生编译错误。\n模板的别名C++11 引入了using，可以轻松的定义别名，而不是使用繁琐的typedef\n函数模板的默认模板参数C++11 之前只有类模板支持默认模板参数，函数模板是不支持默认模板参数的，C++11 后都支持；同时 C++11 支持变长参数模板\n并发  智能指针  基于范围的 for 循环vector&lt;int&gt; vec;for (auto iter = vec.begin(); iter != vec.end(); iter++) &#123; // before c++11    cout &lt;&lt; *iter &lt;&lt; endl;&#125;for (int i : vec) &#123; // c++11 基于范围的 for 循环    cout &lt;&lt; &quot;i&quot; &lt;&lt; endl;&#125;\n\n委托构造函数  委托构造函数允许在同一个类中一个构造函数调用另外一个构造函数，可以在变量初始化时简化操作\nstruct A &#123;    A()&#123;&#125;    A(int a) &#123; a_ = a; &#125;    A(int a, int b) : A(a) &#123; b_ = b; &#125;    A(int a, int b, int c) : A(a, b) &#123; c_ = c; &#125;    int a_;    int b_;    int c_;&#125;;\n\n继承构造函数  继承构造函数可以让派生类直接使用基类的构造函数，如果有一个派生类，我们希望派生类采用和基类一样的构造方式，可以直接使用基类的构造函数，而不是再重新写一遍构造函数\nstruct Base &#123;    Base() &#123;&#125;    Base(int a) &#123; a_ = a; &#125;    Base(int a, int b) : Base(a) &#123; b_ = b; &#125;    Base(int a, int b, int c) : Base(a, b) &#123; c_ = c; &#125;    int a_;    int b_;    int c_;&#125;;struct Derived : Base &#123;    using Base::Base;&#125;;int main() &#123;    Derived a(1, 2, 3);    return 0;&#125;\n\n关键字 nullptrnullptr 是 c++11 用来表示空指针新引入的常量值，在 c++ 中如果表示空指针语义时建议使用 nullptr 而不要使用 NULL，因为NULL 本质上是个 int 型的 0，其实不是个指针\nfinal &amp; overridec++11 关于继承新增了两个关键字，final用于修饰一个类，表示禁止该类进一步派生和虚函数的进一步重载，override用于修饰派生类中的成员函数，标明该函数重写了基类函数，如果一个函数声明了 override 但父类却没有这个虚函数，编译报错，使用 override 关键字可以避免开发者在重写基类函数时无意产生的错误\ndefaultc++11 引入 default 特性，多数时候用于声明构造函数为默认构造函数，如果类中有了自定义的构造函数，编译器就不会隐式生成默认构造函数\ndeletec++ 中，如果开发人员没有定义特殊成员函数，那么编译器在需要特殊成员函数时候会隐式自动生成一个默认的特殊成员函数，例如拷贝构造函数或者拷贝赋值操作符。有时候想禁止对象的拷贝与赋值，可以使用 delete 修饰\nstruct A &#123;    A() = default;    A(const A&amp;) = delete;    A&amp; operator=(const A&amp;) = delete;    int a;    A(int i) &#123; a = i; &#125;&#125;;int main() &#123;    A a1;    A a2 = a1;  // 错误，拷贝构造函数被禁用    A a3;    a3 = a1;  // 错误，拷贝赋值操作符被禁用&#125;\n\ndelele关键字在 c++11 中很常用，std::unique_ptr就是通过 delete 修饰来禁止对象的拷贝的\nexplicitexplicit专用于修饰构造函数，表示只能显式构造，不可以被隐式转换\n不用explicitstruct A &#123;    A(int value) &#123; // 没有 explicit 关键字        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    A a = 1; // 可以隐式转换    return 0;&#125;\n\n使用explicitstruct A &#123;    explicit A(int value) &#123;        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    A a = 1; // error，不可以隐式转换    A aa(2); // ok    return 0;&#125;\n\nconstexprconstexpr是 c++11 新引入的关键字，用于编译时的常量和常量函数，这里直接介绍 constexpr 和const的区别：两者都代表可读，const只表示 read only 的语义，只保证了运行时不可以被修改，但它修饰的仍然有可能是个动态变量，而 constexpr 修饰的才是真正的常量，它会在编译期间就会被计算出来，整个运行过程中都不可以被改变，constexpr可以用于修饰函数，这个函数的返回值会尽可能在编译期间被计算出来当作一个常量，但是如果编译期间此函数不能被计算出来，那它就会当作一个普通函数被处理\nenum classc++11 新增有作用域的枚举类型，不带作用域的枚举类型可以自动转换成整形，且不同的枚举可以相互比较，可能会存在潜在的难以调试的 bug；使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，使用带有作用域的枚举类型后，对不同的枚举进行比较会导致编译失败，同时带作用域的枚举类型可以选择底层类型，默认是int，可以改成其他类型\n平时编程过程中使用枚举，一定要使用有作用域的枚举取代传统的枚举\n\n\nsizeofc++11 中 sizeof 可以用的类的数据成员上\nassertionstatic_assert(true/false, message);\n\nc++11 引入 static_assert 声明，用于在编译期间检查，如果第一个参数值为false，则打印message，编译失败\n内存对齐  什么是内存对齐  理论上计算机对于任何变量的访问都可以从任意位置开始，然而实际上系统会对这些变量的存放地址有限制，通常将变量首地址设为某个数 N 的倍数，这就是内存对齐\n为什么要内存对齐\n硬件平台限制，内存以字节为单位，不同硬件平台不一定支持任何内存地址的存取，一般可能以双字节、4 字节等为单位存取内存，为了保证处理器正确存取数据，需要进行内存对齐\n提高 CPU 内存访问速度，一般处理器的内存存取粒度都是 N 的整数倍，假如访问 N 大小的数据，没有进行内存对齐，有可能就需要两次访问才可以读取出数据，而进行内存对齐可以一次性把数据全部读取出来，提高效率\n\nc++11 关于内存对齐新增了一些函数\nvoid func()&#123;    static std::aligned_storage&lt;sizeof(A), alignof(A)&gt;::type data;    A *attr = new (&amp;data) A;&#125;\n\n随机数功能c++11 关于随机数功能则较之前丰富了很多，典型的可以选择概率分布类型\n#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;int main() &#123;    std::default_random_engine random(time(nullptr));    std::uniform_int_distribution&lt;int&gt; int_dis(0, 100); // 整数均匀分布    std::uniform_real_distribution&lt;float&gt; real_dis(0.0, 1.0); // 浮点数均匀分布    for (int i = 0; i &lt; 10; ++i) &#123;        cout &lt;&lt; int_dis(random) &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;    for (int i = 0; i &lt; 10; ++i) &#123;        cout &lt;&lt; real_dis(random) &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n\n正则表达式#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;regex&gt;#include &lt;string&gt;int main() &#123;    std::string s = &quot;I know, I&#x27;ll use2 regular expressions.&quot;;    // 忽略大小写    std::regex self_regex(&quot;REGULAR EXPRESSIONS&quot;, std::regex_constants::icase);     if (std::regex_search(s, self_regex)) &#123;        std::cout &lt;&lt; &quot;Text contains the phrase &#x27;regular expressions&#x27;\\n&quot;;    &#125;    std::regex word_regex(&quot;(\\\\w+)&quot;);  // 匹配字母数字等字符    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);    auto words_end = std::sregex_iterator();    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; std::distance(words_begin, words_end) &lt;&lt; &quot; words\\n&quot;;    const int N = 6;    std::cout &lt;&lt; &quot;Words longer than &quot; &lt;&lt; N &lt;&lt; &quot; characters:\\n&quot;;    for (std::sregex_iterator i = words_begin; i != words_end; ++i) &#123;        std::smatch match = *i;        std::string match_str = match.str();        if (match_str.size() &gt; N) &#123;            std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match_str &lt;&lt; &#x27;\\n&#x27;;        &#125;    &#125;    std::regex long_word_regex(&quot;(\\\\w&#123;7,&#125;)&quot;);    // 超过 7 个字符的单词用 [] 包围    std::string new_s = std::regex_replace(s, long_word_regex, &quot;[$&amp;]&quot;);    std::cout &lt;&lt; new_s &lt;&lt; &#x27;\\n&#x27;;&#125;\n","categories":["C++"],"tags":["C++","C++ 11"]},{"title":"tolua 原理解析","url":"/2022/01/12/10f6215aba05/","content":"\n    \n\n\n\nlua 虚拟栈lua 代码-- file name: test.luafunction func()    return 1, 2, 3, 4end\n\nC++ 代码#include &lt;iostream&gt;  #include &quot;lua.hpp&quot;   int _tmain(int argc, _TCHAR* argv[])&#123;    //①新建虚拟机      lua_State *L = luaL_newstate();    //②载入库      luaL_openlibs(L);     //③这里执行 test.lua  Lua 文件      luaL_dofile(L, &quot;test.lua&quot;);    //④重新设置栈底    lua_settop(L, 0);     //⑤获取 返回结果      lua_getglobal(L, &quot;func&quot;);     //⑥操作栈调回结果    lua_pcall(L, 0, 4, 0);    printf(&quot;%s\\n&quot;, lua_tostring(L, 1));    printf(&quot;%s\\n&quot;, lua_tostring(L, 2));    printf(&quot;%s\\n&quot;, lua_tostring(L, 3));    printf(&quot;%s\\n&quot;, lua_tostring(L, 4));     //⑦关闭虚拟机      lua_close(L);     system(&quot;pause&quot;);    return 0;&#125;\n\n\n④ 这个过程，是为了确认栈底是空的，以便后面的操作是按照顺序入栈的且从 1 号栈位开始\n\n⑥操作栈调回结果\n\nC++ 告诉 lua 虚拟机，函数以输入栈，函数传入 0 个参数，会返回 4 个函数， 不需要错误信息 。分别  对应上面四个参数。 栈中一个元素：func\nC++ 请求完毕，lua 虚拟机  开始访问栈，从栈中取出 func。 栈中无元素\nlua 虚拟机  得到 `func` 信息送给lua 程序。** 栈中无元素 **\nlua 程序在调用的 lua 文件全局表 中查找 func，并运行返回结果1,2,3,4。 栈中无元素\nlua 程序得到返回结果 1,2,3,4 将结果再压入栈；1先入栈底，2再入栈，以此类推。栈中四个元素：1,2,3,4，顺序为栈底 -&gt; 栈顶\n最后，C++ 再去栈中读取数据；这里 lua_tostring(L, 1) 是读取函数，不会改变栈内的结果的，所以当地⑥步执行完，栈中还是四个元素：1,2,3,4\n\n\n若使用lua_pop(L, 1) 去操作的话，可以弹出指定的位置的栈内容\n\n\n\nlua 热更新原理  使用 assetbundle 进行资源的更新，而由于 lua 运行时才编译的特性，所以 lua 文件也可以被看成是一种资源文件（与 fbx、Image 等一样）可以打进 ab 包中\nC# 调用 lua\n使用 Tolua 的相关类和方法都需要调用命名空间 LuaInterface\n\n调用 lua 脚本必须先创建一个 lua 虚拟机\nLuaState lua = new LuaState();\n在 C# 中运行一段 lua 脚本最简单的方法就是 lua.DoString\npublic object[] DoString(string chunk, string chunkName = &quot;LuaState.DoString&quot;)\n使用完 lua 虚拟机之后记要销毁\n\n先进行 lua 虚拟机的判空lua.CheckTop\n\n\n\nlua 调用 C# 代码  反射 C# 中的反射使用Assembly 定义和加载程序集，加载在程序集清单中列出模块，以及从此程序集中查找类型并创建该类型的实例\n反射用到的命名空间System.ReflectionSystem.TypeSystem.Reflection.Assembly\n\n反射用到的主要类\nSystem.Type类－通过这个类可以访问任何给定数据类型的信息\nSystem.Reflection.Assembly类－它可以用于访问给定程序集的信息，或者把这个程序集加载到程序中\n\n去反射  把所有的 c# 类的 public 成员变量、成员函数，都导出到一个相对应的 Wrap 类中，而这些成员函数通过特殊的标记，映射到 lua 的虚拟机中，当在 lua 中调用相对应的函数时候，直接调用映射进去的 wrap 函数，然后再调用到实际的 c# 类，完成调用过程\nWrap在 tolua 生成的 Wrap 文件中，经常遇见如此写法\n// XXXWrap.csL.BeginStaticLibs(&quot;XXX&quot;);L.RegFunction(&quot;Log&quot;, Log);L.EndStaticLibs();\n\nBeginStaticLibs首先 BeginStaticLibs 最终会走到这条语句上来：LuaDLL.tolua_beginstaticclass(L, name);这语句会执行 tolua.dll 的 C 语言对应方法，tolua_beginstaticclass，该方法最终会在 lua_State 栈顶生成一个名为 name 的table\n/* tolua.c */LUALIB_API void tolua_beginstaticclass(lua_State *L, const char *name)&#123;        lua_pushstring(L, name);  /* 将 name 压入栈中，即 XXX */    lua_newtable(L);/* 创建一个 table 压入栈中 */    _addtoloaded(L);    lua_pushvalue(L, -1);      /* 这里将栈顶表复制了一份压入栈中 即 top [XXX(table),XXX(emptytable)] bottom    */    /* 以上操作相当于生成了名为 name 的 table :XXX = &#123;&#125;  */       /* 以下操作抽象理解 */    /* XXX[&quot;userdata&quot;] = &amp;tag  */    lua_pushlightuserdata(L, &amp;tag);    lua_pushnumber(L, 1);    lua_rawset(L, -3);    /* XXX[&quot;.name&quot;] = XXX  */    lua_pushstring(L, &quot;.name&quot;);    _pushfullname(L, -4);    lua_rawset(L, -3);       /* XXX[&quot;__index&quot;] = static_index_event  */    lua_pushstring(L, &quot;__index&quot;);    lua_pushcfunction(L, static_index_event);    lua_rawset(L, -3);    /* XXX[&quot;__newindex&quot;] = static_newindex_event  */    lua_pushstring(L, &quot;__newindex&quot;);    lua_pushcfunction(L, static_newindex_event);    lua_rawset(L, -3);      &#125;\n\n\n    \n    最终会在 lua_State 栈顶会被压入一个名为 XXX 的 Table\n\n\nEndStaticLibs接着先把尾给收掉，EndStaticLibs最后会来到 tolua.c 这边的 tolua_endstaticclass 方法，该方法最终会将栈顶元素弹出并将其设置为 - 2 位置的元表\n/* tolua.c */LUALIB_API void tolua_endstaticclass(lua_State *L)&#123;    lua_setmetatable(L, -2);    lua_rawset(L, -3);    &#125;\n\n\n    \n    弹出栈顶元素，将其设置为 XXX(Empty Table) 的元表\n\n\nRegFunctionRegFunction先是将要注册的方法转换成了供平台使用的指针，传递到 C 中生成可以供 lua 使用的 LuaCSFunction 函数\n// LuaState.cspublic void RegFunction(string name, LuaCSFunction func)&#123;    IntPtr fn = Marshal.GetFunctionPointerForDelegate(func);    LuaDLL.tolua_function(L, name, fn);            &#125;\n\ntolua.c 文件中 tolua_function 对传入进的函数进行了绑定\n/* tolua.c */LUALIB_API void tolua_function(lua_State *L, const char *name, lua_CFunction fn)&#123;    lua_pushstring(L, name);    tolua_pushcfunction(L, fn);    lua_rawset(L, -3); // 赋值操作：将栈顶作为 v:CClosure，倒数第二位作为 k:name，-3 位置作为 table 进行赋值 ，即 XXX[name] = CClosure&#125;LUA_API int tolua_pushcfunction(lua_State *L, lua_CFunction fn)&#123;            lua_pushboolean(L, 0); // 压入布尔值 false top [0(false),name,XXX(table)] bottom    lua_pushcfunction(L, fn); // 压入函数，这里会以 CClosure 结构体的形式被压入栈    lua_pushcclosure(L, tolua_closure, 2); // 这里会创建一个新的 CClosure 结构，并将栈顶 2 个元素（一个布尔值与一个存放了 fn 的 Closure) 弹出并压入 CClosure 结构体中，最终将新的 CClosure 压入栈中    return 0;&#125;\n\n\nlua_rawset(L, -3);\n赋值操作：将栈顶作为  值——CClosure，倒数第二位作为  键——name，-3 位置作为 table 进行赋值 ，即XXX[name] = CClosure\n\n\n    \n\n\n实际上一个 C# 方法的指针其实被封装了两层：\n\nlua_pushcfunction(L, fn)时 将 fn 封装进了 CClosure 中\nlua_pushcclosure(L, tolua_closure, 2)时将封装了 fn 的CClosure再一次封装进了新的 CClosure 中\n\n当在 lua 中调用注册的方法时，实际上是在调用最外层的 CClosure 结构体，它其中的方法是 tolua_closure，而 C# 方法指针fn 作为该结构体栈中的值被存放着upvalue\nstatic int tolua_closure(lua_State *L)&#123;    /*  获取到所注册的 C# 方法指针 */    lua_CFunction fn = (lua_CFunction)lua_tocfunction(L, lua_upvalueindex(2));    /*  运行 ，因为 lua 跨语言的数据交互都借助栈来完成，所以运行结果都是通过获取栈中元素来获得 */    int r = fn(L);           if (lua_toboolean(L, lua_upvalueindex(1)))    &#123;        lua_pushboolean(L, 0);        lua_replace(L, lua_upvalueindex(1));        return lua_error(L);    &#125;       return r;&#125;\n\n\nlua_pushfunction：实际上压入函数的过程就是形成闭包的过程，在 lua 中函数是以闭包的形式被保存的\n/* lua.h */#define lua_pushcfunction(L,f)  lua_pushcclosure(L, (f), 0) /* 宏 压入闭包方法 n 为 0 */\nlua_pushclosure：生成闭包，将函数存放在闭包结构体中，并将栈顶 n 个元素一同压入闭包内的栈\ntypedef struct CClosure &#123;  ClosureHeader;  lua_CFunction f;  TValue upvalue[1];  /* list of upvalues */&#125; CClosure;/* lua.h */LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);/* lapi.c */LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) &#123;  lua_lock(L);  if (n == 0) &#123;    setfvalue(L-&gt;top, fn);    api_incr_top(L);  &#125;  else &#123;    CClosure *cl;      api_checknelems(L, n);    api_check(L, n &lt;= MAXUPVAL, &quot;upvalue index too large&quot;);  /* #define MAXUPVAL 255  */    cl = luaF_newCclosure(L, n);/* 创建了闭包结构体  */    cl-&gt;f = fn;    L-&gt;top -= n;  /* 将栈顶 n 个元素移除并压入闭包的栈中 upvalue */    while (n--) &#123;      setobj2n(L, &amp;cl-&gt;upvalue[n], L-&gt;top + n);      /* does not need barrier because closure is white */    &#125;    setclCvalue(L, L-&gt;top, cl);    api_incr_top(L);    luaC_checkGC(L);  &#125;  lua_unlock(L);&#125;\n\n","categories":["Lua"],"tags":["lua"]},{"title":"Perforce 学习","url":"/2022/01/25/289bc491b2cd/","content":"\n    \n\n\n\n\nUsing Changelists to Manage FilesCheckout\n    \n\n\n修改文件，必须将其 Checkout，当Checkout 文件是，Perforce 会将有关文件的信息添加到 Changelists，并将本地工作区中文件的可写性从 只读  更改为  读 / 写\nChangelists\n    \n\n\n一个 Changelist 定义了一个文件和文件夹的逻辑上的分组\nChangelist 内容  一个 Changelist 中包含的信息包括 Changelist 的标识符、文件列表、更改提交的日期等等。一个 Changelist 中的文件更改的方式，可以是任意的，包括对文件内容的编辑、文件和文件夹的添加或删除、文件重命名等\nChangelist 种类Changelist 可以处于以下三种状态之一：Pending、Submitted 和 Shelved\n\n    \n\n\n\n未提交的 Changelist 被称为 Pending Changelist 。\n一旦 Changelist 成功提交到服务器，Changelist 状态将更新为 Submitted。\nShelved 是一种特殊形式的待定 Changelist。可以使用 Shelved 的 Changelist 将工作区文件临时存储在服务器上，而无需将更改提交到版本文件存储库。\n\nPerforce 服务器会追踪在系统元数据中存储的 Pending Changelist 中 Checkout 的文件。当在 Perforce GUI 客户端中查看 Changelist 时，正在查看的是存储在服务器上的 Changelist 的本地副本\n默认 Changelist 和编号 ChangelistPerforce 在每个工作区的系统元数据中维护一个  默认  的 Pending Changelist。当 Checkout 文件时，可以将其添加到工作区的默认 Pending Changelist，或创建一个新的  编号 Pending Changelist。\n\n    \n\n\nChangelist 编号机制Perforce 维护一个编号序列，用于 Changelist 的 ID。当创建一个新的 Pending Changelist 时，Perforce 会使用序列中的下一个编号为 Changelist 分配一个 ID 编号。当提交在编号 Pending Changelist 中的修改时，Perforce 会验证最初分配给 Changelist 的编号是否仍然是序列中的下一个编号。如果不是（这在许多人同时在同一个仓库中工作时很常见），Perforce 会在将 Changelist 存储到系统元数据中之前，使用序列中的下一个编号为 Changelist 生成一个新的 ID 编号。\n因为 Perforce 按顺序为每个提交的 Changelist 生成唯一的 ID 号，因此 Changelist 的 ID 反映了每个 Changelist 提交到服务器的时间。\n\n    \n\n\nCleaning up files and directories\nChanges performed by the Clean option are permanent. You cannot revert this operation.\n\n\nSelect a folder and click Actions &gt; Clean, or right-click a folder and select Clean.\nIf there are files that need to be cleaned up, the Clean Workspace (Revert to Depot) dialog appears.\nP4V compares your workspace to the depot and lists the following files:\n\nFiles that were modified locally without being checked out\nLocal files that are not in the depot\nDepot files that are missing from your local workspace\n\n\nBy default, all files are selected for cleanup. If there are any files that you do not want to clean up, clear the respective check boxes.\n\nBy default, files and directories listed in P4IGNORE files are excluded from cleanup and remain unaffected. If you do want to include such files, clear the Apply P4IGNORE files for this workspace check box.\nIn this case, P4V compares your workspace to the depot again and then also lists applicable files that were previously excluded in the respective section.\n\nClick Clean.\n\nIn the Confirm Deleting and Reverting Files dialog, click Continue to confirm the operation.\n\n\n","categories":["日常"],"tags":["p4v","版本控制"]},{"title":"Lua API","url":"/2022/01/14/e4c1a6355096/","content":"lua_gettablevoid lua_gettable(lua_State *L, int index);\n\n把 t[k] 值压入堆栈， 这里的 t 是指有效索引 index 指向的值， 而 k 则是栈顶放的值。这个函数会弹出堆栈上的 key（把结果放在栈上相同位置），在 Lua 中这个函数可能触发对应 __index 事件的元方法\n\n    \n\n\nlua_settablevoid lua_settable(lua_State *L, int index);\n\n作一个等价于 t[k] = v 的操作， 这里 t 是一个给定有效索引 index 处的值， v指栈顶的值， 而 k 是栈顶之下的那个值。这个函数会把键和值都从堆栈中弹出。 在 Lua 中这个函数可能触发 __newindex 事件的元方法\nlua_rawset &amp; lua_rawgetvoid lua_rawset(lua_State *L, int index);void lua_rawget(lua_State *L, int index);\n\nlua_rawset类似于 lua_settable， 但是是作一个直接赋值，不触发元方法；lua_rawget 类似于lua_gettable， 但是作一次直接访问，不触发元方法\nlua_rawseti &amp; lua_rawgetivoid lua_rawgeti(lua_State *L, int index, int n);void lua_rawseti(lua_State *L, int index, int n);\n\n\nlua_rawgeti：把 t[n] 的值压栈， 这里的 t 是指给定索引 index 处的一个值， 这是一个直接访问，不会触发元方法\nlua_rawseti：等价于 t[n] = v，这里的t 是指给定索引 index 处的一个值， 而 v 是栈顶的值，不会触发元方法\n\n","categories":["Lua"],"tags":["lua"]},{"title":"C++ 14 新特性","url":"/2022/02/09/7c2bd2c42898/","content":"\n    \n\n\n\n函数返回值类型推导#include &lt;iostream&gt;using namespace std;auto func(int i) &#123;    return i;&#125;int main() &#123;    cout &lt;&lt; func(4) &lt;&lt; endl;    return 0;&#125;\n\n上面的代码使用 C++11 是不能通过编译的，这个特性需要到 C++14 才被支持\n返回值类型推导也可以用在模板中：\n#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt; auto func(T t) &#123; return t; &#125;int main() &#123;    cout &lt;&lt; func(4) &lt;&lt; endl;    cout &lt;&lt; func(3.4) &lt;&lt; endl;    return 0;&#125;\n\n\n\n函数内如果有多个 return 语句，它们必须返回相同的类型，否则编译失败\n如果 return 语句返回初始化列表，返回值类型推导也会失败\n如果函数是虚函数，不能使用返回值类型推导\n\n\nlambda参数 auto 在 C++11 中，lambda表达式参数需要使用具体的类型声明，在 C++14 中，对此进行优化，lambda表达式参数可以直接是auto\n变量模板C++14 支持变量模板\ntemplate&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L);int main() &#123;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl; // 3    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl; // 3.14159    return 0;&#125;\n\n别名模板template&lt;typename T, typename U&gt;struct A &#123;    T t;    U u;&#125;;template&lt;typename T&gt;using B = A&lt;T, int&gt;;int main() &#123;    B&lt;double&gt; b;    b.t = 10;    b.u = 20;    cout &lt;&lt; b.t &lt;&lt; endl;    cout &lt;&lt; b.u &lt;&lt; endl;    return 0;&#125;\n\nconstexpr的限制 C++14 相较于 C++11 对constexpr 减少了一些限制：\n\nC++11 中 constexpr 函数可以使用递归，在 C++14 中可以使用局部变量和循环\nC++11 中 constexpr 函数必须必须把所有东西都放在一个单独的 return 语句中，而 C++14 则无此限制：\n\n[[deprecated]]标记C++14 中增加了 deprecated 标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用\n二进制字面量与整形字面量分隔符C++14 引入了二进制字面量，也引入了分隔符\nint a = 0b0001&#x27;0011&#x27;1010;double b = 3.14&#x27;1234&#x27;1234&#x27;1234;\n\nstd::make_uniqueC++11 中有std::make_shared，却没有std::make_unique，在 C++14 已经改善\nstd::shared_timed_mutex与 std::shared_lockC++14 通过std::shared_timed_mutex 和std::shared_lock来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行\nstruct ThreadSafe &#123;    mutable std::shared_timed_mutex mutex_;    int value_;    ThreadSafe() &#123;        value_ = 0;    &#125;    int get() const &#123;        std::shared_lock&lt;std::shared_timed_mutex&gt; loc(mutex_);        return value_;    &#125;    void increase() &#123;        std::unique_lock&lt;std::shared_timed_mutex&gt; lock(mutex_);        value_ += 1;    &#125;&#125;;\n\nstd::integer_sequencetemplate&lt;typename T, T... ints&gt;void print_sequence(std::integer_sequence&lt;T, ints...&gt; int_seq)&#123;    std::cout &lt;&lt; &quot;The sequence of size &quot; &lt;&lt; int_seq.size() &lt;&lt; &quot;: &quot;;    ((std::cout &lt;&lt; ints &lt;&lt; &#x27; &#x27;), ...);    std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123;    print_sequence(std::integer_sequence&lt;int, 9, 2, 5, 1, 9, 1, 6&gt;&#123;&#125;);    return 0;&#125;输出：7 9 2 5 1 9 1 6\n\nstd::exchangestd::exchange实现\ntemplate&lt;class T, class U = T&gt;constexpr T exchange(T&amp; obj, U&amp;&amp; new_value) &#123;    T old_value = std::move(obj);    obj = std::forward&lt;U&gt;(new_value);    return old_value;&#125;\n\nstd::quotedC++14 引入 std::quoted 用于给字符串添加双引号\nint main() &#123;    string str = &quot;hello world&quot;;    cout &lt;&lt; str &lt;&lt; endl;    cout &lt;&lt; std::quoted(str) &lt;&lt; endl;    return 0;&#125;\n","categories":["C++"],"tags":["C++","C++ 14"]},{"title":"Pytorch 笔记","url":"/2022/02/21/7c5a55cd05b9/","content":"torch.cat()在给定维度上对输入的张量序列进行连接操作\n\nArgs\ntensors (sequence of Tensors): any python sequence of tensors of the same type. 任意 Tensor 类型的 python 序列，序列中的数据是任意相同 shape 的同类型的Tensor\nNon-empty tensors provided must have the same shape, except in the cat dimension.\n\n\ndim (int, optional): the dimension over which the tensors are concatenated 维度不能超过输入数据任意一个张量的维度\n\n\nKeyword args: out (Tensor, optional): the output tensor.\n\ntorch.gather()torch.gather(input, dim, index, *, sparse_grad=False, out=None) -&gt; Tensor\n\n沿着由 dim 指定的轴收集数值\n\ndim = 0的情况，代表的是横向，按行取值\nlength矩阵中的数的值代表的是行数，所在列代表的是列数\n\n\n\ninput = [    [0.0, 0.1, 0.2, 0.3],    [1.0, 1.1, 1.2, 1.3],    [2.0, 2.1, 2.2, 2.3]]#shape [3,4]input = torch.tensor(input)length = torch.LongTensor([    [2,2,2,2],    [1,1,1,1],    [0,0,0,0],    [0,1,2,0]])#[4,4]out = torch.gather(input, dim=0, index=length)\n\ntensor([[2.0000, 2.1000, 2.2000, 2.3000],        [1.0000, 1.1000, 1.2000, 1.3000],        [0.0000, 0.1000, 0.2000, 0.3000],        [0.0000, 1.1000, 2.2000, 0.3000]])\n\n用矩阵的方式演示\n\nlength矩阵中的数的值代表的是行数，数的位置代表的列数，比如 length 矩阵中的第三行第三列（从 0 数起）的数 0，其值是 0，代表在 input 中所取的数是第 0 行，位置是第三列，则表示在 input 中所取的数是第三列，\n\ndim = 1的情况\nlength矩阵中的数的值代表的是列数，所在行代表的是行数\n\n\n\ninput = [    [0.0, 0.1, 0.2, 0.3],    [1.0, 1.1, 1.2, 1.3],    [2.0, 2.1, 2.2, 2.3]]#shape [3,4]input = torch.tensor(input)length = torch.LongTensor([    [2,2,2,2],    [1,1,1,1],    [0,1,2,0]])#[3,4]out = torch.gather(input, dim=1, index=length)\n\ntensor([[0.2000, 0.2000, 0.2000, 0.2000],        [1.1000, 1.1000, 1.1000, 1.1000],        [2.0000, 2.1000, 2.2000, 2.0000]])\n\n对应的取值矩阵是\n\nunsqueeze()和 squeeze()unsqueeze()函数 torch.unsqueeze(input, dim, out=None) 扩展维度，返回一个新的张量，对输入的既定位置插入维度1\n\n            返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个\n          \n\nx = torch.Tensor([1, 2, 3, 4]) # torch.Tensor 是默认的 tensor 类型（torch.FlaotTensor）的简称x # tensor([1., 2., 3., 4.])x.size() # torch.Size([4])x.dim() # 1x = torch.Tensor([1, 2, 3, 4])x = torch.unsqueeze(x, 0) # tensor([[1., 2., 3., 4.]])x.size() # torch.Size([1, 4])x.dim() # 2x = torch.Tensor([1, 2, 3, 4])x = torch.unsqueeze(x, 1) # tensor([[1.], [2.], [3.], [4.]])x.size() # torch.Size([4, 1])x.dim() # 2x = torch.Tensor([1, 2, 3, 4])x = torch.unsqueeze(x, -1) # tensor([[1.], [2.], [3.], [4.]])x.size() # torch.Size([4, 1])x.dim() # 2x = torch.Tensor([1, 2, 3, 4])x = torch.unsqueeze(x, -2) # tensor([[1., 2., 3., 4.]])x.size() # torch.Size([1, 4])x.dim() # 2\n\n边界测试A dim value within the range [-input.dim() - 1, input.dim() + 1)\nx = torch.Tensor([1, 2, 3, 4])torch.unsqueeze(x, -3)\n\n\n            IndexError: Dimension out of range (expected to be in range of [-2, 1], but got -3)\n          \n\nx = torch.Tensor([1, 2, 3, 4])torch.unsqueeze(x, 2)\n\n\n            IndexError: Dimension out of range (expected to be in range of [-2, 1], but got 2)\n          \n\n\n为何取值范围要如此设计呢？原因：方便操作 0(-2)- 行扩展1(-1)- 列扩展 正向：我们在 0，1 位置上扩展  逆向：我们在 -2，-1 位置上扩展  维度扩展：1 维 -&gt;2 维，2 维 -&gt;3 维，…，n 维 -&gt;n+1 维  维度降低：n 维 -&gt;n-1 维，n-1 维 -&gt;n-2 维，…，2 维 -&gt;1 维\n以 1 维 -&gt;2 维 为例，\n从  正向  的角度思考：\ntorch.Size([4])最初的 tensor([1., 2., 3., 4.]) 是 1 维，我们想让它扩展成 2 维，那么，可以有两种扩展方式：\n一种是：扩展成 1 行 4 列 ，即 tensor([[1., 2., 3., 4.]])针对第一种，扩展成 [1, 4] 的形式，那么，在 dim=0 的位置上添加 1\n另一种是：扩展成 4 行 1 列，即 tensor([[1.], [2.], [3.], [4.]]) 针对第二种，扩展成 [4, 1] 的形式，那么，在 dim=1 的位置上添加 1\n从  逆向  的角度思考：原则：一般情况下， -1是代表的是  最后一个元素  在上述的原则下  扩展成 [1, 4] 的形式，就变成了，在 dim=-2 的的位置上添加 1扩展成 [4, 1] 的形式，就变成了，在 dim=-1 的的位置上添加 1\n\nunsequeeze_和 unsqueeze 的区别 unsqueeze_ 和unsqueeze实现一样的功能，区别在于 unsqueeze_ 是in_place操作，即 unsqueeze不会对使用 unsqueeze 的tensor进行改变，想要获取 unsqueeze 后的值必须赋予个新值，unsqueeze_则会对自己改变\nsqueeze()函数  作用是降维，torch.squeeze(input, dim=None, out=None)将输入张量形状中的 1 去除并返回。 如果输入是形如 (A×1×B×1×C×1×D)，那么输出形状就为：(A×B×C×D)。当给定dim 时，那么挤压操作只在给定维度上。例如，输入形状为:(A×1×B), squeeze(input, 0)将会保持张量不变，只有用squeeze(input, 1)，形状会变成(A×B)\n\n            和 unsqueeze 一样，返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个\n          \n\n多维张量本质上就是一个变换，如果维度是 1 ，那么，1 仅仅起到扩充维度的作用，而没有其他用途，因而，在进行降维操作时，为了加快计算，是可以去掉这些 1 的维度\nm = torch.zeros(2, 1, 2, 1, 2)print(m.size())  # torch.Size([2, 1, 2, 1, 2])n = torch.squeeze(m)print(n.size())  # torch.Size([2, 2, 2])n = torch.squeeze(m, 0)  # 当给定 dim 时，那么挤压操作只在给定维度上print(n.size())  # torch.Size([2, 1, 2, 1, 2])n = torch.squeeze(m, 1)print(n.size())  # torch.Size([2, 2, 1, 2])n = torch.squeeze(m, 2)print(n.size())  # torch.Size([2, 1, 2, 1, 2])n = torch.squeeze(m, 3)print(n.size())  # torch.Size([2, 1, 2, 2])p = torch.zeros(2, 1, 1)print(p)# tensor([[[0.]],#         [[0.]]])print(p.numpy())# [[[0.]]#  [[0.]]]print(p.size())# torch.Size([2, 1, 1])q = torch.squeeze(p)print(q)# tensor([0., 0.])print(q.numpy())# [0. 0.]print(q.size())# torch.Size([2])print(torch.zeros(3, 2).numpy())# [[0. 0.]#  [0. 0.]#  [0. 0.]]\n","categories":["深度学习"],"tags":["pytorch","python"]},{"title":"Git 常用命令","url":"/2022/02/09/fe38b8191226/","content":"\n    \n\n\n\n强制覆盖本地代码（与 git 远程仓库保持一致）git fetch --all # 拉取所有更新，不同步git reset --hard origin/master # 本地代码同步线上最新版本（会覆盖本地所有与远程仓库上同名的文件）git pull # 再更新一次\n\nPlease move or remove them before you can merge\n    \n\n\ngit clean -d -f # To remove &amp; delete all changes\n\nGit 推送本地分支到远端  远程先开好分支然后拉到本地git checkout -b =&lt;branch&gt; origin/&lt;branch&gt;\n\n本地先开好分支然后推送到远程git checkout -b &lt;branch&gt; # 创建并切换到分支 &lt;branch&gt;  git push origin &lt;branch&gt; # 推送本地的 &lt;branch&gt; 分支到远程 origin 的 &lt;branch&gt; 分支\n\nGit 回滚代码到某个 commitgit reset --hard HEAD^ # 回退到上个版本git reset --hard HEAD~3 # 回退到前三次提交之前git reset --hard &lt;commit-id&gt; 退到 / 进到指定 &lt;commit-id&gt; 的 hashm\n","categories":["日常"],"tags":["git"]},{"title":"领域驱动设计","url":"/2022/03/07/79134dd55083/","content":"\n    \n    DDD 基本概念图\n\n\n通用类概念  领域驱动设计 DDD\nDDD 是 Domain-Driven Design 的缩写，是 Eric Evans 于 2004 年提出的一种软件设计方法和理念。\n其主要的思想是，利用确定的业务模型来指导业务与应用的设计和实现。主张开发人员与业务人员持续地沟通和模型的持续迭代式演化，以保证业务模型与代码实现的一致性，从而实现有效管理业务复杂度，优化软件设计的目的。\n\n模型 Model\n通常，模型是对对象、人或系统的信息表示。它通过较为简单的信息结构来代表我们需要理解的复杂事物或系统。\n地图、乐高、算筹都是模型，模型可以简化复杂事务的认知。我们天生就有用简单的东西代表另外一个东西的能力，比如幼儿园数数用的竹签，学习物理时的刚体、真空中的球形鸡，都是模型。通俗来说模型就是经验的抽象集合，平时听到的谚语、公式、定理，本质上都是一种模型。\n\n建模 Modeling\n建模是构建模型的过程。\n在软件设计过程中，通过分析业务，将业务需求使用合适的模型表示出来，是建模的任务。模型可以作为业务分析的产出，并作为软件设计的重要理论基础。 比如在分析一个电商应用的业务时，抽象出订单、商品等概念，进一步定义出模型，并用合适的图例表达，往往是 UML 来表达。\n\n模型驱动设计 Model-Driven Design\n面向模型的分析设计方法，优先通过识别模型来简化业务设计。\n在设计过程中，以模型为中心，始终维护模型，并基于此指导软件设计。\n\n软件设计 Software Design\n软件设计软件需求出发，对软件系统的整体结构、模块做出划分和规划，以便于具体代码的顺利编写。\n由于软件需求具有非结构化、准确的语义，软件设计往往通过经验完成，无法通过某种特定的推理路线严格推导实现。\n\n战略设计 Strategic Design\n战略设计也称为战略建模，是指对业务进行高层次的抽象和归类。主要手段包括理清上下文和进行子域的划分。\n战略设计关注模型的分离，其解决的问题是大的模型如何划分为小模型以及相互之间如何关联。战略设计的产出可以用于指导团队协作，使得规模巨大的软件可以被合理拆分。\n战略设计的产出通常为上下文图，以及模块或微服务划分。\n\n战术设计 Tactical Design\n战术设计也称为战术建模，是指对特定上下文下的模型进行详细设计。\n战术设计的对象包括聚合、实体和值对象，其目标是用明确它们是什么以及相互之间有何关系。战术设计的产出可以是用 UML 表达的类图，需要细化到具体的属性，同时确保在代码级别可实现。\n\n软件 Software\nDDD 讨论下的软件是指，用于解决具体业务问题的计算机程序，既可以是单体也可以是分布式系统。\n软件设计是 DDD 的最终目的，使用 DDD 的各种工具可以指导软件设计，最终构建出健壮、容易维护的软件。\n\n原则 Principle\n为了更好的践行 DDD，需要遵守几个原则：通用语言、聚焦核心域、协作共创和持续建模。\n这些原则是为了更好地服务业务，从业务驱动模型设计。\n\n通用语言 Ubiquitous\n通用语言（Ubiquitous language）是指在软件设计中，业务人员和开发人员需要使用无歧义的统一语言来对话。\n这些语言包括对概念的统一理解和定义，以及业务人员参与到软件建模中，否则业务的变化会造成软件巨大的变化。\n\n聚焦核心域 Focus\n核心域就是最关键的业务逻辑，聚焦核心域决定了软件的定位和投资重心。\n\n协作共创 Collaboration\n协作共创是指领域专家和业务专家共同建模。\n\n持续建模 Continuous\n持续建模是指模型需要随业务变化而被及时更新。\n\n上下文 Context\n上下文是语言学科的概念，指不同语境下的概念虽然相同的用词，可能具有不同的含义。\n在软件设计中，因为自然语言的原因，相同的用词导致实际是不同概念，会对建模和软件设计带来误导。同时，不同的上下文也是识别模型边界的手段。\n\n领域分析类概念  问题空间 Problem Space\n待解决的业务问题的集合。\n在 DDD 实践中，我们应该明确区分问题空间和解空间，避免混为一谈。\n\n领域 Domain\n领域（Domain）是业务相关知识的集合。\n通俗来说，领域就是业务知识。业务有一些内在规则，存在专业性，比如财务、CRM、OA、电商等不同领域的业务规则不同。计算机只是业务规则的自动化。\n\n子域 Sub Domain\n一个子域是领域的一部分。\n为了降低业务理解复杂度，DDD 实践中通常将领域划分为子域，通过分而治之的方法分析问题。\n\n核心域 Core Domain\n核心域是指领域中最核心的部分，通常对应企业的核心业务。\n核心域需要我们投入最大精力，进行充分的分析。因为它是一个企业能运转的基础。\n\n支撑域 Support Domain\n支撑域是一种特殊的子域，是指为了实现核心业务而不得不开发的业务所对应的相关知识的集合。\n例如，活动平台业务属于电商的支撑域，因为该业务对于电商企业并不是必需的，其存在的意义仅在于放大利润。\n\n通用域 General Domain\n通用域是另一种特殊的子域，对应的是业界已经有成熟方案的业务。\n通用域可以看做一种特殊的支撑域，可以使用标准部件来实现，短信通知、邮件等领域问题。\n\n建模类概念  解空间 Solution Space\n解空间是一个数学概念。是指满足问题的所有约束前提下，所有可行解的集合。在 DDD 的上下文中，指的是所有可能的解决方案的集合。\n解空间是相对问题空间存在的，认识到解空间存在的好处是解空间可以通过一些方法从问题空间导出，而不是通过猜测得出的。\n\n领域模型 Model\n领域模型（Model）是业务概念在程序中的一种表达方式。\n领域模型可以用来设计和理解整个软件结构。面向对象设计中的类概念是领域模型的一种表达方式。与此类似，UML 的建模方法也可以应用在对领域模型的表达上。在 DDD 实践中，领域模型应当尽量简洁，能反应业务概念即可。\n\n限界上下文 Bounded Context\n限界上下文是有明确边界的上下文。在 DDD 实践中领域模型会被限定在限界上下文当中。\n限界上下文强调概念的一致性。虽然传统的方法学已经在追求概念的一致性，但是忽略了系统的庞大性，不论系统多庞大，在系统任何位置同一概念通用。DDD 不追求全局的一致性，而是将系统拆成多块，在相同的上下文中实现概念一致性。\n识别上下文可以从概念的二义性着手，比如商品的概念在物流、交易、支付含义完全不一样，但具有不同内涵和外延，实际上他们处在不同上下文。\n界限上下文可以用于微服务划分、避免模型的不正确复用带来的问题。\n\n实体 Entity\n实体（Entity）是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性。\n\n值对象 Value Object\n值对象 （Value Ojbect）是一种特殊的领域模型，不可变，通过值判断同一性。\n实体可以使用 ID 标识，但是值对象是用属性标识，任何属性的变化都视为新的值对象。比如一个银行账户，可以由 ID 唯一标识，币种和余额可以被修改但是还是同一个账户；交易单中的金额由币种和数值组成，无论修改哪一个属性，金额都不再是原来的金额。\n\n聚合 Aggregate\n聚合（Aggregate）是一组生命周期强一致，修改规则强关联的实体和值对象的集合，表达统一的业务意义。\n聚合的意义在于让业务统一、一致，在面向对象中有非常重要价值。比如，订单中有多个订单项，订单的总价是根据订单项目计算而来的。如果没有经验的开发者直接对订单项的做出修改，而不是由订单统一处理业务逻辑，会造成业务的一致性问题。\n聚合需要在相同的上下文中，不能跨上下文。\n\n聚合根 Aggregate Root\n聚合根（ Aggregate Root）是聚合中最核心的实体，其他的实体和值对象都从属于这个实体。\n要管理聚合必须使用一个聚合根，然后使用聚合根来实现发现、持久化聚合的作用，完成统一的业务意义。一个聚合中有且只有一个聚合根，聚合也可以只有一个单独的实体。\n\n软件设计类概念  模块 Module\n模块（Module）一组类或者对象组成的集合。\n在 DDD 实践中推荐使用限界上下文和聚合来指导模块划分。同时，如果不是特别复杂的业务逻辑也可以不遵循该模式。\n\n仓储 Repository\n仓储（Repository）是以持久化领域模型为职责的类。\n仓储的目的是屏蔽业务逻辑和持久化基础设施的差异。例如，对于同样的持久化业务需求，在采用关系型数据库和非关系型数据库作为存储基础设施时的实现细节是有所不同的。\n软件的设计往往是围绕着对数据的修改完成的。经验不多的开发者往往会认为，软件的开发过程就是对数据库的增删改查。但实际上基于该认知的软件设计让软件难以维护。\n对于采用关系数据库作为存储基础设施的项目，仓库层可以被 ORM 实现。若不使用 ORM，则需自己实现仓库。\n\n服务 Service\n服务（Service）是领域模型的操作者，负责领域内的业务规则的实现。\n领域模型用于承载数据和系统状态，服务承载业务逻辑的实践。\n在实践中如果使用主、客体的思维来进行设计，则服务为主体，领域模型为客体。使用拟人化的方式来对服务进行命名，可以让开发者更容易理解。比如，一个维护客户数据的 CRM 应用中，客户数被抽象为模型： Client，对应的服务可以设计为：ClientManager。\n\n工厂 Factory\n工厂（Factory）是以构建领域模型（实体或值对象）为职责的类或方法。\n工厂可以利用不同的业务参数构建不同的领域模型。对于简单的业务逻辑实现可以不使用工厂。工厂的实现不一定是类的形式，也可以是具备工厂功能的方法。\n在面向对象程序设计中，工厂是一种设计模式。在广义的工厂模式中，工厂可以根据不同的规则的业务需求构造不同的对象。例如在 Redis 连接客户端的实现中，可以使用 Redis 单机、哨兵、集群等不同的方式来构建 Redis 连接客户端。\n\n策略 Strategy\n策略（Strategy）是业务规则的实现方式。\n例如通知业务，可以使用不同的渠道来实现，不同渠道的实现逻辑可以认为是不同的策略。 在面向对象程序设计中，策略模式也是一种设计模式，是多态的一种实现模式。\n策略通常会搭配着接口来设计。如果说接口是一种契约，那策略就是契约的履约方式。\n\n规格 Specification\n规格（Specification） 是一些特殊的业务规则。通常表现为用于校验（e.g. 数据格式，业务逻辑）、查询和搜索条件。\n在实践中，规格既可以被设计为灵活的查询或校验条件，也可以被抽象出来以便复用。\n例如，在 JPA、MongoDB、ElastiSearch 和一些具有查询能力的 ORM 都大量使用这种设计方式，同样的在应用程序中我们也可以参考这种设计模式，把业务的规则提取出来。\n\n分层架构（逻辑）\n分层架构是指在软件设计过程中按照既定的原则将不同的功能实现拆分到不同的层级进行实现的一种设计方式。每个层级有独立的职责，多个层次协同以提供完整功能。按照 DDD 的分层模型，通常可以划分为：接入层、应用层、领域层、基础设施层\n分层架构在具体的软件中可以表现为不同的形式。例如，在分布式系统中，不同层级的软件实现，可以表现为独立部署的服务。而在单体系统中，分层可以用不同的模块或包来实现。\n分层架构的设计理念与计算机网络的层级结构类似，上层依赖下层的实现，而下层实现无需关心上层实现。例如，HTTP 协议构建在 TCP 协议之上，TCP 协议只负责提供传输层的能力，而不需要知道具体的应用层协议。\n分层架构中层级的数量需要依照系统复杂度来定，并不需要死板地按照 DDD 推荐的四层来进行设计。在简单的系统中，可以通过减少分层来避免样板代码，减少冗余。例如，在 web 系统中有时候只有一种接入方式，接入层和应用层能力高度重叠，可以考虑直接使用应用层代替接入层。\n软件框架的使用，通常会引入新的层级，从而影响系统整体的分层架构。例如，ORM 框架本身就提供了对 Repository 的一层抽象。\n\n接入层 Interface\n接入层负责的是系统的输入和输出。\n接入层只关心沟通协议，不关心业务相关的数据校验。 接入层的实现是与业务应用强相关的，不同的业务应用有不同的实现方式。例如，对于普通的 Web 应用，基于 HTTP 协议的 API 是一种接入层实现方式；对于 IoT 传感器的数据上传业务，接入层的实现可能需要基于 websocket 或 MQTT 协议。\n接入层的特点：\n接入层对应用数据透明，只关心数据格式而不关心数据的内容\n在大部分单体系统中接入层通常被框架实现。例如，在 Spring Boot 框架中，HTTP 协议的 API 设计不需要关注 HTTP 协议本身。\n在分布式系统中接入层通常被网关实现。\n\n\n\n应用层 Application\n应用层，组织业务场景，编排业务，隔离场景对领域层的差异。\n应用层遵循面向对象核心思想中的 “关注点分离” 理念。应用层的关注点在于业务场景的处理。例如，对于一个服务多种类型用户的应用，to C 的网页界面和后台管理界面对应的是不同的业务场景。对于新用户注册这个业务来说，通过 to C 的网页注册和通过后台管理界面进行后台注册是不同的业务场景。然而，“用户注册”在系统层面的基本逻辑是一样的。所以，“用户注册”的基本业务逻辑可以交由领域层来实现。而两种不同渠道进行用户注册所需要进行的身份验证等逻辑，可以设计在应用层进行实现。这样便能达到关注点分离，复用核心业务逻辑的目的。\n应用层的特点：\n关心处理完一个完整的业务\n该层只负责业务编排，对象转换，而具体的业务逻辑由领域层实现\n虽不关心请求从何处来，但关心谁来、做什么、有没有权限做\n利用不同的领域服务来解决问题\n对最终一致性有要求的业务和事务处理需要放到应用层来处理\n功能权限放到这层\n\n\n\n领域层 Domain\n领域层，实现具体的业务逻辑、规则，为应用层提供无差别的服务能力。\n实际处理业务的地方，领域层需要对应用层提供无差别的服务和能力。例如，对于用户注册的场景，用户既可以通过邮箱自己注册，也可以由管理员在后台进行添加。用户注册的核心逻辑可以由领域层完成，但是对于不同渠道进行用户注册的参数校验和权限验证等逻辑则由应用层实现。\n领域层的特点：\n不关心场景，关心模型完整性和业务规则\n不关心谁来，不关心场景完整的业务，关心当前上下文的业务完整\n强一致性事务放到这层，聚合的事务是 “理所当然的”\n对应到分布式系统中的 domain service、后台等概念\n领域层做业务规则验证\n数据权限放到这层（比如只允许删除自己创建的商品），因为数据权限涉及业务规则\n根据业务情况，参考反范式理论，跨上下文使用值对象做必要的数据冗余\n\n\n\n基础设施层 Infrastructure\n基础设施层，提供具体的技术实现，比如存储，基础设施对业务保持透明。\n对于基础设施层来说，基础设施层并不是指 MySQL、Redis 等外部组件，而是外部组件的适配器，Hibernate、Mybatis、Redis Template 等，因此在 DDD 中适配器模式被多次提到，基础设施层往往不能单独存在，还是要依附于领域层。技术设施层的适配器还包括了外部系统的适配，互联网产品系统的外部系统非常多，常见的有活体监测、风控系统、税务发票等。\n技术设施层的特点：\n关心存储、通知、第三方系统等外部设施（防腐层隔离）\n基础设施的权限由配置到应用的凭证控制，例如数据库、对象存储的凭证，技术设施层不涉及用户的权限\n\n\n\n部署架构（物理）\n部署架构是指具体的架构实现\n主要是在分布式系统、单体系统，甚至在客户端软件中体现。\n把逻辑架构和部署架构区分开可以很好的理解软件设计上和部署上的不同，对于应用构架来说，逻辑上的设计不一定对应部署结构。\n这样就很好理解 DDD 在不同场合中的使用方式，避免生搬硬套。当 DDD 的分层结构在单体应用中使用时，每层可能使用包、模块来表达，在微服务中使用时候，每层可能由不同角色的微服务来完成。\n\n微服务 Micro Service\n微服务是一种低耦合的分布式应用系统。\n维基百科的定义是：一种软件开发技术 - 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。这个定义没有问题，但是忽略了一个重要的信息，微服务是一种分布式架构，微服务必须面对分布式系统的各种问题。\n分布式系统是通过计算机网络连接、协同工作的 IT 系统，因此在使用 DDD 时候，需要为这种系统做适配，而不是简单的做出切分。\n\n单体 Monomer\n单体是主要业务实现和部署在单一服务器上的应用。\n单体系统是相对于微服务来说的，其特点是主要的实现在单一的服务器中。\n\n分布式应用系统 Distributed\n分布式应用系统是建立在计算机网络之上的应用软件系统，不同单元通过计算机网络集成。\n\n事件风暴类概念  事件风暴 Event Storming\n事件风暴是一种以工作坊的形式，使用 DDD 建模的方式。\n事件风暴的发明人是 Alberto Brandolini ，它来源于 Gamestorming，通过工作坊的方式将领域专家和技术专家拉到一起，进行建模。\n事件风暴是一种捕获行为需求的方法，类似传统软件的开发用例分析。所有人员（领域专家和技术专家） 对业务行为进行一次发散，并最终收敛达到业务的统一。\n\n领域事件 Domain Event\n事件是系统状态发生的某种客观现象，领域事件是和领域有关的事件。\n领域事件（Domain Event），是在业务上真实发生的客观事实，这些事实对系统会产生关键影响，是观察业务系统变化的关键点。领域事件一般是领域专家关心的。\n事件的评价方式是系统状态是否发生变化。系统状态变化意味着领域模型被业务规则操作，这是观察系统业务的好方法。\n识别领域事件的线索有：\n是否产生了某种数据\n系统状态是否发生变化，无论这种状态存放到数据库还是内存\n是否对外发送了某些消息\n\n\n\n业务规则 Policy\n业务规则是指对业务逻辑的定义和约束。\n不同的业务规则往往意味着不同的领域事件被触发，未来在技术实现时可能是一些分支条件，对应 DDD 实现中可能通过领域服务、规格、策略等方式实现。\n业务规则的识别是为了将数据和算法分开。\n\n命令 Command\n命令是执行者发起的操作，构成要件是执行者和行为。\n命令可以类比于 UML 分析中的业务用例，是某个场景中领域事件的触发动作。\n\n执行者 Actor\n执行者是指使用系统的主体，是导致系统状态变化的触发源。\n执行者有点像 UML 的涉众，不过区别是执行者不仅是用户，还包括外部系统和本系统。 在事件风暴中，执行者可以是：用户、外部系统、本系统、定时器。\n\n用户 User\n用户是执行者的一种，是指使用软件或服务的人。\n用户可以有不同的角色，通常我们会把不同角色的相似行为作为不同的命令来处理，有可能得到同样的事件。比如系统出现了商品已添加的事件，有可能有多个触发的场景：\n系统管理员在后台中添加\n商户在自己的管理平台中添加\n导入任务在特定时间添加\n\n\n1 和 2 是用户的行为，不过是不同的角色。\n\n外部系统 Out System\n外部系统是执行者的一种，系统开放 API 的调用发起者。\n有一些系统会提供对外的 API 给外部系统，这时候外部系统也会发出命令让系统产生事件，这里的外部系统特指作为执行者的外部系统。\n\n本系统 System\n本系统是执行者的一种，指系统本身。\n事件的触发可以由用户、外部系统、定时器触发，也可以由上一个事件触发，因此这里的触发者（主体）就是系统本身。\n\n定时器 Timer\n定时器是执行者的一种，通常是定时任务。\n定时器可以作为执行者，不过需要区别于本系统这个触发源。定时器可以看待为外部一个时间信号源，类似于计算机中主机中的振荡器。\n\n参与人 Participants\n作为工作坊的参与人员（应区别于执行者）。\n参与人只是一种角色，而非具体的一个人，可以是多个自然人做群体参与，也可以一人分饰不同的角色。\n在开始工作坊之前，参与人需要满足一些条件：\n参与人需要对解决的问题和产出目标达成共识\n参与人需要 DDD 的基本知识或接受过基本培训\n领域专家、技术专家需要能全程参加\n\n\n\n领域专家 Domain Expert\n领域专家是指熟悉业务规则的人，在工作坊中一般是能敲定业务规则的人。\n在实际的事件风暴工作坊中，领域专家是一个比技术专家更难获得人，一个合格的、能让工作坊进展下去的领域专家需要有几个要求：\n了解现有业务个情况\n能对具体的业务方向做出结论性的输出\n在做工作坊时，需要分清现状（As-IS）和目标（To-Be）业务，现状业务很多人都能说出来，不过真正的领域专家是能对目标业务做出描述的人\n\n\n\n技术专家 Tech Expert\n技术专家是指熟悉技术方案和实现方式的人，能给出可行的技术方案和了解基础设计的限制条件。\n技术专家需要能对现有的技术做出描述，而未来的技术选型可能是动态的，能有一定预见性最好。技术专家往往是当前团队中最熟悉架构和代码的人。\n\n主持人 Facilitator\n主持人工作坊流程的推动者，以及 DDD 方法论的守护者。\n在一些工作坊中，主持人往往是外部的咨询师，他们有大量的实践经验，需要能对 DDD 的概念、方法有成体系的研究，并能推动工作坊进行。\n\n","categories":["软件工程"],"tags":["DDD","设计"]},{"title":"尝试 Visual Code 调试 Lua","url":"/2022/07/27/04b7f04d08ea/","content":"namespace LuaTools&#123;    static class LuaDebugWithVsCode    &#123;        public static void Debug()        &#123;            IMLua luaEngine = MInterfaceMgr.singleton.GetInterface&lt;IMLua&gt;(MCommonFunctions.GetHash(&quot;MLua&quot;));            if (luaEngine != null)            &#123;                var str = string.Format(@&quot;local func = function()                local path = &quot;&quot;C:/Users/mingzhewang/.vscode/extensions/tangzx.emmylua-0.5.5/debugger/emmy/windows/x64/emmy_core.dll&quot;&quot;                package.cpath = package.cpath..&quot;&quot;;&quot;&quot;..path                local dbg = require(&quot;&quot;emmy_core&quot;&quot;)                dbg.tcpConnect(&quot;&quot;localhost&quot;&quot;, 9966)                end            local handle = function()                logError(&quot;&quot;VS Code 没有开启调试 &quot;&quot;)            end            xpcall(func, handle)&quot;);                luaEngine.DoString(str);            &#125;            else            &#123;                EditorUtility.DisplayDialog(&quot;LuaFast Execute Failed!&quot;, &quot; 获取 luaEngine 失败 &quot;, &quot;OK&quot;);            &#125;        &#125;    &#125;&#125;\n","categories":["日常"],"tags":["调试 Lua","Visual Code"]},{"title":"渲染管线","url":"/2021/11/05/bc62e4de65c0/","content":"\n\n应用阶段  准备好场景数据，包括 Camera 的位置、朝向，视锥体，场景物件、光源信息，渲染对象的渲染状态准备包括材质、纹理、Shader 等基本信息，调用渲染图元的指令。\n\n把数据加载到显存\n设置渲染状态\n调用 DrawCall\n\n几何阶段  传入顶点数据，经过顶点着色器、曲面细分着色器、几何着色器、三角形裁剪、屏幕映射。\n\n顶点着色器：操作顶点，可编程。主要是坐标变换和逐顶点光照，输出后续阶段需要的数据，从模型空间到齐次裁剪空间。\n曲面细分着色器、几何着色器：目前在手机上支持不是很好，手机渲染基本上不能用。\n三角形裁剪：把那些不在摄像机视野范围内的顶点裁剪掉，并剔除掉不在屏幕范围内的顶点。这个过程可配置。\n屏幕映射：把图元的顶点坐标转化为屏幕坐标系的二维坐标，输入的是三维坐标（归一化的 NDC 坐标）。\n\n光栅化阶段  光栅化阶段的目的有两个：①计算每个图元覆盖了那些像素，②为这些像素计算他们的颜色。\n\n三角形设置：上一个阶段，我们已经拿到了图元顶点的屏幕二维坐标，包括顶点法线、深度值、视角方向等信息，根据这些信息，我们来计算光栅化一个三角形所需要的信息，比如该三角形包含那些像素点等。\n三角形遍历：在这个阶段会检测每个像素的中心（或者说每个采样点）是否被三角形覆盖，像素中三角形覆盖的部分会生成一个 fragment，而寻找采样点或者像素位于哪个三角形上，这一过程被称为三角形遍历。而三角形中我们所生成的每一个fragment，其属性都由三角形的顶点插值而来。这些属性包括fragment 的深度和从几何阶段传输来的其他着色数据\n片元着色器：可编程，作用是处理上一个阶段生成的每个片元，最终计算出每个像素的最终颜色。实际上就是数据的集合。这个数据集合包含每个像素的各个颜色分量和像素透明度的值。\n逐片元操作：修改颜色，修改深度，混合\n屏幕图像\n\n\n\n顶点数据  一个模型或者图形是由点线面构成的，为了让计算机绘制出这个图形，就必须告诉计算机这些数据的值，顶点数据包括顶点坐标、坐标的法线、坐标的切线、颜色等信息。 对于 OpenGL，这些数据一般都是向量结构体。对于游戏引擎，这些数据来自导入的模型中。在开始渲染之前，CPU 会获取这些数据，然后传递给 GPU，作为最原始数据，做好计算准备。\n顶点着色器  顶点着色器（vertex shader） 在渲染管线中的作用非常大，是渲染管线的第一个可编程着色器。处理单元是顶点数据。顶点着色器的主要功能是对坐标进行变换。将输入的局部左边变换到世界坐标、观察坐标和裁剪坐标。 除此之外当然也可以进行光照着色，但是着色效果远不如在片元着色器中进行光照着色，因为计算量较小。\n图元装配  图元装配（primitive assembly）是对传入的顶点数据进行重新组装，将顶点着色器的输出作为输入。 这一点正验证了渲染的过程是以流水线的形式进行的，图元装配会将顶点装配成指定的图形，与此同时，会进行裁剪、表面剔除等操作，以减少不必要的计算，加速渲染过程。\n几何着色器  几何着色器（geometry shader）会将图元装配阶段的数据作为输入数据。几何着色器属于不可编程阶段，由硬件设备自动完成， 其重要作用是对顶点数据进行重构， 可以在此阶段产生新的顶点数据，来弥补之前存在的一些问题。以便为接下来要进行的操作做好充分的准备工作。\n光栅化  光栅化阶段（rasterization stage）的数据输入来自几何着色器的输出数据，为了实现顶点到屏幕像素的映射。 光栅化的作用就是将两个顶点之间缺少的像素点通过插值的形式进行补充，生成片元着色器可以处理的片段。此阶段由硬件完成插值极端。在插值的过程中，会将不可见的顶点进行剔除。\n片元着色器  片元着色器处理的对象是像素点的颜色信息，也是最终显示在屏幕上的像素点，在这个过程中，可以处理光照和阴影计算，将处理完的值保存至缓冲区中。\n混合处理阶段  混合处理阶段属于屏幕后期梳理范围，这意味着此阶段主要做的任务为屏幕优化操作，通过片元着色器得到的像素，有些不能被显示出来，比如透明度为 0 的像素点，对于这类像素点，我们需要进行测试，测试的范围包括 Alpha 测试、模板测试和深度测试等。不能通过测试的像素点将会被丢弃，就不会参与接下来的操作；通过测试的像素会进入混合阶段。混合阶段主要是处理透明物体，混合阶段不需要进行编程，但是常见的渲染管线接口会开放初一些参数给程序员做调整。\n","categories":["图形学"],"tags":["Graphics"]},{"title":"C++ 17 新特性","url":"/2022/02/22/84e21c0b6a1a/","content":"\n    \n\n\n\n\n构造函数模板推导  在 C++17 前构造一个模板类对象需要指明类型，C++17 就不需要特殊指定，直接可以推导出类型\npair&lt;int, double&gt; p(1, 2.2); // before c++17pair p(1, 2.2); // c++17 自动推导vector v = &#123;1, 2, 3&#125;; // c++17\n\n结构化绑定 if-switch 语句初始化// if (init; condition)if (int a = GetValue()); a &lt; 101) &#123;    cout &lt;&lt; a;&#125;string str = &quot;Hi World&quot;;if (auto [pos, size] = pair(str.find(&quot;Hi&quot;), str.size()); pos != string::npos) &#123;    std::cout &lt;&lt; pos &lt;&lt; &quot; Hello, size is &quot; &lt;&lt; size;&#125;\n\n内联变量C++17 前只有内联函数，现在有了内联变量，C++ 类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的\n// header filestruct A &#123;    static const int value;  &#125;;inline int const A::value = 10;// ========== 或者 ========struct A &#123;    inline static const int value = 10;&#125;\n\n折叠表达式C++17 引入了折叠表达式使可变参数模板编程更方便\ntemplate &lt;typename ... Ts&gt;auto sum(Ts ... ts) &#123;    return (ts + ...);&#125;int a &#123;sum(1, 2, 3, 4, 5)&#125;; // 15std::string a&#123;&quot;hello &quot;&#125;;std::string b&#123;&quot;world&quot;&#125;;cout &lt;&lt; sum(a, b) &lt;&lt; endl; // hello world\n\nconstexpr lambda表达式 C++17 前lambda 表达式只能在运行时使用，C++17 引入了 constexpr lambda 表达式，可以用于在编译期进行计算\nint main() &#123; // c++17 可编译    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;    static_assert(lamb(3) == 9, &quot;a&quot;);&#125;\n\n\nconstexpr函数有如下限制：函数体不能包含汇编语句、goto 语句、label、try 块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有 new delete 等，不能是虚函数\n\nnamespace嵌套namespace A &#123;    namespace B &#123;        namespace C &#123;            void func();        &#125;    &#125;&#125;// c++17，更方便更舒适namespace A::B::C &#123;    void func();)&#125;\n\n__has_include预处理表达式  可以判断是否有某个头文件，代码可能会在不同编译器下工作，不同编译器的可用头文件有可能不同，所以可以使用此来判断\n#if defined __has_include#if __has_include(&lt;charconv&gt;)#define has_charconv 1#include &lt;charconv&gt;#endifstd::optional&lt;int&gt; ConvertToInt(const std::string&amp; str) &#123;    int value&#123;&#125;;#ifdef has_charconv    const auto last = str.data() + str.size();    const auto res = std::from_chars(str.data(), last, value);    if (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) return value;#else    // alternative implementation...    其它方式实现#endif    return std::nullopt;&#125;\n\n在 lambda 表达式用 *this 捕获对象副本  正常情况下，lambda表达式中访问类的对象成员变量需要捕获 this，但是这里捕获的是this 指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题\n所以 C++17 增加了新特性，捕获 *this，不持有this 指针，而是持有对象的拷贝\nstruct A &#123;    int a;    void func() &#123;        auto f = [*this] &#123; // 这里            cout &lt;&lt; a &lt;&lt; endl;        &#125;;        f();    &#125;  &#125;;int main() &#123;    A a;    a.func();    return 0;&#125;\n\n新增 Attribute 在项目中见过 declspec，__attribute，#pragma 指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息\nstruct A &#123; short f[3]; &#125; __attribute__((aligned(8)));void fatal() __attribute__((noreturn));\n\n在 C++11 和 C++14 中有更方便的方法\n\n[[carries_dependency]]让编译期跳过不必要的内存栅栏指令\n[[noreturn]]函数不会返回\n[[deprecated]]函数将弃用的警告\n[[noreturn]] void terminate() noexcept;\n[[deprecated(&quot;use new func instead&quot;)]] void func() &#123;&#125;\n\nC++17 又新增了三个\n\n[[fallthrough]]：用在 switch 中提示可以直接落下去，不需要 break，让编译期忽略警告\nswitch (i) &#123;&#125;    case 1:        xxx; // warning    case 2:        xxx;         [[fallthrough]];      // 警告消除    case 3:        xxx;       break;&#125;\n\n使得编译器和其它开发者都可以理解开发者的意图\n\n[[nodiscard]]：表示修饰的内容不能被忽略，可用于修饰函数，标明返回值一定要被处理\n[[nodiscard]] int func();void F() &#123;    func(); // warning 没有处理函数返回值&#125;\n[[maybe_unused]]：提示编译器修饰的内容可能暂时没有使用，避免产生警告\nvoid func1() &#123;&#125;[[maybe_unused]] void func2() &#123;&#125; // 警告消除void func3() &#123;    int x = 1;    [[maybe_unused]] int y = 2; // 警告消除&#125;\n\n字符串转换   新增from_chars 函数和 to_chars 函数\n  #include &lt;charconv&gt;int main() &#123;    const std::string str&#123;&quot;123456098&quot;&#125;;    int value = 0;    const auto res = std::from_chars(str.data(), str.data() + 4, value);    if (res.ec == std::errc()) &#123;        cout &lt;&lt; value &lt;&lt; &quot;, distance &quot; &lt;&lt; res.ptr - str.data() &lt;&lt; endl;    &#125; else if (res.ec == std::errc::invalid_argument) &#123;        cout &lt;&lt; &quot;invalid&quot; &lt;&lt; endl;    &#125;    str = std::string(&quot;12.34);    double val = 0;    const auto format = std::chars_format::general;    res = std::from_chars(str.data(), str.data() + str.size(), value, format);    str = std::string(&quot;xxxxxxxx&quot;);    const int v = 1234;    res = std::to_chars(str.data(), str.data() + str.size(), v);    cout &lt;&lt; str &lt;&lt; &quot;, filled &quot; &lt;&lt; res.ptr - str.data() &lt;&lt; &quot; characters \\n&quot;;    // 1234xxxx, filled 4 characters&#125;\n\nstd::variantC++17 增加 std::variant 实现类似 union 的功能，但却比 union 更高级，举个例子 union 里面不能有 string 这种类型，但 std::variant 却可以，还可以支持更多复杂类型，如 map 等\nint main() &#123; // c++17 可编译    std::variant&lt;int, std::string&gt; var(&quot;hello&quot;);    cout &lt;&lt; var.index() &lt;&lt; endl;    var = 123;    cout &lt;&lt; var.index() &lt;&lt; endl;    try &#123;        var = &quot;world&quot;;        std::string str = std::get&lt;std::string&gt;(var); // 通过类型获取值        var = 3;        int i = std::get&lt;0&gt;(var); // 通过 index 获取对应值        cout &lt;&lt; str &lt;&lt; endl;        cout &lt;&lt; i &lt;&lt; endl;    &#125; catch(...) &#123;        // xxx;    &#125;    return 0;&#125;\n\n\n一般情况下 variant 的第一个类型一般要有对应的构造函数，否则编译失败\nstruct A &#123;    A(int i)&#123;&#125;  &#125;;int main() &#123;    std::variant&lt;A, int&gt; var; // 编译失败&#125;\n\n可以使用 std::monostate 来打个桩，模拟一个空状态\nstd::variant&lt;std::monostate, A&gt; var; // 可以编译成功\n\nstd::optional有时候可能会有需求，让函数返回一个对象，如下：\nstruct A &#123;&#125;;A func() &#123;    if (flag) return A();    else &#123;        // 异常情况下，怎么返回异常值呢，想返回个空呢    &#125;&#125;\n\n有一种办法是返回对象指针，异常情况下就可以返回nullptr，但是这就涉及到了内存管理，也许会使用智能指针，但这里其实有更方便的办法就是std::optional\nstd::optional&lt;int&gt; StoI(const std::string &amp;s) &#123;    try &#123;        return std::stoi(s);    &#125; catch(...) &#123;        return std::nullopt;    &#125;&#125;void func() &#123;    std::string s&#123;&quot;123&quot;&#125;;    std::optional&lt;int&gt; o = StoI(s);    if (o) &#123;        cout &lt;&lt; *o &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;&#125;\n\nstd::anyC++17 引入了 any 可以存储任何类型的单个值\nint main() &#123; // c++17 可编译    std::any a = 1;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; endl;    a = 2.2f;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;float&gt;(a) &lt;&lt; endl;    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a.reset();    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a = std::string(&quot;a&quot;);    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; endl;    return 0;&#125;\n\nstd::apply使用 std::apply 可以将 tuple 展开作为函数的参数传入\nint add(int first, int second) &#123; return first + second; &#125;auto add_lambda = [](auto first, auto second) &#123; return first + second; &#125;;int main() &#123;    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; &#x27;\\n&#x27;;    std::cout &lt;&lt; add(std::pair(1, 2)) &lt;&lt; &quot;\\n&quot;; // error    std::cout &lt;&lt; std::apply(add_lambda, std::tuple(2.0f, 3.0f)) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\nstd::make_from_tuple使用 make_from_tuple 可以将 tuple 展开作为构造函数参数\nstruct Foo &#123;    Foo(int first, float second, int third) &#123;        std::cout &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; &quot;, &quot; &lt;&lt; third &lt;&lt; &quot;\\n&quot;;    &#125;&#125;;int main() &#123;   auto tuple = std::make_tuple(42, 3.14f, 0);   std::make_from_tuple&lt;Foo&gt;(std::move(tuple));&#125;\n\nstd::string_view通常传递一个 string 时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了 string_view 就可以避免拷贝操作，平时传递过程中传递 string_view 即可\nvoid func(std::string_view stv) &#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;int main(void) &#123;    std::string str = &quot;Hello World&quot;;    std::cout &lt;&lt; str &lt;&lt; std::endl;    std::string_view stv(str.c_str(), str.size());    cout &lt;&lt; stv &lt;&lt; endl;    func(stv);    return 0;&#125;\n\nas_constC++17 使用 as_const 可以将左值转成 const 类型\nstd::string str = &quot;str&quot;;const std::string&amp; constStr = std::as_const(str);\n\nfile_systemC++17 正式将 file_system 纳入标准中，提供了关于文件的大多数功能\nnamespace fs = std::filesystem;fs::create_directory(dir_path);fs::copy_file(src, dst, fs::copy_options::skip_existing);fs::exists(filename);fs::current_path(err_code);\n\nstd::shared_mutexC++17 引入了shared_mutex，可以实现读写锁\n","categories":["C++"],"tags":["C++","C++ 17"]},{"title":"破解 GitKraken","url":"/2022/03/08/438e50146ce5/","content":"\n    \n\n\n\nGitKraken 简介GitKraken 是一款界面十分美观的 Git 可视化管理工具，比较遗憾的是 GitKraken 是收费软件，类似的免费软件有 Sourcetree ，不过使用体验不如 GitKraken。\nGitKraken 连接 GitLabStart a hosted repo\n    \n\n\n通过 File/Preferences 进入偏好设置界面，选择 Authentication 中的 GitLab Self-Managed 页面，输入 GitLab 地址和 Token\n获得 Personal Access Token\n    \n\n\n\n进入User Settings，选择Access Token\n输入一个 Token 的名字\n勾选 api 和read_user\n生成 Token\n复制 Token（这个 Token 离开页面后将不被保存）\n\n连接成功\n    \n\n\n破解  安装yarnnpm i yarn -g\n\n运行破解项目  破解前先确保 GitKraken 已关闭退出，破解工具在 Github 上是一个开源项目 5cr1pt/GitCracken ，将该项目 clone 到本地，使用方法也可参考项目的 README.md 文件，另外也在 Gitee 上也有。仓库拷贝到本地后，进入仓库的 GitCracken/GitCracken 目录，依次执行以下指令运行破解\nyarn installyarn buildnode dist/bin/gitcracken.js patcher\n\n\n运行 yarn install 可能会出现连接超时的错误\n\n\n直接安装对应的 module 即可\n\n\n执行成功后可看到如下界面\n\n    \n\n\n在 GitKraken 界面右下角可以看到破解后的状态\n\n    \n\n","categories":["Tools"],"tags":["crack","GitKraken"]},{"title":"游戏体系","url":"/2022/08/13/a173e2727ab6/","content":"\n             英文简历\n          \n\n             动画系统\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n             四元数与三维旋转\n           goto\n\n            AI\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n             状态机\n          &nbsp;&nbsp;&nbsp;&nbsp;\n            Behavior Tree\n          \n\n            OpenGL\n          \n\n            RL\n          \n\n             寻路\n          \n\n            3D 运算\n          \n\n             向量运算及含义\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n            Geometric Tests\n           goto\n","categories":["游戏开发"],"tags":["GamePlay","游戏","TODO"]},{"title":"Shader Variant","url":"/2022/08/06/93ff363a107d/","content":"基础知识  什么是 Shader Variant在写 Shader 时，往往会在 Shader 中定义多个宏，并在 Shader 代码中控制开启宏或关闭宏时物体的渲染过程。最终编译的时候也是根据这些不同的宏来编译生成多种组合形式的 Shader 源码。其中每一种组合就是这个 Shader 的一个  变体\nMaterial Shader Keywords 与 Shader VariantMaterial 所包含的 Shader Keywords 表示启用 Shader 中对应的宏，Unity 会调用当前宏组合所对应的变体来为 Material 进行渲染\n\n\n在 Editor 下，可以通过将 Material 的 Inspector 调成 Debug 模式来查看当前 Material 定义的 Keywords，也可以在此模式下直接定义 Keywords，用空格分隔 Keyword\n在代码中，可用 Material.EnableKeyword()、Material.DisableKeyword()、Shader.EnableKeyword()、Shader.DisableKeyword() 来启用 / 禁用相应的宏\nEnable函数应与 Disable 函数相对应。若一个宏由 Material.EnableKeyword() 开启，则应由 Material.DisableKeyword() 关闭，Shader.DisableKeyword()无法关闭这个宏\n\n\nmulti_compile与 shader_featuremulti_compile 的用法解析#paragma multi_compile OFF ON\n\n表示定义了两个变体，OFF和 ON。在运行时，其中的一个将被激活，根据材质或者全局着色器关键字（#ifdef OFF 之类的宏命令也可以）来确定激活哪个。若两个关键词都没有启用，那么将默认使用前一个选项，也就是OFF。\n也可以同时创建多个变体：\n#paragma multi_compile A B C\n\n还可以使用多行指令对变体进行组合，但是这样做的话，会导致变体数量成倍的增长，如果使用下面的代码生成变体，会得到  中不同的变体：\n#paragma multi_compile A B C#paragma multi_compile D E\n\nshader_feature用法简析 shader_feature 的用法与 multi_compile 大致相同，唯一的区别在于 shader_feature 不会将不用的 Shader 变体添加到程序中去。shader_feature更适用于材质的关键字，而 multi_compile 更适用于代码的全局关键字\n#paragma shader_feature A\n\n\n其实 #paragma shader_feature A 是#paragma shader_feature _ A的简写，下划线表示未定义宏（NoKeyword）。因此此时 Shader 其实对应了两个变体，一个是 NoKeyword，一个是定义了宏 A。而#paragma multi_compile A 并不存在简写这一说，所以 Shader 此时只对应 A 这个变体。若要表示未定义任何变体，则应写为#paragma multi_compile _ A\n\n如何控制项目中 Shader 变体的生成\n\n\n生成方式\n优点\n缺点\n\n\n\nShader 与材质打在一个包中\n变体根据材质中的 keywords 自动生成\n多个不同的材质包中可能存在相同的 Shader 变体，造成资源冗余  若在程序运行时动态改变材质的 keyword，使用 shader_feature 定义的宏，其变体可能并没有被生成\n\n\nShader 单独打包，使用 multi_compile 定义全部宏\n全部变体都被生成，不会发生需要的变体未生成的情况\n生成的变体数量庞大，严重浪费资源\n\n\nShader 单独打包，shader_feature（需要使用 ShaderVariantCollection 生成变体）与multi_compile（还是会生成所有变体）结合使用\n能够有效控制 shader_feature 变体数量\n如何确定哪些变体需要生成  容易遗漏需要生成的变体，特别是需要动态替换的变体\n\n\n使用 shader_feature 的解决方案：ShaderVariantCollectionShaderVariantCollection 介绍 ShaderVariantCollection 的其中一个作用就是用来记录 Shader 中使用shader_feature 定义的宏产生的变体。能够设置生成任何变体，从而避免生成不必要的变体；Shader 不必和材质打在一个包中，避免了多个包中存在相同的变体资源；明确直观的显示了哪些变体是需要生成的。\n\n在 Unity 中可以通过 Create-&gt;Shader-&gt;Shader Variant Collection，就可以新建一个 ShaderVariantCollection 文件\n\nShaderVariantCollection 生成通过 shader_feature 定义的变体规则\n必定生成首个宏定义开启所对应的变体\n\npragma shader_feature A：除了生成 A 的变体，nokeyword 所对应的变体也会被生成\npragma shader_feature A B C：ShaderVariantCollection 中即使未添加变体 A，这个变体也会被生成\n\n\nShader 中又多个 Pass 时变体的生成规则\n\n读取 ShaderVariantCollection 中已存在的变体，获取他们的 keywords\n\n将这些 keywords 分别与每个 Pass 的多组 keywords 列表求交集，取交集中 keywords 数量最多的那组\n\n用得到的 keywords 与对应 PassType 生成 Shader 变体，并添加到 ShaderVariantCollection 中\n\n若得到的交集中有新的 keywords，则回到 2\n\n例如 Shader 中有 ForwardBase、ForwardAdd、Normal 三种 PassType，定义的宏如下：\n\n\n\nForwardBase\nForwardAdd\nNormal\n\n\n\n#pragma shader_feature A#pragma shader_feature B#pragma shader_feature C\n#pragma shader_feature A#pragma shader_feature E\n#pragma shader_feature A#pragma shader_feature B#pragma shader_feature E\n\n\n此时若 ShaderVariantCollection 中包含的变体是 ForwardBase ABC，ForwardAdd AE。则此时生成的变体为：这三种 PassType 的默认定义的宏 (nokeyword) 所对应的变体（3 个）以及原先直接包含的 ForwardBase ABC、ForwardAdd AE。除此之外 Unity 还会额外生成 ForwardAdd A、ForwardBase A、Normal A、Normal AB、 ForwardBase AB、Normal AE 这 6 个变体\nABC ∩ Add AE -&gt; Add A (A is NewKeyword)  A ∩ Base ABC -&gt; Base A  A ∩ Normal ABE -&gt; Normal AABC ∩ Normal ABE -&gt; Normal AB (AB is NewKeyword) AB ∩ Base ABC -&gt; Base AB AE ∩ Normal ABE -&gt; Normal AE\n\n\n\n\n变体的调用规则  当 ShaderVariantCollection 将变体准确生成后，便能在运行时通过修改材质中的 keywords 来实现对不同变体的调用。假设某 collection 生成的变体只有 Forward ABC，Forward ABE，Forward nokeyword 这三种，则此时调用关系如下：\n\n\n\nMaterial 中的 Keywords\n调用的变体\n解释\n\n\n\nA B C\nForward A B C\n正常匹配\n\n\nA B\nForward nokeyword\n没有匹配的变体，调用首个被定义的宏 所对应的变体\n\n\nA B C D\nForward A B C\n调用交集中 keyword 数量多的变体 ABCD ∩ ABC = ABC ABCD ∩ ABE = AB\n\n\nA B C E\nForward A B C\n交集中 keyword 数量相同，在 collection 中谁在前就调用谁\n\n\nA B E C\nForward A B C\n与在 material 中的定义顺序无关\n\n\n项目中变体的添加\n遍历每个材质，提取其 Shader keywords\n将获得的 keywords 与 Shader 的每个 PassType 所包含的宏定义做交集，并将其结果添加到 ShaderVariantCollection 中\n\n变体代码在 Shader 中编写规范\n建议使用 shader_feature 时将定义语句写成完整模式，并且不要在一个语句中定义多个宏\n#pragma shader_feature _ A，不建议写成#pragma shader_feature A\n\n\n若在 Shader 中使用shader_feature，请为这个 Shader 指定一个 CustomEditor\n\n","categories":["游戏开发"],"tags":["Shader","Variant"]},{"title":"Unity 技术美术 - Shader 篇","url":"/2023/04/03/6539b036c88c/","content":"片段着色器  图元、片元和像素  生成的先后顺序：顶点 → 图元 → 片元 → 像素\nShaderLab 模板\nStandard Surface Shader 表面着色器\nUnlit Shader 不受光照（UnLight）\nImage Effect Shader 后处理\nCompute Shader\nRay Tracing Shader\n\nSubShaderGPU 会检查第一个 SubShader，如果 SubShader 不支持（显卡特性等），会检查第二个 SubShader，如果没有找到合适的 SubShader 就会执行 FallBack 中的 Shader 代码\n常用的 cginc\nHLSLSupport.cginc 编译 CGRPOGRAM 时自动包含此文件，其中声明了很多预处理器宏帮助多平台开发\nUnityShaderVariables.cginc 编译 CGRPOGRAM 时自动包含此文件，其中声明了很多各种内置的全局变量\nUnityCG.cginc 需要手动添加，其中声明了很多内置的帮助函数与结构\n\n材质属性 Properties语法格式// Attribute 为属性// _Name 为变量名// Dispaly_Name 为展示在材质面板上的名字// Type 为变量类型/********************* *   &#123; *       color, *       int, *       float, *       vector, *       2D, *       3D, *       cube *   &#125;**********************/// Default_Value 为默认值[Attribute]_Name(&quot;Display_Name&quot;, Type) = Default_Value\n\nProperties&#123;    [HDR]_Color(&quot; 颜色 &quot;, color) = (1, 1, 0, 1)    _Int(&quot; 整数 &quot;, int) = 0.5    [PowerSlider(3)]_Float(&quot; 浮点数 &quot;, range(0, 10)) = 0.5    _Vector(&quot; 四维向量 &quot;, vector) = (0.5, 2, -1, 1)    _2DTex(&quot;2D 纹理 &quot;, 2D) = &quot;black&quot;&#123;&#125;&#125;\n\n混合操作  片段着色器（源颜色 * SrcFactor） BlendOp 帧缓冲区 Frame Buffer（目标颜色 * DstFactor）\nShader 中的时间_Time_Time.xyzw\n\n_Time.x (t / 20)\n_Time.y (t)\n_Time.z (t * 2)\n_Time.w (t * 3)\n\n相关术语  菲涅尔效应  在真实世界中，除了金属之外，其它物质均有不同程度的“菲涅尔效应”。简单的讲，就是视线垂直于表面时，反射较弱，而当视线非垂直表面时，夹角越小，反射越明显。如果你看向一个圆球，那圆球中心的反射较弱，靠近边缘较强。不过这种过度关系被折射率影响。如果你站在湖边，低头看脚下的水，你会发现水是透明的，反射不是特别强烈；如果你看远处的湖面，你会发现水并不是透明的，但反射非常强烈。这就是“菲涅尔效应”\n","categories":["游戏开发"],"tags":["Shader","Unity","课程"]},{"title":"Lua 小知识","url":"/2022/08/15/3b201e9d4ade/","content":"数组元素的插入与删除 table.insert 与table.remove方法可以从数组中间的位置插入或移除一个元素。进行此操作时，lua 核心会将插入位置开始的所有元素  逐一  向后移动一位（移除元素亦然）。因此以下代码：\nlocal t = {}for i = 1, 10000 do    table.insert(t, 1, i)end\n\n会移动元素  次。\n一般的解决方法：\n\n如果你并不要求这是一个数组（比如你不会去遍历这个表），那么你可以直接将元素置空，或是插入到表的空位中：\n-- 删除元素t[100] = nil-- 插入到表的空位中t[#t+1] = object-- 上下 2 种写法等价，但是上面的写法略微高效一些table.insert(t, object)\n\n注意这里插入到表的空位中的写法，lua 规定只有当数组是紧密的时候， #t才能返回数组的长度。当数组为稀疏的时候，#t会返回任意一个边界（#t非空，但 #t+1 为空），因此使用 #t+1 不会覆盖已有数据。\n\n如果你要求他一定是数组，但是不要求保持顺序，那么可以在移除时将尾部的元素挪过来填补空位：\n-- 删除元素t[100] = t[#t]t[#t]  = nil-- 新的元素总是添加到末尾t[#t+1] = object-- 上下 2 种写法等价，但是上面的写法略微高效一些table.insert(t, object)\n如果你要求他一定是数组，但是不要求保持顺序，那么可以在移除时将尾部的元素挪过来填补空位：\n-- 删除元素t[100] = false -- 往原来的位置放置一个占位符，遍历时过滤掉此占位符-- 在适当的时候，清理掉数组中的所有占位符local count = 0for i = 1, #t do    if t[i] == false then        t[i] = nil    else        count = count + 1        t[count] = t[i]    endend\n\nTry-Catch你可以使用 pcall 与 xpcall 以保护模式运行一段代码，当代码发生异常后会带着错误消息回到此函数的调用处，例如：\n   local suc, res = pcall(function ()    local n = nil + 1    print(n) -- 不会执行到end)print(suc, res) -- false, error message\n\n   xpcall 则可以再传入一个 catch ，使得你可以在现场捕获错误并查看堆栈\n   xpcall(function ()     local n = nil + 1    print(n) -- 不会执行到end, function (error_message)    print(debug.traceback(error_message))end)\n\n\n你可以直接把 debug.traceback 当做 catch 传给 xpcall ，因为 debug.traceback 的功能之一是接收一个错误消息，然后把堆栈信息拼在错误消息后面返回回来；而 xpcall 会将 catch 的返回值作为新的错误消息返回出来，这样一来就可以在调用处查看错误堆栈。\nlocal suc, res = xpcall(function ()     local n = nil + 1    print(n) -- 不会执行到end, debug.traceback)print(suc, res) -- false, error message with traceback\n\n判空  在 Lua 中只有 nil 与 false 会被认为是假值，而所有其他值都是真值，包括 0 '' {} 。\n因此大部分情况下你只需要简单的通过 if x then 来进行判空。\n但有一种情况是你有个非常长的操作链，例如 local x = t.x.y.z()[1]  而 lua 并不支持可选操作符（比如 TS 中可以这么写： let x = t?.x?.y?.z?.()?.[1])\n常见的几种解决方案如下：\n\n依次判空，最朴素的思路，TS 中的可选操作符最终也是编译为依次判空的\nlocal xif t and t.x and t.x.y and t.x.y.z then -- 这里需要确定取字段没有副作用    local _r = t.x.y.z() -- 函数调用通常有副作用，因此需要缓存结果    if _r then        x = _r[1]    else        catchError('z() is nil')    endelse    catchError('x or y or z is nil')end\n\n这个写法简单易懂，几乎没有额外开销，但是显然写起来很复杂，很不优美\n\n创建默认值，这是来自《Lua 程序设计》作者的方案\nlocal x = ((((t or {}).x or {}).z or function () end)() or {})[1]\n\n根据我们人工预测，每步操作大概率不会是空值，根据 Lua 的短路规则一般不会真的创建出很多对象，基本没有额外开销。而当出现空值时，作为出错情况创建一点对象也不是很有所谓。不过缺点就是括号实在是太多了，很难看清是否写对\n如果想捕获错误需要再加个捕获（假设捕获函数 catchError 没有返回值）：\nlocal x = ((((     t or catchError('t is nil')   or {})    .x or catchError('x is nil')   or {})    .z or catchError('z is nil')   or function () end)    () or catchError('z() is nil') or {})    [1]\n封装成函数\nlocal function getValue(v, ...)    local n = select('#', ...)    for i = 1, n do        local k = select(i, ...)        if v[k] then            v = v[k]        else            catchError(k .. 'is nil')            return nil        end    end    return vend-- 以上整个函数由 copilot 生成，我没仔细看，有问题告诉我local x = getValue(t, 'x', 'y', 'z', 1)\n\n这个方法只能支持取字段操作，没法实现函数调用。但考虑到实际工程中很少会把函数调用放到长操作链中，这也是个不错的解决方案。缺点是语义不太清晰，而且无论是不是空都需要付出很多额外的函数调用的开销\n\n所有的操作都 try 1 try\nlocal xxpcall(function ()    x = t.x.y.z()[1]end, catchError)\n重写 nil 的操作。实际工程中我们经常会遇到需要连续大段的读表，直接让 Lua 对 nil 进行读字段 / 函数调用等操作\nLua 可以通过 debug.setmetatable 给基础类型添加元表，所有该类型的值会共享同一个元表，因此我们可以给 nil 添加一个重载了所有运算符的元表，具体代码比较长就不贴出来了，可以到这里看：without-check-nil.lua\n\n\n需要注意的是，在我们进行完长链操作后需要及时禁用掉此功能，以免把你其他代码中的错误吃掉\n另外由于 Lua 无法重载 asindex ，因此无法处理 t[nil] = 1 这种情况\n\n\nlocal nonil = require 'without-check-nil'nonil.watch = function (ev, exp1, exp2)    catchError(string.format('[%s] error, exp1 = %s, exp2 = %s', ev, exp1, exp2))endnonil.enable()local x = t.x.y.z()[1]nonil.disable()\n\n总结\n\n\n方案\n优点\n缺点\n开销\n错误捕获\n\n\n\n依次判空\n简单\n写起来麻烦 看起来费劲 1 行变 5 行\n有少量额外开销\n可以手动捕获错误，但是会让代码写起来更麻烦\n\n\n创建默认值\n不会增加行数\n操作链长的话括号会很多\n有少量额外开销\n可以手动捕获错误，但是会让代码写起来更麻烦\n\n\n封装成函数\n不会增加行数 写起来比较简单\n只能进行取值操作\n有一些额外开销\n可以在封装函数中自动捕获\n\n\nTry 1 Try\n写起来简单 看起来直观\n1 行变 3 行\n有一些额外开销\n等同于手动捕获\n\n\n重写 nil 的操作\n几乎不需要修改代码\n重写 nil 操作为全局开关，需要记得关 如果业务和读表混在一起，可能会吃掉业务里的错误 无法处理键为空的错误\n没有额外开销\n通过注册 watch 函数来全局捕获\n\n\n提升性能的写法  有时我们必须用 Lua 写一些运算密集的代码，此时可以通过一些写法略微提升性能。注意，优化性能时优先级第一是找 bug，第二是改进算法设计，之后才轮到更高效的写法。更改写法很可能会降低代码的可读性，你需要自己寻找性能与可读性之间的平衡点，适当留下注释，并且切记  不要过早优化。\n\n使用 t[#t+1] = n 代替 table.insert(t, n) ；使用 t[#t] = nil 代替 table.remove(t) 。这是因为 Lua 调用函数的开销比运算符要高。但是使用这种写法时请注意，如果你的 t 是个表达式，那么这个表达式会被求 2 次\n\n使用局部变量代替全局变量，如：\nlocal tinsert = table.insertlocal t = {}for i = 1, 10000 do    tinsert(t, i)end\n\n该写法的提升很小，只有在非常密集的循环运算中才有改写的价值\n\n使用局部变量缓存结果，如：\n-- 原本的代码：a.b.c.d[#a.b.c.d+1] = ncall(a.b.c.d)a.b.c.d[#a.b.c.d] = nil-- 可以改写成：local t = a.b.c.dt[#t+1] = ncall(t)t[#t] = nil\n\nLua 的局部变量是没有额外开销的，因为 Lua 本身就会通过隐藏的局部变量（寄存器）来保存中间结果。例如上面例子中原本的代码，Lua 生成的字节码伪代码如下：\nlocal a1, a2, a3a1 = getglobal('a')a1 = getfield(a1, 'b')a1 = getfield(a1, 'c')a1 = getfield(a1, 'd')a2 = getglobal('a')a2 = getfield(a2, 'b')a2 = getfield(a2, 'c')a2 = getfield(a2, 'd')a2 = getlen(a2)a2 = binary('+', a2, 1)a3 = getglobal('n')setfield(a1, a2, a3)\n避免创建对象，主要是表\nlocal function isSupported(t)    for _, v in ipairs {'Windows', 'macOS', 'Linux'} do        if t[v] then            return true        end    end    return falseend-- 改写为local supported = {'Windows', 'macOS', 'Linux'}local function isSupported(t)    for _, v in ipairs(supported) do        if t[v] then            return true        end    end    return falseend-- 其实调用 ipairs 也会创建一个新的闭包，如果你非常在意，可以就改写为local supported = {'Windows', 'macOS', 'Linux'}local function isSupported(t)    for i = 1, #supported do        local v = supported[i]        if t[v] then            return true        end    end    return falseend-- 如果你连循环都不想要，那么可以使用终极手段 - 手动展开local supported = {'Windows', 'macOS', 'Linux'}local codes = {'local t = ...'}for _, v in ipairs(supported) do    codes[#codes+1] = string.format([[if t[%q] then    return trueend]], v)endcodes[#codes+1] = 'return false'local code = table.concat(codes, '\\n')local isSupported = load(code) -- Lua 5.1 用 loadstring\n\n一些坑\nLua 的数组索引是从 1 开始的\n\n如果数组构造的最后一个元素是一个函数调用，要注意这个函数调用的所有返回值都保存到表里，例如：\nlocal username = 'sumneko'local platform = 'Windows11'local t = {username, string.gsub(platform, '%d+', '') }print(t[1]) --\"sumneko\"print(t[2]) --\"Windows\"print(t[3]) -- 1           -- 这是 string.gsub 的第二个返回值，表示成功替换了 1 次\n\n同理函数调用的最后一个参数也有这个问题，例如：\nlocal input = '#ffcc00'local n = tonumber(string.gsub(input, '#', '0x'))-- 上面这行会报错，因为 string.gsub 会返回 2 个返回值 \"0xffcc00\" 与 1，-- 之后相当于调用了 tonumber(\"0xffcc00\", 1) ，表示以 1 进制转换该字符串\n\n解决办法：\n-- 1. 分成 2 行写local input = '#ffcc00'local int16 = string.gsub(input, '#', '0x')local n = tonumber(int16)-- 2. 加个括号强制，强制只保留第一个返回值local input = '#ffcc00'local n = tonumber((string.gsub(input, '#', '0x')))\npairs 遍历哈希表时，顺序未定义\nlocal t = {    a = 1,    b = 2,    c = 3,    d = 4,}for k in pairs(t) do    print(k)end\npairs 遍历哈希表时，不能往这张表里保存新的字段\nfor k in pairs(t) do    if string.sub(k, 1, 2) == 'm_' then        local realKey = string.sub(3)        for i = 1, 100 do            local newKey = realKey .. tostring(i)            t[newKey] = true        end    endend-- 这种写法会导致未定义行为，通常表现为同一个 key 被遍历到多次，甚至是死循环-- 这种写法其实比较容易看出遍历时保存了数据，麻烦的是下面这种：for id, unit in pairs(AllUnitsMap) do    if unit:isRemoved() then        allUnitsMap[id] = nil -- 遍历表的时候修改或移除存在的字段是 OK 的        eventDispatch('单位 - 移除', unit)    endend-- 上面这段代码在遍历中移除元素后向外抛出了一个事件，-- 这是非常危险的，因为事件中可能会往表中添加元素。-- 在这个例子中，有可能是策划希望在某个单位被移除后创建一个新的单位出来，-- 而新建的单位会被添加到正在遍历的全局表中。\n局部函数的声明方式\nlocal f = function ()    f() -- 这里的 f 是全局变量，因此无法递归当前函数endlocal function f()    f() -- 这里的 f 是局部变量，会递归当前函数end-- 上下 2 个写法是等价的，上者是下者的语法糖local f;f = function ()    f() -- 这里的 f 是局部变量，会递归当前函数end\nrequire 只会执行文件一次，且只接受一个返回值\n-- 文件 A.luaprint('loaded')return 1, 2, 3-- 文件 B.lualocal x1, y1, z1 = require 'A'print(x1) -- 1print(y1) -- \"@A.lua\" # 第一次 require 文件时，会返回文件路径 （仅 Lua 5.4）print(z1) -- nillocal x2, y2, z2 = require 'A'print(x1) -- 1print(y1) -- nilprint(z1) -- nil-- 只会打印一次 'loaded' ，因为文件 A 只被执行了一次\n\n但是，如果你用不同的名字加载同一个文件，那么这个文件就会被加载多次，这是一定要避免的！\n-- 文件 A/init.luarequire 'A.init' -- 通过 '?.lua' 搜索到 'A/init.lua'require 'A/init' -- 通过 '?.lua' 搜索到 'A/init.lua'require 'A'      -- 通过 '?/init.lua' 搜索到 'A/init.lua'require 'a'      -- 通过 '?/init.lua' 搜索到 'a/init.lua'，在 Windows 平台下会映射到 'A/init.lua'\n\n例子中的 4 行代码最终使得同一个文件被执行了 4 次\n\nos.clock 在不同的平台行为不一致\n其实这不算是 Lua 的坑，这是 Windows 的历史遗留问题。ISO 标准中规定了 clock() 函数返回当前进程占用的 CPU 时间，但是 Windows 错误的实现成了当前进程从启动开始到现在经过的总时间。因此要注意不能拿他用于获取现实时间（除非只在 Windows 运行）\n\n\n拼接字符串Lua 的字符串是不可变对象，因此对字符串进行的操作需要创建新的字符串，例如：\nlocal str = 'a' .. 'b' .. 'c' .. 'd'-- 这段代码会创建 'ab' 'abc' 'abcd' 3 个字符串\n\n一般来说，如果你的字符串比较短或是拼接次数比较少，那么无需在意。但如果需要再循环中进行大量拼接，那么应当使用 table.concat 来实现，例如：\nlocal function f(units)    local str = ''    for _, u in ipairs(units) do        str = str .. u:getUUID() .. ','    end    return strend-- 假设 units 的数组长度为 1000，且每个 unit 的 UUID 长度为 16 个字节，-- 那么上述代码一共会创建 2000 个字符串，共申请 17M 的内存。-- 因此将其改写为：local function f(units)    local buf = {}    for _, u in ipairs(units) do        buf[#buf+1] = u:getUUID()        buf[#buf+1] = ','    end    return table.concat(buf)end-- 如此一来就只会创建一个字符串，申请 17K 的内存\n\n空（none）与 nil 在 Lua 层，由于获取一个空值时会返回 nil，因此很难察觉到空值的存在。而在 C 层则是提供了lua_isnil/lua_isnone/lua_isnoneornil 这 3 个 API 进行区分。大部分情况下我们确实不需要关心他们的区别，但还是有一个地方需要用到。\nLua 默认提供的几个 API 会根据参数的数量决定不同的行为，例如 table.insert：\n\ntable.insert(t, v) 在 t 的末尾添加v\ntable.insert(t, pos, v) t中从 pos 开始的元素都往后移动一格，然后将 v 放在 t[pos] 上\n\n这里就是根据你传入的参数数量决定的，因此你调用 table.insert(t, v, nil) 时实际上调用的是 3 参数版本\n这时候你可能会说：你当我瞎嘛，我当然知道这是 3 个参数。客官莫急，看看这两种情况：\n\ntable.insert(t, ...)\ntable.insert(t, getValue())\n\n前一种不定参会导致你的参数数量由当前函数的调用者决定，因此你需要做好判断的工作。判断不定参的参数数量需要用到 select 方法：\nlocal function count(...)    return select('#', ...)endprint(count()) --&gt; 0print(count(1, 2)) --&gt; 2print(count(1, 2, nil, nil)) --&gt; 4\n\n后一种则是要保证好目标函数的返回值数量：\nlocal function getValue(n)    if n == 0 then        return    elseif n == 1 then        return nil    elseif n == 2 then        return nil, nil    elseif n == 3 then        return nil, nil, nil    endendprint(select('#', getValue(0))) --&gt; 0print(select('#', getValue(1))) --&gt; 1print(select('#', getValue(2))) --&gt; 2print(select('#', getValue(3))) --&gt; 3\n\n前文“一些坑”中有提到过，尽量使用中间变量来明确函数返回值的数量\n不定参  不定参是不能跨越函数（作为闭包的上值）的，也就是你无法这么写：\nlocal function factory(...)    return function ()        return ... --&gt; 语法错误    endend\n\n\n有时你会在网上的教程中看到不定参会被存到隐藏参数 arg（表）中，这是旧版 Lua 的功能，出于性能考虑已被废弃（当然 C 代码中有宏可以启用这个功能）\n\n如果有这个需求的话，需要将不定参包装到一个表中，一般来说这么写就足够了\nlocal function factory(...)    local vars = {...}    return function ()        return table.unpack(vars) --&gt; Lua 5.1 为 `unpack`    endend\n\n但有的时候我们需要保证不定参需要被  原样  返回出去，比如转发 / 代理任意消息。如果不定参的末尾跟着nil，上面的写法会导致返回出去的值的数量不同，因此需要保存不定参的数量：\nlocal function factory(...)    local vars = {...}    local num  = select('#', ...)    return function ()        return table.unpack(vars, 1, num)    endend\n\n此外也可以用 table.pack 实现相同的功能：\nlocal function factory(...)    local vars = table.pack(...) --&gt; Lua 5.1 不可用；LuaJIT 可用    return function ()       return table.unpack(vars, 1, vars.n) --&gt; 不定参长度保存在字段 `n` 中    endend\n\n这 2 种写法根据使用场景会有一点点的性能区别，例如：\nlocal function getSum1(...)    local sum = 0    for i = 1, select('#', ...) do        sum = sum + (select('#', i) or 0)    end    return sumendlocal function getSum2(...)    local sum = 0    local vars = table.pack(...)    for i = 1, vars.n do        sum = sum + (vars[i] or 0)    end    return sumend\n\n肉眼可见，第一种写法每个参数都要调用一次函数，第二种写法则固定要创建一张表，所以你可以根据实际情况预估一下参数数量决定使用哪种写法。不过说实话差别很小，不需要特别在意\n环境与沙盒 Lua 通过全局表与环境表来实现全局变量。在 Lua 5.1 与 LuaJIT 中每个函数都会绑定一个环境表 (env，默认就是_G)，当你读写全局变量时，其实修改的是环境表中的对象。新建的函数会继承父函数的环境，同时也提供了函数setfenv 来修改函数的环境\nX = 1 local function f()    Y = Xend\n\n-- 上面的代码在 Lua 5.1 中会被这样解释（伪代码）：setfenv(1, env) -- `env` 是当前环境，默认为 `_G`. `env` 并不存在于变量列表中。getfenv(1)['X'] = 1local function f()    getfenv(1)['Y'] = getfenv(1)['X']endsetfenv(f, getfenv(1))\n\n然而这个设计引发了很多困惑，你无法准确的判断出当前函数的内的全局变量到底是从哪个环境里读取的，因为任何人都有权限随时修改你的环境。\n另一方面，如果一个函数返回了一个闭包，创建闭包的时候闭包会继承父函数的环境，但之后修改父函数的环境将无法再影响闭包。相对之下修改上值（upvalue）是可以作用于闭包的，因此这又引发了“变量作用域”规则的不一致性，引发了困扰\n因此从 Lua 5.2 开始，环境改为通过上值来实现，从而统一了概念，减少了特例\n-- 上面的代码在 Lua 5.2 中会被这样解释（伪代码）：local _ENV = env -- `env` 是当前环境，默认为 `_G`._ENV['x'] = 1local function f()    _ENV['Y'] = _ENV['X']end\n\n其中 _ENV 是真实存在于局部变量列表中的，这使得环境的基础概念由每个函数单独一个环境变为了同一个文件共享同一个环境。这个方案使得函数的环境由代码写法决定，而不是由运行时的状态决定。当你修改环境时，所有的函数与闭包的环境也会被一并修改\nlocal print = printlocal pairs = pairs_ENV = nil -- 禁止下面的代码使用全局变量，避免拼写错误导致的误用print(pairs)print(paris) -- 运行时这里会报错，因为被解释为了 `_ENV['paris']`，而此时的 `_ENV` 为 `nil`\n\n垃圾回收  目前主流的垃圾回收有 2 种，分别是引用计数与标记清理。\n引用计数的原理很朴素，每当对象被持有时计数 +1，当持有被解除后 -1，归 0 即释放。这种朴素的思想自然会产生很多问题，包括难以解决循环引用以及对于动态语言来说浪费性能等。但 Lua 没有使用这种方式的主要原因是 Lua 设计为需要频繁和 C 交互，而引用计数势必会侵入 CAPI 的部分，会给 C 的代码带来额外的心智负担。\n标记清理则是从目的出发：既然垃圾回收的目的是为了清理掉无法再访问到的内存，那么我们只要进行一次可达性测试，即可找出要收集的垃圾，如图所示：\n\n    \n\n\n我们只需要从根集（注册表）出发，顺着应用链往下递归，将访问到的对象全部标记为黑色。当递归结束后，那些没有被标记到的对象便成为了垃圾可以释放掉了。这个流程实现起来很简单，因为 Lua 的结构简单，并且提供了完善的调试与反射功能，甚至使用纯 Lua 也能实现扫描，可以用于内存分析等功能\n增量回收  标记清理有个显而易见的问题，那就是由于单次回收需要扫描整个内存空间，会产生严重的停顿。因此需要将这个回收尽量切成小片，并分散在运行时的各个时机中\n标记过程显然是一个可以拆分的流程，因为他的本质是递归，可以将递归解为一个循环，而循环只要保存一下队列与当前状态即可随时暂停与恢复\n为了方便理解，我们需要引入一个中间量灰色，表示那些放在队列中等待扫描的对象（即已经确定被根集引用到，但还不知道它引用了哪些别的对象）。整个流程大概就是：\n\n将根集（注册表）标记为黑色，并将附近的节点（全局变量表、运行栈等）染为灰色\n随便挑一个灰色，将其标记为黑色，并将附近的白色节点染为灰色\n重复第 2 步，直到没有任何灰色节点为止\n\n因为第 2 步可以随时打断，我们可以将其分散到代码的各个过程中，Lua 的默认设置为会以内存增长速度的 2 倍进行扫描，意思是每创建一个新的对象，我就会扫描 2 个灰色对象（这里假设对象大小都一样）\n增量回收的加入使得 Lua 的地位发生了根本性的改变，回顾历史，Lua 正是在此时从一个纯粹的胶水语言变为了编程语言\n一些使用老版本 Unity 的游戏项目有时会因为使用的 C# 版本较老不支持增量回收，为了避免垃圾回收带来的停顿，将对象全部托管到了 Lua 中\n另外还需要说明一点，增量回收大大增加了垃圾回收实现的复杂度，并且产生了额外的开销。一般我们通过“吞吐量”来描述垃圾回收器的性能，而增量回收势必会让吞吐量下降。因此 Lua 提供了 collectgarbage 接口可以通过参数调整策略，自己寻找一个吞吐量与暂停时间的平衡点\n程序开发中一直有所谓的“二八原则”，垃圾回收也不例外。到目前为止我描述的都是垃圾回收中最基础的思想和最主要的实现，它们占据了 80% 的情况，只需要付出 20% 的经历与代码量即可完成。在这之后我们会遇到 20% 的边界情况，为了对付他们，我们需要引入大量复杂的设计，付出 80% 的精力与代码量\n写屏障  在上面的增量回收流程中，我们看到了一个理想的模型：在纯白的地图上，一个黑色出现，之后灰色边界产生并慢慢扩散，并且灰色慢慢转换为黑色，最终将地图分割为非黑即白的世界。其中灰色作为缓冲带分割了黑色与白色，黑色对象不会指向白色对象\n但实际运行中，我们完全有可能在垃圾回收暂停的过程中，通过赋值操作直接将黑色对象指向白色对象，例如\n_G['X'] = {} -- _G 表作为根集之一，很可能是黑色的；而新建的空表一定是白色的\n\n因此我们需要引入写屏障来解决这个问题。写屏障这个名字听着很厉害，实际上就是在赋值操作里面加了个判断，发现白色对象被赋值到了黑色对象的引用中时，将其中一个对象改为灰色。到底把谁改为灰色，这个一般是根据概率统计出来的经验（分支预测），因此这里不再展开说了，理论上改谁都可以\n再次灰色  如果一个对象被反复改为灰色（每次从黑改灰都意味着需要重新扫描这个对象），那么这个对象会被标记为一个特殊的灰色，之后增量阶段不再扫描此对象（避免反复扫描这个对象），改为增量阶段结束后使用一个原子阶段一次性扫描\n弱引用Lua 使用弱表实现了弱引用，但弱表本身也是需要扫描的，因为字符串本身虽然是个可回收对象，但是在作为弱表的键值时总是强引用。此外弱表还有个特殊的情况，考虑以下情况：\nlocal t = setmetatable({}, { __mode = 'k' }) -- 构造一个弱键表t[X] = Yt[Y] = X\n\n在这个例子中，表的键为弱引用，值为强引用。当扫描此表时，发现 X 与 Y都作为值，而该表的值为强引用，于是认为他们被引用住了，因此不会回收这 2 个对象。但实际上这是一个弱循环引用，应当被回收。\n为此，Lua 引入了一个叫做“蜉蝣表”的概念，可以正确发现并回收这种弱循环引用。你问我这个“蜉蝣表”的原理？请自己去啃 论文 吧，这玩意儿没人翻译，我看了一眼就睡着了\n\n值得注意的是论文中提到蜉蝣表存在一些“最坏情况”，例如这个例子：\ncollectgarbage 'stop'local oo = {}for i = 1, 5000 do    oo[i] = {}endlocal t = setmetatable({}, { __mode = 'k' })for i = 1, #oo do    local k = oo[i]    local v = oo[i+1]    t[k] = v -- t[o1] = o2, t[o2] = o3, t[o3] = o4 ...endlocal ref = oo[1] -- 确保 o1 有个强引用oo = nil -- 确保其他对象都没有外部引用local clock = os.clock()collectgarbage()print(os.clock() - clock)\n\n在这个例子中，我构造了一个蜉蝣表，表中所有的所有的键值对形成一个链，并确保只有第一个对象有外部的强引用。分别对蜉蝣表与正常表进行了垃圾回收测试：\n\n\n\n对象数量\n正常表耗时\n蜉蝣表耗时\n\n\n\n5000\n0.001\n0.064\n\n\n10000\n0.001\n0.36\n\n\n15000\n0.001\n0.607\n\n\n20000\n0.001\n1.368\n\n\n25000\n0.001\n1.764\n\n\n30000\n0.002\n2.172\n\n\n35000\n0.002\n4.369\n\n\n40000\n0.003\n4.981\n\n\n45000\n0.003\n5.868\n\n\n50000\n0.005\n7.293\n\n\n蜉蝣表是在 Lua 5.2 中被引入的，Lua 5.1 中如果没有外部强引用的话会产生内存泄漏\n\n清理弱表  弱表规定了当键或值被回收后，这个键值对会从弱表中移除。而 Lua 作为引用安全的语言，不允许引用悬空，因此在回收一个对象后必须即时把他们从弱表中移除。在这里 Lua 使用了一个原子阶段，会一次性遍历虚拟机中所有的弱表，清理掉失效的键值对。因此如果你的环境中存在大量巨大的弱表，这个清理阶段可能会造成长时间的停顿。（典型的例子是，为了追踪所有对象的存活情况，使用一个巨大的弱表保存了所有的对象）\n终结器（解析器）Lua 允许你通过元方法 __gc 给对象添加一个终结器，当对象被回收后就会调用此终结器，用于释放对象背后引用的资源（比如在文件对象释放后关闭文件句柄）\n为了保证一致性，所有带有终结器的的对象会在一个原子阶段依次调用（按照创建顺序的反序）。由于调用终结器时需要传入被回收的对象，因此会让这个对象活过这轮。在下一轮垃圾回收时，如果发现该对象依然没有引用就会正式删除（当然不会再调用终结器了），但如果发现该对象重新有了引用（你在终结器中将其重新引用住了，例如将其保存到了全局变量中），那么这个对象就会被正式复活，以后再被回收的话会重新触发终结器\n由于调用终结器是原子操作，因此我们必须要保证终结器内的运行尽量简单以减少停顿。另外为了避免垃圾回收重入，此时的垃圾回收是暂停状态，因此不要创建太多的临时内存。说到底还是要让终结器内的操作尽量简单，复杂的事情要加入到队列中以后再做\n","categories":["Lua"],"tags":["lua"]},{"title":"Unity Shader","url":"/2022/11/25/c639d5d56c8f/","content":"零散的知识  普通纹理绘制  在 CG 语法中，当属性中定义了一个纹理类型的变量\nProperties &#123;    _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;&#125;\n\n想要在 CGPROGRAM 中引用这个纹理，就需要声明一个采样器：\nsampler2D _MainTex;\n\n而在 HLSL 中，sampler2D这个对象被拆分为两部分，即纹理对象和采样器，需要同时声明两个变量来保存它们：\n/*声明主纹理并且为主纹理设置一个采样器（这是一种固定的格式）主纹理的声明同属性的声明，注意类型为 TEXTURE2D，采样通过 SAMPLER 来定义，括号中的名字为采样器的变量名，变量名为 &lt;sampler_纹理名 &gt;，由于这里的纹理名为 MainTex，所以采样器为 sampler_MainTex*/TEXTURE2D(_MainTex);SAMPLER(sampler_MainTex);\n\n之后需要通过采样器函数 SAMPLE_TEXTURE2D 来对它们进行采样：\nhalf4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);\n","categories":["游戏开发"],"tags":["Graphics","Shader","Unity"]},{"title":"Life of a triangle","url":"/2023/04/20/ed6487d7b99b/","content":"\nLife of a triangle\n\nSince the release of the ground breaking Fermi architecture almost 5 years have gone by, it might be time to refresh the principle graphics architecture beneath it. Fermi was the first NVIDIA GPU implementing a fully scalable graphics engine and its core architecture can be found in Kepler as well as Maxwell. The following article and especially the “compressed pipeline knowledge” image below should serve as a primer based on the various public materials, such as whitepapers or GTC tutorials about the GPU architecture. This article focuses on the graphics viewpoint on how the GPU works, although some principles such as how shader program code gets executed is the same for compute.\n自从开创性的 Fermi 架构发布以来，已经过去了近五年时间，现在揭开其背后的基础图形架构了。Fermi 是 NVIDIA 首款实现完全可扩展图形引擎的 GPU，其核心架构也应用到 Kepler 和 Maxwell 的架构中。以下内容，特别是“管线缩略图”，广泛被各种 GPU 架构相关资料（如白皮书或 GTC 教程）所引用。本文从图形角度出发探讨 GPU 的工作原理，其中涉及到的着色器代码如何运行等原理和实际应用中是相同的。\n\n              Fermi Whitepaper  Kepler Whitepaper  Maxwell Whitepaper  Fast Tessellated Rendering on Fermi GF100  Programming Guidelines and GPU Architecture Reasons Behind Them\n          \n\nPipeline Architecture Image\n    \n\n\nGPUs are Super Parallel Work DistributorsWhy all this complexity? In graphics we have to deal with data amplification that creates lots of variable workloads. Each drawcall may generate a different amount of triangles. The amount of vertices after clipping is different from what our triangles were originally made of. After back-face and depth culling, not all triangles may need pixels on the screen. The screen size of a triangle can mean it requires millions of pixels or none at all.\n在图形处理中，需要进行数据增强（包括但不限于裁剪、缩放、旋转、翻转、色彩变换、添加噪声等），对整个图形工作流有很大负担。每个 drawcall 都会会产生不同数量的三角形。裁剪后三角形顶点数量可能与原始三角形顶点数量不同。在背面剔除和深度剔除之后，并非所有三角形都需要在屏幕上显示。屏幕上的三角形需要上百万个像素组成，也可以不需要任何像素表示。这就是图形处理中复杂性的原因。我们需要处理这些变化，以确保图像能够正确、高效地渲染出来。\nAs a consequence modern GPUs let their primitives (triangles, lines, points) follow a logical pipeline, not a physical pipeline. In the old days before G80’s unified architecture (think DX9 hardware, ps3, xbox360), the pipeline was represented on the chip with the different stages and work would run through it one after another. G80 essentially reused some units for both vertex and fragment shader computations, depending on the load, but it still had a serial process for the primitives/rasterization and so on. With Fermi the pipeline became fully parallel, which means the chip implements a logical pipeline (the steps a triangle goes through) by reusing multiple engines on the chip.\n简单来说，现代 GPU 让基本图元（如三角形、线条、点）遵循逻辑管线，而不是物理管线。在 G80 统一架构出现之前（比如 DX9 硬件、PS3、Xbox300 等），GPU 的处理流程在芯片上被划分为不同的阶段，并且图元会按照一定的顺序一个接着一个的处理。G80 架构虽然在一定程度上实现了顶点和片元着色器计算的单元复用，但基本图元（如三角形）和栅格化等处理仍然是串行的。而到了 Fermi 架构，处理流程实现了全并行化，这意味着 GPU 通过复用芯片上的多个引擎，来并行地实现一个逻辑管线（即三角形等图元经历的各个处理步骤）。这样的设计大大提高了 GPU 的效率和性能。\nLet’s say we have two triangles A and B. Parts of their work could be in different logical pipeline steps. A has already been transformed and needs to be rasterized. Some of its pixels could be running pixel-shader instructions already, while others are being rejected by depth-buffer (Z-cull), others could be already being written to framebuffer, and some may actually wait. And next to all that, we could be fetching the vertices of triangle B. So while each triangle has to go through the logical steps, lots of them could be actively processed at different steps of their lifetime. The job (get drawcall’s triangles on screen) is split into many smaller tasks and even subtasks that can run in parallel. Each task is scheduled to the resources that are available, which is not limited to tasks of a certain type (vertex-shading parallel to pixel-shading).\n可以这样来解释：假设我们有两个三角形 A 和 B。它们的工作流程中可能包含不同的逻辑管线。三角形 A 已经完成了变换，接下来需要进行光栅化。在这个过程中，A 的一些像素可能已经在执行像素着色器指令，而另一些可能因为深度缓冲区（Z-cull）而被拒绝，还有一些可能已经被写入到帧缓冲区中，还有一些可能还在等待处理。与此同时，我们可能正在获取三角形 B 的顶点。所以，虽然每个三角形都需要按照逻辑管线进行处理，但在它们的生命周期中，很多步骤都可以并行地进行处理。整个任务（即将 drawcall 后的三角形显示在屏幕上）被分割成许多更小的任务或者子任务，这些子任务可以并行运行。每个子任务都被调度到可用的资源上，包括某些特定的任务（如顶点着色器与像素着色器也可以并行处理）。\nThink of a river that fans out. Parallel pipeline streams, that are independent of each other, everyone on their own time line, some may branch more than others. If we would color-code the units of a GPU based on the triangle, or drawcall it’s currently working on, it would be multi-color blinkenlights :)\n可以将这个架构想象成河流的支流，形成的多条并行的支流，它们彼此独立，各自按照自己的时间线流动，有些模块可能会生成更多的支流。如果我们根据 GPU 中当前正在处理的三角形或 drawcall 来给 GPU 中的单元模块染色，那么它们就会像各种颜色的信号灯一样闪烁：)\nGPU Architecture\n    \n\n\nSince Fermi NVIDIA has a similar principle architecture. There is a Giga Thread Engine which manages all the work that’s going on. The GPU is partitioned into multiple GPCs (Graphics Processing Cluster), each has multiple SMs (Streaming Multiprocessor) and one Raster Engine. There is lots of interconnects in this process, most notably a Crossbar that allows work migration across GPCs or other functional units like ROP (render output unit) subsystems.\n英伟达（NVIDIA）的 Fermi 架构和 Maxwell 架构原理一样。用一个  千兆线程引擎  处理所有任务。GPU 被划分为多个图形处理集群（GPC），每个 GPC 都包含若干流式多处理器（SM）和一个光栅引擎（Raster Engine）。在这个过程中，存在大量的互连，其中最重要的是一个交叉开关（Crossbar），它允许任务在 GPC 之间或像 ROP（渲染输出单元）子系统等其他功能单元之间迁移。\nThe work that a programmer thinks of (shader program execution) is done on the SMs. It contains many Cores which do the math operations for the threads. One thread could be a vertex-, or pixel-shader invocation for example. Those cores and other units are driven by Warp Schedulers, which manage a group of 32 threads as warp and hand over the instructions to be performed to Dispatch Units. The code logic is handled by the scheduler and not inside a core itself, which just sees something like “sum register 4234 with register 4235 and store in 4230” from the dispatcher. A core itself is rather dumb, compared to a CPU where a core is pretty smart. The GPU puts the smartness into higher levels, it conducts the work of an entire ensemble (or multiple if you will).\n大部分可编程的工作（着色器的运行）是在 SM（流式多处理器）上完成的。它包含许多以数学计算为核心的线程。例如，一个线程可能被顶点着色器或像素着色器所占用。核心和其他单元都由 Warp 调度器驱动，其中每个 32 个线程组成一个束，并将要执行的指令交给调度单元。代码逻辑由调度器处理，而不是核心本身，例如：“将寄存器 4234 的值与寄存器 4235 的值相加并存储在寄存器 4230 中”的指令是有调度器完成。然而，相比于 CPU 的核可以处理复杂的逻辑，GPU 的核显得更单一。原因是 GPU 的将复杂的逻辑处理放在更高的一级，它可以协调 GPU 整体进行运作。\nHow many of these units are actually on the GPU (how many SMs per GPC, how many GPCs..) depends on the chip configuration itself. As you can see above GM204 has 4 GPCs with each 4 SMs, but Tegra X1 for example has 1 GPC and 2 SMs, both with Maxwell design. The SM design itself (number of cores, instruction units, schedulers…) has also changed over time from generation to generation (see first image) and helped making the chips so efficient they can be scaled from high-end desktop to notebook to mobile.\n这些单元实际上在 GPU 上的数量（每个 GPC 中有多少个 SM，有多少个 GPC 等）取决于芯片配置。例如 GM204 拥有 4 个 GPC，每个 GPC 中有 4 个 SM；Tegra X1 则只有 1 个 GPC 和 2 个 SM，两者都采用了 Maxwell 设计。而 SM 的设计（包括核心数量、指令单元、调度器等）也在更新迭代（请参考 Fermi 管线架构图），让芯片更加高效，能够从高端主机兼容到笔记本再到移动设备。\nThe Logical PipelineFor the sake of simplicity several details are omitted. We assume the drawcall references some index- and vertexbuffer that is already filled with data and lives in the DRAM of the GPU and uses only vertex- and pixelshader (GL: fragmentshader).\n为了简化说明，假设一次 drawcall 只引用了一些索引缓冲区和顶点缓冲区，这些缓冲区已经被数据填充，并存储在 GPU 的动态随机存取存储器（DRAM）中。一次 drawcall 仅使用顶点着色器和像素着色器（在 OpenGL 中称为片段着色器）来处理数据。这是一个在 GPU 上执行的图形渲染过程，它利用已经准备好的数据来绘制图形，这些数据通过索引和顶点缓冲区来组织，并使用着色器程序来渲染最终的图像。\n\n    \n\n\n\nThe program makes a drawcall in the graphics api (DX or GL). This reaches the driver at some point which does a bit of validation to check if things are “legal” and inserts the command in a GPU-readable encoding inside a pushbuffer. A lot of bottlenecks can happen here on the CPU side of things, which is why it is important programmers use apis well, and techniques that leverage the power of today’s GPUs.\n 当用图形 API（如 DirectX 或 OpenGL）发起一次 drawcall，命令会传到驱动程序，并进行合法性验证；然后这个命令以 GPU 可读的编码方式插入到一个推送缓冲区中。由于现代 GPU 的性能和处理速度越来越快，导致整个渲染过程在 CPU 会遇到瓶颈，所以要规范的使用图形 API 才能避免性能瓶颈。\n\nAfter a while or explicit “flush” calls, the driver has buffered up enough work in a pushbuffer and sends it to be processed by the GPU (with some involvement of the OS). The Host Interface of the GPU picks up the commands which are processed via the Front End.\n 当收到明确的“刷新”指令时或者缓存一定时间后，驱动程序会在推送缓冲区中缓存一定数量的任务，将其发送给 GPU 进行处理（操作系统这时也会参与进来）。GPU 的主机接口用来接收这些命令，并通过前端进行处理。简单来说，这个过程就是驱动程序先将一些需要 GPU 处理的任务缓存起来，当达到一定量或者通过特定操作触发时，这些任务就会被发送到 GPU 进行进一步的执行。\n\nWe start our work distribution in the Primitive Distributor by processing the indices in the indexbuffer and generating triangle work batches that we send out to multiple GPCs.\n 在“图元分配器”（Primitive Distributor）中，开始进行任务分配的。这个过程涉及到处理索引缓冲区（indexbuffer）中的索引，生成三角形批次，然后将每个批次发送到 GPCs 进行处理。\n \n     \n \nWithin a GPC, the Poly Morph Engine of one of the SMs takes care of fetching the vertex data from the triangle indices (Vertex Fetch).\n 在 GPC 中，Poly Morph 模块负责从索引中检索顶点数据（顶点提取）这个过程是图形渲染流水线中的一部分，它负责从存储的三角形数据中提取出构成这些三角形的顶点信息。Poly Morph 引擎是图形处理单元（GPU）中的一个关键组件，它优化了顶点数据的提取和转换，以便后续进行光栅化和像素着色等处理。\n\nAfter the data has been fetched, warps of 32 threads are scheduled inside the SM and will be working on the vertices.\n 数据提取后，在 SM 内部会调度 32 个线程的束（warp）处理顶点。这里的“顶点”是指图计算、图形渲染或任何需要并行处理大量数据点的场景中的元素。束（warp）是 GPU 编程中的一个术语，它指的是一组并行执行的线程，这些线程在 GPU 中一起工作，以提高处理效率。在 NVIDIA 的 GPU 架构中，一个束通常包含 32 个线程。\n\nThe SM’s warp scheduler issues the instructions for the entire warp in-order. The threads run each instruction in lock-step and can be masked out individually if they should not actively execute it. There can be multiple reasons for requiring such masking. For example when the current instruction is part of the “if (true)” branch and the thread specific data evaluated “false”, or when a loop’s termination criteria was reached in one thread but not another. Therefore having lots of branch divergence in a shader can increase the time spent for all threads in the warp significantly. Threads cannot advance individually, only as a warp! Warps, however, are independent of each other.\n SM 的束调度器按顺序为整个束发出指令。线程以同步的方式运行每条指令，如果指令不主动执行，则可以单独屏蔽掉这条指令。可能需要这种屏蔽方式的原因有很多，例如，当前指令只有满足 if (true) 的条件才会执行，而该线程具体的数值计算为 false 时，需要屏蔽掉该指令；或者当一个线程的循环终止条件达到而另一个线程未达到时，需要屏蔽掉已经终止的线程中的指令。因此，着色器中存在大量分支语句会显著增加束中线程运行的时间。线程不能单独运行，只能组成一个束统一调度；但是，束与束之间是独立的。\n\nThe warp’s instruction may be completed at once or may take several dispatch turns. For example the SM typically has less units for load/store than doing basic math operations.\n 指令的执行可能是立即完成的，也可能需要几个调度周期。例如，SM 中用于加载 / 存储的单元要比执行基本数学运算的单元要少。这意味着不同的指令可能需要不同的时间来执行，这取决于它们的类型和所需的资源。在一些情况下，比如需要频繁地访问内存时，执行速度可能会相对较慢。\n\nAs some instructions take longer to complete than others, especially memory loads, the warp scheduler may simply switch to another warp that is not waiting for memory. This is the key concept how GPUs overcome latency of memory reads, they simply switch out groups of active threads. To make this switching very fast, all threads managed by the scheduler have their own registers in the register-file. The more registers a shader program needs, the less threads/warps have space. The less warps we can switch between, the less useful work we can do while waiting for instructions to complete (foremost memory fetches).\n 由于某些指令比其他指令需要更长的时间来完成，尤其是内存加载，束调度器会切换到另一个不在等待内存的束。这就是 GPU 解决内存存读取延迟的关键，做法就是简单地切换到活跃线程组。为了使这种切换非常快速，调度器管理的所有线程都有自己的寄存器。着色器程序需要的寄存器越多，线程或束的空间就越少。可切换的束越少，在等待指令完成（主要是内存读取）时能做的有用工作就越少。\n \n     \n \nOnce the warp has completed all instructions of the vertex-shader, it’s results are being processed by Viewport Transform. The triangle gets clipped by the clipspace volume and is ready for rasterization. We use L1 and L2 Caches for all this cross-task communication data.\n 当顶点着色器完成了所有指令的处理后，还需要经过视口变换（Viewport Transform）进一步处理。在这个过程中，三角形会根据裁剪空间进行裁剪，以准备进行光栅化。在整个跨任务通信数据处理的过程中，会使用 L1 和 L2 缓存来加快处理速度。\n \n     \n \nNow it gets exciting, our triangle is about to be chopped up and potentially leaving the GPC it currently lives on. The bounding box of the triangle is used to decide which raster engines need to work on it, as each engine covers multiple tiles of the screen. It sends out the triangle to one or multiple GPCs via the Work Distribution Crossbar. We effectively split our triangle into lots of smaller jobs now.\n三角形被分割后，会离开它当前的 GPC。一个三角形的包围盒决定需要的光栅引擎的个数，同时每个光栅引擎会覆盖屏幕上多个像素块。这个过程是通过任务分配器的交叉开关可以将三角形分配到一个或多个 GPC(s) 进行处理。这样就三角形的数据处理分配到到多个较小的任务上进行。\n\n    \n\nAttribute Setup at the target SM will ensure that the interpolants (for example the outputs we generated in a vertex-shader) are in a pixel shader friendly format.\n在指定的 SM 上进行属性设置时，要保证插值变量（例如在顶点着色器中生成的输出）符合像素着色器处理的格式。这一步骤是为了保证在图形渲染的后续阶段，尤其是在像素着色器中，这些变量能够被正确且高效地使用。\n\nThe Raster Engine of a GPC works on the triangle it received and generates the pixel information for those sections that it is responsible for (also handles back-face culling and Z-cull).\n在 GPC 中的光栅引擎处理其被分配的三角形，并生成像素信息（同时还处理背面剔除和深度剔除）。\n\nAgain we batch up 32 pixel threads, or better say 8 times 2x2 pixel quads, which is the smallest unit we will always work with in pixel shaders. This 2x2 quad allows us to calculate derivatives for things like texture mip map filtering (big change in texture coordinates within quad causes higher mip). Those threads within the 2x2 quad whose sample locations are not actually covering the triangle, are masked out (gl_HelperInvocation). One of the local SM’s warp scheduler will manage the pixel-shading task.\n将 32 个像素线程分成 8 个 2x2 像素块，这是像素着色器中处理的最小单元。2x2 像素块是用来计算诸如纹理 mip-map 贴图的导数（如果 2x2 像素块内的纹理坐标变化较大，将使用更高分辨率的 mip-map 贴图）。在 2x2 像素块内，那些不实际覆盖三角形的线程会被屏蔽。用其中一个 SM 的束调度器管理像素着色的任务。\n\nThe same warp scheduler instruction game, that we had in the vertex-shader logical stage, is now performed on the pixel-shader threads. The lock-step processing is particularly handy because we can access the values within a pixel quad almost for free, as all threads are guaranteed to have their data computed up to the same instruction point (NV_shader_thread_group).\n像素着色器线程中的束调度器使用了与顶点着色器阶段相同的调度机制。这个机制允许在像素块内访问值几乎不需要任何代价，所以同步处理非常方便。由于所有线程的数据都保证计算到同一步指令位置，线程之间可以高效地共享数据。\n\n    \n\nAre we there yet? Almost, our pixel-shader has completed the calculation of the colors to be written to the rendertargets and we also have a depth value. At this point we have to take the original api ordering of triangles into account before we hand that data over to one of the ROP (render output unit) subsystems, which in itself has multiple ROP units. Here depth-testing, blending with the framebuffer and so on is performed. These operations need to happen atomically (one color/depth set at a time) to ensure we don’t have one triangle’s color and another triangle’s depth value when both cover the same pixel. NVIDIA typically applies memory compression, to reduce memory bandwidth requirements, which increases “effective” bandwidth (see GTX 980 pdf).\n像素着色器完成颜色和深度值的计算后，需要考虑三角形按照 API 中的顺序传递给 ROP 单元。在 ROP 单元中进行深度测试和帧缓冲区混合等操作，这些操作是原子性的，以保证渲染结果的正确性。NVIDIA 还使用内存压缩技术来减少内存带宽需求，从而提高传输效率（参考 GTX 980）。\n\n\nFurther Reading\n  A trip through the graphics-pipeline\n  Performance Optimization Guidelines and the GPU Architecture behind them\n  Pomegranate: A Fully Scalable Graphics Architecture \n\n","categories":["图形学"],"tags":["Graphics","翻译","GPU"]},{"title":"Lua 解释器构建：从虚拟机到编译器","url":"/2023/04/03/6a4770ec7c72/","content":"增量式标记清除算法  整个 GC 执行的过程中，大致经历以下几个阶段\n\npause 阶段\nmainthread 和 global table 包含 GC 起始点，因此要将它们插入到 gray 链表中，并将它们标记为灰色，进入到 propagate 阶段\n\npropagate 阶段\n\n不断从 gray 链表中取出对象，然后把它从灰色变为黑色，再遍历它所引用的对象，并将其插入到 gray 链表中\npropagate 阶段累积遍历的对象大小超过一定的字节数，本轮 GC 会被终止，等待下一次 GC 步骤开始后继续扫描 gray 链表中的对象\n当 gray 链表为空时，进入 atomic 阶段\n\n\natomic 阶段\n\nGC 步骤在 pause 阶段是可以被中断的，假如新建的对象被标记为黑色的对象引用，本轮 GC 就不会对其进行遍历和标记，到 sweep 阶段就会被当作不可达的对象而清除掉\n需要为新建对象设置屏障（barrier）\n向前设置屏障：直接将新创建的对象标记为灰色，放入到 gray 链表中\n向后设置屏障：将黑色对象标记为灰色， grayagain 链表中\n\n\n原子执行 atomic 阶段\n\n\nsweep 阶段\n从 allgc 链表中去除若干个对象；如果已经是本轮 GC 要被清除的  白色 ，那么它会被清除；如果不是，则标记为 另一种白，以供下一轮 GC 使用\n\n\nLua 虚拟机的字符串\n从 Lua-5.2.1 开始，字符串就分为长字符串合短字符串。其中短字符串会进行充分的哈希运算，并进行内部优化处理；长字符串不会进行哈希运算和内部化\n字符串内部化的本质就是为每个字符串创建唯一的实例\n在 Lua 中，字符串 Body 长度小于或等于 40B 的是短字符串，大于 40B 的是长字符串；在 Lua-5.3 中，短字符串的大小限制由 LUAI_MAXSHORTLEN 决定，这个宏定义在 llimits.h 中定义\n\nLua 虚拟机的表Lua 表的基本数据结构// luaobject.htypedef union lua_Value &#123;    struct GCObject* gc;    void* p;    int b;    lua_Interger i;    lua_Number n;    lua_CFunction f;&#125; Value;typedef struct lua_TValue &#123;    Value value_;    int tt_;&#125; TValue;// lua Tabletypedef union TKey &#123;    struct &#123;        Value value_;        int tt; // 用来标记 value_是什么类型        int next;    &#125; nk;    TValue tvk;&#125; TKey;typedef struct Node &#123;    TKey key;    TValue value;&#125; Node;struct Table &#123;    CommonHeader;               // GC 部分    TValue* array;              // 数组部分    unsigned int arraysize;     // 数组大小    Node* node;                 // hash 部分    unsigned int lsizenode;     // hash 大小，实际大小为 2&lt;sup&gt;lsizenode    Node* lastfree;             // 空闲指针    struct GCObject* gclist;    // GC 部分&#125;\n\n键值的哈希运算 Node 结构的 key 可以是任意 Lua 类型。key值是如何和哈希表的索引对应起来\n\n对 key 进行哈希运算\n根据得到的哈希值，换算成表结构 node 数组的索引值\nindex = hash_value &amp; (2^lsizenode - 1)\n\n\n查找元素\n被查找的元素 key 是 int 类型：\nkey 在数组范围之内（在 array 中查找），返回array[k - 1]\nkey 不在数组范围之内，计算哈希值（在 node 链表中查找）\n\n\n被查找的元素 key 不是 int 类型：key 不在数组范围之内，计算哈希值（在 node 链表中查找）\n\n\n\n调整表的大小\nnums[i]的含义：统计 $(2^{i - 1}, 2^i]$ 区间内，所有数组索引值、哈希表key（类型为int）的哈希值位于这个区间的元素总数n\n\n判断新插入的元素的 key 值是否为整数类型，如果是则对应区间总数增加 1：nums[i]++\n\n完成 nums 的统计后，根据 nums 计算新的数组大小。在数组大小范围内，值不为 nil 的元素要超过数组大小的一半：\n  int i = 0;int asize = 0;for (; i &lt; 32; i++) &#123;    asize += nums[i];    if (asize &gt; pow(2, i) / 2) &#123;        arraysize = pow(2, i)    &#125;&#125;\n计算在数组大小范围内有效元素的个数，记为array_used_num\n\n当数组比原来大时，扩展  原来的数组到新的大小，并将哈希表中 key 值小于等于 arraysize，且大于 0 的元素转移到数组中，并将哈希表大小调整为 $\\lceil \\log_2^{total - array_used_num} \\rceil$，同时对每个node 重新定位\n\n当数组比原来小时，缩小  原来的数组到新的大小，并将数组中 key 值超过数组大小的元素转移到哈希表中，并将哈希表大小调整为 $\\lceil \\log_2^{total - array_used_num} \\rceil$，同时对每个 node 重新定位\n\n\nLua 中的三种函数类别 Light C Function 可以理解为普通的 C 函数，如\nstatic int test_main(struct lua_State* L)&#123;    int arg1 = (int)luaL_tointeger(L, 1);    int arg2 = (int)luaL_tointeger(L, 2);    printf(&quot;test main arg1:%d arg2%d \\n&quot;, arg1, arg2);    lua_pushinteger(L, arg1 + arg2);    return 1;&#125;\n\n要在 Lua 虚拟机中运行 test_main 函数，需要调用lua_pcall，其声明如下\n// L 表示 Lua 线程// narg 表示在 Lua 线程里执行的函数有多少个参数// nresult 表示在 Lua 线程里执行的函数有多少个返回值int lua_pcall(struct lau_State* L, int narg, int nresult);\n\nC 闭包#define ClosureHeader \\   CommonHeader; lu_byte nupvalues; GCObject* gclisttypedef struct CClosure &#123;    ClosureHeader;    lua_Function f;    TValue upvalue[1]; // upvalue 列表&#125; CClosure;\n\n一个 C 闭包和 Light C Function 函数相比，除了受 GC 托管并且拥有上值列表外，其他功能和 Light C Function 函数差不多\nLua 闭包 Lua 闭包是受 Lua 虚拟机的 GC 托管的，Lua 脚本代码经过编译生成的虚拟指令，以及其他一些编译相关的信息会存放在 LClosure 中的Proto 类型变量中\ntypedef struct LClosure &#123;    ClosureHeader;    struct Proto* p;    UpVal* upvals[1];&#125; LClosure;\n\nProto结构// common/luaobject.htypedef struct Proto &#123;    CommonHeader;    int is_vararg;          // 标记 Lua 函数参数列表是否为可变参，0 表示否，1 表示是    int nparam;             // 当 is_varrag 为 0 时生效，它表示该函数参数的数量    Instruction* code;      // Lua 函数经过编译后，生成的虚拟机指令列表    int sizecode;           // 指明 code 列表的大小    TValue* k               // 常量列表，如数值、字符串等    int sizek;              // 常量列表大小    LocVar* localvars;      // local 变量列表    int sizelocvar;         // local 变量列表大小    Upvaldesc* upvalues;    // upvalue 信息列表，主要记录 upvalue 的名称，以及其所在的地址，并不是 upvalue 实际值的列表    int sizeupvalues;       // upvalue 列表大小    struct Proto** p;       // 内嵌定义的函数列表    int sizep;              // proto 列表长度    TString* source;        // 脚本路径    struct GCObjects* gclist;    int maxstacksize;       // Proto 所对应的 Lua 函数被调用时，函数栈的最大尺寸&#125; Proto;\n\n上值生成过程  上值实际上是再编译时确定（位置信息和外层函数的关联等）、在运行时生成的。用来表示上值的数据结构有两个，一个是编译时期存储上值信息的 Upvaldesc（这个结构并不存储上值的实际值，只是用来标记上值的位置信息），另一个是在运行时实际存储上值的UpVal 结构\n// luaobject.htypedef struct Upvaldesc &#123;    // 本函数的上值是否指向外层函数的栈（如果不是则指向外层函数的某个上值）    int in_stack;    // 上值在外层函数中的位置（栈的位置或 upval 列表中的位置，根据 in_stack 确定）    int idx;    // 上值的名称    TString* name; &#125; Upvaldesc；\n\n// luafunc.hstruct Upval &#123;    // 指向外层函数的 local 变量（开放上值），或者指向自己（上值关闭时）    TValue* v;    // Upval 实例被引用的次数    int refcount;    union &#123;        struct &#123;            struct UpVal* next; .. 下一个开放上值            int touched;        &#125; open;        Tvalue value;    &#125; u;&#125;\n\nLua 脚本的编译信息会被存储到 Proto 结构实例中，当一个 Lua 函数的某个变量不是 local 变量时，如果希望获得它的值，实际上就要查找这个变量的位置，如果在 local 列表中找不到，则进入一下流程：\n\n到自己的 Upvaldesc 列表中，根据变量名查找，如果存在则使用它，否则进行下一步；\n到外层函数查找 local 变量，如果找到它就将它作为自己的上值，否则查找它的 Upvaldesc 表，找到就将其生成为自己的上值，否则进入更外层函数，重复这一步；\n如果一直到顶级函数都找不到，那么表示这个上值不存在，此时需要去 _ENV 中查找\n\n","categories":["读书笔记"],"tags":["lua","源码"]},{"title":"C++ 知识","url":"/2021/11/08/ea34a7c058d8/","content":"C++ 虚函数C++ 虚函数是定义在基类中的函数，子类必须对其进行覆盖。\n虚函数的作用\n定义子类对象，并调用对象中未被子类重写的基类函数 A。同时在该函数A 中，又调用了已被子类重写的基类函数B。那此时将会调用基类中的函数B，可我们本应该调用的是子类中的函数B。虚函数即能解决这个问题。\n\n#include&lt;iostream&gt;using namespace std;// 基类 Fatherclass Father &#123;public:    void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;    // 在函数中调用了，子类重写基类的函数 display()    void fatherShowDisplay() &#123;        display();    &#125;&#125;;// 子类 Sonclass Son:public Father &#123;public:    // 重写基类中的 display() 函数    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Son son;                    // 子类对象    son.fatherShowDisplay();    // 通过基类中未被重写的函数，想调用子类中重写的 display 函数&#125;\n\n\nFather::display()\n\n用虚函数：\n#include&lt;iostream&gt;using namespace std;// 基类 Fatherclass Father &#123;public:    virtual void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;    // 在函数中调用了，子类重写基类的函数 display()    void fatherShowDisplay() &#123;        display();    &#125;&#125;;// 子类 Sonclass Son:public Father &#123;public:    // 重写基类中的 display() 函数    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Son son;                    // 子类对象    son.fatherShowDisplay();    // 通过基类中未被覆盖的函数，想调用子类中重写的 display 函数&#125;\n\n\nSon::display()\n\n\n在使用  指向子类对象的基类指针，并调用子类中的重写函数  时，如果该函数不是虚函数，那么将调用基类中的该函数；如果该函数是虚函数，则会调用子类中的该函数。\n\n#include&lt;iostream&gt;using namespace std;// 基类 Fatherclass Father &#123;public:    void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;&#125;;// 子类 Sonclass Son:public Father &#123;public:    // 重写基类中的 display 函数    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Father *fp;     // 定义基类指针    Son son;        // 子类对象    fp = &amp;son;        // 使基类指针指向子类对象    fp-&gt;display();  // 通过基类指针想调用子类中重写的 display 函数&#125;\n\n\nFather::display()\n\n#include&lt;iostream&gt;using namespace std;// 基类 Fatherclass Father &#123;public:    // 定义了虚函数    void virtual display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;&#125;;// 子类 Sonclass Son:public Father &#123;public:    // 覆盖基类中的 display 函数    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Father *fp;     // 定义基类指针    Son son;        // 子类对象    fp = &amp;son;        // 使基类指针指向子类对象    fp-&gt;display();  // 通过基类指针想调用子类中覆盖的 display 函数&#125;\n\n\nSon::display()\n\n虚函数的原理  虚函数的本质是一个简单的  虚函数表 。当一个类存在虚函数时，通过该类创建的对象实例，会在内存空间的前 4 个字节保存一个指向虚函数表的指针__vfptr。__vfptr 指向的虚函数表是类独有的，而且该类的所有对象共享。虚函数表的实质是一个虚函数地址的数组，它包含了类中每个虚函数的地址，既有当前类定义的虚函数，也有重写父类的虚函数，也有继承而来的虚函数。当子类重写了父类的虚函数时，子类虚函数表将包含子类虚函数的地址，而不会有父类虚函数的地址。同时，当用基类指针指向子类对象时，基类指针指向的内存空间中的 __vfptr 依旧指向了子类的虚函数表。所以，基类指针依旧会调用子类的虚函数。\n定义一个有虚函数的类class Base1 &#123;public:    int base1_1;    int base1_2;        virtual void base1_func1() &#123;&#125;    virtual void base1_func2() &#123;&#125;&#125;;\n\n定义两个对象：\nBase1 b1;Base1 b2;\n\n两个对象的内存空间分配如下：\n\n定义一个子类class Base1 &#123;public:    int base1_1;    int base1_2;    virtual void base1_fun1() &#123;&#125;    virtual void base1_fun2() &#123;&#125;    &#125;;class Derive1 : public Base1 &#123;public:    int derive1_1;    int derive1_2;    // 覆盖基类函数    virtual void base1_fun1() &#123;&#125;&#125;;\n\n定义一个子类对象：\nDerive1 d1;\n\n其内存空间如下：\n\nc++ 中的纯虚函数  纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加=0\nclass A&#123;public:    virtual void foo() = 0;&#125;;\n\n在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。而针对每种动物的方法又有所不同，此时需要使用多态特性，也就需要在基类中定义虚函数。\n纯虚函数是在基类中声明的虚函数，它要求任何派生类都要定义自己的实现方法，以实现多态性。实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数。\n定义纯虚函数是为了实现一个接口，用来规范派生类的行为，也即规范继承这个类的程序员必须实现这个函数。派生类仅仅只是继承函数的接口。纯虚函数的意义在于，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但基类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\n含有纯虚函数的类称之为抽象类，它不能生成对象（创建实例），只能创建它的派生类的实例。抽象类是一种特殊的类，它是为了抽象和设计的目的为建立的，它处于继承层次结构的较上层。抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。\n抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。\n虚析构函数  主要功能就是确保继承体系中的对象正确释放。\nclass Base&#123;public:    virtual ~Base()&#123;&#125;&#125;;class Derived :public Base&#123;public:    Derived() &#123;        pointer = new int[10];    &#125;    ~Derived() &#123;        delete []pointer;    &#125;    int *pointer;&#125;;void main()&#123;    Derived *d = new Derived();    Base *b = d;    delete b;&#125;\n\n如果没有虚析构函数，则只会调用基类的析构函数，那么派生类中分配的内存就没办法释放，造成泄露。所以，如果发生继承，一定要把基类析构函数定义为虚函数。\nC++ 中函数重载、重写和重定义\n重载（overload）：函数名相同，参数列表不同，重载只存在类的内部\n\n重写（override）：子类重新定义父类中有相同名称和参数的虚函数，存在于继承关系之间\n\n被重写的函数不能是 static 的，必须是 virtual 的\n重写函数必须有相同的返回值类型、名称和参数列表\n重写函数的访问修饰符可以不同\n\n\n重定义（redefining）：子类重新定义父类有相同名称的非虚函数\n\n\n编译器如何解决命名冲突\n编译后，重载的函数名各不相同。变名的机制：作用域 + 返回类型 + 函数名 + 参数列表，来解决命名冲突的问题\n智能指针 shared_ptr、weak_ptr、unique_ptrshared_ptr 只有指向动态分配的对象的指针才能交给 shared_ptr 对象托管。\n不能用下面的方式使得两个 shared_ptr 对象托管同一个指针：\nA* p = new A(10);shared_ptr&lt;A&gt; sp1(p), sp2(p);\n\nsp1和 sp2 并不会共享同一个 p 的托管技术，而是各自将对 p 的的托管计数都记为 1。这样，当 sp1 消亡时要析构 p，sp2 消亡时要再次析构p，这会导致程序崩溃。\nweak_ptrweak_ptr是一种用于解决 shared_ptr 相互引用时产生死锁问题的智能指针。weak_ptr时对对象的一种弱引用，它不会增加对象的引用计数，weak_ptr和 shared_ptr 可以相互转化，shared_ptr可以直接赋值给 weak_ptr，weak_ptr 也可以通过 lock 函数来获得shared_ptr。\n\nweak_ptr指针通常不单独使用，只能和 shared_ptr 类型指针搭配使用。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放。即使有 weak_ptr 指向对象，对象也还是会被释放。\nweak_ptr并没有重载 operator -&gt; 和operator *操作符，因此不可直接通过 weak_ptr 使用对象，典型的用法时调用其 lock 函数来获得 shared_ptr 实例，进而访问原始对象。\n\nunique_ptrunique_ptr是一个独享所有权的智能指针，unique_ptr对象包装一个原始指针，并负责其生命周期。当该对象被销毁时，会在其析构函数中删除关联的原始指针。unique_ptr重载了 -&gt; 和*运算符，因此可以像其他普通指针一样使用。\n引用计数是在对上还是栈上  多个 shared_ptr 或weak_ptr可以指向同一个被引用计数的对象。而其中一个或几个离开作用域被析构，强引用计数未归 0，指向的对象不能释放。因此不能放到栈上。\n","categories":["C++"],"tags":["c++"]},{"title":"DIY 摆放","url":"/2024/05/31/ee6e87e384c9/","content":"分析\n    \n\n\n相关细节  自定义网格  基础网格\npublic class Grid&lt;T&gt;&#123;    public T[,] grids;    public Vector3 rotation; // 为 0 时表示地面，63（arctan2）时表示墙面    public int width;    public int height;    private Vector3 cellSize; // 网格大小，类似 unity 中 tilemap，layout 设置为 `isometric` 类型，(2, 1, 1) 表示每个 cell 的 width:height 为 2:1    private Vector3 origin;&#125;\n\n网格物件\npublic class GridObject&#123;    public int x, y;    private Grid&lt;GridObject&gt; grid;    public PlaceableObject PlaceableObject;    public bool CanBuild;    public GridObject(Grid&lt;GridObject&gt; grid, int x, int y)    &#123;        this.grid = grid;        this.x = x;        this.y = y;    &#125;&#125;\n\n\n    \n    \n\n\n可放置物件public class PlaceableObject&#123;    public int depth; // 记录物件的深度，每有一个物件被放置深度加一    public Vector2Int offset; // 相对于网格原点的偏移    public Transform placedObjectTransform; // 贴图 transform    public List&lt;Vector2Int&gt; GridPositions; // 占据的网格大小    private List&lt;Grid&lt;GridObject&gt;&gt; grids; // 物件也有网格，用于堆叠&#125;\n\n遮挡和排序\n深度值越大的（即被放置到其他物件之上），越靠前\n网格索引 (x, 0, z) 越小排序越靠前\n地面的可以遮挡墙面的\n\n工具\n定义可编辑场景，导入相关资源\n编辑模式\n编辑物件的 Placeable 部分\n编辑物件的 Grid 部分\n删除区域\n\n\n响应利用射线检测鼠标位置，在不同编辑模式下，将屏幕坐标转成世界坐标，再转换到网格坐标\n存储编辑结果\n利用ScriptableObject、Json、二进制等存储方式进行保存\n加载\n\n\n\n","categories":["游戏开发"],"tags":["Unity","C#"]},{"title":"RO 项目相关","url":"/2024/05/09/8015191e61fc/","content":"客户端自动战斗 AIBehaviour Designer 行为树插件AI 的解决方案\n编码：反应型 AI\n状态机\n行为树\n基于规则的系统\n\n\n求解：协商行 AI\nA*\n目标导向型行动计划（GOAP）\n层次人物网规划（HTN）\n规划器\n\n\n学习：机器学习\n模仿学习\n强化学习\n\n\n\n游戏中常见的 AI 解决方案都是反应型 AI，RO 中大量用到反应型 AI 的行为树作为解决方案，这个行为树插件就是 Behaviour Designer\nBehaviour Designer 中的 Task简单行为树实际上就是 Task 的集合，Task 有四种不同的类型：\n\nAction 动作——代表了某种状态，最基本的任务\nConditional 条件——用来检测是否达到某种条件\nComposite 复合——包含了一系列子任务列表的父任务\nDecorator 修饰符——也是一个父任务，并且只能包含一个子任务，是用来修改子任务的行为。例如将一个子任务运行 10 次（Repeater），或者对子任务的结果取反（Inverter）\n\nAction 和 Conditional 自定义 Task一般情况下只会在 Behaviour Designer 中定义 Action 和 Conditional，Composite 和 Decorator 使用提供的就可以，下面的 Action 代码由工具自动生成\n[BehaviorDesigner.Runtime.Tasks.TaskDescriptionAttribute(\"血量属性比较\")]public class MAISelfCompareByHP : BehaviorDesigner.Runtime.Tasks.Action{    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"是否自己\")]    public BehaviorDesigner.Runtime.SharedBool is_self;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"目标\")]    public BehaviorDesigner.Runtime.SharedTransform target;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"值类型 (hp 血量 、hp 百分比）\")]    public MoonClient.MAISelfCompareByHP.MHPValueType hp_value_type;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"比较类型\")]    public MoonClient.MNumberComparisonType hp_cmp_type;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"右值\")]    public BehaviorDesigner.Runtime.SharedFloat right_value;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"保存左值结果\")]    public BehaviorDesigner.Runtime.SharedFloat store_left_value;    private MoonClient.MAISelfCompareByHP node;    private MEntity entity;    private MoonClient.MAISelfCompareByHP.MNodeArgs args;       public override void OnAwake()    {     entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.gameObject.name));     if(entity == null) return;     node = new MoonClient.MAISelfCompareByHP();     args = new MoonClient.MAISelfCompareByHP.MNodeArgs();      args.is_self = is_self.swigValue;      args.hp_value_type = hp_value_type;      args.hp_cmp_type = hp_cmp_type;      args.right_value = right_value.swigValue;      args.store_left_value = store_left_value.swigValue;     node.SetNodeArgs(args);    }        public override TaskStatus OnUpdate()    {     if(entity == null) return TaskStatus.Failure;     return node.Update(entity) ? TaskStatus.Success : TaskStatus.Failure;    }}\n\n常用的 Parent Tasks\nComposite 复合类型\n\nSequence 将其所有子节点依次执行，也就是说当前一个返回“完成”状态后，再运行先一个子节点 [Image]The sequence task is similar to an “and” operation. It will return failure as soon as one of its child tasks return failure. If a child task returns success then it will sequentially run the next task. If all child tasks return success then it will return success. 和“and”操作符逻辑类似，下面的子任务按照从左到右的顺序执行，如果有一个子任务返回 false，后续子任务都不执行，并且该任务直接返回 false\nSelector 选择其子节点的某一个执行 [Image]The selector task is similar to an “or” operation. It will return success as soon as one of its child tasks return success. If a child task returns failure then it will sequentially run the next task. If no child task returns success then it will return failure. 和“or”操作符逻辑类似，让子任务从左到右依次执行，如果有一个人物返回 true，后续所有人物就不执行，该任务直接返回 true\nParallel 将其所有子节点都运行一遍\n\n\nDecorator 装饰器类型\n\nInverter\nRepeater\nReturn Failure 和 Return Success\n\n// ReturnFailure.cspublic override TaskStatus Decorate(TaskStatus status){    // Return failure even if the child task returned success.    if (status == TaskStatus.Success) {        return TaskStatus.Failure;    }    return status;}// ReturnSuccess.cspublic override TaskStatus Decorate(TaskStatus status){    // Return success even if the child task returned failure.    if (status == TaskStatus.Failure) {        return TaskStatus.Success;    }    return status;}\n\n无论返回成功还是失败，都是返回相应任务对应的结果\n\nUntil Failure 和 Until Success\nRandom Probability\n\n\n\n变量相关  行为树的优点是非常灵活，因为所有任务都是解耦合的，任务之间是不互相依赖的。但是有时候需要提供彼此共享的信息，这是会用到行为树提供的共享变量类型。在需要的 Task 中定义了某个类型，需要在行为树中创建该类型，并在 Task 中引用该类型\n局部变量就是当前行为树可以共享的变量，全局变量就是所有行为树都可以共享的变量，Behaviour Designer 内置的共享变量类型有以下几种：\nSharedAnimationCurveSharedBoolSharedColorSharedFloatSharedGameObjectSharedGameObjectListSharedIntSharedMaterialSharedObjectSharedObjectListSharedQuaternionSharedRectSharedStringSharedTransformSharedTransformListSharedVector2SharedVector3IntSharedVector3SharedVector3IntSharedVector4\n\nBehaviour Designer 中的共享变量的理解 Behaviour Designer 的共享变量是一种黑板（Blackboard）设计模式 输入内容的来源取决于行为树用在整个 AI 架构的哪一层，可以是游戏世界的信息，或者是上层模块的输出。输入的形式，可以是分散的（Decentralized），也可以是集中的（Centralized）。举个例子来说，如果我们做一个战士是移动，还是攻击的决策，这是决策层的行为，所以输入内容就是游戏世界的信息，它可能包括战士自身状态（在模块 A 中），敌人状态（在模块 B 中），装备物品情况（在模块 C），地图场景情况（在模块 D 中）等等，所以，当我们搜索和执行行为树时，我们需要从 4 个模块中获取信息来帮助决策，这样的方式就是我上面说的分散的方式，它的好处是调用非常直接（可能是用多个 Singleton 提供的接口），没有数据冗余，缺点是使得行为树对于数据的依赖度太分散。\n集中的方式的话，就是我们可以定义一个数据结构专门用于行为树的输入，将上面提到的需要用到的数据，在进行行为树决策前，先从各个模块中收集到这个数据结构里，然后再递交给行为树使用。集中式的输入减少了输入和行为树之间的接口数量（只和预定义的数据结构通信），但缺点是，存在数据冗余。不过，我们可以看到集中式的数据输入使得行为树的表现更像一个黑盒了（可以伪造数据来测试行为树），这也是我们一直以来想要的。可以参看下面对于两种方式的示意图：在行为树的使用过程中，发现有时候节点和节点间，行为树和行为树之间确实需要有数据共享，比如对于序列（Sequence）节点来说，它的执行行为是依次执行每一个子节点，直白一点说的话，就是执行完一个再执行下一个。一般用到序列的行为，其子节点间总会有一些联系，这里就可能存在节点间通信的问题。再比如，在一些团队 AI 的决策过程中，当前 AI 的行为树决策可能需要参考其他 AI 的决策结果，所以这样就存在了行为树之间需要通信的情况。\n所以，在实践过程中，我们还会定义另一块黑板来负责行为树间和节点间的通信需求，示意图如下\nRO 中的 MShareData 可共享的变量类型public enum MSharedDataType{    kSharedDataInt = 0,    kSharedDataBool,    kSharedDataFloat,    kSharedDataString,    kSharedDataVector,    kSharedDataTransform,    kSharedDataInt64,    kSharedDataTypeCount,};\n\nAI 节点中变量名和值的存储  主要由记录变量名对应的哈希值（其实就是自增值）和存储各个变量类型的数组（类型值数组）建立起来的映射关系，这些数组里以变量名的哈希值作为下标，存储相应的值；主要的变量如下：\n// 存储变量名的哈希值，每种变量类型分别记录，读取时根据不同的变量类型读取相应的类型值数组private static Dictionary&lt;string, uint&gt;[] name_hash_ =    new Dictionary&lt;string, uint&gt;[(int)MSharedDataType.kSharedDataTypeCount];private static uint[] name_index_ =    new uint[(int)MSharedDataType.kSharedDataTypeCount]; //int 型数组里面的值默认初始化为 0    // 声明类型值数组private const int kMaxAIDataCount = 150; // 所有变量的数量上限private float[] float_var_;private int[] int_var_;private long[] long_var_;private bool[] bool_var_;private ulong[] trans_var_;private string[] string_var_;private Vector3[] vector3_var_;/* 默认初始化  * bool --&gt; false * int、float --&gt; 0 * 其他值类型 --&gt; 该类型字段默认值 * 引用类型（包括 string) --&gt; null*/float_var_ = new float[kMaxAIDataCount];int_var_ = new int[kMaxAIDataCount];long_var_ = new long[kMaxAIDataCount];bool_var_ = new bool[kMaxAIDataCount];trans_var_ = new ulong[kMaxAIDataCount];string_var_ = new string[kMaxAIDataCount];vector3_var_ = new Vector3[kMaxAIDataCount];\n\n运行时通过以下映射关系读取对应 AI 节点中的变量值\n\n    \n\n\nPB 数据  客户端行为树的 Node 生成\n主要解析运行时 AI 代码的源文件，遍历 Assets/Scripts/MoonClient/AI/Node 目录下所有。cs 文件，源文件中每个类都继承自 MAINodeAction 或者 MAINodeAction，根据基类的不同导出不同类型的节点[Image]\n\n根据类中定义 MNodeArgs 的成员变量添加 public 成员变量，成员变量的类型根据下面的字典映射\nprivate static readonly Dictionary&lt;Type, Type&gt; typeRemapDict = new Dictionary&lt;Type, Type&gt;(){    {typeof(int), typeof(SharedInt) },    {typeof(long), typeof(SharedLong) },    {typeof(ulong), typeof(SharedULong) },    {typeof(float), typeof(SharedFloat) },    {typeof(string), typeof(SharedString) },    {typeof(bool), typeof(SharedBool) },    {typeof(UnityEngine.Vector3), typeof(SharedUnityVector3) },    {typeof(ROGameLibs.Vector3), typeof(SharedVector3) },    {typeof(SWIGTYPE_p_Vector3), typeof(SharedVector3) },#if LIBS_EDITOR    {typeof(SWIGTYPE_p_ROObject), typeof(SharedTransform) },#endif    {typeof(MoonClient.MEntity), typeof(SharedTransform) },    {typeof(IntVector), typeof(SharedIntList) },    {typeof(LongVector), typeof(SharedLongList) },    {typeof(FloatVector), typeof(SharedFloatList) },    {typeof(StringVector), typeof(SharedStringList) },    {typeof(ULongVector), typeof(SharedULongList) },};\n同时根据属性 NodeComment，设置编辑器中变量的悬浮注释\n\n固定格式的代码段\nprivate MoonClient.XXX node; // XXX 为源文件类名private MEntity entity;private MoonClient.XXX.MNodeArgs args; // XXX 为源文件类名public override void OnAwake(){    entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.  gameObject.name));    if(entity == null) return;    node = new MoonClient.MAIAutoFollow();    args = new MoonClient.MAIAutoFollow.MNodeArgs();    // args.follow_target_radius = follow_target_radius.swigValue;    // args.teleport_distance = teleport_distance.swigValue;    // 源文件中 MNodeArgs 的成员变量赋值    node.SetNodeArgs(args);}public override TaskStatus OnUpdate(){    if(entity == null) return TaskStatus.Failure;    return node.Update(entity) ? TaskStatus.Success : TaskStatus.  Failure;}\n\n运行时 AI初始化\n初始化 AI 组件：MPlayer::InitComponents\n初始化行为树：MAIComponent::InitBehaviorTree\n初始化所有玩家通用的 AI 树：MAIBehaviorTree::Init\n加载 PlayerAI/Player_Auto_AI.bytes 文件：MAITreeManager::LoadFile\n构造 AI 树：MAITreeManager::BuildAITree\n递归构造节点：MAITreeManager::BuildOneNode\n未初始化时，初始化所有节点类型对象的委托：MAINodeFactory::CreateAINodeByName\n初始化完成即调用，解析 PB 初始化节点\n\n\n\n\n\n\n\n调用逻辑\n在 MAIComponent::Update 每次 Update 满足一定条件后都执行一次_behaviorTree.Tick(Entity)\n每次 tick 都从 AINode 的 RootNode 递归到每个子节点，执行相应业务逻辑节点的 Update 函数中的逻辑\n\n客户端如何进行自动释放\n策划会在行为树中配置一些列的条件（顺序执行或选择执行）\n自动跟随的距离\nEntity 类型限制\n战斗半径大小\n变身情况\n…\n\n\n依次遍历装配在自动战斗槽位的技能（1~6）\n当第 i 个槽位有装配技能时，根据技能 id 读取技能表中配置的AITreeName\n将查询到的 AITreeName 放置到 tree_name 共享变量中\n再通过 MAIDynamicTreeReference 读取 tree_name 中的值，并读取改节点树的 PB，合并到当前 MAIDynamicTreeReference 的父节点上\n读取到相关技能节点树后，根据策划的配置条件，满足后可释放\n技能是否存在\n释放技能后，是否存在不可叠加的 buff\n…\n\n\n释放技能：通过 MWaitingDataMgr 添加可释放的技能到待执行队列中，每次 update 走技能释放逻辑\n\n相关改进  线上 bug：某些职业释放技能后，已经上了不可叠加的 buff（buff 效果消失之前不能够重复释放改技能），但是客户端的 AI 依然会继续持续释放，造成抽搐的表现（偶现问题没有查到具体原因）解决方案：更改 MAICastSkill 节点，释放次数超过一定数值，不可释放该技能\n附身  需求\n技能：灵喵附身\n技能描述：喵喵附身于选中的队友身上，每秒消耗 5 点自然力量，持续 20 秒，自身处于无敌状态，且将自身 10% 的六维属性附加于附身的队友\n\n实现方式\n释放技能为角色添加 Buff\n\n客户端根据 Buff 状态类型进行判断，如果是附身 Buff 状态类型\n\n附身目标只有一个，取服务器发过来的第一个 Buff 相关目标（区别于 Buff 目标）的 uid\n在 MBuffComponent 组件中记录该 uid\n广播 StopMove 事件，让玩家无法移动\n设置玩家的位置、朝向与被附身的玩家一致\n\n\n屏蔽玩家的碰撞体，使玩家和被附身的人保持一致\n\n在 MHideComponent 组件中，将玩家设置为半透明状态\n\n控制移动\n\n屏蔽摇杆和点击地面的移动效果\n\n在 MMoveComponent 组件的 Update 中，每帧设置玩家的移动距离改为和被附身的玩家做差\nvar buffFollowTarget = Entity.BuffFollowTarget;if (buffFollowTarget != null){    Entity.AppendMove(buffFollowTarget.Position - Entity.Position);}else{    Entity.AppendMove(Entity.ServerPos - Entity.Position);}\n\n\n\nOdin OdinMenuTreeUI 框架Windows 生命周期\n打开 UI：Active -&gt; BindEvents -&gt; OnActive -&gt; OnShow -&gt; AfterShow\n关闭 UI：Deactive -&gt; UnBindEvents -&gt; OnHide -&gt; OnDeActive -&gt; AfterOnDeActive -&gt; ReleaseAll\n\nUIBase\nOnLoad：加载资源\nbaseloadCallback：资源加载成功后的回调\nInit：初始化\n\n\nOnBindPanel：绑定预制\nOnUnload：释放资源，关闭界面或者切换语言\nInit：OnUnload后调用\nUninit：UnLoad或关闭游戏进程后调用\nOnActive：Active后调用\nOnDeActive：DeActive后调用\nOnShow\nAfterShow：当上层界面完全关闭后调用\nOnHide\nBindEvents：Active后，OnActive之前调用\nUpdate\nUpdateInput\nOnLogout\nOnReconnected\n\nUIManager\nUIManager 打开关闭界面以组的方式进行处理。\n所有的组信息都会进栈进行管理。\n会根据配置来确定这个组里面有哪些界面\n没做配置的界面会把这一个界面当成一组\n支持静态配置和打开界面时传递动态配置\n\n\n\n\n\nActiveUI打开某个 Window 函数入口\n通过 require 指定 Window 名字，并进行初始化UI[panelClassName].new()\n为当前 Window 添加groupName\n_createUIPanelConfig 生成 UIPanel 配置，得到界面的配置数据\nActiveUIPanelInGroup 打开界面时对栈进行处理\n\n\n设置 UI 层级（UILayer）---@class UILayerUILayer = {    Normal = 0,   -- 20    Function = 1, -- 40    Tips = 2,     -- 60    Guiding = 3,  -- 80    Top = 4       -- 100}\n\n界面类型（ActiveType）\nNone：不做任何处理\nNormal：显示时会把这个界面加入主界面组中（NormalLayer -&gt; MainPanelsGroupGroup，无视设置的 UILayer 放到 NormalLayer）\nExclusive：显示时会隐藏前面的组（隐藏 Normal Exclusive 类型 UI，Layer 无关）\nStandalone：显示后不会被 Exclusive 类型隐藏\n\n剧本解析  代码结构clientcode\\CSProject\\MoonClient\\CommandSystem:. │  CommandBlock.cs 创建以及执行 Block 的方法都会在这里│  CommandBlockManager.cs 上下文环境管理，变量储存│  CommandBlockTriggerManager.cs 触发器管理│  CommandConst.cs 所有与命令相关的常量都会记录在这里│   ├─Attribute 静态语法检查│      CommandArgsAttribute.cs │      CommandCheckAttribute.cs │       ├─Checker 静态语法检查│      CommandBlockChecker.cs │       ├─Commands C# 命令│  │  BaseCommand.cs │  │  LuaCommand.cs │  │   │  ├─NPC │  │      ChangeEmotionCommand.cs │  │      .​.. 省略│  │       │  ├─Other │  │      FindElfCommand.cs │  │      ShowModelAlarmCommand.cs │  │       │  └─System │          AddLocalBuffCommand.cs │          .​.. 省略│           ├─Compile 二进制编译│      CommandBlockBinaryCompiler.cs │      CommandBlockParser.cs │       ├─Data PB 数据结构以及动态参数解析│      BaseArg.cs │      BlockIndexArg.cs │      BlockVarArg.cs │      CommandBlockArg.cs │      CommandBlockStringArg.cs │      CommandData.cs │      CommandLuaArg.cs │      ExpressionArg.cs │      FunctionArg.cs │      ValueArg.cs │       ├─Expression 表达式词法解析器│      EOFToken.cs │      IdentifierToken.cs │      Lexer.cs │      LuaConverter.cs │      NumberToken.cs │      StringToken.cs │      Token.cs │       └─Trigger 触发器相关    │  CommandTrigger.cs     │       └─Event 触发器事件埋点            BaseEvent.cs             OnCollectSuccEvent.cs             OnDamagedByPlayerEvent.cs             OnEnterDungeons.cs             OnExitDungeons.cs             OnKilledByPlayerEvent.cs             OnNpcCreateEvent.cs             OnNpcDestroyEvent.cs             OnStartCollectEvent.cs\n\n在 ScriptHandle 函数解析每一行剧本时确定是用 C# 中的 BaseCommand 还是 Lua 中的 LuaCommand 进行解析\n// 只有在列出的类型或者 Lua 类型才会通过池子进行复用if (CommandConst.CommandTypeDict.TryGetValue(dacommandType, out var type)){    command = UUIDObjectPool.Get(type) as BaseCommand;}else{    var luaCommand = UUIDObjectPool.Get(typeof(LuaCommand)) as LuaCommand;    luaCommand?.SetCodeId(data.commandType);    command = luaCommand;}\n\n解析特殊表达式// Arg 数字 | 任意字符 | LUA&lt;&lt; 函数名 &gt;&gt; | &lt;&lt; 函数名 &gt;&gt;public static readonly string ArgsRegex = @\"{{Arg(\\d+?)}}|{{(.+?)}}|LUA&lt;&lt;(.+?)&gt;&gt;|&lt;&lt;(.+?)&gt;&gt;\";public CommandBlockStringArg Init(string origin){    OriginString = origin;    if (origin == null)    {        return this;    }    _formatString = origin;    int argNum = 0;    var argMatch = Regex.Matches(_formatString, ArgsRegex);    foreach (Match match in argMatch)    {        var blockArgValue = match.Groups[1].Value;        var blockVarValue = match.Groups[2].Value;        var luaValue = match.Groups[3].Value;        var exprValue = match.Groups[4].Value;        if (!string.IsNullOrEmpty(blockArgValue))        {            if (int.TryParse(blockArgValue, out int index))            {                var arg = MCommonObjectPool&lt;BlockIndexArg&gt;.Get().Init(index);                _formatArgs.Add(arg);                _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");                argNum++;            }        }        else if (!string.IsNullOrEmpty(blockVarValue))        {            var arg = MCommonObjectPool&lt;BlockVarArg&gt;.Get().Init(blockVarValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }        else if (!string.IsNullOrEmpty(luaValue))        {            var arg = MCommonObjectPool&lt;CommandLuaArg&gt;.Get().Init(luaValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }        else if (!string.IsNullOrEmpty(exprValue))        {            var arg = MCommonObjectPool&lt;ExpressionArg&gt;.Get().Init(exprValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }    }    return this;}\n\nUI Renderer Texture使用 URP 管线进行 RT 渲染\nCreatUIModelData：RtModelAssistant[RT 动效助手] 进行模型创建\nMModel.OriginData设置相关数据\nLayer设置为 ID_RTFACTORY，只渲染ID_RTFACTORY 层\n\n\nMUIRTData：定义 RT 渲染设置数据\nRawImage\n相机位置\n描边\n阴影\n反射\n大小\n\n\nCreateRawImageRT\n创建新的 RawImage\n创建新的 RTStage，用于管理 RT\nRTCamera.Init\n加载 Camera 预制（UIRTCamera）\nCulling Mask\n位置\nprojectionMatrix\ntargetTexture\n替他\n阴影\n反射\n\n\n\n\n\n\nRawImage 与 RTStage 绑定\n\n\nUIRTCamera（采用 UniversalRenderPipelineAsset_RTRenderer 管线配置）\n由于设定了 Culling Mask，相机只会照到需要渲染的物体\n\n\n\n自定义MCBRTRendererFeature\n调用 CreatUIModelData 时会存储 Rt 和对其应的渲染数据RawImageRtDataDicAdd\n\nUpdateRawImageRT 处理模型的 renders\n\n收集全部 renders\n收集不透明材质的 renders\n\n\nUpdateRendererByRawImage 开始真正的渲染\n\n渲染 All Renders\n初始化CBRTData\nRenderEx\n检查设备是否支持RenderTextureFormat.ARGB32\ntexture 大小是否为正数\nGetRenderTexture\nCameraMode 相机模式\nOutlineRendererShader 传入相机位置属性标记_CameraPos\ndata.pMatrix.m00 /= aspect;\n判断是否可以使用共享 RT _sharedRT\n_sharedRT会在 Awake 时初始化为 Vector2.one 的大小\n不使用共享 RT 时，则会根据传入的 width 和height大小获取 texture RenderTexture.GetTemporary\n\n\n创建渲染队列\n设置材质的标识符和 rt 关联\n\n\n\n\n\n\n描边、阴影、描边\n因为在场景中模型的材质和 UI 中用的材质不一样所以需要替换一下\nMResLoader.singleton.CreateMatFromPool(MShaderUtil.EffectOutlineMaterialPath);\n记录到 CBRTQuene 的materialDict中\n\n\n\n\nMCBRTRenderPass执行 URP 管线中的 Excute 函数，通过 CommandBuff 进行绘制\n\n不使用共享 RT 绘制，绘制单个 RT\n设置渲染目标 SetRenderTarget texture 为初始化 CBRT 队列时传入的 texture\n清除渲染状态 ClearRenderTarget\n调用绘制函数 DrawRenderers\n\n\n开启了共享 RT 绘制的会继续绘制共享 RT\n设置渲染目标 SetRenderTarget texture 为_sharedRT\n清除渲染状态 ClearRenderTarget\n调用绘制函数 DrawRenderers\n\n\n\n\n绘制 DrawRenderers\n\n设置自定义 MVP 矩阵\n根据 Render 的材质生成 CommandBuffer 列表\n根据 renderQueue 和CameraDistance对 CommandBuffer 列表进行排序\n调用 DrawRenderer 进行渲染\n\n\n每帧进行 _sharedRT 大小检测，超出 256 进行扩容\n  private void LateUpdate(){    //if (_temporaryCBRTs.Count &gt; _GCThreshold)    {        // 当池中数量超过阈值时触发清空空队列，提升一些性能        ReleaseEmpty();    }    // 合并 RT 图集    List&lt;CBRTQuene&gt; rtQuenes = MListPool&lt;CBRTQuene&gt;.Get();    foreach (var rtQuene in _CBRTQuenes)    {        if (rtQuene.isValid &amp;&amp; rtQuene.isRTAltas &amp;&amp; rtQueneIsInActiveRawImage())        {            rtQuenes.Add(rtQuene);        }    }    if (rtQuenes.Count == 0)    {        ResizeShareRT(Vector2.one);        MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);        return;    }    rtQuenes.Sort((x, y) =&gt; y.clipRect.width.CompareTo(xclipRect.width));    // clipRect 计算 x y    Vector2 targetSize = new Vector2(256, 256);    bool loop = true; // 重新计算    while (loop)    {        Vector2 position = Vector2.zero;        float nextX = 0.0f;        loop = false;        foreach (var rtQuene in rtQuenes)        {            // 一个 ClipRect.height 高超出 y，则 y *= 2            if (rtQuene.clipRect.height &gt; targetSize.y)            {                loop = true;                targetSize.y *= 2;                break;            }            // 高超出了 y，则下一列            if (position.y + rtQuene.clipRect.height &gt;targetSize.y)            {                position.x = nextX;                position.y = 0;                                    }            rtQuene.clipRect.x = position.x;            rtQuene.clipRect.y = position.y;            nextX = Mathf.Max(nextX, position.x + rtQueneclipRect.width);            // nextX 超出 x            if (nextX &gt; targetSize.x)            {                loop = true;                // 先扩展 x                if (targetSize.x &lt;= targetSize.y)                {                    targetSize.x += 256;                }                // 再扩展 y                else                {                    targetSize.y += 256;                }                break;            }            position.y += rtQuene.clipRect.height;        }    }    ResizeShareRT(targetSize);    foreach (var rtQuene in rtQuenes)    {        rtQuene.renderTexture = _sharedRT;        rtQuene.AltasComplete();    }    MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);}\n\n\nRenderTexture.GetTemporary\nAllocate a temporary render texture.\nThis function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using ReleaseTemporary as soon as you’re done with it, so another call can start reusing it if needed.\nInternally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually &gt; destroyed when they aren’t used for a couple of frames.\nIf you are doing a series of post-processing “blits”, it’s best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. &gt; This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a DiscardContents call which helps to avoid costly restore operations on the previous render texture contents.\nYou can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform\n\nTimeLine\n    \n\n\n运行时MCutSceneMgr\n外部调用 Play(int id, DirectoreWrapMode mode = DirectorWrapMode.Hold, Action endCallback = null, Action = startCallback = null) 进行 CutScene 播放\n\n根据表格配置的路径进行  资源  预处理preAll\n\n播放黑屏 显示黑屏 UI\n设置播放状态为CutSceneState.Prepare\n利用引用计数来决定所有资源是否加载完成，引用计数为 0 时表示资源都加载好了\n每次进行资源加载或预加载引用计数加 1，在加载完成后的回调函数中引用计数减 1\n引用计数包括：_necessaryLoadCount、_preloadFlag、_preloadRootCount\n加载完成后可以进行播放\n\n\n模型、特效等 Root 节点初始化；扩展功能初始化\n资源异步加载，加载的资源类型为.playable\n加载 .playable 资源成功后继续预加载各种根节点\nVcRoot\nVcPathRoot\nSpineRoot\n\n\n加载 Track\n特效\n视频\n天气\n模型\n虚拟相机\nCinemachine\n动画\nSpine 动画\n\n\n\n\nUpdate函数中每帧执行\n\n资源全部加载好之后（所有加载资源相关的引用计数为 0），设置播放状态为CutSceneState.Ready\n\n设置相机的裁剪遮罩\n\n设置播放状态为CutSceneState.Play\n\n调用 CutScene 播放开始的回调函数_startAction\n\n调用 PlayableDirector.Play() 进行播放\n\n调用扩展功能的 Update 函数\n\n调用 CutScene 播放结束的回调函数_endCallback\n\n检测是否可以更新下一个 CutScene\n\n没有循环播放或者正在播放，可进行下面的判断\n\n计算剩余时长  的相反数 remain = (float)(_playableDirector.time - _playableDirector.duration);\n\nDirectorWrapMode为 Hold 时，remain &gt;= 0f时立即准备下一个 CutScene 播放\n\nDirectorWrapMode为 None 时，不太清除这块的逻辑了\nif (MCommonFunctions.IsEqual(_playableDirector.time, 0)){    _cntZeroTime++;}if (_cntZeroTime &lt;= 1 &amp;&amp; (_playPath.Count &lt;= 0 || !(Mathf.Abs(tmp) &lt;= 0.1f)) &amp;&amp; !(tmp &gt;= 0f)) return;\n根据表格中的 CutScene 配置，取第二个路径为 nextPath 继续走资源加载然后播放的的流程\n\n\n\n\n\n\n\n&gt;public enum DirectorWrapMode&gt;{   //   // 摘要：   //     Hold the last frame when the playable time reaches it's duration.   Hold,   //   // 摘要：   //     Loop back to zero time and continue playing.   Loop,   //   // 摘要：   //     Do not keep playing when the time reaches the duration.   None&gt;}\n\n其他辅助类\nMCutsceneObject 继承自MGameObject\nMCutSceneHelper 定义在 Hierarchy 结构中显示的节点名称\nMCutSceneData 序列化 CutScene 二进制\nList&lt;MCutSceneTrack&gt; 序列化轨道数据\nCStrackType\nMCutSceneModelData\nMCutSceneCirtualCameraData\nList&lt;MCutSceneAnimClip&gt;\nList&lt;MCutSceneCirCamClip&gt;\nMCutSceneSpineData\n\n\nMDollyCart 可理解为装载轨道摇臂的“轨道车”\n\n\n\nPlayableBehaviour、PlayableAsset和TrackAsset\nTrackAsset：轨道资源，用来创建片段和 Playable 混合器，提供序列化数据与 Binding\nPlayableAsset：片段资源，用来创建 Playable 以及提供序列化数据\nPlayableBehaviour：逻辑行为，用来实现 Playable 具体的业务逻辑\n\n资源管理 RO 的资源打包流程 所有可能被打包的资源都会被归类到一个个的 filter 类中\n\nABDir：处理后的资源存放的文件夹（前缀都是 roab/ 平台）\nAbType：资源类型。一共三大类型：\nAB：需要打成 AB 的资源   基类为：ABBaseFilter\nbytes：后缀为 robytes 的资源   基类为：ABBaseFilter\n直接 copy 的资源：音频、视频、Resources\\QualitySetting 和 MiniStringPool 中的 json 文件基类为：ABCopyBaseFilter。他的基类为：ABBaseFilter\n\n\nFilters：将要处理的资源列表。 所有的资源都会用 ABFilter 数据结构存储\n\n打 AB 流程\nXbuildAB：打 AB 的接口文件，这里可以看到打 AB 的各个步骤\nXABContainer：管理所有的 XABItem\nXABItem：AB 的最小单位，一个小的资源对应一个 XABItem 实例。但并不是所有的都会导出\n\n步骤\n\n通过 XABContainer 生成 filter 中的文件对应的 XABItem 类，又分为三类：\n普通 AB\nAtlas 图集\nShader，将所有 Shader 打成了一个 AB，ab 名字为 shader 的跟文件夹路径的 hash\n\n\n分析依赖\n分析步骤一中生成的所有 XABItem 的依赖关系，从而找到所有可能被打成 AB 的资源，并记下来其前后依赖关系（我依赖了哪些，哪些依赖了我，要求不能循环引用）\n确定需要导出的 AB 列表，是否导出根据如下规则\nAsset = 1  // 普通素材，被根素材依赖的，跟随其根素材到一个 AB 中\nRoot = 1 &lt;&lt; 1 // 根，只有 filter 中指定的才会是根，会被单独打成 AB\nStandalone = 1 &lt;&lt; 2 // 被两个或者离两个以上素材引用的会被单独打成 AB\n\n\n\n\n导出 AB\n导出的 AB 在 roab 这个工程目录中\n先打图集的 AB，再打非图集的。图集要EditorSettings.spritePackerMode = SpritePackerMode.AlwaysOnAtlas，非图集要设置为SpritePackerMode.Disabled\n压缩算法选了 lz4, 移动端 &amp;PC 端关闭 typetree, 为了热更的需要设置了DeterministicAssetBundle\n构建 AssetBundleBuild 的时候，场景文件不用记录所有依赖，Unity 会自动做\n\n\n写入 dep.all 文件\nAB 中包含的资源列表。实际测下来，只有 shader 有多个，其余的都是只有一个\nAB 的 hash 值\nAB 的类型\n需要依赖的 AB 数量及列表\n\n\n删除冗余的 AB（给增量 bundle 使用）\n先从其他目录拷贝 AB（资源会有删除的）\n再打增量 AB\n判断没有用的 AB 需要删除掉\n\n\nBytes\n翻译\n其他配置文件\n直接拷贝\n\n\n脚本\n通过 luajit 将。lua 文件处理成二进制文件\n\n\n其他资源\n\n\n_analyze_step == 0：开始分析_analyze_step == 1：存在循环依赖（A → B → A 或 A → B → C → A），直接抛出异常_analyze_step == 2：已经分析过\n\n读表  读取整表function GetTable()    local l_tables = {}    if l_tablePtr ~= nil then        for i=1, l_tableSize do            table.insert(l_tables, GetRow(i))        end    else        logError(\"SkillTable l_tablePtr is nil\")    end    return l_tablesend\n\n读取一行\nROGameLibs.TableDataLuaProxy:GetRowIDByINT\n\nHash/// &lt;sumarry&gt;/// 不断地乘 33 （(hash &lt;&lt; 5) + hash）/// &lt;/summary&gt;public static uint GetHash(string str){    if (str == null) return 0;    uint hash = 0;    for (int i = 0; i &lt; str.Length; i++&gt;)    {        hash = (hash &lt;&lt; 5) + hash + str[i];    }    return hash;}\n","categories":["游戏开发"],"tags":["行为树","剧情脚本","资源管理"]},{"title":"Unity 面试","url":"/2022/08/19/573a0a3f3e9f/","content":"业务Unity 的运行时序\n    \n\n\nUnity 垃圾回收机制  简单来看下 BDWGC（全称：Boehm-Demers-Weiser conservative garbage collector），也就是常说的 Boehm 回收器。其实它除了回收之外还做了很多分配的工作，甚至还可以用来检查内存泄漏。\n而 Unity 用的是改良过的 BDWGC，它属于保守式内存回收。目前主流的回收器有如下三种：\n\n保守式回收（Conservative GC），以 Boehm 为代表。\n分代式回收（Generational GC），以 SGen（Simple Generational GC）为代表。\n引用（计数）式内存回收（Reference Counting GC），例如 Java 就是使用的这种，但是它是结合了保守式的引用式内存回收。那么为什么 Unity 不用分代式的呢？分代式的是否更好呢？答案是，虽然分代式确实有很多的优点，但是它们都要付出额外的代价。例如分代式的 GC，它要进行内存块的移动，一块内存在频繁分配区长时间不动的话，会被移动到长时分配区，造成额外消耗。另外每次回收的时候还要进行一个评估，判断当前内存是否是一个活跃内存，这些东西都不是免费的，而是要消耗额外的 CPU 性能。当然 sGen 也有它的优势，例如它是可移动的，可以进行合并的（可以减少内存碎片）等等。但是在计算力本身就很紧张的移动平台上，再花费 CPU 去计算内存的搬迁和移动实际上是不合算的，引用计数也有类似的问题，所以 unity 还是使用相对比较保守的 Boehm 回收。\n\nUnity 数据持久化你使用过哪些、说说它们之间的优缺点 PlayerPrefs 这是 Unity 自带的解决方案，会自动生成文件存储于本地，API 简单，封装了繁琐的序列化反序列化过程，但他只支持几种基本数据类型，string、int、float，比较简单的数据存读取功能的话，用这个会比较方便。\nScriptableObjectScriptableObject 并不依赖于游戏对象（GameObject），也不受场景加载和卸载的影响。它的生命周期由 Unity 引擎管理\n序列化：Json、XML、二进制  关于序列化：\n\n必须是 public 类，其中的字段或属性必须是可序列化的\n类中的方法不会被序列化\n构造函数不可被序列化\n不可被序列化的数据类型：\n静态类或静态成员\n委托\n事件\n指针\n索引器\n\n\n\nJson 是字符串文本，可以存储复杂一点的对象；XML 一样可以存储复杂数据对象，相较于 Json 优点是可读性良好，但效率较低，适合大量的数据配置；二进制就是 01 序列，在数据存储和传输效率、紧凑性和速度上占有优势（ProtoBuf、MessagePack）\n几个含 Serialize 的相关属性\nSerializable是一个 C# 中的特性，它告诉编译器这个类是可以被序列化\nSerializeReference是 Unity 2019.3 引入的新特性，用于处理多态对象的序列化，使得可以在 Inspector 窗口中为该字段分配任意继承自同意父类的对象\nSerializeField这个是把 private 变量暴露到 Inspector 中\n\nC# 相关 List 的底层原理、Dictionary 的底层原理List 底层实现浅析Add 在Add前，都会调用 EnsureCapacity 来保证有充足的空间存放元素，如果容量不足，就会进行扩容，每次容量不够的时候，整个数组的容量都会扩充一倍，_defaultCapacity是容量的默认值为 4。因此整个扩充的路线为 4，8，16，32，64，128，256，512，1024，……以此类推\n\nList 使用数组形式作为底层数据结构，好处是使用索引方式提取元素很快，但在扩容的时候就会很糟糕，每次 new 数组都会造成内存垃圾，这给垃圾回收 GC 带来了很多负担\n\nInsertpublic void Insert(int index, T item) {    // Note that insertions at the end are legal.    if ((uint) index &gt; (uint)_size) {        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);    }    Contract.EndContractBlock();    if (_size == _items.Length) EnsureCapacity(_size + 1);    if (index &lt; _size) {        Array.Copy(_items, index, _items, index + 1, _size - index);    }    _items[index] = item;    _size++;                _version++;}\n\n插入的关键就是 Array.Copy(_items, index, _items, index +1, _size - index)，把指定索引加 1 到数组末尾的元素向后移动，然后赋值，这个跟数组的插入删除一样，都要花费 的时间去挪动数组\nRemovepublic bool Remove(T item) {    int index = IndexOf(item);    if (index &gt;= 0) {        RemoveAt(index);        return true;    }    return false;}public void RemoveAt(int index) {    if ((uint)index &gt;= (uint)_size) {        ThrowHelper.ThrowArgumentOutOfRangeException();    }    Contract.EndContractBlock();    _size--;    if (index &lt; _size) {        Array.Copy(_items, index + 1, _items, index, _size - index);    }    _items[_size] = default(T);    _version++;}\n\n删除跟插入相反，Array.Copy(_items, index +1, _items, index, _size - index)，用IndexOf（遍历）找到指定元素在数组中的索引，然后用指定索引加 1 到数组末尾的元素向前移动，覆盖。这个步骤，被删除元素后面的数都要往前移动，时间复杂度\n\n在使用 List 的时候，要注意，如果过于频繁使用的话，会导致效率降低，也会造成不少内存的冗余，使得垃圾回收 (GC) 时承担了更多的压力\n\n索引public T this[int index] {    get {        // Following trick can reduce the range check by one        if ((uint) index &gt;= (uint)_size) {            ThrowHelper.ThrowArgumentOutOfRangeException();        }        Contract.EndContractBlock();        return _items[index];     }    set {        if ((uint) index &gt;= (uint)_size) {            ThrowHelper.ThrowArgumentOutOfRangeException();        }        Contract.EndContractBlock();        _items[index] = value;        _version++;    }}\n\nClearpublic void Clear() {    if (_size &gt; 0)    {        Array.Clear(_items, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.        _size = 0;    }    _version++;}\n\nClear接口在调用时并不会删除数组，而只是将数组中的元素清零，并设置 _size 为 0 而已，用于虚拟地表明当前容量为 0\nforeach已经在 unity5.5 解决之前，foreach每次获取迭代器时，会新建一个Enumerator，如果大量使用迭代器的话就会造成大量的垃圾对象，在 unity5.5 解决之后就不会产生额外的 GC 了\nSortArray.Sort使用的是快速排序方式进行排序，List 的 Sort 排序的效率为。\nDictionary 底层实现浅析 Entry 结构体 Dictionary 种存放数据的最小单位，调用Add(Key, Value) 方法添加的元素都会被封装在这样的一个结构体中\nprivate struct Entry {    public int hashCode;    // 除符号位以外的 31 位 hashCode 值，如果该 Entry 没有被使用，那么为 -1    public int next;        // 下一个元素的下标索引，如果没有下一个就为 -1    public TKey key;        // 存放元素的键    public TValue value;    // 存放元素的值}\n\n除了 Entry 结构体外，还有几个关键的私有变量\nprivate int[] buckets;    // Hash 桶private Entry[] entries;  // Entry 数组，存放元素private int count;      // 当前 entries 的 index 位置private int version;    // 当前版本，防止迭代过程中集合被更改private int freeList;    // 被删除 Entry 在 entries 中的下标 index，这个位置是空闲的private int freeCount;    // 有多少个被删除的 Entry，有多少个空闲的位置private IEqualityComparer&lt;TKey&gt; comparer;  // 比较器private KeyCollection keys;    // 存放 Key 的集合private ValueCollection values;    // 存放 Value 的集合\n\nAdd 操作public void Add(TKey key, TValue value) {    Insert(key, value, true);}private void Insert(TKey key, TValue value, bool add){        if(key == null ) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets == null) Initialize(0);    // 通过 key 获取 hashCode    int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;    // 计算出目标 bucket 下标    int targetBucket = hashCode % buckets.Length;  // 碰撞次数    int collisionCount = 0;    for (int i = buckets[targetBucket]; i &gt;= 0; i = entries[i].next) {        if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {            // 如果是增加操作，遍历到了相同的元素，那么抛出异常            if (add) {        ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);            }            // 如果不是增加操作，那可能是索引赋值操作 dictionary[\"foo\"] = \"foo\"            // 那么赋值后版本 ++，退出            entries[i].value = value;            version++;            return;        }        // 每遍历一个元素，都是一次碰撞        collisionCount++;    }    int index;    // 如果有被删除的元素，那么将元素放到被删除元素的空闲位置    if (freeCount &gt; 0) {        index = freeList;        freeList = entries[index].next;        freeCount--;    }    else {        // 如果当前 entries 已满，那么触发扩容        if (count == entries.Length)        {            Resize();            targetBucket = hashCode % buckets.Length;        }        index = count;        count++;    }    // 给 entry 赋值    entries[index].hashCode = hashCode;    entries[index].next = buckets[targetBucket];    entries[index].key = key;    entries[index].value = value;    buckets[targetBucket] = index;    // 版本号 ++    version++;    // 如果碰撞次数大于设置的最大碰撞次数，那么触发 Hash 碰撞扩容    if(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer))     {        comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);        Resize(entries.Length, true);    }}\n\nFind 操作// 寻找 Entry 元素的位置private int FindEntry(TKey key) {    if(key == null) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets != null) {        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF; // 获取 HashCode，忽略符号位        // int i = buckets[hashCode % buckets.Length] 找到对应桶，然后获取 entry 在 entries 中位置        // i &gt;= 0; i = entries[i].next 遍历单链表        for (int i = buckets[hashCode % buckets.Length]; i &gt;= 0; i = entries[i].next) {            // 找到就返回了            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) return i;        }    }    return -1;}internal TValue GetValueOrDefault(TKey key) {    int i = FindEntry(key);    // 大于等于 0 代表找到了元素位置，直接返回 value    // 否则返回该类型的默认值    if (i &gt;= 0) {        return entries[i].value;    }    return default(TValue);} public bool TryGetValue(TKey key, out TValue value) {    int i = FindEntry(key);    if (i &gt;= 0) {        value = entries[i].value;        return true;    }    value = default(TValue);    return false;}\n\nRemove 操作public bool Remove(TKey key) {    if(key == null) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets != null) {        // 1. 通过 key 获取 hashCode        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;        // 2. 取余获取 bucket 位置        int bucket = hashCode % buckets.Length;        // last 用于确定是否当前 bucket 的单链表中最后一个元素        int last = -1;        // 3. 遍历 bucket 对应的单链表        for (int i = buckets[bucket]; i &gt;= 0; last = i, i = entries[i].next) {            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {                // 4. 找到元素后，如果 last&lt; 0，代表当前是 bucket 中最后一个元素，那么直接让 bucket 内下标赋值为 entries[i].next 即可                if (last &lt; 0) {                    buckets[bucket] = entries[i].next;                }                else {                    // 4.1 last 不小于 0，代表当前元素处于 bucket 单链表中间位置，需要将该元素的头结点和尾节点相连起来，防止链表中断                    entries[last].next = entries[i].next;                }                // 5. 将 Entry 结构体内数据初始化                entries[i].hashCode = -1;                // 5.1 建立 freeList 单链表                entries[i].next = freeList;                entries[i].key = default(TKey);                entries[i].value = default(TValue);                // *6. 关键的代码，freeList 等于当前的 entry 位置，下一次 Add 元素会优先 Add 到该位置                freeList = i;                freeCount++;                // 7. 版本号 +1                version++;                return true;            }        }    }    return false;}\n\nResize 操作（扩容）两种情况会发生扩容操作：\n\nentries数组满了，没有办法继续存放新的元素\nDictionary 中发生的碰撞次数太多，会严重影响性能，也会触发扩容操作\n\n\n目前 .Net Framwork 4.7 中设置的碰撞次数阈值为 100\n\nprivate void Resize() {    Resize(HashHelpers.ExpandPrime(count), false);}private void Resize(int newSize, bool forceNewHashCodes) {    Contract.Assert(newSize &gt;= entries.Length);    // 1. 申请新的 Buckets 和 entries    int[] newBuckets = new int[newSize];    for (int i = 0; i &lt; newBuckets.Length; i++) newBuckets[i] = -1;    Entry[] newEntries = new Entry[newSize];    // 2. 将 entries 内元素拷贝到新的 entries 总    Array.Copy(entries, 0, newEntries, 0, count);    // 3. 如果是 Hash 碰撞扩容，使用新 HashCode 函数重新计算 Hash 值    if(forceNewHashCodes) {        for (int i = 0; i &lt; count; i++) {            if(newEntries[i].hashCode != -1) {                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp; 0x7FFFFFFF);            }        }    }    // 4. 确定新的 bucket 位置    // 5. 重建 Hahs 单链表    for (int i = 0; i &lt; count; i++) {        if (newEntries[i].hashCode &gt;= 0) {            int bucket = newEntries[i].hashCode % newSize;            newEntries[i].next = newBuckets[bucket];            newBuckets[bucket] = i;        }    }    buckets = newBuckets;    entries = newEntries;}\n\nCollection 版本控制  迭代过程中不允许集合出现变化，否则会抛出 System.InvalidOperationException:”Collection was modified; enumeration operation may not execute.” 这样的异常\ninternal Enumerator(Dictionary&lt;TKey,TValue&gt; dictionary, int getEnumeratorRetType) {    this.dictionary = dictionary;    version = dictionary.version;    index = 0;    this.getEnumeratorRetType = getEnumeratorRetType;    current = new KeyValuePair&lt;TKey, TValue&gt;();} public bool MoveNext() {    if (version != dictionary.version) {        ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion);    }    // Use unsigned comparison since we set index to dictionary.count+1 when the enumeration ends.    // dictionary.count+1 could be negative if dictionary.count is Int32.MaxValue    while ((uint)index &lt; (uint)dictionary.count) {        if (dictionary.entries[index].hashCode &gt;= 0) {            current = new KeyValuePair&lt;TKey, TValue&gt;(dictionary.entries[index].key, dictionary.entries[index].value);            index++;            return true;        }        index++;    }    index = dictionary.count + 1;    current = new KeyValuePair&lt;TKey, TValue&gt;();    return false;}\n\n在迭代器初始化时，就会记录 dictionary.version 版本号，之后每一次迭代过程都会检查版本号是否一致，如果不一致将抛出异常。这样就避免了在迭代过程中修改了集合，造成很多诡异的问题\n装修拆箱int x = 1023;object o = x; // 装箱int y = (int) o; // 拆箱\n\n装箱：值类型转换为引用对象，一般是转换为 System.Object 类型或值类型实现的接口引用类型\n\n在堆中申请内存，内存大小为值类型的大小，再加上额外固定空间（引用类型的标配：TypeHandle和同步索引块）\n将值类型的字段值（x = 1023）拷贝新分配的内存中\n返回新引用对象的地址（给引用变量object o）\n\n拆箱：引用类型转换为值类型，注意，这里的引用类型只能是被装箱的引用类型对象\n\n检查实例对象（object o）是否有效，如是否为null，判断其装箱的类型与拆箱的类型（int）是否一致，如检测不合法，抛出异常\n指针返回，就是获取装箱对象（object o）中值类型字段值的地址\n字段拷贝，把装箱对象（object o）中值类型字段值拷贝到栈上，意思就是创建一个新的值类型变量来存储拆箱后的值\n\n\n\n只有值类型才有装箱、拆箱两个状态，而引用类型一直都在箱子里\n一般来说，装箱的性能开销更大，因为引用对象的分配更加复杂，成本也更高，值类型分配在栈上，分配和释放的效率都很高。装箱过程是需要创建一个新的引用类型对象实例，拆箱过程需要创建一个值类型字段，开销更低\n\n\n事件委托  委托是一个类，它定义了方法的类型，使得可以将方法当作另一个方法的参数来进行传递，事件是一种特殊的委托\n委托  委托，是一种存储函数引用的类型。声明一个委托与声明函数类似，区别在于不包含函数体，需要使用关键字delegate。一个委托包含其可以引用的函数签名（返回类型和参数列表）\n对于委托的初始化赋值，可以使用两种语法：\n// 方法一delegate double ProcessDelegate(double arg1, double arg2);ProcessDelegate process;// 方法二process = new ProcessDelegate(Multiply) // double Multiply(double arg1, double arg2)process = Divide; // double Divide(double arg1, double arg2)\n\n委托对象可使用 + 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。-运算符可用于从合并的委托中移除组件委托。这样就可以创建一个委托被调用时要调用的方法的调用列表。但是多播委托的调用顺序无法保证\n委托的类型：delegate、Action、Func、predicate\ndelegate：至少 0 个参数，至多 32 个参数，可以无返回值，也可以指定返回值类型\nAction：是无返回值的泛型委托\nFunc：是有返回值的泛型委托\npredicate：是返回 bool 型的泛型委托\n\n事件  事件类似于异常，都由对象引发（或抛出），然后通过提供的代码进行处理。事件需要在处理之前进行订阅（ subscribe ），表示提供了在事件发生时需要执行的代码，即事件处理程序。C# 中的事件 event 关键字是语言层面的  观察者模式  的实现，将事件的发起者（被观察者）与处理者（观察者）的代码解耦。事件处理程序需要被匹配事件所要求的返回值和参数，这个限制由委托来指定\n在 C# 中，事件就像是一种机制，在程序运行到一定阶段的时候或者遇到某些状况的时候，就会触发一个事件。然后如果有其他代码订阅了这个事件，就会自动执行订阅的代码。描述起来很抽象，简单来讲就是在类声明一个委托，并标记这个委托是一个事件，在另一个方法中执行这个事件。其中，触发这个事件的类称为发布者，接受或者注册了处理方法的类称为订阅者\n声明一个事件有两种方式，一种是直接使用EventHandler，另一种是自己先定义一个委托，然后用这个委托定义事件\n\n使用 EventHandler\n\npublic class EventDemo{    public event EventHandler HandlerEvent;}\n\n\n使用自定义委托\n\npublic class EventDemo{    public delegate void EventDelegate(object sender, EventArgs e);    public event EventDelegate DelegateEvent;}\n\n一般事件的定义约定俗称是一个 void 方法，第一个参数是 sender 表示事件的发布者，默认是 object 类型，第二个参数是 EventArgs 类型的事件变量，表示触发事件时需要订阅者注意的内容，一般用来传一些参数；EventArgs只有一个默认构造方法和几个继承自 Object 的方法。所以在开发中，会定义一个事件变量类型，为了保持一致会继承EventArgs\nDemopublic class EventDemo{    public delegate void EventDelegate(object sender, EventArgs e);    public event EventDelegate DelegateEvent;    public void Trigger()    {        if (DelegateEvent != null)// 触发事件，按需判断事件的订阅者列表是否为空        {            DelegateEvent(this, new EventArgs());        }    }}EventDemo demo = new EventDemo(); demo.DelegateEvent += (sender, eventArgs) =&gt;{    // 省略订阅者的方法内容}demo.Trigger();// 触发事件\n\n将其中的 event 去掉，程序依然正常运行，不会出现任何问题。事件实际上是一个特殊的委托实例，不用事件也没有关系。实际上事件只是削弱了委托的功能，event在编译器角度保护了程序的安全，因为只能使用 +=、-= 来注册事件了，而不能使用 = 为事件关联方法。（在委托中还可以使用 = 来绑定方法，不过 = 是一种破坏性代码，不管之前是否已经绑定的有方法了，都会将其清除）\nC# 的异步和 Unity 的协程  协程 Coroutine —— 伪异步 Unity 引擎是单线程的（也就是有一个主线程）。为了满足开发者的特定的 异步 、 多线程  的开发需求，Unity 也提供了一个  伪异步  的解决思想——协程。需要注意的是，协程不是线程，也不是异步执行的，本质上其实还是在生命周期的 Update 中执行的\n使用协程的好处就在于：\n\n大大减少了 Update 函数的臃肿\n方便开发者对代码的阅读和维护\n\n弊端：\n\n运行效率没有变化\n不能返回值，只能注入委托调用\n\n线程 Thread —— 真异步  多线程（Thread）是 C# 带来的特性。在 Unity 中恰当的使用多线程会提高一定的程序效率，使用多线程的场景一般是涉及到数据的加载和逻辑处理，不如文件读写，网络通信等。\nnote\n子线程内不可访问游戏对象或者组件以及相关的 Unity API，如果需要与主线程沟通的话需要进行回调\n\n\n利用 async 和await简化多线程异步调用\n    \n\n\n官方建议\n两者的功能是有区别的，但是一般都是被搭配一起使用\nawait运算符通知编译器异步方法：在等待的异步过程完成后才能继续通过该点。 同时，控制返回至异步方法的调用方。\nasync关键字仅用于修饰方法体，并且方法体中一定要有 await 关键字存在，否则它们将永不暂停\n对 Task&lt;TResult&gt; 类型前使用 await 关键字，代表对该 Task 进行异步等待返回结果，届时会被挂起直到异步操作完成\n\nCoroutine 的原理、Coroutine 在哪些场景会被用到A coroutine is a function that is executed partially and, presuming suitable conditions are met, will be resumed at some point in the future until its work is done.\n即协程是一个分部执行，遇到条件（yield return 语句）会挂起，直到条件满足才会被唤醒继续执行后面的代码\n通过设置 MonoBehaviour 脚本的 enabled 对协程是没有影响的，但如果 gameObject.SetActive(false) 则已经启动的协程则完全停止了，即使在 Inspector 把 gameObject 激活还是没有继续执行。也就说协程虽然是在 MonoBehvaviour 启动的（StartCoroutine）但是协程函数的地位完全是跟 MonoBehaviour 是一个层次的，不受 MonoBehaviour 的状态影响，但跟 MonoBehaviour 脚本一样受 gameObject 控制，也应该是和 MonoBehaviour 脚本一样每帧“轮询”yield的条件是否满足\n值类型和引用类型\n值类型将数据和内存都保存在同一位置，而引用类型则会有一个指向实际内存区域的指针\n\n\n值类型 ：当将一个int 类型的值赋值到另一个 int 类型的值时，它实际上是创建了一个完全不同的副本。换句话说，如果改变了其中某一个的值，另一个不会发生改变。C# 的所有值类型均隐式派生自System.ValueType\n引用类型 ：当创建一个对象并且将此对象赋值给另外一个对象时，他们彼此都指向了内存中同一块区域。因此，当将obj 赋值给 obj1 时，他们都指向了堆中的同一块区域。换句话说，如果此时改变了其中任何一个，另一个都会受到影响\n\n哪些是值类型，哪些是引用类型\nC# 的值类型包括：数值类型、bool、用户定义的struct，enum，可空类型\nC# 的引用类型包括：数组，class、interface、delegate，object，string\n\nC# 中 struct 和class的区别，分别存放在哪个内存区\nstruct是值类型，class是对象类型\nstruct不能被继承，class可以被继承\nstruct默认的访问权限是 public，而class 默认的访问权限是private\nstruct总是有默认的构造函数，即使是重载默认构造函数仍然会保留。这是因为 struct 的构造函数是由编译器自动生成的，但是如果重载构造函数，必需对 struct 中的变量全部初始化。并且 struct 的用途是那些描述轻量级的对象，例如 Line，Point 等，并且效率比较高。class在没有重载构造函数时有默认的无参数构造函数，但是一被重载，默认构造函数将被覆盖\nstruct的 new 和 class 的 new 是不同的。struct的 new 就是执行一下构造函数创建一个新实例再对所有的字段进行拷贝。而 class 则是在堆上分配一块内存然后再执行构造函数，struct的内存并不是在 new 的时候分配的，而是在定义的时候分配\n\n在 C# 中，用 struct 或class来声明一个类型为值类型 / 引用类型。考虑下面的例子：\nSomeType[] oneTypes = new SomeType[100];\n\n\n如果 SomeType 是值类型，则只需要一次分配，大小为 SomeType 的 100 倍\n如果 SomeType 是引用类型，刚开始需要 100 次分配，分配后数组的各元素值为null，然后再初始化 100 个元素，结果总共需要进行 101 次分配。这将消耗更多的时间，造成更多的内存碎片。所以，如果类型的职责主要是存储数据，值类型比较合适\n\nstruct和 class 应用上的区别\n值类型适合存储供 C# 应用程序操作的数据\n引用类型应该用于定义应用程序的行为\n\n创建值类型的前提\n该类型的主要职责用于数据存储\n该类型的共有接口完全由一些数据成员存取属性定义\n该类型永远不可能有子类\n该类型不具有多态行为\n\n对象池重复依赖和循环依赖的话怎么处理.Net 与 Mono 的关系.Net.Net 拥有跨语言，跨平台性\n\n跨语言：就是只要是面向 .Net 平台的编程语言，用其中一种语言编写的类型就可以无缝的在另外一种语言编写的应用程序中互操作。\n跨平台：一次编译，不需要任何代码修改，应用程序就可以运行在任意在 .Net 实现的平台上跑，即代码不依赖于操作系统，也不依赖硬件环境。一个 .Net 程序运行的核心在于 .Net\n\nCLR（公共语言运行时，或者称为 .Net 虚拟机，类似 Java 虚拟机的概念），为了让 .Net 程序在其他平台（目前只能在 .Net 平台，windows 系统）上跑，微软官方还推出了在其他平台上 (MacOs,Linux) 跑的.Net 的实现，就推出了 .Net Core。然而，Unity 引擎需求也是需要跨平台，支持多语言（C#，Js，Boo）。就参考微软开发 .Net Core 的概念，于是，推出了 Mono\n\n    \n\n\nMono\n    \n\n\n\nmcs 编译器：C#编译器，C# 编译为 IL 中间指令\nUnity 跨平台的原理：就是 Mono 运行时编译器支持将 IL 代码转为对应平台原生码，IL 可以在任何支持 CLI(Common Language Insfrastructure, 通用语言环境结构）中运行，IL 的运行是依托于 Mono 运行时\nIOS 不支持 jit 编译原因：机器码被禁止映射到内存，即封存了内存的可执行权限，变相的封锁了 jit 编译方式，详情参考\nJIT 编译：将 IL 代码转为对应平台原生码并且将原生码映射到虚拟内存中执行。JIT 编译的时候 IL 是在依托 Mono 运行时，转为对应的原生码后在依托本地运行。\nAOT，JIT，Full-AOt 三者关系：注意 JIT，AOT 编译并不是互斥关系，他们可以共存。Mono 的 AOT 模式仍然会保留部分代码在程序运行时采用 jit 编译，因为 ios 被禁止了 jit，为了解决这个问题，Mono 提供了一个被称为 Full-AOT 的模式。即预先对程序集中所有 IL 代码进行 AOT 编译生成一个本地代码映像，然后在运行时直接加载这个映像而不再使用 jit\n\nC# 中抽象类 abstract 和接口 interface 的相同点与区别  相同点\n都可以被继承\n都不能被实例化\n都可以包含方法声明\n派生类必须实现未实现的方法\n\n区别\n抽象基类可以定义字段、属性、方法实现。接口只能定义属性、索引器、事件、和方法声明，不能包含字段。\n抽象类是一个不完整的类，需要进一步细化，而接口是一个行为规范。微软的自定义接口总是后带 able 字段，证明其是表述一类“我能做。。。”\n接口可以被多重实现，抽象类只能被单一继承\n抽象类更多的是定义在一系列紧密相关的类间，而接口大多数是关系疏松但都实现某一功能的类中\n抽象类是从一系列相关对象中抽象出来的概念，因此反映的是事物的内部共性；接口是为了满足外部调用而定义的一个功能约定， 因此反映的是事物的外部特性\n接口基本上不具备继承的任何具体特点, 它仅仅承诺了能够调用的方法\n接口可以用于支持回调, 而继承并不具备这个特点\n抽象类实现的具体方法默认为虚的，但实现接口的类中的接口方法却默认为非虚的，当然您也可以声明为虚的\n如果抽象类实现接口，则可以把接口中方法映射到抽象类中作为抽象方法而不必实现，而在抽象类的子类中实现接口中方法\n\n渲染  渲染流程\n    \n\n\nDrawCall 是什么、DrawCall 过高会有什么影响  什么是 DrawCallDrawCall 本身的含义很简单，就是 CPU 调用图像编程接口，如 OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawlndexedPrimitive 命令，以命令 GPU 进行渲染的操作\n为什么 DrawCall 过高会影响帧率  在每次调用 DrawCall 之前， CPU 需要向 GPU 发送很多内容，包括数据、状态和命令等。在这一阶段， CPU 需要完成很多工作，例如检查渲染状态等。而一旦 CPU 完成了这些准备工作， GPU 就可以开始本次的渲染。GPU 的渲染能力是很强的，渲染 200 个还是 2000 个三角网格通常没有什么区别，因此渲染速度往往快于 CPU 提交命令的速度。如果 DrawCall 的数量太多， CPU 就会把大量时间花费在提交 DrawCall 上，造成 CPU 的过载\nDrawCall 优化方案\n静态合并\n动态合并\nGPU Instancing\nSRP Batcher（本质上 DrawCall 不会减少，减少的是 DrawCall 数据拷贝）\n\n\n“关于 DrawCall 相关还需要注意的问题”\n\n如果静态批处理前有一些物体共享了相同的网格，那么每一个物体都会有一个该网格的复制品（本来 Unity 只会保留一份，但是静态批处理会生成新的一个大网格，所以会保留所有物体的网格，最后合并），即一个网格会变成多个网格被发送给 GPU，这回导致一次性提交过大的数据，虽然引擎是有限制的，一般是 65535 个顶点\n对于那些 shader 相同，纹理不同导致的不同材质无法进行批处理的物体（比如项目中的场景环境，地面，如果都使用了比较复杂的 Shader）通过纹理合并的方法来使得它们可以被静态批处理。但这会引发带宽问题，详细原因关系到 Bus 总线带宽的问题\n一下子提交大量的 DrawCall 导致的卡顿问题，这个可以阅读下 多线程渲染 相关的。主要是可能是因为，提交渲染 (eglSwapBuffers) 会导致驱动层中缓存的渲染指令立即执行，此时 CPU 被阻塞。如果在提交渲染时驱动层缓存了大量的指令，CPU 就会被阻塞很长时间；也可能是因为提交大量 DrawCall 的时候存在纹理的 Upload\nCPU 完成一次 DrawCall，除了需要发一个 DrawCall 的命令之外，还需要把内存中顶点数据、纹理贴图、Shader 参数通过 Bus 总线拷贝到内存分配给 GPU 的显存之中，注意这是拷贝，不是指针传递，速度不快。如果一次 DrawCall 传递的数据过大，带宽成为了瓶颈，那就会大大影响效率（其它的 DrawCall 无法出发，GPU 又处于闲置）。这种情况最有可能出现在为了减少 DrawCall，疯狂的合并纹理上。在项目中，UI 的 DrawCall 调用占了很大一部分，也会最难优化的。为了减少 DrawCall , 把 UI 合并成大的贴图，DrawCall 下降了，但是帧率却也下降了，内存使用也增加了，原因就是这个。在项目中，不会同时出现的元素不要打包到一起，保证单张合并纹理不大于 1024 一般就不会有问题了，最大尽量不要超过 2048\n\n\nLOD 是什么，优缺点是什么LOD 技术即 Levels of Detail 的简称，意为多细节层次。LOD 技术指根据物体模型的节点在现实环境中所处的位置和重要度，决定物体渲染的资源分配，降低非重要物体的面熟和细节的，从而获得高效率的渲染运算\n\n优点：可根据具体动态地渲染不同细节的模型\n缺点：加重美术的负担，要准备不同细节的同一模型，同样的会稍微增加包体大小\n\nMipMap 是什么，优缺点是什么MipMap，又叫多级渐进贴图纹理映射，根据渲染物体距离相机的远近，选用不同大小的纹理贴图\n\n可以使得远处的像素不发生闪烁\n减小带宽：因为在读取贴图的时候，正常的 UV 在 0~1 的区间连续读取，GPU 会尽量将这个 Shader 中读取这张贴图的指令拼接在一起，GPU 会将贴图中第一个读取指令的 UV 值的周围的一块像素读取到 L2，L1 缓存中，这就是贴图读取的预测策略。这样做的好处就是：由于 UV 连续，这样会有高命中率直接获取所需要 UV 值的颜色，要采样的两个 UV 距离很远时，当内存中不存在这个贴图的 UV 位置的内存数据，那么久职能清空当前已经进入缓存的数据，重新采样对应 UV 的周围一块像素值，再次放入 L2，L1 缓存中，这就是  缓存命中率降低  造成的带宽上升\n\n缺点：会占用内存（大约为 1/3）\nOverDraw 是什么，过高会有什么影响，怎么优化 OverDrawOverdraw 是指在渲染过程中，同一像素被多次绘制的现象。当游戏中有大量的透明物体叠加在一起时，Overdraw 就会发生。这是因为在渲染管线中，像素的颜色计算是基于背后像素的颜色计算的。当多个透明物体重叠在一起时，每个像素都需要计算多次，导致性能下降。\n造成 Overdraw 的原因有很多，其中之一是使用了过多的透明材质。透明材质在渲染过程中需要额外的计算资源，因此使用过多的透明材质会增加 Overdraw 的发生概率。另一个原因是过度使用粒子系统。粒子系统在渲染过程中会产生大量的透明像素，因此过度使用粒子系统也会增加 Overdraw 的发生。\n为了减少 Overdraw 对游戏性能的影响，我们可以采取一些优化措施。首先，我们可以合并多个透明物体为一个物体。通过将多个透明物体合并为一个物体，可以减少 Overdraw 的发生。其次，我们可以使用不透明的材质替代透明材质。不透明材质不需要额外的计算资源，因此可以减少 Overdraw 的发生。此外，我们还可以通过减少粒子系统的使用来减少 Overdraw 的发生。\n工具 TextMeshProUGUI 的Text 的文字是如何渲染出来 Text 继承了MaskableGraphic, ILayoutElement\nprotected override void OnPopulateMesh(VertexHelper toFill){    if (font == null)        return;     // We don't care if we the font Texture changes while we are doing our Update.    // The end result of cachedTextGenerator will be valid for this instance.    // Otherwise we can get issues like Case 619238.    m_DisableFontTextureRebuiltCallback = true;     Vector2 extents = rectTransform.rect.size;     var settings = GetGenerationSettings(extents);    cachedTextGenerator.PopulateWithErrors(text, settings, gameObject);     // Apply the offset to the vertices    IList&lt;UIVertex&gt; verts = cachedTextGenerator.verts;    float unitsPerPixel = 1 / pixelsPerUnit;    int vertCount = verts.Count;     // We have no verts to process just return (case 1037923)    if (vertCount &lt;= 0)    {        toFill.Clear();        return;    }     Vector2 roundingOffset = new Vector2(verts[0].position.x, verts[0].position.y) * unitsPerPixel;    roundingOffset = PixelAdjustPoint(roundingOffset) - roundingOffset;    toFill.Clear();    if (roundingOffset != Vector2.zero)    {        for (int i = 0; i &lt; vertCount; ++i)        {            int tempVertsIndex = i &amp; 3;            m_TempVerts[tempVertsIndex] = verts[i];            m_TempVerts[tempVertsIndex].position *= unitsPerPixel;            m_TempVerts[tempVertsIndex].position.x += roundingOffset.x;            m_TempVerts[tempVertsIndex].position.y += roundingOffset.y;            if (tempVertsIndex == 3)                toFill.AddUIVertexQuad(m_TempVerts);        }    }    else    {        for (int i = 0; i &lt; vertCount; ++i)        {            int tempVertsIndex = i &amp; 3;            m_TempVerts[tempVertsIndex] = verts[i];            m_TempVerts[tempVertsIndex].position *= unitsPerPixel;            if (tempVertsIndex == 3)                toFill.AddUIVertexQuad(m_TempVerts);        }    }     m_DisableFontTextureRebuiltCal\n\n\n重写 Graphic 的OnPopulateMesh方法，会在 Graphic 的Rebuild方法被调用，为 CanvasRenderer 的 Mesh 提供了顶点位置、顶点颜色、UV 和三角形信息\n根据用户设置生成了一个 TextGenerationSettings 文本生成设置，然后调用 TextGenerator.PopulateWithErrors 生成 Mesh 的顶点、顶点颜色、UV 和三角形信息\n计算偏移量（例如左对齐需要紧靠左边），最后遍历 TextGenerator 的顶点数组，将它们的位置除以pixelsPerUnit（每单元像素）并加上偏移量（如果有的话），得到的结果填到VertexHelper\n\nUI 添加文本\n\n文本字形是作为独立的面片 (quad) 进行渲染的，每个字符都是一个面片。这些面片通常都含有大量的空白区域围绕着字形，空白区域的大小取决于字形的形状，在放置文本时很容易就会无意中破坏其他 UI 元素的批处理\nUI 文本的网格重建是个重点问题。当 Text 组件发生变化时，必须重新计算用于显示实际文本的多边形。当 Text 组件或它的任意级别的父节点被禁用或启用时，也需要进行重新计算\n\n\n\n游戏中的 Text RenderingBitmap font 位图字体  最简单直接的方式，就是每个字符使用一张图片来表示，打包成一个图集，然后用一种方式来描述字符的位置。用来做一些彩色 UI 字体相当方便，这种方式有一个问题，就是只能支持固定大小的字体，放大后会出现模糊\nTTF OTF 字体  不同于位图的图片描述，TTF/OTF 字体使用贝塞尔曲线来描述字形 (glyph)，这样就可以保证缩放字体时不会失真。在渲染时，会动态生成需要用到的字符的字形位图并缓存起来，不同字号的字符需要不同的位图。从贝塞尔曲线生成位图，一般是用 CPU 来计算生成，现在也有使用 GPU 的 Computer Shader 等来生成的方式。这种方式是绝大多数文档等各类系统中的文本渲染方式，也是游戏 UI 中的默认选项\n但是在游戏的 3D 平面中渲染一些文字的时候，会出现一些问题。因为生成的位图是按照屏幕像素来生成的，Texture 中的一个纹素 (texel) 对应一个像素 (pixel)。在 3D 空间渲染文字时，可能会在不同的角度和不同的距离观察文字，就会出现失真抖动的问题\n基于 SDF 绘制  在字体位图图集的基础上，计算每个像素点到周围像素点的距离，得到 SDF 的值，然后映射到 0~1 的范围，生成一张 Alpha 贴图，0.5 的值代表正好是边缘。渲染文本的时候，对 Alpha=0.5 进行 AlphaTest，就可以渲染出文本。得益于 Texture 的双线性插值，可以得到平滑边缘的文本\nSDF 渲染文本的另一个巨大优势是，, 可以很方便地调整渲染的 shader，得到一些特殊的效果。比如：\n\nAA，在文本边缘处插值一些透明度过渡\nOutline，判断 alpha 值，0.51 正常渲染文本， 0.5-delta0.5 渲染描边色\nGlow，判断 alpha 值，在 0~0.5 处插值一个发光色\nDrop Shadow， 在 Pixel Shader 中进行 UV 偏移，二次查找 SDF Texture，得到阴影\n\nGPU 绘制字形TextMeshPro 组件TextMeshPro 文字渲染插件是基于 SDF（Signed Distance Function）实现的。使其可以在任意尺寸和分辨率下清晰的渲染文本。使用一系列自定义的着色器来提升 SDF 文本渲染的能力后，TextMeshPro 可以简单的通过修改材质属性来动态地改变视觉效果，例如，放大、外边框、软阴影等，并且可以通过创建材质预设来保存这些效果，在以后重新调用\nSDF Signed Distance FunctionIn mathematics and its applications, the signed distance function (or oriented distance function) is the orthogonal distance of a given point  to the boundary of a set  in a metric space, with the sign determined by whether or not  is in the interior of . The function has positive values at points  inside , it decreases in value as  approaches the boundary of  where the signed distance function is zero, and it takes negative values outside of .\nSDF，又可以称为定向距离函数（oriented distance function），在度量空间中的一个有限区域  内给定一个点 ，确定 到边界的距离，并根据  是否在  内部确定距离的符号：在  内部为正，位于外部为负，位于边界上 SDF 为 0\n对应文本渲染\nSDF 记录着当前像素点距离某一个区域的最小距离，这个区域  可以理解为文字，就是说可以假设像素值为 0 的点在区域内，像素值为 255 的点在区域外\n\n\nSDF 生成算法 Saito 的算法 欧几里得距离转换 (Euclidean Distance Transform, EDT) 简单的说即是以最常用的欧几里得距离作为  距离度量，找到每一个前景点到最近的背景点之间的距离，是将二维图片转为两个一维向量\n一些基本定义：\n\n背景点为 0，黑色\n前景点为 1，白色\n\nstep1：1-D Transformation\n从上到下，计算每一行中前景点到本行背景点距离最近的平方，得到中间结果\n\n    \n\n\n如下图，（a）为原图（b）为同一行的距离平方图，即，公式如下：\nMissing or unrecognized delimiter for \\left G(i, j) = \\mathop{min}\\limits_y \\left{(j - y)^2 | F(i, y) = 0 \\right} \nstep2：2-D Transformation\n从左到右，对每一列，对中间结果  进行操作，计算本列背景点与本行背景点距离平方和的最小值，得到距离图（Distance Map）\n\n    \n\n\n如下图（4 即使最近距离的平方）\n8ssedt设定像素点值为 0 表示空，1 表示为物体，那么对于任何一个像素点，我们要找距离它最近的目标像素点，就有以下几种情况：\n\n像素点值为 1：自身就是目标点，所以距离为 0。\n像素点值为 0：目标点应该在自己的四周，但可能是上下左右任意一方向\n假如当前像素点周围最近的某个像素（上下左右四个方向距离为 1 的像素）正好为 1，那这个像素点的 SDF 就应该为 1，因为不会有更近的情况了，其次就是左上、左下、右上、右下四个点，如果有为 1 的点，那该像素点的 SDF 值就应该为。以此类推，如果知道了当前像素点周围所有像素的 SDF 值，那么该像素点的 SDF 值一定为：\n\n// near 表示附近像素点// cur 表示当前像素// near.SDF 表示 near 的 SDF 值// Distance 表示两点之间距离min(near.SDF + Distance(cur, near))\n\n源码\n源码编译优化\n动画系统  骨骼动画的原理  基础概念  给一个模型加上骨骼前，一般要求这个模型摆成 T 字型，才方便动作师加骨骼和做动作。此时，加骨骼操作被称为骨骼绑定 (Skeleton Binding)；或者从模型角度讲叫做，模型蒙皮 (Model Skinning) 到骨骼\n这个初始骨骼摆位，就是绑定姿势 (Bind Poses)。但要注意，绑定姿势本身只记录了骨骼各个关节的姿势信息，并不包括蒙皮信息。蒙皮信息是存储于模型数据里的，因为所谓蒙皮，即是让每一个顶点绑定至  个关节，这  个关节运动的时候，会影响到该顶点的当前位置\n局部关节姿势 Local Joint Poses关节姿势分为局部关节姿势和全局关节姿势，局部关节姿势是相对直属父关节而言的，可以用一个结构体表示：\nstruct JointPose {    Quaternion rot; // R 关节旋转信息    Vector3 trans; // T 关节位移信息    Vector3 scale; // S 关节缩放信息}\n\n一个关节只需要存一组 RTS 信息。这 3 个信息可分别转换成 3 个矩阵，并且可以合并成一个矩阵。合并后的矩阵就被称为关节仿射变换矩阵 ： 一个骨骼，就是所有关节仿射变换的集合：即：\nstruct Skeleton {    size_t jointCount; // 关节数量    JointPose* local Poses; // 多个局部关节姿势}\n\n把  应用到关节  的局部坐标系的某个点或向量 ，就能把它变换到父关节 的坐标系：\n\n假设有 ，表示关节 的局部坐标系的圆点，是一个平移矩阵 ，那么 的结果就是 ，即 表示父关节  坐标系下的坐标\n可以定义子关节  到父关节的变换为 $(P_{C \\rightarrow P})j。这  样形  式不  太好  看，可  以换  一种 ， 先定  义一  个函  数p(j)，p(j)返  回关  节j的  父关  节索  引。那  么(P{C \\rightarrow P})j可  以写  成P{j \\rightarrow p(j)}$\n\n全局关节姿势 Global Joint Poses局部关节姿势是一种原始信息，实际上再渲染蒙皮动画前，需要做预处理，把局部关节姿势转换成全局关节姿势。全局关节姿势变换，指的是把关节姿势，用模型空间坐标系表示。首先定义，即根关节的父节点为模型空间\n每个关节  的全局关节姿势变换 ，可以用刚才的 来表示：\n\n\n\n\n对每个关节都做一遍这个公式，就能得到一个全局关节姿势数组。然后可以写入SkeletonPose：\nstruct SkeletonPose {    size_t jointCount; // 关节数量    JointPose* localPoses; // 多个局部关节姿势    Matrix4x4* globalPoses; // 多个全局关节姿势}\n\n全局关节姿势的存储，并不只限定于用 RTS，而是既可以用 RTS 也可以用矩阵。因为实时渲染里矩阵更通用快速，所以得存成矩阵\n绑定姿势矩阵（Bind Poses Matrix）、绑定姿势逆矩阵（Inversed Bind Poses Matrix）定义矩阵  为关节  在模型空间的全局绑定姿势矩阵。根据上文，可以把  从关节  的局部空间变换到模型空间\n反过来，要把一个点（模型的任意一个顶点）或向量，变换到关节  的空间，就是：就是绑定姿势逆矩阵，也可以写成：再定义  为模型任意顶点  在绑定姿势的模型空间坐标，而  为当前姿势的模型空间坐标。如果要求  在关节  的局部空间坐标 ，则公式为： 然后再乘以当前姿势的姿势矩阵（不是绑定姿势），得到当前姿势的模型空间坐标：\n蒙皮矩阵 Skinning Matrix\n就是关节  的蒙皮矩阵了：把绑定姿势模型空间下的顶点，先转换到绑定姿势关节空间，然后再转换到当前姿势模型空间\nozz-animation 中算  矩阵的代码片段：\nfor (size_t j = 0; j &lt; models.Count(); ++j) {    skinning_matirces[j] = models[j] * mesh.inverse_bind_poses[j];}\n\nmodels[j]就是当前姿势当前时刻第  的关节的 ；mesh.inverse_bind_poses[j] 就是，这个逆矩阵是预先算好的，比运行时再算逆矩阵要快得多，一般的蒙皮动画引擎都是这样做\nAnimation 和 Animator\nAnimator：动画控制器，控制 Mecanim 动画系统的接口，用来管理多个动画；\nAnimation：用于播放动画，老版中单独的一个 Animation 也可以完成动画的播放和切换，不过状态切换之类的需要程序代码控制。在新版中，状态管理部分交给了 Animator；\nAnimationClip：动画剪辑片段，储存基于关键帧的动画，是用于 Animation 来播放动画；\nAnimationState：动画状态，用来改变单一动画的播放速度、权重、时间、层级、播放 Mode，以及混合模式；\nAnimationEvent：动画事件，用于某种条件下触发自定义函数；\nStateMachineBehaviour： 动画状态机管理器拓展类，脚本继承了该类之后，绑定到 Animator 上某 State 上面。当状态发生变化，可以重载响应函数。类似 触发器的响应函数；\n\nAnimator 的性能缺陷  什么是 Animator Override。假设我们有个多个不同的角色，他们都有相同的动作，例如待机，跑步，攻击等等，并且触发条件也都相同。但是为了区分角色，他们相同的动作对应的动画往往都不相同，例如下图不同的跑步动画：\n\n    \n\n\nUnity 会尝试把 AnimatorController 里所有的 State 合并到一个名为 Animationset 的数据结构中。这意味着所有的 AnimationClip 再乘上所有 Clip 里所用的曲线都要经过一系列的运算。因此我们的 State 和 AnimationClip 越多越复杂，这个运算的耗时也会增加，导致性能问题\nLuaLua 如何实现面向对象的三大特性  面向对象的实现\n类 ：这是对象的元表，在访问不到对象的字段时，会触发类的index，而index 可以设为类自己，这样就变成访问类的字段。通常我们把对象的功能函数放在类中，让该类的所有对象都共享一套函数\n类的元表：这个表是为了实现继承，类也找不到字段时，会触发类的元表的__index，这里会取出父类并继续访问，如此循环，一直到父类为空为止。\n对象：这就是一个普通的table，把它的元表设为指定的类，那么它就被称为该类的对象\n\n-- rtl.lualocal rtl = {}local ksuper = {}   -- 作为查找父类的 key-- 定义一个类，super 是父类，为 nil 表示没有父类function rtl.class(super)    local klass = {}        -- 这就是代表类的 table    klass[ksuper] = super   -- 把父类 table 保存起来    klass.__index = klass   -- __index 设为自己    local _class_metatable = rtl._class_metatable   -- 这是类的元表，所有类都设置同一个元表    if not _class_metatable then        _class_metatable = {            __index = function (t, k)                -- 取得类的父类                local super = rawget(t, ksuper)                if super then                    -- 然后继续访问 k，如果找不到还会触发这个__index，一直往上追溯                    return super[k]                else                    return nil                end            end,            __call = function (cls, ...)                -- 创建类的对象，cls 就是类                local obj = {}                -- 将 cls 设为 obj 的元表，找不到 obj 的字段时，就会触发 klass.__index                -- 而__index 指向 kclass 自己，所以相当于在 kclass 上访问字段。                setmetatable(obj, cls)                -- 约定_init 为类的构造函数，所以这里会调用构造函数                local _init = cls._init                if _init then                    _init(obj, ...)                end                -- 最后返回这个对象                return obj            end          }        rtl._class_metatable = _class_metatable    end    -- 设置类的元表    setmetatable(klass, _class_metatable)     -- 最后返回类    return klassendreturn rtl\n\n项目中的多继承实现function class(classname, ...)    local cls = {__cname = classname}    local supers = {...}    for _, super in ipairs(supers) do        local superType = type(super)        assert(superType == \"nil\" or superType == \"table\" or superType == \"function\",            string.format(\"class() - create class \\\"%s\\\"with invalid super class type \\\"%s\\\"\",                classname, superType))        if superType == \"function\" then            assert(cls.__create == nil,                string.format(\"class() - create class \\\"%s\\\" with more than one creating function\",                    classname));            -- if super is function, set it to __create            cls.__create = super        elseif superType == \"table\" then            if super[\".isclass\"] then                -- super is native class                assert(cls.__create == nil,                    string.format(\"class() - create class \\\"%s\\\" with more than one creating function or native class\",                        classname));                cls.__create = function() return super:create() end            else                -- super is pure lua class                cls.__supers = cls.__supers or {}                cls.__supers[#cls.__supers + 1] = super                if not cls.super then                    -- set first super pure lua class as class.super                    cls.super = super                end            end        else            error(string.format(\"class() - create class \\\"%s\\\" with invalid super type\",                        classname), 0)        end    end    cls.__index = cls    if not cls.__supers or #cls.__supers == 1 then        setmetatable(cls, {__index = cls.super})    else        setmetatable(cls, {__index = function(_, key)            local supers = cls.__supers            for i = 1, #supers do                local super = supers[i]                if super[key] then return super[key] end            end        end})    end    if not cls.ctor then        -- add default constructor        cls.ctor = function() end    end    cls.new = function(...)        local instance        if cls.__create then            instance = cls.__create(...)        else            instance = {}        end        setmetatableindex(instance, cls)        instance.class = cls        instance:ctor(...)        return instance    end    cls.create = function(_, ...)        return cls.new(...)    end    return clsendlocal setmetatableindex_setmetatableindex_ = function(t, index)    if type(t) == \"userdata\" then        local peer = tolua.getpeer(t)        if not peer then            peer = {}            tolua.setpeer(t, peer)        end        setmetatableindex_(peer, index)    else        local mt = getmetatable(t)        if not mt then mt = {} end        if not mt.__index then            mt.__index = index            setmetatable(t, mt)        elseif mt.__index ~= index then            setmetatableindex_(mt, index)        end    endendsetmetatableindex = setmetatableindex_\n\nUI什么是图集、图集的作用\n所谓图集就是将很多零碎的 2 维小图整合成一张大图\n\n图集的作用\n\n提升效率：图片尺寸为 2 的次幂时，GPU 处理起来会快很多，小图自己是做不到每张图都是 2 的次幂的，但打成一张大图就可以\n\nUI 的合批理减少 DrawCall：打成图集后，CPU 在传送资源信息给 GPU 时，只需要传一张大图就可以了，因为 GPU 可以在这张图中的不同区域进行采样，然后拼出对应的界面\n\n这就是为什么一个 UI 界面需要用同一个图集的原因\n\n\n避免浪费资源：打成图集后把图片上的空间尽量利用得充实一点\n\n\n\n\n老版的 Sprite Packer 和新版的 Sprite Altas 的区别\nSprite Packer：2017.3 及之前使用的图集方案，通过对 Sprite 打 Tag 的方式，来自动生成图集。可以自定义打图集的策略\nSprite Altas：2017.4 新出的图集方案，用来替代 Sprite Packer。Sprite Packer 和 Sprite Atlas 不能共存，Unity 的 Sprite Packer Mode 中的单选性决定了这个不能共存的性质\nSprite Atlas 针对 Sprite Packer 图集打包系统在性能和易用性上的不足，进行了全面改善\n\nUGUI 的优化、实现过最复杂的 UI 面板是什么、简述一下自己项目中实现的 UI 框架  性能消耗的关键点unity 将 UI 的渲染分为两个步骤，对 mesh 的操作称为 Rebatch，对 material 和 layout 的操作称为 Rebuild，所以性能消耗也是在这两个部分。\nRebatch 的内部实现Rebatch 发生在 C++ 层面，是指 Canvas 分析 UI 节点生成最优批次的过程，节点数量过多会导致算法（贪心策略）耗时较长。对应 SetVerticesDirty，当一个 canvas 中包含的 mesh 发生改变时就触发，例如 SetActive、transform 的改变、 颜色改变、文本内容改变等等，canvas 独立处理，互相不影响。消耗在对 meshes 按照深度和重叠情况排序、共享材质的检测等。\nBatch 以 Canvas 为单位，同一个 Canvas 下的 UI 元素最终都会被 Batch 到一个 Mesh 中。Batch 前，UGUI 根据 UI 材质以及渲染顺序重排，在不改变渲染结果的前提下，尽可能将相同材质的 UI 元素合并在同一个 SubMesh 中，以减少 DC。Batch 只在 UI 元素发生变化时进行，合成的 Mesh 越大，耗时越大。重建对 Canvas 下所有 ui 元素生效，不论是否修改过。\n5.2 之后底层是多线程的，考虑到现在手机上都是多核，这部分消耗可能会小很多。不过对于复杂的 UI，还是多注意一些更好。\n针对 Rebatch 的优化方法\nCanvas 动静分离，合理划分，按游戏类型和 UI 数量划分，太多也有额外消耗。\n减少节点层次和数量，合批计算量小，速度快。\n使用相同材质贴图的 UI 尽量保持深度相同，这样对合批算法友好，速度快。\n修改 Image 的 Color 属性，原理是修改顶点色，会引起网格 Rebatch，同时触发 Canvas.SendWillRenderCanvases。好处在于修改顶点色材质不变，没有额外 DC。修改 shader 颜色不会重绘，材质不变，没有 Rebatch。\n\nRebuild 的触发原因Rebuild 发生在 C# 层面，是指 UGUI 库中 layout 组件调整 RectTransform 尺寸、Graphic 组件更新 Material，以及 Mask 执行 Cull 的过程，耗时和发生变化的节点数量基本呈线性相关。\n只有 LayoutGroup 的直接子节点，并且是 Graphic 类型的（比如 Image 和 Text）会触发 SetLayoutDirty。\nGraphic 改变的原因包括，基本的大小、旋转以及文字的变化、图片的修改等等，对应 SetMaterialDirty。\n针对 Rebuild 的优化方法\n少用 layout，简单的布局 RectTransform 代替\nCanvas 动静分离，按项目类型去规划。\n\n针对组件的优化\n不要用空的 Image，只接收事件不显示的对象，继承 Graphic，填充数据函数写成空的。\n不显示的对象，不要 SetActive，设置 Canvas Group 的 alpha 为 0，scale 为 0，这样 vbo 不会被清除。或是 canvasRenderer.cull 为 true。\n不需要响应事件的，取消 RaycastTarget。添加工具，代码设置 Image 和 text 默认取消。\nCanvas 渲染模式为 World Space 或 Screen Space Camera，始终分别设置事件摄像机和渲染摄像机非常重要，没有设置会通过 FindWithTag 查找主摄像机。\n少用 Mask，用 RectMask2D 代替。\nTextMeshPro 代替原生 text。\n字体 OutLine 多绘制 4 次。PixelPerfect 有消耗，滑动消耗更大。\nFont.CacheFontForText：生成动态字体 Font Texture，一次性打开 UI 界面中的文字越多，开销越大。如果当前 Font Texture 不能容下接下来的文字，扩大 texture，性能影响大。\n\n通用策略\n压缩图片，降低内存，动态加载释放和缓存。\n图集管理，减少 DrawCall，加载压力，这部分按游戏类型不同策略不同。一个简单的规则是一个 UI 只依赖自身一个图集，加上通用图集，实际做的时候图集还要多花时间检测，是个持续调优的事。\n特定条件下用大图片代替多个小图组合，减少 OverDraw。\n血条、飘字等实时刷新的注意性能，容易出现瓶颈。可以减少可见数量，降低远处刷新频率等。\ngameobject 隐藏方法，enable 有很大消耗，底层处理很多东西，移动坐标或是设置 layer。\n简化 UI 结构，空的节点越少越好，层级越少越好，不用的节点及时删除。因为 UI 一般修改较多，很容易把不显示的隐藏，依然有一定消耗。\n动态图集，用在图片数量多，不能合成一个大图集的情况。\n界面上少挂粒子特效，动态加载。\n全屏 UI 时关闭场景相机。\n\nUGUI 的理解，简单聊聊你对 Image 和 RawImage 的理解\nImage： 使用纹理（Texture）作为图像源，支持着色和 alpha 混合等高级功能\nMask： 可以使用另一个 Image 或 Shape 控件作为遮罩，创建更复杂的图像形状。\nAlpha 混合： 可以设置图像的透明度，使它与背景混合或叠加。\n裁剪： 可以裁剪图像，只显示纹理的一部分。\n\n\nRawImage： 使用原始像素数据作为图像源，不提供着色或 alpha 混合功能，但性能更佳\n性能优化： 由于不进行着色或混合，因此 RawImage 控件性能更好，非常适合处理大量图像或高分辨率纹理\n像素完美： RawImage 控件显示图像的原始像素，没有任何平滑或抗锯齿，因此非常适合像素艺术或复古游戏\n\n\n\n遮挡 MaskRectMask2D只能遮挡矩形范围，类似 NGUIpanel 的裁剪方式。这种方式不增加 DrawCall，比 Mask 性能高些，但是只能遮挡矩形区域。\nShader 部分，定义 UNITY_UI_CLIP_RECT，color.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); 实现裁剪；代码部分，调用 CanvasRenderer 的EnableRectClipping方法，传遮挡区域，底层设置给_ClipRect\nRectMask2D 节点下的 Maskable 组件，注册到 ClipperRegistry 类，底层控制对应的 Shader 打开宏定义\nMask原理设置模板缓冲值，通过测试的像素显示，从而只在指定范围内显示图像。透明度为 0 的区域不显示。将渲染分 3 个步骤，* 渲染 Mask，设置模板缓冲的值\n\n渲染模板下的对象，判断模板缓冲值，相同才渲染，也就是在根节点定义的区域内渲染\n最后将模板缓冲区设置为 0\n\n缺点\n\n打乱合批\n圆形边缘锯齿明显，原因是并不支持边缘渐变，只有显示和不显示两个状态\n遮挡效果只是显示，点击逻辑还是完整的区域，一般常用的，扩展一个图形更好，比如圆形\n\nUGUI 的重绘顺序是怎样的CanvasUpdateRegistry 负责驱动，也就是通知需要渲染的 UI 组件，为什么用通知的方式而不是 UI 自己处理呢，UGUI 的处理流程是这样的，UI 自己记录是否需要重新渲染，注册事件给 registry，registry 在要渲染的时候触发事件，UI 再去提交数据。这样的好处是，首先 UI 各种数据会在一帧内多次改变，肯定不能每次改变都发渲染事件，一帧处理一次效率比较高。再一个如果不发事件，那就必然要在 update 里写逻辑，比统一事件要麻烦些。\nUI 组件的基类是 Graphic，Graphic 核心功能是组织 mesh 和 material 然后传给底层，也就是 CanvasRenderer 类。\nCanvasRenderer 连接画布和渲染组件，通过 CanvasRenderer 把网格绘制到 Canvas 上，CR 并不是直接渲染，而是交给 Canvas，Canvas 还要做合批等操作\nCanvasRenderer 这个名字有点误导，并不是对应 Canvas，而是对应 Graphic。重要的接口有两个，SetMesh 和 SetMaterial。一次设置后，如果没有改变，不需要重复设置，底层有缓存，mesh 和 material 可以分开设置。\n每个 Graphic 的 CanvasRenderer 保存了当前元素的 mesh 和 material，但并不会每个 Graphic 一个 drawcall，canvas 会对节点下的 Graphic 进行合批，所以一个 Graphic 设置 dirty，整个 canvas 都需要重新计算合批，这个消耗是比较大的，合理分配 canvas，对性能影响较大，这是界面渲染性能要注意的地方。\n\n    \n\n\n重绘触发条件\nenable，disable，validate都会触发\nSetVerticesDirty\nMeshEffect 有变化\nshadow 属性改版\ntransform 大小改变\nimage 类型改变，层级改变，填充方式改变\nRawImage：texture 改变，uvRect 改变，触发动画效果\ntext 内容改变，开关 richtex，等等很多，text 是最频繁 dirty 的\nSetMaterialDirty\nmaterial 替换\nImage 触发动画\n显示 mask，设置是否开启 mask\ntransform 层级变化\ncanvas 层级变化\n重新计算 mask\nRawImage 替换 texture，使触发动画\n同时 dirty，包括 layout、transform 层级改变\nSprite 替换，改变图片大小，替换图集\n字体改变，字体图集变化\n\nNGUI 和 UGUI 区别\nUGUI 在需要重绘时触发事件，NGUI 在 update 每帧检测，界面复杂的情况下会有一定额外消耗\n合批，NGUI 开源，修改方便，也更好查问题。UGUI 只是传数据到底层，规则只能是测试和猜。不过合批的原理基本相同，性能上 UGUI 更好，底层不用 C#，在语言层面效率就更高些。\n重绘，在 NGUI 和 UGUI 都是个性能消耗点，要注意。\n层级，UGUI 按节点顺序，调整起来容易一点，NGUI 要点开才能看到 depth，有点麻烦\n裁剪，NGUI 通过切换 shader，多创建一个 material 实现的，要多一个 shader，没有 UGUI 方便，而且 UGUI2D 的方式更高效，不过 NGUI 支持裁剪边缘模糊，UGUI 要自己实现。\n图集，NGUI 的图集比较可控，UGUI 默认的图集不可控，一般还要用其他方案实现\n\n对 UI 进行 SetActive 这个操作为什么要避免频繁进行，具体做了些什么内容，有什么方法可以代替它\nC# 层到 Native 层的穿梭调用速度比 C# 层内的速度慢。\nUI 元素的变化导致所在的 Canvas 变化，触发函数 Canvas.SendWillRenderCanvases() 与Canvas.BuildBatch()造成高耗时\nUI 元素的网格顶点数组改变会造成堆内存分配，触发 GC，导致耗时（不过对 UI 元素进行位置移动不会造成堆内存分配）\n\n因此，优化也可以从以下几点考虑：\n\n在 C# 层设置变量来标识相应的 GO 处于 Active 还是非 Active 状态，避免对 Active 的对象进行 SetActive(true)，避免对非 Active 的对象进行 SetActive(false)。对 Active 进行 SetActive(true) 时，“底层”会进行判断，但调用的时候，就已经是从 C# 层调用底层，导致开销较高。在 C# 层判断好，就避免了让底层判断。\n将要频繁变化的 UI 元素与不频繁变化的 UI 元素放在不同的 Canvas 中，减少 UI 元素变化时的耗时。\n通过将 UI 元素的坐标移动到 Canvas 的范围之外的方法来显示与隐藏，避免 SetActive 的耗时以及 SendWillRenderCanvases 的耗时。\n经测试，对 Component 进行 enabled = false 的操作比对 GO 进行 SetActive(false) 的操作耗时低。\n通过添加 CanvasGroup 组件设置透明度的方式来进行显示与隐\n\nCanvas 的三种模式  渲染模式  在 Unity3D 中，Canvas 组件有三种不同的渲染模式：Screen Space - Overlay、Screen Space - Camera 和 World Space。不同的渲染模式适用于不同的场景和需求。\n\nScreen Space - Overlay 是最常用的渲染模式，它将 UI 元素渲染在屏幕上，并且总是位于所有其他对象的前面。在这种模式下，UI 元素的位置是以屏幕分辨率为基准的，不受相机的影响。这种模式适用于游戏中的常驻 UI，例如菜单、血条等\nScreen Space - Camera 模式将 UI 元素渲染在相机的前面，并且会受相机的视野和位置的影响。在这种模式下，UI 元素的位置是以相机为基准的，可以随着相机的移动而移动。这种模式适用于需要 UI 元素随着相机移动的场景，例如第一人称射击游戏中的准心\nWorld Space 模式将 UI 元素渲染在 3D 世界中的某个位置，并且会受到场景中其他 3D 对象的遮挡和光照的影响。在这种模式下，UI 元素的位置是以场景中的 3D 坐标为基准的。这种模式适用于需要将 UI 元素与场景中的 3D 对象进行交互的场景，例如在游戏中显示 NPC 的对话框\n\n屏幕适配  在移动设备上，屏幕的尺寸和分辨率各不相同，为了能够在不同设备上正确显示 UI 元素，我们需要进行屏幕适配。在 Canvas 组件中，有两种常用的屏幕适配方式：Constant Pixel Size 和 Scale With Screen Size\n\nConstant Pixel Size 是一种固定像素大小的适配方式，即 UI 元素的大小不会随着屏幕尺寸的变化而变化。在这种适配方式下，UI 元素的大小是以像素为单位的，对于不同的屏幕尺寸，UI 元素的大小会有所变化。这种适配方式适用于需要保持 UI 元素大小不变的场景，例如游戏中的按钮\nScale With Screen Size 是一种根据屏幕尺寸进行缩放的适配方式，即 UI 元素的大小会随着屏幕尺寸的变化而变化。在这种适配方式下，UI 元素的大小是以百分比为单位的，对于不同的屏幕尺寸，UI 元素的大小会按照比例进行缩放。这种适配方式适用于需要根据屏幕尺寸进行自适应的场景，例如游戏中的背景图像\n\n资源管理  资源管理模块 AssetBundle 的原理 如何从 Bundle 加载一份资源到 Game 里面，需要经过几次或者几个内存区  如何管理 AB 包  如何安全卸载 AB 包或者 Asset如何解决依赖Unity 会自动收集并分析其依赖的资源，如果该资源依赖的某个资源没有被显式指定打包到 ab 中，就将其依赖的这个资源打包进该资源所在的 ab 里；如果已经被指定打包进其他 ab 里，那么这两个 ab 之间就会构成依赖关系，加载 ab 时，先加载其依赖的 ab 即可。\n这一套依赖管理机制使用方便的同时也会带来一个问题：如果两个 ab A 和 B 中的一些资源都依赖了一个没有被指定要打包的资源 C，那么 C 就会同时被打进 ab A 和 B 中，造成资源的冗余，增大 ab 和安装包的体积。而这个被 A，B 依赖的资源 C 又可以分为两种类型，一种是 Assets 下外部导入的资源，即开发者导入或创建的资源；另一种则是 Unity 内置的资源，例如内置的 Shader，Default-Material 和 UGUI 一些组件如 Image 用的一些纹理资源等等。因此要解决资源冗余的问题，就要分别对这两种被依赖的资源进行处理。\n处理被依赖的外部资源  对于没有被指定打包的外部资源，如果多个 ab 包依赖了它，打包时该资源就会被多次打包进依赖它的 ab 包中，造成冗余。解决方案就是将这些被多个 ab 包依赖的资源打包到一个公共 ab 包中。处理过程如下：\n\n使用 EditorUtility.CollectDependencies() 得到 ab 依赖的所有资源的路径\n统计资源被所有 ab 引用的次数，将被多个 ab 引用的资源打包为公共 ab 包\n\n\nEditorUtility.CollectDependencies()收集到的资源包含了脚本，dll 和编辑器资源，这些资源无需打进 ab 中\n\n处理被依赖的内部资源  性能优化  使用过哪些性能分析工具、性能主要是在考虑哪方面的因素影响Unity ProfilerUnity Profiler 是 Unity 中最常用的官方性能分析工具，在使用 Unity 开发游戏的过程中，借助 Profiler 来分析 CPU、GPU 及内存使用状况是至关重要的\n\n合批的原理，合批有哪些，区别是什么  合批，也可以叫做批量渲染。合批就是通过减少 CPU 向 GPU 发送渲染命令（DrawCall）的次数，以及减少 GPU 切换渲染状态的次数，尽量让 GPU 一次多做一些事情，来提升逻辑线和渲染线的整体效率。但参与合批有个前提，就是参与合批的材质必须相同\n静态合批  对标记为 static 的 Mesh 自动合批。以空间换时间的策略来提升渲染效率。以存储更多网格数据为代价的\n如果在使用相同材质球的条件下，在 Build 的时候 Unity 会自动地提取这些共享材质的静态模型的 Vertex Buffer 和 Index Buffer。根据其摆放在场景中的位置等最终状态信息，将这些模型的顶点数据变换到世界空间下，存储在新构建的大 Vertex Buffer 和 Index Buffer 中，并且记录每一个子模型的 Index Buffer 数据在构建的大 Index Buffer 中的起始 (start0) 及结束 (end0) 位置\n\n    \n\n\n在后续的绘制过程中，一次性提交整个合并模型的顶点数据，根据引擎的场景管理系统判断各个子模型的可见性。然后设置一次渲染状态，调用多次 DrawCall 分别绘制每一个子模型。所以其实 Static Batching 是不减少 DrawCall 的数量（但是在编辑器时由于计算方法区别 DrawCall 数量是会显示减少了的），但是由于我们预先把所有的子模型的顶点变换到了世界空间下，所以在运行时 CPU 不需要再次执行顶点变换操作，节约了少量的计算资源，并且这些子模型共享材质，所以在多次 DrawCall 调用之间并没有渲染状态的切换，渲染 API（Command Buffer）会缓存绘制命令，起到了渲染优化的目的 。\n但静态合并有个很大的缺点就是打包之后会导致应用体积增大，应用运行时所占用的内存体积也会增大。例如，在茂密的森林级别将树标记为静态会严重影响内存，因为场景中所有引用相同模型的 GameObject 都必须将模型顶点信息复制，并经过计算变化到最终在世界空间中，存储在最终生成的 Vertex Buffer 中，这个时候的 vertex Buffer 会特别大\n\n    \n\n\n动态合批  将数份 Mesh 的数据复制粘贴到一起，也就是实时的，每一帧都合并，但不适用于网格数据太多的物体（比如球）\n在进行场景绘制之前将所有的共享同一材质的模型的顶点信息变换到世界空间中，然后通过一次 DrawCall 绘制多个模型，达到合批的目的。模型顶点变换的操作是由 CPU 完成的，所以这会带来一些 CPU 的性能消耗。并且计算的模型顶点数量不宜太多，否则 CPU 串行计算耗费的时间太长会造成场景渲染卡顿，所以 Dynamic Batching 只能处理一些小模型。所以仅仅在合批操作的性能消耗小于不合批，Dynamic Batching 才会有意义，虽然在内存占用和发布的程序体积方面要优于 Static Batching。\n无法参加 Dynamic Batching 的情况：\n\n物件 Mesh 大于等于 900 个面\n代码动态改变材质变量后不算同一个材质，会不参与合批\n如果你的着色器使用顶点位置，法线和 UV 值三种属性，那么你只能批处理 300 顶点以下的物体；如果你的着色器需要使用顶点位置，法线，UV0，UV1 和切向量，那你只能批处理 180 顶点以下的物体，否则都无法参与合批\n\n\n    \n\n\n动态合批与静态合批的区别\n动态合批不会创建常驻内存的“合并后网格”，也就是说它不会在运行时造成内存的显著增长，也不会影响打包时的包体大小；\n动态合批在绘制前会先将顶点转换到世界坐标系下，然后再填充进顶点、索引缓冲区；静态合批后子网格不接受任何变换操作，仅手动合批后的 Root 节点可被操作，因此静态合批的顶点、索引缓冲区中的信息不会被修改（Root 的变换信息则会通过 Constant Buffer 传入）；\n因为 2 的原因，动态合批的主要开销在于遍历顶点进行空间变换时的对 CPU 性能的开销；静态合批没有这个操作，所以也没有这个开销；\n动态合批使用根据渲染器类型分配的公共缓冲区，而静态合批使用自己专用的缓冲区。\n\nURPSetPassCall 和 DrawCall要想 CPU 和 GPU 既可以并行又可以独立工作，要使用一个命令缓冲区（Command Buffer）。命令缓冲区包含了一个命令队列，当 CPU 需要渲染一些对象时，它会通过图像编程接口向命令缓冲区添加命令，当 GPU 完成上次的渲染任务后，它会从命令队列读取一个命令并执行它，添加和读取的过程是相互独立的\n命令缓冲区有很多种类型，而 Draw Call 就是其中一种，其它命令还有 Set Pass Call 等等。Set Pass Call 代表了常说的改变渲染状态，当切换材质或者切换同一材质中 Shader 的不同 Pass 进行渲染时都会触发一次 Set Pass Call。比如渲染 1000 个相同的物体和渲染 1000 个不同的物体，虽然两者 Draw Call 都是 1000，但是前者的 Set Pass Call 为 1，后者还是 1000。切换渲染状态往往比 Draw Call 更耗时，所以这也是 URP 不再支持多 Pass 的原因\n每次调用 Draw Call 之前，CPU 都要向 GPU 发送很多内容，包括数据、状态和命令等。在这一阶段 CPU 需要完成很多工作，例如检查渲染状态等。一旦 CPU 完成了这些准备工作，GPU 就可以开始本次渲染，GPU 的渲染能力很强，渲染速度往往比 CPU 的提交命令速度快，如果 Draw Call 数量过多，CPU 就会把机会把大量时间花费在提交 Draw Call 上，造成 CPU 过载，游戏帧率变低\n早期 Unity 只支持动态批处理和静态批处理，后来有支持了 GPU Instancing，最后 SRP 出现时支持了一种新的批处理方式——SRP Batcher\nSRP BatcherSRP Batcher 中将 CPU 收集与提交 GPU 部分省略，并不是完全省略而是不需要每帧都给 GPU 传递数据，如果数据没有发生变化它们将被保存在 GPU 内存中，这样每帧只需要惊醒绑定数据就行，从而节省了效率。\n\nSRP Batcher 是否发生打断合传统方式是不同的：传统方式即使两个材质使用了  相同的着色器  也会产生 Set Pass Call，而 SRP Batcher 却不会，它判断打断并不是按材质是否变化，二十着色器变种是否发生变化，只要变种相同即使是用了不同的材质也能有效 SRP Batcher\n\nConstant BufferUnity 没有直接提供 MVP 矩阵，而是拆开成两个举证 M 和 VP，因为 VP 矩阵  在一帧中不会改变，可以重复利用。Unity 将 M 矩阵和 VP 矩阵存入 Constant Buffer 中以提高运算效率，M 矩阵存入的 Buffer 为UnityPerDraw Buffer，也就是针对每个物体的绘制不会改变。VP 矩阵则存入的是UnityPerFrame Buffer，即每一帧 VP 矩阵并不会改变。Constant Buffer 并不是所有平台都支持，目前 OpenGL 就不支持\n使用 cbuffer 关键字来引入 Constant Buffer，Constant Buffer 中还有很多其他的数据\ncbuffer UnityPerFrame {    float4x4 unity_MatirxVP;};cbuffer UnityPerDraw {    float4x4 unity_ObjectToWorld;};cbuffer UnityPerMaterial {        }\n\nUnityPerMaterial所有材质相关数据都应该在名为 UnityPerMaterial 的单个 CBUFFER 中声明\n\n什么是Per Material\n通常是在着色器属性部分声明的所有变量，不能把这些数据漏写或者写道别的 CBUFFER 中\n\nUnityPerDraw该 CBUFFER 应该包含所有 Unity 的内置引擎变量。UnityPerDraw的 CBUFFER 内部变量声明顺序也很重要，所有变量都应该遵顼名为 Block Feature 的布局——如果不需要，则不必声明部分块功能。UnityPerDraw中的所有内置引擎变量都应该为 float4 或float4x4类型\n\n在移动平台上，开发者可能想使用 real4 类型，以节省部分 GPU 带宽。不是所有 UnityPerDraw 变量都可以使用 real4 类型\n\nSRP Batcher 原理 SRP Batcher 会在主存中将模型的坐标信息、材质信息、主光阴影参数、非主光阴影参数分别保存成不同的CBUFFER 中，只有 CBUFFEER 产生变化才会重新提交到 GPU 中。如下图所示，将模型信息、位置信息、变换信息与材质信息分开，模型可能每帧都会移动坐标，但不会每帧都修改材质参数信息，材质信息每次变化后都通过 CBUFFER 传到 GPU 中并且保存（只要没有变化就不需要重新提交），最终 Shader 在显存中通过每帧变化的坐标信息和不一定每帧变化的材质信息渲染出模型来\n\n    \n\n\n\nCBUFFER_START(UnityPerDraw)：每个物体绘制共享的 CBUFFER，包括模型控件转世界空间矩阵、世界空间转模型空间矩阵、LOD 参数、 世界变换参数、灯光参数、环境贴图参数、烘焙参数、球谐光照信息\nCBUFFER_START(UnityPerMaterial)：同一材质只能些一个 CBUFFER_START(UnityPerMaterial)，如果写多个会报错。由于这个CBUFFER 是自己写的，所以所以数据的赋值在 Shader 代码的属性框架中，在材质面板中就可以设置参数了\n每个材质的内容持久化在 GPU 的内存上\n一个专用的代码路径来管理一个大的“Per Object”的CBUFFER\n\n\n\n着色器标识 Shader.PropertyToID获取着色器  属性名称  的唯一标识符。使用属性标识符比将字符串传递到所有材质属性函数更有效。例如，如果要多次调用 Material.SetColor 或者使用 MaterialPropertyBlock，则最好只获取一次所需属性的标识符。在 Unity 中，着色器属性的每个名称（例如 _MainTex 或 _Color）均分配有唯一 整数，在整个游戏中，该整数均保持相同。在游戏的不同次运行之间或在不同机器之间，这些数字不同，因此不要存储或通过网络发送这些数字\n","categories":["面试"],"tags":["unity","面试","2022"]},{"title":"Unreal 基础","url":"/2024/06/10/f3b491abe2f8/","content":"UPROPERTY()和UFUNCTION()UPROPERTY()\nBlueprintCallable：可以在蓝图中被调用\nBlueprintReadOnly：可以被蓝图读取，但是不可被修改\nBlueprintReadWrite：可以被蓝图读取和修改\nCategory：为属性添加分类标签\nEditAnywhere：该属性可以在属性窗口中修改\nEditDefaultOnly：可以在属性窗口中修改，但是只能在基类的属性窗口修改\nVisibleAnywhere：可以在属性窗口看见，但是不可修改\nVisibleDefaultsOnly：该属性只可在基类的属性窗口中看见而且不可修改\nMeta：可以用来设置一些元数据，如文档、关键字等，meta=(AllowPrivateAccess=&quot;true&quot;) 允许私有属性在编辑器中进行编辑\nTransient：该属性不会被序列化保存，通常用于临时数据或不希望被保存的数据\nReplicated：属性在网络中进行复制\n\nUFUNCTIONUFUNCTION是 Unreal Engine 中神功函数的宏，它用于标记某个函数是一个 Unreal Engine 托管的函数，并且可以在编辑器中惊醒访问和操作\nUFUNCTION宏提供了一系列参数，用于定义函数的属性和行为，例如是否是阑入可调用的，是否可在网络中复制等\n\nBlueprintCallable：可以在蓝图或者关卡蓝图中调用\nBlueprintPure：生命该函数为纯函数，即不会修改对象的状态\nBlueprintImplementableEvent：这个函数在头文件声明但是应该在类蓝图或关卡蓝图中重写，应该和 BlueprintCallable 一起使用，这样蓝图就可以调用它。\nCategory：指定在编辑器中现实的该函数所属的分类\nMeta：可以用来设置一些元数据，如文档、关键字等\nServer**、Client、Reliable：用于网络功能，指定该函数在服务端、客户端执行，以及指定该函数是否可靠传输\nBlueprintNativeEvent：这个函数可以在蓝图类中重写，同时拥有 C++ 实现，函数名为FuncName_Implementtation\n\n#include引入头文件与不完全声明  建议在源文件中引入其他头文件，而不是在头文件中引入其他头文件\n\n减少编译时间\n比秒循环依赖\n增强可维护性\n\n打印 LOG\nUE_LOG\n\nUE_Log宏是 Unreal Engine 重用日志记录的标准方式。它可以输出日志信息到控制台和日志文件，支持多种日志级别（如Log，Warning，Error）\nUE_LOG(LogCategory, LogVerbosity, Format, ...)\n\n\nGEngine-&gt;AddOnScreenDebugMessage\n\nGEngine-&gt;AddOnScreenDebugMessage可以在游戏屏幕上现实调试信息，通常用于快速查看和调试\nGEngine-&gt;AddOnScreenDebugMessage(Key TimeToDisplay, Color, Message)\n\n\n\n控制输入\nInput Mapping Context\n定义了那些输入键触发那些输入动作的规则集合\n\n\nInput Action\n代表了玩家可以执行的某种动作\n\n\nEnhancedInputComponent\n更灵活\n输入绑定优化\n输入处理流程的改进\n\n\n\nAnim Instnce 与动画 AActor、APawn 和ACharactor\nUObject：基础类 UObject 是所有非 Actor 类的基类，几乎所有的 Unreal Engine 对象都继承自UObject\nAActor：继承自UObject，并且是所有场景中对象（角色、道具、灯光等）的基类\nAPawn：可以被玩家或 AI 控制的对象，丹斯不需要复杂的运动和动画系统\n可控制性\n控制器：APawn通常与 AController 或APlayerController关联，以实现移动和交互\n不包含骨骼网格和动画\n\n\nACharacter是一种特殊类型的APawn，它包含用于行走、跳跃、游泳等运动功能。它是带有骨骼动画和动画系统的高级角色类\n骨骼网格和动画：ACharacter包含 ``USkeletallMeshComponent 和动画蓝图，用于角色的外观和动画\n角色运动：包含UCharacterMovementComponent，支持复杂的角色运动\n碰撞和胶囊体：默认包含一个胶囊碰撞体，用于角色的碰撞检测\n\n\n\n游戏是怎样运行的\nAGameModeBase\n这是游戏模式的基类，它定义了游戏的规则、逻辑和行为\n可以通过创建自定义的游戏模式类来扩展它，并重写其中的方法来实现特定的游戏的逻辑\n\n\nAGameMode\nAGameMode类是 AGameModeBase 的一个子类，它提供了更多的功能和控制权，例如玩家控制、团队管理、积分系统等\n可以使用 AGameMode 类来实现更复杂的游戏逻辑和规则\n\n\nGame Session\nGame State\nPlayer State\nDefault Pawn Class\nAPlayerController\nAHUD\n\n","categories":["游戏开发"],"tags":["Unreal","蓝图"]},{"title":"ProtoBuf 的基本原理","url":"/2024/06/04/77811b82e50c/","content":"\n            🔗 原文链接\n          \n\nProtobuf 是由 Google 设计的一种高效、轻量级的信息描述格式，起初是在 Google 内部使用，后来被开放出来，它具有语言中立、平台中立、高效、可扩展等特性，它非常适合用来做数据存储、RPC 数据交换等。与 json、xml 相比，Protobuf 的编码长度更短、传输效率更高，其实严格意义上讲，json、xml 并非是一种「编码」, 而只能称之为「格式」, json、xml 的内容本身都是字符形式，它们的编码采用的是 ASCII 编码，本文讲述 Protobuf 的底层编码原理，以便于了解 Protobuf 为什么编码长度短并且扩展性强，与此同时我们也将了解到它有哪些不足Protobuf 的一个典型应用场景便是做通信的数据交换格式，它在通信管道上是以纯二进制的形式进行传输，发送端使用编码器将数据序列化为二进制，接收端使用解码器将收到的二进制流进行反序列化从而取得原始信息，因此当对通信管道进行抓包时无法获知数据的详细内容，事实上，同一段 Protobuf 的二进制数据流，在接收端使用不同的解码格式进行解码，可能得到完全不同的信息。在了解 Protobuf 的底层编码细节之前，需要首先了解 Protobuf 所用到的两种主要的编码方式，它们分别是 Varints 编码和 Zigzag 编码\n1.1 Varints 编码  通常来说，普通的 int 数据类型，无论其值的大小，所占用的存储空间都是相等的，这点可以引起人们的思考，是否可以根据数值的大小来动态地占用存储空间，使得值比较小的数字占用较少的字节数，值相对比较大的数字占用较多的字节数，这便是变长整型编码的基本思想，采用变长整型编码的数字，其占用的字节数不是完全一致的，为了达到这一点，Varints 编码使用每个字节的最高有效位作为标志位，而剩余的 7 位以二进制补码的形式来存储数字值本身，当最高有效位为 1 时，代表其后还跟有字节，当最高有效位为 0 时，代表已经是该数字的最后的一个字节，在 Protobuf 中，使用的是 Base128 Varints 编码，之所以叫这个名字原因即是在这种方式中，使用 7 bit 来存储数字，在 Protobuf 中，Base128 Varints 采用的是小端序，即数字的低位存放在高地址，举例来看，对于数字 1, 我们假设 int 类型占 4 个字节，以标准的整型存储，其二进制表示应为\n00000000 00000000 00000000 00000001\n可见，只有最后一个字节存储了有效数值，前 3 个字节都是 0, 若采用 Varints 编码，其二进制形式为\n00000001\n因为其没有后续字节，因此其最高有效位为 0, 其余的 7 位以补码形式存放 1, 再比如数字 666, 其以标准的整型存储，其二进制表示为\n00000000 00000000 00000010 10011010\n而采用 Varints 编码，其二进制形式为\n10011010 00000101\n我们可以尝试来复原一下上面这个 Base128 Varints 编码的二进制串，首先看最高有效位，高 8 位的最高有效位为 1, 代表其后还跟有有效字节，低 8 位的最高有效位为 0, 代表其已是最后一个字节，由于 Protobuf 采用小端字节序存储数据，因此我们移除两个字节的最高有效位，并交换字节序便得到\n1010011010\n转换为十进制，即是数字 666\n从上面的编码解码过程可以看出，可变长整型编码对于不同大小的数字，其所占用的存储空间是不同的，编码思想与 CPU 的间接寻址原理相似，都是用一比特来标识是否走到末尾，但采用这种方式存储数字，也有一个相对不好的点便是，无法对一个序列的数值进行随机查找，因为每个数字所占用的存储空间不是等长的，因此若要获得序列中的第 N 个数字，无法像等长存储那样在查找之前直接计算出 Offset, 只能从头开始顺序查找\n1.2 Zigzag 编码Varints 编码的实质在于去掉数字开头的 0, 因此可缩短数字所占的存储字节数，在上面的例子中，我们只举例说明了正数的 Varints 编码，但如果数字为负数，则采用 Varints 编码会恒定占用 10 个字节，原因在于负数的符号位为 1, 对于负数其从符号位开始的高位均为 1, 在 Protobuf 的具体实现中，会将此视为一个很大的无符号数，以 Go 语言的实现为例，对于 int32 类型的 pb 字段，对于如下定义的 proto\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 a = 1;&#125;\n\nRequest 中包含类型为 int32 类型的字段，当 a 为负数时，其序列化之后将恒定占用 10 个字节，我们可以使用如下的测试代码\nfunc main() &#123;    a := pbTest.Request&#123;        A: -5,    &#125;    bytes, err := proto.Marshal(&amp;a)    if err != nil &#123;        fmt.Println(err)        return    &#125;    fmt.Println(fmt.Sprintf(&quot;%08b&quot;, bytes))&#125;\n\n对于 int32 类型的数字 -5, 其序列化之后的二进制为\n\n    \n\n\n究其原因在于 Protobuf 的内部将 int32 类型的负数转换为 uint64 来处理，转换后的 uint64 数值的高位全为 1, 相当于是一个 8 字节的很大的无符号数，因此采用 Base128 Varints 编码后将恒定占用 10 个字节的空间，可见 Varints 编码对于表示负数毫无优势，甚至比普通的固定 32 位存储还要多占 4 个字节。Varints 编码的实质在于设法移除数字开头的 0 比特，而对于负数，由于其数字高位都是 1, 因此 Varints 编码在此场景下失效，Zigzag 编码便是为了解决这个问题，Zigzag 编码的大致思想是首先对负数做一次变换，将其映射为一个正数，变换以后便可以使用 Varints 编码进行压缩，这里关键的一点在于变换的算法，首先算法必须是可逆的，即可以根据变换后的值计算出原始值，否则就无法解码，同时要求变换算法要尽可能简单，以避免影响 Protobuf 编码、解码的速度，我们假设 n 是一个 32 位类型的数字，则 Zigzag 编码的计算方式为\n(n &lt;&lt; 1) ^ (n &gt;&gt; 31)\n要注意这里左边是逻辑移位，右边是算术移位，右边的含义实际是得到一个全 1 （对于负数） 或全 0 （对于正数）的比特序列，因为对于任意一个位数为 η 的有符号数 n, 其最高位为符号位，剩下的 η - 1 位为数字位，将其算术右移 η - 1 位，由于是算术移位，因此右移时左边产生的空位将由符号位来填充，进行 η - 1 次算术右移之后便得到 η 位与原先的符号位相等的序列，然后对两边按位异或便得到 Zigzag 编码，我们用一个图示来直观地说明 Zigzag 编码的设计思想，为了简化，我们假定数字是 16 位的，先来看负数的情形，假设数字为 -5, 其在内存中的形式为\n11111111 11111011\n首先对其进行一次逻辑左移，移位后空出的比特位由 0 填充\n11111111 11110110\n然后对原数字进行 15 次算术右移，得到 16 位全为原符号位（即 1) 的数字\n11111111 11111111\n然后对逻辑移位和算术移位的结果按位异或，便得到最终的 Zigzag 编码\n00000000 00001001\n可以看到，对负数使用 Zigzag 编码以后，其高位的 1 全部变成了 0, 这样以来我们便可以使用 Varints 编码进行进一步地压缩，再来看正数的情形，对于 16 位的正数 5, 其在内存中的存储形式为\n00000000 00000101\n我们按照与负数相同的处理方法，可以得到其 Zigzag 编码为\n00000000 00001010\n从上面的结果来看，无论是正数还是负数，经过 Zigzag 编码以后，数字高位都是 0, 这样以来，便可以进一步使用 Varints 编码进行数据压缩，即 Zigzag 编码在 Protobuf 中并不单独使用，而是配合 Varints 编码共同来进行数据压缩，Google 在 Protobuf 的官方文档中写道：Google ProtobufIf you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long – it is, effectively, treated like a very large unsigned integer. If you use one of the signed types, the resulting varint uses ZigZag encoding, which is much more efficient.\n在上面的讨论中，我们了解了 Protobuf 所使用的 Varints 编码和 Zigzag 编码的编码原理，本节我们来讨论 Protobuf 的数据组织方式，首先来看一个例子，假设客户端和服务端使用 protobuf 作为数据交换格式，proto 的具体定义为\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 age = 1;&#125;\n\nRequest 中包含了一个名称为 name 的字段，客户端和服务端双方都用同一份相同的 proto 文件是没有任何问题的，假设客户端自己将 proto 文件做了修改，修改后的 proto 文件如下\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 age_test = 1;&#125;\n\n在这种情形下，服务端不修改应用程序仍能够正确地解码，原因在于序列化后的 Protobuf 没有使用字段名称，而仅仅采用了字段编号，与 json xml 等相比，Protobuf 不是一种完全自描述的协议格式，即接收端在没有 proto 文件定义的前提下是无法解码一个 protobuf 消息体的，与此相对的，json xml 等协议格式是完全自描述的，拿到了 json 消息体，便可以知道这段消息体中有哪些字段，每个字段的值分别是什么，其实对于客户端和服务端通信双方来说，约定好了消息格式之后完全没有必要在每一条消息中都携带字段名称，Protobuf 在通信数据中移除字段名称，这可以大大降低消息的长度，提高通信效率，Protobuf 进一步将通信线路上消息类型做了划分，如下表所示\n\n    \n\n\n对于 int32, int64, uint32 等数据类型在序列化之后都会转为 Varints 编码，除去两种已标记为 deprecated 的类型，目前 Protobuf 在序列化之后的消息类型 (wire-type) 总共有 4 种，Protobuf 除了存储字段的值之外，还存储了字段的编号以及字段在通信线路上的格式类型 (wire-type), 具体的存储方式为\nfield_num &lt;&lt; 3 | wire type\n即将字段标号逻辑左移 3 位，然后与该字段的 wire type 的编号按位或，在上表中可以看到，wire type 总共有 6 种类型，因此可以用 3 位二进制来标识，所以低 3 位实际上存储了其后所跟的数据的 wire type, 接收端可以利用这些信息，结合 proto 文件来解码消息结构体，我们以上面 proto 为例来看一段 Protobuf 实际序列化之后的完整二进制数据，假设 age 为 5, 由于 age 在 proto 文件中定义的是 int32 类型，因此序列化之后它的 wire type 为 0, 其字段编号为 1, 因此按照上面的计算方式，即 1 &lt;&lt; 3 | 0, 所以其类型和字段编号的信息只占 1 个字节，即 00001000, 后面跟上字段值 5 的 Varints 编码，所以整个结构体序列化之后为\n\n    \n\n\n有了字段编号和 wire type, 其后所跟的数据的长度便是确定的，因此 Protobuf 是一种非常紧密的数据组织格式，其不需要特别地加入额外的分隔符来分割一个消息字段，这可大大提升通信的效率，规避冗余的数据传输\n1.4 总结\nProtobuf 是一种高效的数据描述格式，具有平台无关、语言无关、可扩展等特点，适合做数据存储、RPC 的通信协议等场景\nProtobuf 采用 Varints 编码和 Zigzag 编码来编码数据，其中 Varints 编码的思想是移除数字高位的 0, 用变长的二进制位来描述一个数字，对于小数字，其编码长度短，可提高数据传输效率，但由于它在每个字节的最高位额外采用了一个标志位来标记其后是否还跟有有效字节，因此对于大的正数，它会比使用普通的定长格式占用更多的空间，另外对于负数，直接采用 Varints 编码将恒定占用 10 个字节，Zigzag 编码可将负数映射为无符号的正数，然后采用 Varints 编码进行数据压缩，在各种语言的 Protobuf 实现中，对于 int32 类型的数据，Protobuf 都会转为 uint64 而后使用 Varints 编码来处理，因此当字段可能为负数时，我们应使用 sint32 或 sint64, 这样 Protobuf 会按照 Zigzag 编码将数据变换后再采用 Varints 编码进行压缩，从而缩短数据的二进制位数\nProtobuf 不是完全自描述的信息描述格式，接收端需要有相应的解码器（即 proto 定义）才可解析数据格式，序列化后的 Protobuf 数据不携带字段名，只使用字段编号来标识一个字段，因此更改 proto 的字段名不会影响数据解析（但这显然不是一种好的行为）, 字段编号会被编码进二进制的消息结构中，因此我们应尽可能地使用小字段编号\nProtobuf 是一种紧密的消息结构，编码后字段之间没有间隔，每个字段头由两部分组成：字段编号和 wire type, 字段头可确定数据段的长度，因此其字段之前无需加入间隔，也无需引入特定的数据来标记字段末尾，因此 Protobuf 的编码长度短，传输效率高\n\n","categories":["游戏开发"],"tags":["proto"]},{"title":"XLua 如何与 C# 进行交互","url":"/2024/06/04/04dccfe10a89/","content":"\n🔗 深入 xLua 实现原理之 Lua 如何调用 C#\n\nxLua 是腾讯的一个开源项目，为 Unity、 .Net、 Mono 等 C# 环境增加 Lua 脚本编程的能力。本文主要是探讨 xLua 下 Lua 调用 C# 的实现原理\nLua 与 C# 数据通信机制  无论是 Lua 调用 C#，还是 C# 调用 Lua，都需要一个通信机制，来完成数据的传递。而 Lua 本身就是由 C 语言编写的，所以它出生自带一个和 C/C++ 的通信机制\nLua 和 C/C++ 的数据交互通过栈进行，操作数据时，首先将数据拷贝到”栈”上，然后获取数据，栈中的每个数据通过索引值进行定位，索引值为正时表示相对于栈底的偏移索引，索引值为负时表示相对于栈顶的偏移索引，索引值以 1 或 -1 为起始值，因此栈顶索引值永远为 -1， 栈底索引值永远为 1 。 “栈”相当于数据在 Lua 和 C/C++ 之间的中转地。每种数据都有相应的存取接口\n而 C# 可以通过 P/Invoke 方式调用 Lua 的 dll，通过这个 dll 执行 Lua 的 C API。换言之 C# 可以借助 C/C++ 来与 Lua 进行数据通信。在 xLua 的 LuaDLL.cs 文件中可以找到许多 DllImport 修饰的数据入栈与获取的接口\n// LuaDLL.cs[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern void lua_pushnumber(IntPtr L, double number);[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern void lua_pushboolean(IntPtr L, bool value);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern void xlua_pushinteger(IntPtr L, int value);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern double lua_tonumber(IntPtr L, int index);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern int xlua_tointeger(IntPtr L, int index);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern uint xlua_touint(IntPtr L, int index);[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern bool lua_toboolean(IntPtr L, int index);\n\n传递 C# 对象到 Lua对于 bool，int 这样简单的值类型可以直接通过 C API 传递。但对于 C# 对象就不同了，Lua 这边没有能与之对应的类型，因此传递到 Lua 的只是 C# 对象的一个索引，具体实现请看下面的代码\n// ObjectTranslator.cspublic void Push(RealStatePtr L, object o)&#123;    // ...    int index = -1;    Type type = o.GetType();#if !UNITY_WSA || UNITY_EDITOR    bool is_enum = type.IsEnum;    bool is_valuetype = type.IsValueType;#else    bool is_enum = type.GetTypeInfo().IsEnum;    bool is_valuetype = type.GetTypeInfo().IsValueType;#endif    bool needcache = !is_valuetype || is_enum;  // 如果是引用或枚举，会进行缓存    if (needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index)))  // 如果有缓存    &#123;        if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)          &#123;            return;        &#125;        // 这里实在太经典了，weaktable 先删除，然后 GC 会延迟调用，当 index 会循环利用的时候，不注释这行将会导致重复释放        //collectObject(index);    &#125;    bool is_first;    int type_id = getTypeId(L, type, out is_first);    // 如果一个 type 的定义含本身静态 readonly 实例时，getTypeId 会 push 一个实例，这时候应该用这个实例    if (is_first &amp;&amp; needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index)))     &#123;        if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)           &#123;            return;        &#125;    &#125;    // C# 侧进行缓存    index = addObject(o, is_valuetype, is_enum);    // 将代表对象的索引 push 到 lua    LuaAPI.xlua_pushcsobj(L, index, type_id, needcache, cacheRef);&#125;\n\n代码中的两个 if 语句主要是对缓存的判断，如果要传递的对象已经被缓存过了就直接使用缓存的。如果这个对象是被第一次传递，则进行以下两步操作\n\n通过 addObject 将对象缓存在 objects 对象池中，并得到一个索引（通过这个索引可以获取到该对象）\n // ObjectTranslator.csint addObject(object obj, bool is_valuetype, bool is_enum)&#123;    int index = objects.Add(obj);    if (is_enum)    &#123;        enumMap[obj] = index;    &#125;    else if (!is_valuetype)    &#123;        reverseMap[obj] = index;    &#125;        return index;&#125;\n通过 xlua_pushcsobj 将代表对象的索引传递到 Lua\n\n\n参数 key 表示代表对象的索引，参数 meta_ref 表示代表对象类型的表的索引，它的值是通过 getTypeId 函数获得的，后面会详细讲到。参数 need_cache 表示是否需要在 Lua 侧进行缓存，参数 cache_ref 表示 Lua 侧缓存表的索引\n// xlua.cLUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) &#123;    int* pointer = (int*)lua_newuserdata(L, sizeof(int));    *pointer = key;        if (need_cache) cacheud(L, key, cache_ref);  // Lua 侧缓存    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);    lua_setmetatable(L, -2);  // 为 userdata 设置元表&#125;// 将 key = userdata 存入缓存表static void cacheud(lua_State *L, int key, int cache_ref) &#123;    lua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);    lua_pushvalue(L, -2);    lua_rawseti(L, -2, key);    lua_pop(L, 1);&#125;\n\nxlua_pushcsobj的主要逻辑是，代表对象的索引被 push 到 Lua 后，Lua 会为其创建一个 userdata，并将这个userdata 指向对象索引，如果需要缓存则将 userdata 保存到缓存表中， 最后为 userdata 设置了元表。也就是说，C# 对象在 Lua 这边对应的就是一个userdata，利用对象索引保持与 C# 对象的联系。\n注册 C# 类型信息到 Lua为 userdata（特指 C# 对象在 Lua 这边对应的代理userdata，后面再出现的userdata 也是同样的含义，就不再赘述了）设置的元表，表示的实际是对象的类型信息。在将 C# 对象传递到 Lua 以后，还需要告知 Lua 该对象的类型信息，比如对象类型有哪些成员方法，属性或是静态方法等。将这些都注册到 Lua 后，Lua 才能正确的调用。这个元表是通过 getTypeId 函数生成的\n// ObjectTranslator.csinternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)&#123;    int type_id;    is_first = false;    if (!typeIdMap.TryGetValue(type, out type_id)) // no reference    &#123;        // ...        is_first = true;        Type alias_type = null;        aliasCfg.TryGetValue(type, out alias_type);        LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);        if (LuaAPI.lua_isnil(L, -1)) //no meta yet, try to use reflection meta        &#123;            LuaAPI.lua_pop(L, 1);            if (TryDelayWrapLoader(L, alias_type == null ? type : alias_type))            &#123;                LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);            &#125;            else            &#123;                throw new Exception(&quot;Fatal: can not load metatable of type:&quot; + type);            &#125;        &#125;        // 循环依赖，自身依赖自己的 class，比如有个自身类型的静态 readonly 对象。        if (typeIdMap.TryGetValue(type, out type_id))        &#123;            LuaAPI.lua_pop(L, 1);        &#125;        else        &#123;            // ...            LuaAPI.lua_pushvalue(L, -1);            type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);  // 将元表添加到注册表中            LuaAPI.lua_pushnumber(L, type_id);            LuaAPI.xlua_rawseti(L, -2, 1);   // 元表 [1] = type_id            LuaAPI.lua_pop(L, 1);            if (type.IsValueType())            &#123;                typeMap.Add(type_id, type);            &#125;            typeIdMap.Add(type, type_id);        &#125;    &#125;    return type_id;&#125;\n\n函数主要逻辑是以类的名称为 key 通过 luaL_getmetatable 获取类对应的元表，如果获取不到，则通过 TryDelayWrapLoader函数生成。然后调用 luaL_ref 将获取到的元表添加到 Lua 注册表中，并返回 type_id。type_id 表示的就是元表在 Lua 注册表中的索引，通过这个索引可以在 Lua 注册表中取回元表。前面提到的 xlua_pushcsobj函数就是利用 type_id 即meta_ref，获取到元表，然后为 userdata 设置的元表。下面来看元表具体是怎样生成的\n// ObjectTranslator.cspublic bool TryDelayWrapLoader(RealStatePtr L, Type type)&#123;    // ...    LuaAPI.luaL_newmetatable(L, type.FullName); // 先建一个 metatable，因为加载过程可能会需要用到    LuaAPI.lua_pop(L, 1);    Action&lt;RealStatePtr&gt; loader;    int top = LuaAPI.lua_gettop(L);    if (delayWrap.TryGetValue(type, out loader))  // 如果有预先注册的类型元表生成器，则直接使用    &#123;        delayWrap.Remove(type);        loader(L);    &#125;    else    &#123;#if !GEN_CODE_MINIMIZE &amp;&amp; !ENABLE_IL2CPP &amp;&amp; (UNITY_EDITOR || XLUA_GENERAL) &amp;&amp; !FORCE_REFLECTION &amp;&amp; !NET_STANDARD_2_0        if (!DelegateBridge.Gen_Flag &amp;&amp; !type.IsEnum() &amp;&amp; !typeof(Delegate).IsAssignableFrom(type) &amp;&amp; Utils.IsPublic(type))        &#123;            Type wrap = ce.EmitTypeWrap(type);            MethodInfo method = wrap.GetMethod(&quot;__Register&quot;, BindingFlags.Static | BindingFlags.Public);            method.Invoke(null, new object[] &#123; L &#125;);        &#125;        else        &#123;            Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));        &#125;#else        Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));#endif        // ...    &#125;    if (top != LuaAPI.lua_gettop(L))    &#123;        throw new Exception(&quot;top change, before:&quot; + top + &quot;, after:&quot; + LuaAPI.lua_gettop(L));    &#125;    foreach (var nested_type in type.GetNestedTypes(BindingFlags.Public))    &#123;        if (nested_type.IsGenericTypeDefinition())  // 过滤泛型类型定义        &#123;            continue;        &#125;        GetTypeId(L, nested_type);    &#125;        return true;&#125;\n\nTryDelayWrapLoader 主要用来处理两种情况\n通过 delayWrap 判断，是否有为该类生成代码，如果有，直接使用生成函数进行填充元表（loader方法）。在 xLua 的生成代码中有一个 XLuaGenAutoRegister.cs 文件，在这个文件中会为对应的类注册初始化器，而这个初始化器负责将类对应的元表生成函数添加到 delayWrap 中。\n\n// XLuaGenAutoRegister.cspublic class XLua_Gen_Initer_Register__&#123;    static void wrapInit0(LuaEnv luaenv, ObjectTranslator translator)    &#123;        // ...        translator.DelayWrapLoader(typeof(TestXLua), TestXLuaWrap.__Register);  // 将类型对应的元表填充函数__Register 添加到 delayWrap 中        // ...    &#125;        static void Init(LuaEnv luaenv, ObjectTranslator translator)    &#123;        wrapInit0(luaenv, translator);        translator.AddInterfaceBridgeCreator(typeof(System.Collections.IEnumerator), SystemCollectionsIEnumeratorBridge.__Create);    &#125;        static XLua_Gen_Initer_Register__()    &#123;            XLua.LuaEnv.AddIniter(Init);  // 注册初始化器        &#125;&#125;\n\n\n如果没有生成代码，通过反射填充元表（ReflectionWrap方法）\n\n使用生成函数填充元表  以LuaCallCSharp修饰的 TestXLua 类为例来查看生成函数是如何生成的\n// TestXLua.cs[LuaCallCSharp]public class TestXLua&#123;    public string Name;    public void Test1(int a)&#123;    &#125;    public static void Test2(int a, bool b, string c)    &#123;    &#125;&#125;\n\nGenerate Code 之后生成的 TestXLuaWrap.cs 如下所示\npublic class TestXLuaWrap &#123;    public static void __Register(RealStatePtr L)    &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        System.Type type = typeof(TestXLua);        Utils.BeginObjectRegister(type, L, translator, 0, 1, 1, 1);        Utils.RegisterFunc(L, Utils.METHOD_IDX, &quot;Test1&quot;, _m_Test1);        Utils.RegisterFunc(L, Utils.GETTER_IDX, &quot;Name&quot;, _g_get_Name);        Utils.RegisterFunc(L, Utils.SETTER_IDX, &quot;Name&quot;, _s_set_Name);        Utils.EndObjectRegister(type, L, translator, null, null,            null, null, null);        Utils.BeginClassRegister(type, L, __CreateInstance, 2, 0, 0);        Utils.RegisterFunc(L, Utils.CLS_IDX, &quot;Test2&quot;, _m_Test2_xlua_st_);        Utils.EndClassRegister(type, L, translator);    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int __CreateInstance(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            if(LuaAPI.lua_gettop(L) == 1)            &#123;                TestXLua gen_ret = new TestXLua();                translator.Push(L, gen_ret);                return 1;            &#125;        &#125;        catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return LuaAPI.luaL_error(L, &quot;invalid arguments to TestXLua constructor!&quot;);            &#125;    [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _m_Test1(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            &#123;                int _a = LuaAPI.xlua_tointeger(L, 2);                gen_to_be_invoked.Test1(_a);                return 0;            &#125;        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _m_Test2_xlua_st_(RealStatePtr L)    &#123;        try &#123;            &#123;                int _a = LuaAPI.xlua_tointeger(L, 1);                bool _b = LuaAPI.lua_toboolean(L, 2);                string _c = LuaAPI.lua_tostring(L, 3);                TestXLua.Test2(_a, _b, _c);                return 0;            &#125;        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _g_get_Name(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);                    TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            LuaAPI.lua_pushstring(L, gen_to_be_invoked.Name);        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return 1;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _s_set_Name(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);                    TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            gen_to_be_invoked.Name = LuaAPI.lua_tostring(L, 2);                &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return 0;    &#125;&#125;\n\n生成函数 __Register 主要是这样一个框架\nUtils.BeginObjectRegister，在对类的非静态值（例如成员变量，成员方法等）进行注册前做一些准备工作。主要是为元表添加 __gc 和__tostring元方法，以及准备好 method 表、getter表、setter表，后面调用 RegisterFunc 时，可以选择插入到对应的表中\n // Utils.cspublic static void BeginObjectRegister(Type type, RealStatePtr L, ObjectTranslator translator, int meta_count, int method_count, int getter_count,    int setter_count, int type_id = -1)&#123;    if (type == null)    &#123;        if (type_id == -1) throw new Exception(&quot;Fatal: must provide a type of type_id&quot;);        LuaAPI.xlua_rawgeti(L, LuaIndexes.LUA_REGISTRYINDEX, type_id);    &#125;    else    &#123;        LuaAPI.luaL_getmetatable(L, type.FullName);        // 如果 type.FullName 对应的元表是空，则创建一个新的元表，并设置到注册表中        if (LuaAPI.lua_isnil(L, -1))        &#123;            LuaAPI.lua_pop(L, 1);            LuaAPI.luaL_newmetatable(L, type.FullName);        &#125;    &#125;    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());    LuaAPI.lua_pushnumber(L, 1);    LuaAPI.lua_rawset(L, -3);  // 为元表设置标志    if ((type == null || !translator.HasCustomOp(type)) &amp;&amp; type != typeof(decimal))    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);        LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);        LuaAPI.lua_rawset(L, -3);  // 为元表设置__gc 方法    &#125;    LuaAPI.xlua_pushasciistring(L, &quot;__tostring&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);    LuaAPI.lua_rawset(L, -3);  // 为元表设置__tostring 方法    if (method_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, method_count);  // 创建 method 表    &#125;    if (getter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, getter_count);  // 创建 getter 表    &#125;    if (setter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, setter_count);  // 创建 setter 表    &#125;&#125;\n多个 Utils.RegisterFunc，将类的每个非静态值对应的包裹方法注册到不同的 Lua 表中。包裹方法是 Generate Code 时动态生成的，对于类的属性会生成两个包裹方法，分别是get 和set包裹方法\n 例如成员方法 Test1 对应的包裹方法是 _m_Test1，并被注册到了method 表中。Name变量的 _g_get_Name 包裹方法被注册到getter 表，而 _s_set_Name 包裹方法被注册到 setter 表。这个包裹方法只是对原来方法的一层包裹，调用这个包裹方法本质上就是调用原来的方法。至于为什么需要生成包裹方法，后面会再讲到\n // Utils.cs RegisterFunc 根据不同的宏定义会有不同的版本，但大同小异public static void RegisterFunc(RealStatePtr L, int idx, string name, LuaCSFunction func)&#123;    idx = abs_idx(LuaAPI.lua_gettop(L), idx);    LuaAPI.xlua_pushasciistring(L, name);    LuaAPI.lua_pushstdcallcfunction(L, func);    LuaAPI.lua_rawset(L, idx);  // 将 idx 指向的表中添加键值对 name = func&#125;\nUtils.EndObjectRegister，结束对类的非静态值的注册。主要逻辑是为元表生成 __index 元方法和 __newindex 元方法，这也是 Lua 调用 C# 的核心所在\n // Utils.cspublic static void EndObjectRegister(Type type, RealStatePtr L, ObjectTranslator translator, LuaCSFunction csIndexer,    LuaCSFunction csNewIndexer, Type base_type, LuaCSFunction arrayIndexer, LuaCSFunction arrayNewIndexer)&#123;    int top = LuaAPI.lua_gettop(L);    int meta_idx = abs_idx(top, OBJ_META_IDX);    int method_idx = abs_idx(top, METHOD_IDX);    int getter_idx = abs_idx(top, GETTER_IDX);    int setter_idx = abs_idx(top, SETTER_IDX);    //begin index gen    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, method_idx);  // 1. 压入 methods 表    LuaAPI.lua_pushvalue(L, getter_idx);  // 2. 压入 getters 表    if (csIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, csIndexer);  // 3. 压入 csindexer        // ...    &#125;    translator.Push(L, type == null ? base_type : type.BaseType());  // 4. 压入 base    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  // 5. 压入 indexfuncs    if (arrayIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, arrayIndexer);  // 6. 压入 arrayindexer        // ...    &#125;    LuaAPI.gen_obj_indexer(L);  // 生成__index 元方法    if (type != null)    &#123;        LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua indexs function tables        translator.Push(L, type);        LuaAPI.lua_pushvalue(L, -3);        LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaIndexs][type] = __index 函数        LuaAPI.lua_pop(L, 1);    &#125;    LuaAPI.lua_rawset(L, meta_idx);    //end index gen    //begin newindex gen    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, setter_idx);    if (csNewIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, csNewIndexer);        // ...    &#125;    translator.Push(L, type == null ? base_type : type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    if (arrayNewIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, arrayNewIndexer);        // ...    &#125;    LuaAPI.gen_obj_newindexer(L);  // 生成__newindex 元方法    if (type != null)    &#123;        LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua newindexs function tables        translator.Push(L, type);        LuaAPI.lua_pushvalue(L, -3);        LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaNewIndexs][type] = __newindex 函数        LuaAPI.lua_pop(L, 1);    &#125;    LuaAPI.lua_rawset(L, meta_idx);    //end new index gen    LuaAPI.lua_pop(L, 4);&#125;\n\n __index元方法是通过调用 gen_obj_indexer 获得的，在调用该方法前会依次压入 6 个参数（代码注释中有标注），gen_obj_indexer内部又会再压入一个 nil 值，用于为 baseindex 提前占位。共 7 个参数会作为 upvalue 关联到闭包 obj_indexer。obj_indexer 函数就是 __index 元方法，它的逻辑是当访问 userdata[key] 时，先依次查询之前通过 RegisterFunc 填充的 methods，getters 等表中是否存有对应 key 的包裹方法，如果有则直接使用，如果没有则递归在父类中查找。__newindex元方法是通过调用 gen_obj_newindexer 获得的，与__index 的获得原理类似，这里就不再列出了\n // xlua.cLUA_API int gen_obj_indexer(lua_State *L) &#123;    lua_pushnil(L);    lua_pushcclosure(L, obj_indexer, 7);    return 0;&#125;//upvalue --- [1]: methods, [2]:getters, [3]:csindexer, [4]:base, [5]:indexfuncs, [6]:arrayindexer, [7]:baseindex//param   --- [1]: obj, [2]: keyLUA_API int obj_indexer(lua_State *L) &#123;            if (!lua_isnil(L, lua_upvalueindex(1))) &#123;  // 如果 methods 中有 key，则使用 methods[key]        lua_pushvalue(L, 2);        lua_gettable(L, lua_upvalueindex(1));        if (!lua_isnil(L, -1)) &#123;//has method            return 1;        &#125;        lua_pop(L, 1);    &#125;        if (!lua_isnil(L, lua_upvalueindex(2))) &#123;  // 如果 getters 中 key，则调用 getters[key]        lua_pushvalue(L, 2);        lua_gettable(L, lua_upvalueindex(2));        if (!lua_isnil(L, -1)) &#123;//has getter            lua_pushvalue(L, 1);            lua_call(L, 1, 1);            return 1;        &#125;        lua_pop(L, 1);    &#125;        if (!lua_isnil(L, lua_upvalueindex(6)) &amp;&amp; lua_type(L, 2) == LUA_TNUMBER) &#123;  // 如果 arrayindexer 中有 key 且 key 是数字，则调用 arrayindexer[key]        lua_pushvalue(L, lua_upvalueindex(6));        lua_pushvalue(L, 1);        lua_pushvalue(L, 2);        lua_call(L, 2, 1);        return 1;    &#125;        if (!lua_isnil(L, lua_upvalueindex(3))) &#123;  // 如果 csindexer 中有 key，则调用 csindexer[key]        lua_pushvalue(L, lua_upvalueindex(3));        lua_pushvalue(L, 1);        lua_pushvalue(L, 2);        lua_call(L, 2, 2);        if (lua_toboolean(L, -2)) &#123;            return 1;        &#125;        lua_pop(L, 2);    &#125;        if (!lua_isnil(L, lua_upvalueindex(4))) &#123;  // 递归向上在 base 中查找        lua_pushvalue(L, lua_upvalueindex(4));        while(!lua_isnil(L, -1)) &#123;            lua_pushvalue(L, -1);            lua_gettable(L, lua_upvalueindex(5));            if (!lua_isnil(L, -1)) // found            &#123;                lua_replace(L, lua_upvalueindex(7)); //baseindex = indexfuncs[base]                lua_pop(L, 1);                break;            &#125;            lua_pop(L, 1);            lua_getfield(L, -1, &quot;BaseType&quot;);            lua_remove(L, -2);        &#125;        lua_pushnil(L);        lua_replace(L, lua_upvalueindex(4));//base = nil    &#125;        if (!lua_isnil(L, lua_upvalueindex(7))) &#123;          lua_settop(L, 2);        lua_pushvalue(L, lua_upvalueindex(7));          lua_insert(L, 1);        lua_call(L, 2, 1);  // 调用父类的__index，indexfuncs[base](obj, key)        return 1;    &#125; else &#123;        return 0;    &#125;&#125;\nUtils.BeginClassRegister，在对类的静态值（例如静态变量，静态方法等）进行注册前做一些准备工作。主要是为类生成对应的 cls_table 表，以及提前创建好 static_getter 表与 static_setter 表，后续用来存放静态字段对应的 get 和set包裹方法。注意这里还会为 cls_table 设置元表meta_table\n // Utils.cspublic static void BeginClassRegister(Type type, RealStatePtr L, LuaCSFunction creator, int class_field_count,    int static_getter_count, int static_setter_count)&#123;    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);    LuaAPI.lua_createtable(L, 0, class_field_count);    LuaAPI.xlua_pushasciistring(L, &quot;UnderlyingSystemType&quot;);    translator.PushAny(L, type);    LuaAPI.lua_rawset(L, -3);    int cls_table = LuaAPI.lua_gettop(L);    SetCSTable(L, type, cls_table);    LuaAPI.lua_createtable(L, 0, 3);    int meta_table = LuaAPI.lua_gettop(L);    if (creator != null)    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__call&quot;);#if GEN_CODE_MINIMIZE        translator.PushCSharpWrapper(L, creator);#else        LuaAPI.lua_pushstdcallcfunction(L, creator);#endif        LuaAPI.lua_rawset(L, -3);    &#125;    if (static_getter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, static_getter_count);   // 创建好 static_getter 表    &#125;    if (static_setter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, static_setter_count);  // 创建好 static_setter 表    &#125;    LuaAPI.lua_pushvalue(L, meta_table);    LuaAPI.lua_setmetatable(L, cls_table);  // 设置元表&#125;\n\n cls_table 表是根据类的命名空间名逐层添加到注册表中的，主要是通过 SetCSTable 实现\n // Utils.cspublic static void SetCSTable(RealStatePtr L, Type type, int cls_table)&#123;    int oldTop = LuaAPI.lua_gettop(L);    cls_table = abs_idx(oldTop, cls_table);    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    List&lt;string&gt; path = getPathOfType(type);    // 对于 A.B.C 来说    // for 循环处理 A.B    // 1. 注册表 [xlua_csharp_namespace][A] = &#123;&#125; 且出栈 注册表 [xlua_csharp_namespace]    // 2. 注册表 [xlua_csharp_namespace][A][B] = &#123;&#125; 且出栈 注册表 [xlua_csharp_namespace][A]    for (int i = 0; i &lt; path.Count - 1; ++i)    &#123;        LuaAPI.xlua_pushasciistring(L, path[i]);        if (0 != LuaAPI.xlua_pgettable(L, -2))        &#123;            var err = LuaAPI.lua_tostring(L, -1);            LuaAPI.lua_settop(L, oldTop);            throw new Exception(&quot;SetCSTable for [&quot; + type + &quot;] error: &quot; + err);        &#125;        if (LuaAPI.lua_isnil(L, -1))  // 如果 注册表 [xlua_csharp_namespace] 中没有 key path[i] , 则添加一个 path[i] = &#123;&#125; 键值对        &#123;            LuaAPI.lua_pop(L, 1);            LuaAPI.lua_createtable(L, 0, 0);            LuaAPI.xlua_pushasciistring(L, path[i]);            LuaAPI.lua_pushvalue(L, -2);            LuaAPI.lua_rawset(L, -4);        &#125;        else if (!LuaAPI.lua_istable(L, -1))        &#123;            LuaAPI.lua_settop(L, oldTop);            throw new Exception(&quot;SetCSTable for [&quot; + type + &quot;] error: ancestors is not a table!&quot;);        &#125;        LuaAPI.lua_remove(L, -2);    &#125;    // 处理 C    // 注册表 [xlua_csharp_namespace][A][B][C] = cls_table 且出栈 [xlua_csharp_namespace][A][B][C]    LuaAPI.xlua_pushasciistring(L, path[path.Count - 1]);    LuaAPI.lua_pushvalue(L, cls_table);    LuaAPI.lua_rawset(L, -3);      LuaAPI.lua_pop(L, 1);    // 在 注册表 [xlua_csharp_namespace] 中添加键值对 [type 对应的 lua 代理 userdata] = cls_table    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    ObjectTranslatorPool.Instance.Find(L).PushAny(L, type);    LuaAPI.lua_pushvalue(L, cls_table);    LuaAPI.lua_rawset(L, -3);    LuaAPI.lua_pop(L, 1);&#125;\n\n 以 A.B.C 类为例，将在 Lua 注册表中添加以下表结构，而 Lua 注册表 xlua_csharp_namespace 实际上对应的就是 CS 全局表，所以要在 xLua 中访问 C# 类时才可以直接使用 CS.A.B.C 这样的形式\n Lua 注册表 = &#123;    xlua_csharp_namespace = &#123;  -- 就是 CS 全局表        A = &#123;            B = &#123;                C = cls_table            &#125;        &#125;,    &#125;,&#125;\n多个 Utils.RegisterFunc，与BeginObjectRegister 到EndObjectRegister之间的 RegisterFunc 作用相同，将类的每个静态值对应的包裹方法注册到对应的 Lua 表中。静态变量对应的 get 和 set 包裹方法会被分别注册到 static_getter 表和 static_setter 表（只读的静态变量除外）\n\nUtils.EndClassRegister，结束对类的静态值的注册。与 EndObjectRegister 类似，但它是为 cls_table 的元表 meta_tabl 设置 __index 元方法和 __newindex 元方法\n // Utils.cspublic static void EndClassRegister(Type type, RealStatePtr L, ObjectTranslator translator)&#123;    int top = LuaAPI.lua_gettop(L);    int cls_idx = abs_idx(top, CLS_IDX);    int cls_getter_idx = abs_idx(top, CLS_GETTER_IDX);    int cls_setter_idx = abs_idx(top, CLS_SETTER_IDX);    int cls_meta_idx = abs_idx(top, CLS_META_IDX);    //begin cls index    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, cls_getter_idx);    LuaAPI.lua_pushvalue(L, cls_idx);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);      LuaAPI.gen_cls_indexer(L);    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua indexs function tables      translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaClassIndexs][type] = __index 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta_idx);    //end cls index    //begin cls newindex    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, cls_setter_idx);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_newindexer(L);    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua newindexs function tables    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaClassNewIndexs][type] = __newindex 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta_idx);    //end cls newindex    LuaAPI.lua_pop(L, 4);&#125;\n\n上述 6 个部分的代码量比较大，逻辑也比较复杂，到这里有必要做一个总结\n生成代码会为类的非静态值都生成对应的包裹方法，并将包裹方法以 key = func 的形式注册到不同的表中。userdata元表的 __index 和__newindex负责从这不同的表中找到对应 key 的包裹方法，最终通过调用包裹方法实现对 C# 对象的控制\n-- lua 测试代码local obj = CS.TestXLua()obj.Name = &quot;test&quot;  -- 赋值操作将触发 obj 元表的__newindex，__newindex 在 setter 表中找到 Name 对应的 set 包裹方法_s_set_Name，然后通过调用_s_set_Name 方法设置了 TestXLua 对象的 Name 属性为 &quot;test&quot;\n\n生成代码还会为每个类以命名空间为层次结构生成 cls_table 表。与类的非静态值相同，生成代码也会为类的静态值都生成对应的包裹方法并注册到不同的表中（注意这里有些区别，类的静态方法会被直接注册到 cls_table 表中）。而 cls_table 元表的 __index 和__newindex负责从这不同的表中找到对应 key 的包裹方法，最终通过调用包裹方法实现对 C# 类的控制\n-- lua 测试代码CS.TestXLua.Test2()  -- CS.TestXLua 获取到 TestXLua 类对应的 cls_table，由于 Test2 是静态方法，在 cls_table 中可以直接拿到其对应的包裹方法_m_Test2_xlua_st_，然后通过调用_m_Test2_xlua_st_而间接调用了 TestXLua 类的 Test2 方法\n\n使用反射填充元表  当没有生成代码时，会使用反射进行注册，与生成代码进行注册的逻辑基本相同。通过反射获取到类的各个静态值和非静态值，然后分别注册到不同的表中，以及填充 __index 和__newindex元方法\n// Utils.cspublic static void ReflectionWrap(RealStatePtr L, Type type, bool privateAccessible)&#123;    LuaAPI.lua_checkstack(L, 20);    int top_enter = LuaAPI.lua_gettop(L);    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);    //create obj meta table    LuaAPI.luaL_getmetatable(L, type.FullName);    if (LuaAPI.lua_isnil(L, -1))    &#123;        LuaAPI.lua_pop(L, 1);        LuaAPI.luaL_newmetatable(L, type.FullName);    &#125;    // 为元表添加 xlua_tag 标志    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());    LuaAPI.lua_pushnumber(L, 1);    LuaAPI.lua_rawset(L, -3);  // 元表 [xlua_tag] = 1    int obj_meta = LuaAPI.lua_gettop(L);      LuaAPI.lua_newtable(L);    int cls_meta = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_field = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_getter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_setter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int cls_field = LuaAPI.lua_gettop(L);    //set cls_field to namespace    SetCSTable(L, type, cls_field);    //finish set cls_field to namespace    LuaAPI.lua_newtable(L);    int cls_getter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int cls_setter = LuaAPI.lua_gettop(L);    LuaCSFunction item_getter;    LuaCSFunction item_setter;    makeReflectionWrap(L, type, cls_field, cls_getter, cls_setter, obj_field, obj_getter, obj_setter, obj_meta,        out item_getter, out item_setter, privateAccessible ? (BindingFlags.Public | BindingFlags.NonPublic) : BindingFlags.Public);    // init obj metatable    LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);    LuaAPI.lua_rawset(L, obj_meta);    LuaAPI.xlua_pushasciistring(L, &quot;__tostring&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);    LuaAPI.lua_rawset(L, obj_meta);    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, obj_field);  // 1.upvalue methods = obj_field    LuaAPI.lua_pushvalue(L, obj_getter);  // 2.upvalue getters = obj_getter    translator.PushFixCSFunction(L, item_getter);  // 3.upvalue csindexer = item_getter    translator.PushAny(L, type.BaseType());  // 压入 BaseType，4.upvalue base    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  // 5.upvalue indexfuncs = 注册表 [LuaIndexs]    LuaAPI.lua_pushnil(L);  // 6.upvalue arrayindexer = nil    LuaAPI.gen_obj_indexer(L);  // 生成__index 函数    //store in lua indexs function tables    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);      translator.Push(L, type);  // 压入 type    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaIndexs][type] = __index 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, obj_meta); // set __index  即 obj_meta[&quot;__index&quot;] = 生成的__index 函数    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, obj_setter);    translator.PushFixCSFunction(L, item_setter);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.lua_pushnil(L);    LuaAPI.gen_obj_newindexer(L);    //store in lua newindexs function tables    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaNewIndexs][type] = __newindex 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, obj_meta); // set __newindex                                    //finish init obj metatable    LuaAPI.xlua_pushasciistring(L, &quot;UnderlyingSystemType&quot;);    translator.PushAny(L, type);    LuaAPI.lua_rawset(L, cls_field);  // cls_field[&quot;UnderlyingSystemType&quot;] = type  ， 记录类的基础类型    if (type != null &amp;&amp; type.IsEnum())    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__CastFrom&quot;);        translator.PushFixCSFunction(L, genEnumCastFrom(type));        LuaAPI.lua_rawset(L, cls_field);    &#125;    //init class meta    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, cls_getter);    LuaAPI.lua_pushvalue(L, cls_field);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_indexer(L);    //store in lua indexs function tables    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // 注册表 [LuaClassIndexs][type] = __index 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta); // set __index     LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, cls_setter);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_newindexer(L);    //store in lua newindexs function tables    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // // 注册表 [LuaClassNewIndexs][type] = __newindex 函数    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta); // set __newindex    // ...&#125;\n\n调用 C# 方法时参数的传递  先来解决前面遗留的一个问题，对于类的静态值或是非静态值为什么都需要生成对应的包裹方法？其实包裹方法就是用来处理参数传递问题的。\n为了正确的和 Lua 通讯，C 函数已经定义好了协议。这个协议定义了参数以及返回值传递方法：C 函数通过 Lua 中的栈来接受参数，参数以正序入栈（第一个参数首先入栈）。因此，当函数开始的时候，lua_gettop(L)可以返回函数收到的参数个数。第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 lua_gettop(L) 处。当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），然后返回这些返回值的个数。在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。和 Lua 函数一样，从 Lua 中调用 C 函数可以有很多返回值。也就是说，Lua 这边调用 C 函数时的参数会被自动的压栈，这套机制 Lua 内部已经实现好了。文章开头也提到，C# 可以借助 C/C++ 来与 Lua 进行数据通信，所以 C# 需要通过 C API 获取到 Lua 传递过来的参数，而这个逻辑就被封装在了包裹方法中。以 TestXLua 的Test1方法为例，它需要一个 int 参数。所以它的包裹方法需要通过 C API 获取到一个 int 参数，然后再使用这个参数去调用真正的方法\n[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static int _m_Test1(RealStatePtr L)&#123;    try &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);        &#123;            int _a = LuaAPI.xlua_tointeger(L, 2);  // 获取到 int 参数            gen_to_be_invoked.Test1(_a);  // 调用真正的 Test1 方法            return 0;        &#125;    &#125; catch(System.Exception gen_e) &#123;        return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);    &#125;&#125;\n\n这也解释了为什么需要为类的属性生成对应的 get 和set方法，因为只有将 Lua 的访问或赋值操作转换成函数调用形式时，参数才能利用函数调用机制被自动的压栈，从而传递给 C#\n-- lua 测试代码obj.Name = &quot;test&quot;  -- 赋值操作setter[&quot;Name&quot;](&quot;test&quot;)  -- 函数调用形式\n\n这里再提一下函数重载的问题，因为 C# 是支持重载的，所以会存在多个同名函数，但参数不同的情况。对于这种情况，只能通过同名函数被调用时传递的参数情况来判断到底应该调用哪个函数\n[LuaCallCSharp]public class TestXLua&#123;    // 函数重载 Test1    public void Test1(int a)&#123;    &#125;    // 函数重载 Test1    public void Test1(bool b)&#123;    &#125;&#125;// 为 Test1 生成的包裹方法[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static int _m_Test1(RealStatePtr L)&#123;    try &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);        int gen_param_count = LuaAPI.lua_gettop(L);        if(gen_param_count == 2&amp;&amp; LuaTypes.LUA_TNUMBER == LuaAPI.lua_type(L, 2))  // 根据参数数量与类型判断调用哪个方法        &#123;            int _a = LuaAPI.xlua_tointeger(L, 2);            gen_to_be_invoked.Test1(_a);            return 0;        &#125;        if(gen_param_count == 2&amp;&amp; LuaTypes.LUA_TBOOLEAN == LuaAPI.lua_type(L, 2))  // 根据参数数量与类型判断调用哪个方法        &#123;             bool _b = LuaAPI.lua_toboolean(L, 2);            gen_to_be_invoked.Test1(_b);            return 0;        &#125;    &#125; catch(System.Exception gen_e) &#123;        return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);    &#125;    return LuaAPI.luaL_error(L, &quot;invalid arguments to TestXLua.Test1!&quot;);&#125;\n\nGCC# 和 Lua 都是有自动垃圾回收机制的，并且相互是无感知的。如果传递到 Lua 的 C# 对象被 C# 自动回收掉了，而 Lua 这边仍毫不知情继续使用，则必然会导致无法预知的错误。所以基本原则是传递到 Lua 的 C#对象，C# 不能自动回收，只能 Lua 在确定不再使用后通知 C# 进行回收  为了保证 C# 不会自动回收对象，所有传递给 Lua 的对象都会被 objects 保持引用。真实传递给 Lua 的对象索引就是对象在 objects 中的索引 Lua 这边为对象索引建立的userdata 会被保存在缓存表中，而缓存表的引用模式被设置为弱引用\n// ObjectTranslator.csLuaAPI.lua_newtable(L);  // 创建缓存表LuaAPI.lua_newtable(L);  // 创建元表LuaAPI.xlua_pushasciistring(L, &quot;__mode&quot;);LuaAPI.xlua_pushasciistring(L, &quot;v&quot;);LuaAPI.lua_rawset(L, -3);  // 元表 [__mode] = v，表示这张表的所有值皆为弱引用LuaAPI.lua_setmetatable(L, -2);  // 为缓存表设置元表cacheRef = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n\n当 Lua 这边不再引用这个 userdata 时，userdata会被从缓存表中移除，Lua GC 时会回收这个 userdata，回收之前又会调用 userdata 元表的 __gc 方法，以此来通知 C#，”我 Lua 这边不再使用这个对象了，你该回收可以回收了”。在 BeginObjectRegister方法内部，会为 userdata 的元表添加 __gc 方法\n// Utils.cs BeginObjectRegister 方法if ((type == null || !translator.HasCustomOp(type)) &amp;&amp; type != typeof(decimal))&#123;    LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);    LuaAPI.lua_rawset(L, -3);  // 为元表设置__gc 方法&#125;\n\ntranslator.metaFunctions.GcMeta实际上就是 StaticLuaCallbacks 的LuaGC方法\n// StaticLuaCallbacks.cs[MonoPInvokeCallback(typeof(LuaCSFunction))]public static int LuaGC(RealStatePtr L)&#123;    try    &#123;        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);        if (udata != -1)        &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            if (translator != null )            &#123;                translator.collectObject(udata);            &#125;        &#125;        return 0;    &#125;    catch (Exception e)    &#123;        return LuaAPI.luaL_error(L, &quot;c# exception in LuaGC:&quot; + e);    &#125;&#125;\n\nLuaGC方法又会调用 collectObject 方法。在 collectObject 方法内部会将对象从 objects 移除，从而使对象不再被固定引用，能够被 C# GC 正常回收\n// ObjectTranslator.csinternal void collectObject(int obj_index_to_collect)&#123;    object o;        if (objects.TryGetValue(obj_index_to_collect, out o))    &#123;        objects.Remove(obj_index_to_collect);                if (o != null)        &#123;            int obj_index;            //lua gc 是先把 weak table 移除后再调用__gc，这期间同一个对象可能再次 push 到 lua，关联到新的 index            bool is_enum = o.GetType().IsEnum();            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))                &amp;&amp; obj_index == obj_index_to_collect)            &#123;                if (is_enum)                &#123;                    enumMap.Remove(o);                &#125;                else                &#123;                    reverseMap.Remove(o);                &#125;            &#125;        &#125;    &#125;&#125;\n","categories":["游戏开发"],"tags":["C#","xLua"]},{"title":"C++ 20 新特性","url":"/2024/07/11/2ed7adeb8fce/","content":"\n    \n\n\n\n\n语言特性  三路比较运算符  三路比较运算符表达式的形式为：左操作数 &lt;=&gt; 右操作数，表达式返回一个对象，使得\n\n若左操作数 &lt; 右操作数则(a &lt;=&gt; b) &lt; 0\n若左操作数 &gt; 右操作数则(a &lt;=&gt; b) &gt; 0\n而若左操作数和右操作数相等 / 等价则(a &lt;=&gt; b) == 0\n\nint main() &#123;    double foo = -0.0;    double bar = 0.0;     auto res = foo &lt;=&gt; bar;     if (res &lt; 0)        std::cout &lt;&lt; &quot;-0 小于 0&quot;;    else if (res &gt; 0)        std::cout &lt;&lt; &quot;-0 大于 0&quot;;    else // (res == 0)        std::cout &lt;&lt; &quot;-0 与 0 相等 &quot;;&#125;\n\n范围 for 中的初始化语句和初始化器  继 C++ 17 中在 if 和switch语句中添加初始化器后，C++ 20 在范围 for 中也实现了这个功能\nfor (auto n = v.size(); auto i : v) // 初始化语句（C++20）    std::cout &lt;&lt; --n + i &lt;&lt; &#x27; &#x27;;\n\nconstevalconsteval指定函数是立即函数（immediate function），即每次调用该函数必须产生编译时常量。如果不能在编译期间执行，则编译失败\nconsteval int sqr(int n) &#123;  return n * n;&#125;constexpr int r = sqr(100);  // OK int x = 100;int r2 = sqr(x);  // 错误：调用不产生常量 consteval int sqrsqr(int n) &#123;  return sqr(sqr(n)); // 在此点非常量表达式，但是 OK&#125; constexpr int dblsqr(int n) &#123;  return 2 * sqr(n); // 错误：外围函数并非 consteval 且 sqr(n) 不是常量&#125;\n\nconstintconstinit断言变量拥有静态初始化，即零初始化与常量初始化，否则程序非良构\nconst char *g() &#123; return &quot;dynamic initialization&quot;; &#125;constexpr const char *f(bool p) &#123; return p ? &quot;constant initializer&quot; : g(); &#125; constinit const char *c = f(true); // OK// constinit const char *d = f(false); // 错误\n\n概念（concepts）概念（concepts）就是一种编译时谓词，指出一个或多个类型应如何使用，其能用于进行模板实参的编译时校验，以及基于类型属性的函数派发。\n例如在老版本的 C++，如果想要定义一个只针对某个类型的函数模板，就只能通过类型萃取机制如 enable_if_t 写一些又臭又长的代码。例如想声明一个只针对整数的函数模板\ntemplate &lt;typename T&gt;auto mod(std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt; d)&#123;    return d % 10;&#125;\n\n如果约束条件简单还行，但是如果条件复杂，则代码就会又臭又长，且难以进行复用。而在 C++ 20 中引入了 concepts，此时我们就可以用 concepts 来指定函数类型，例如：\ntemplate &lt;class T&gt;concept integral = std::is_integral_v&lt;T&gt;; template &lt;integral T&gt;auto mod(T d)&#123;    return d % 10;&#125;\n\n约束  约束是逻辑操作和操作数的序列，它了指定对模板实参的要求。它们可以在 requires 表达式中出现，也可以直接作为概念的主体。例如这里使用 requires 约束表达式写一个针对 utf-8 的 string 的约束类型u8string_t\ntemplate &lt;typename T&gt;concept u8string_t = requires (T t)&#123;    t += u8&quot;&quot;;&#125;;\n\n接着以这个约束类型声明一个模板函数 print，此时只能能够满足u8string_t 约束的类型才能够匹配当前模板\ntemplate &lt;u8string_t T&gt;auto print(T t)&#123;    cout &lt;&lt; t &lt;&lt; endl;&#125;\n\n此时以不同类型的 string 来尝试调用，此时只有 u8string 调用成功\nint main()&#123;    string str;    u8string str_u8;    u16string str_u16;    u32string str_u32;    print(str);     // 调用失败    print(str_u8);  // 调用成功    print(str_u16); // 调用失败    print(str_u32); // 调用失败&#125;\n\n协程  协程是能暂停执行以在之后恢复的函数。协程是无栈的：它们通过返回到调用方暂停执行，并且从栈分离存储恢复执行需要的数据。这样就可以编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O），还支持对惰性计算的无限序列上的算法及其他用途\n如果函数的定义进行了下列操作之一，那么它是协程：\n\nco_await 暂停执行，直到恢复\n\ntask&lt;&gt; tcp_echo_server() &#123;  char data[1024];  while (true) &#123;    std::size_t n = co_await socket.async_read_some(buffer(data));    co_await async_write(socket, buffer(data, n));  &#125;&#125;\n\n\nco_yield 暂停执行并返回一个值（协程无法return）\n\ngenerator&lt;int&gt; iota(int n = 0) &#123;  while(true)    co_yield n++;&#125;\n\n\nco_return完成执行并返回一个值\n\nlazy&lt;int&gt; f() &#123;  co_return 7;&#125;\n\n\n注意：协程不能使用变长实参，普通的 return 语句，或占位符返回类型（auto或 Concept）。constexpr函数、构造函数、析构函数及 main 函数不能是协程\n\n模块C++ 20 中正式引入了模块的概念，模块是一个用于在翻译单元间分享声明和定义的语言特性。它们可以在某些地方替代使用头文件。其主要优点如下：\n\n没有头文件\n声明实现仍然可分离，但非必要\n可以显式指定导出哪些类或函数\n不需要头文件重复引入宏（include guards）\n模块之间名称可以相同，并且不会冲突\n模块只处理一次，编译更快（头文件每次引入都需要处理，需要通过 pragma once 约束）\n预处理宏只在模块内有效\n模块的引入与引入顺序无关\n\n创建模块// helloworld.cppexport module helloworld;  // 模块声明import &lt;iostream&gt;;         // 导入声明 export void hello() &#123;      // 导出声明    std::cout &lt;&lt; &quot;Hello world!\\n&quot;;&#125;\n\n导入模块// main.cppimport helloworld;  // 导入声明 int main() &#123;    hello();&#125;\n\n库特性 format 文本格式化库提供 printf 函数族的安全且可扩展的替用品。有意使之补充既存的 C++ I/O 流库并复用其基础设施，例如对用户定义类型重载的流插入运算符\nstd::string message = std::format(&quot;The answer is &#123;&#125;.&quot;, 42);osyncstreamtemplate&lt;    class CharT,    class Traits = std::char_traits&lt;CharT&gt;,    class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_osyncstream: public std::basic_ostream&lt;CharT, Traits&gt;\n\n类模板 std::basic_osyncstream 是std::basic_syncbuf的便利包装。它提供机制以同步写入同一流的线程（主要用于解决 std::cout 线程不安全问题）\n用法如下：\n&#123;    std::osyncstream sync_out(std::cout); // std::cout 的同步包装    sync_out &lt;&lt; &quot;Hello, &quot;;    sync_out &lt;&lt; &quot;World!&quot;;    sync_out &lt;&lt; std::endl; // 注意有冲入，但仍未进行    sync_out &lt;&lt; &quot;and more!\\n&quot;;&#125; // 转移字符并冲入 std::cout\n\nspanspan是对象的连续序列上的无所有权视图。其所描述的对象能指代对象的相接序列，序列的首元素在零位置。span能拥有静态长度，该情况下序列中的元素数已知并编码于类型中，或拥有动态长度\n#include &lt;algorithm&gt;#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;span&gt; template&lt;class T, std::size_t N&gt; [[nodiscard]]constexpr auto slide(std::span&lt;T,N&gt; s, std::size_t offset, std::size_t width) &#123;    return s.subspan(offset, offset + width &lt;= s.size() ? width : 0U);&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool starts_with(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; prefix) &#123;    return data.size() &gt;= prefix.size()         &amp;&amp; std::equal(prefix.begin(), prefix.end(), data.begin());&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool ends_with(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; suffix) &#123;    return data.size() &gt;= suffix.size()         &amp;&amp; std::equal(data.end() - suffix.size(), data.end(),                       suffix.end() - suffix.size());&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool contains(std::span&lt;T,N&gt; span, std::span&lt;T,M&gt; sub) &#123;    return std::search(span.begin(), span.end(), sub.begin(), sub.end()) != span.end();//  return std::ranges::search(span, sub).begin() != span.end();&#125; void print(const auto&amp; seq) &#123;    for (const auto&amp; elem : seq) std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;;    std::cout &lt;&lt; &#x27;\\n&#x27;;&#125; int main()&#123;    constexpr int a[] &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8 &#125;;    constexpr int b[] &#123; 8, 7, 6 &#125;;     for (std::size_t offset&#123;&#125;; ; ++offset) &#123;        constexpr std::size_t width&#123;6&#125;;        auto s = slide(std::span&#123;a&#125;, offset, width);        if (s.empty())            break;        print(s);    &#125;     static_assert(starts_with(std::span&#123;a&#125;, std::span&#123;a,4&#125;)        &amp;&amp; starts_with(std::span&#123;a+1, 4&#125;, std::span&#123;a+1,3&#125;)        &amp;&amp; !starts_with(std::span&#123;a&#125;, std::span&#123;b&#125;)        &amp;&amp; !starts_with(std::span&#123;a,8&#125;, std::span&#123;a+1,3&#125;)        &amp;&amp; ends_with(std::span&#123;a&#125;, std::span&#123;a+6,3&#125;)        &amp;&amp; !ends_with(std::span&#123;a&#125;, std::span&#123;a+6,2&#125;)        &amp;&amp; contains(std::span&#123;a&#125;, std::span&#123;a+1,4&#125;)        &amp;&amp; !contains(std::span&#123;a,8&#125;, std::span&#123;a,9&#125;));&#125;\n\nendianendian主要用于判断当前机器是大端还是小端（之前只能通过整型截断或者 union 判断，较为麻烦）\n\n若所有标量类型均为小端，则 std::endian::native 等于std::endian::little\n若所有标量类型均为大端，则 std::endian::native 等于std::endian::big\n若所有标量类型拥有等于 1 的 sizeof，则端序无影响，且std::endian::little，std::endian::big 及std::endian::native三个值相同\n若平台使用混合端序，则 std::endian::native 既不等于 std::endian::big 亦不等于std::endian::little\n\n#include &lt;bit&gt;#include &lt;iostream&gt; int main() &#123;     if constexpr (std::endian::native == std::endian::big)        std::cout &lt;&lt; &quot;big-endian\\n&quot;;    else if constexpr (std::endian::native == std::endian::little)        std::cout &lt;&lt; &quot;little-endian\\n&quot;;    else std::cout &lt;&lt; &quot;mixed-endian\\n&quot;;&#125;\n\njthreadjthread即是通过 RAII 机制封装的 thread，其会在析构时自动调用join 防止线程 crash。同时其也是可中断的，可以搭配这些中断线程执行的相关类使用：\n\nstop_token：查询线程是否中断\nstop_source：请求线程停止运行\nstop_callback：stop_token执行时，可以触发的回调函数\n\nsemaphore信号量是一个轻量级的同步原语，可用来实现任何其他同步概念如 mutex、shared_mutex、latches、barriers 等\n根据 LeastMaxValue 不同，主要分为两种：\n\ncounting_semaphore（多元信号量）：counting_semaphore允许同一资源有多于一个同时访问，至少允许 LeastMaxValue 个同时的访问者\nbinary_semaphore（二元信号量）：是 counting_semaphore 的特化的别名，其 LeastMaxValue 为 1 。实现可能将 binary_semaphore 实现得比 counting_semaphore 的默认实现更高效\n\n// 全局二元信号量实例// 设置对象计数为零// 对象在未被发信状态std::binary_semaphore smphSignal(0); void ThreadProc()&#123;    // 通过尝试减少信号量的计数等待来自主程序的信号    smphSignal.acquire();     // 此调用阻塞直至信号量的计数被从主程序增加     std::cout &lt;&lt; &quot;[thread] Got the signal&quot; &lt;&lt; std::endl; // 回应消息     // 等待 3 秒以模仿某种线程正在进行的工作    std::this_thread::sleep_for(3s);     std::cout &lt;&lt; &quot;[thread] Send the signal\\n&quot;; // 消息     // 对主程序回复发信    smphSignal.release();&#125; int main()&#123;    // 创建某个背景工作线程，它将长期存在    std::jthread thrWorker(ThreadProc);     std::cout &lt;&lt; &quot;[main] Send the signal\\n&quot;; // 消息     // 通过增加信号量的计数对工作线程发信以开始工作    smphSignal.release();     // release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟：    std::this_thread::sleep_for(50ms);     // 通过试图减少信号量的计数等待直至工作线程完成工作    smphSignal.acquire();     std::cout &lt;&lt; &quot;[main] Got the signal\\n&quot;; // 回应消息&#125;\n\nlatchlatch是 std::ptrdiff_t 类型的向下计数器，它能用于同步线程。在创建时初始化计数器的值。其主要有以下特点：\n\n线程可能在 latch 上阻塞直至计数器减少到零。没有可能增加或重置计数器，这使得 latch 为单次使用的屏障\n同时调用 latch 的成员函数，除了析构函数，不引入数据竞争\n不同于 std::barrier，参与线程能减少std::latch 多于一次\n\nbarrier类模板 barrier 提供允许至多为期待数量的线程阻塞直至期待数量的线程到达该屏障。不同于 latch，屏障可重用：一旦到达的线程从屏障阶段的同步点除阻，则可重用同一屏障。屏障对象的生存期由屏障阶段的序列组成。每个阶段定义一个阶段同步点。在阶段中到达屏障的线程能通过调用wait 在阶段同步点上阻塞，而且将保持阻塞直至运行阶段完成步骤\n屏障阶段由以下步骤组成：\n\n每次调用 arrive 或arrive_and_drop减少期待计数\n期待计数抵达零时，运行阶段完成步骤。完成步骤调用完成函数对象，并除阻所有在阶段同步点上阻塞的线程。完成步骤的结束强先发生于所有从完成步骤所除阻的调用的返回\n对于特化 std::barrier&lt;&gt;（使用默认模板实参），完成步骤作为对arrive 或arrive_and_drop的导致期待计数抵达零的调用的一部分运行\n对于其他特化，完成步骤在该阶段期间到达屏障的线程之一上运行。而若在完成步骤中调用屏障对象的 wait 以外的成员函数，则行为未定义\n\n\n完成步骤结束时，重置期待计数为构造中指定的值，可能为 arrive_and_drop 调用所调整，并开始下一阶段\n\n同时调用 barrier 的成员函数，除了析构函数，不引入数据竞争\n位运算库 bit 库封装了一些常用的位操作。包括：\nbit_cast：将一个类型的对象表示重解释为另一类型的对象表示byteswap：反转给定整数值中的字节has_single_bit：检查一个数是否为二的整数次幂bit_ceil：寻找不小于给定值的最小的二的整数次幂bit_floor：寻找不大于给定值的最大的二的整数次幂bit_width：寻找表示给定值所需的最小位数rotl：计算逐位左旋转的结果rotr：计算逐位右旋转的结果countl_zero：从最高位起计量连续的 0 位的数量countl_one：从最高位起计量连续的 1 位的数量countr_zero：从最低位起计量连续的 0 位的数量countr_one：从最低位起计量连续的 1 位的数量popcount：计量无符号整数中为 1 的位的数量\nnamespace std &#123;  // bit_­cast  template&lt;class To, class From&gt;    constexpr To bit_cast(const From&amp; from) noexcept;   // 位交换  template &lt;class T&gt;  constexpr T byteswap (T value) noexcept;   // 2 的整数次幂  template&lt;class T&gt;    constexpr bool has_single_bit(T x) noexcept;  template&lt;class T&gt;    constexpr T bit_ceil(T x);  template&lt;class T&gt;    constexpr T bit_floor(T x) noexcept;  template&lt;class T&gt;    constexpr T bit_width(T x) noexcept;   // 旋转  template&lt;class T&gt;    [[nodiscard]] constexpr T rotl(T x, int s) noexcept;  template&lt;class T&gt;    [[nodiscard]] constexpr T rotr(T x, int s) noexcept;   // 计数  template&lt;class T&gt;    constexpr int countl_zero(T x) noexcept;  template&lt;class T&gt;    constexpr int countl_one(T x) noexcept;  template&lt;class T&gt;    constexpr int countr_zero(T x) noexcept;  template&lt;class T&gt;    constexpr int countr_one(T x) noexcept;  template&lt;class T&gt;    constexpr int popcount(T x) noexcept;   // 端序  enum class endian &#123;    little = /* 见描述 */,    big    = /* 见描述 */,    native = /* 见描述 */  &#125;;&#125;\n\nrangesranges提供处理元素范围的组件，包括各种视图适配器。其最大的作用就是让我们可以像组装函数一样组装算法，使代码更加高效、便利、可读。提供命名空间别名 std::views，作为std::ranges::views 的缩写\n#include &lt;ranges&gt;#include &lt;iostream&gt; int main()&#123;    auto const ints = &#123;0,1,2,3,4,5&#125;;    auto even = [](int i) &#123; return 0 == i % 2; &#125;;    auto square = [](int i) &#123; return i * i; &#125;;     // 组合视图的“管道”语法：    for (int i : ints | std::views::filter(even) | std::views::transform(square)) &#123;        std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;    &#125;     std::cout &lt;&lt; &#x27;\\n&#x27;;     // 传统的“函数式”组合语法：    for (int i : std::views::transform(std::views::filter(ints, even), square)) &#123;        std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;    &#125;&#125;\n","categories":["C++"],"tags":["C++","C++ 20","Modern C++"]},{"title":"Lua 问题","url":"/2024/06/19/92509e685a8f/","content":"int64乘法问题local a = int64.new(1000)local b = 0.01print(a + b) -- 1000print(a * b) -- 0\n\n原因：\n\nint64乘法会触发元方法__mul\n\nlua_pushstring(L, &quot;__mul&quot;),lua_pushcfunction(L, _int64mul);lua_rawset(L, -3); // 指向栈顶static int _int64mul(lua_State* L)&#123;    int64_t lhs = toluas_checkint64(L, 1);        int64_t rhs = toluas_checkint64(L, 2);    toluas_pushint64(L, lhs * rhs);    return 1;    &#125;\n\n\n触发元方法后调用 toluas_checkint64 检查栈中的数值类型并做类型转换，当 int64 类型和 number 类型相乘时，会将其转换成整型——(int64_t)0.01，所以相乘的结果是0\n\nstatic int64_t toluas_checkint64(lua_State* L, int pos)&#123;    int64_t n = 0;    int type = lua_type(L, pos);        switch(type)    &#123;        case LUA_TNUMBER:            n = (int64_t)lua_tonumber(L, pos);            break;        case LUA_TSTRING:            n = _long(L, pos);            break;        case LUA_TUSERDATA:            if (_isint64(L, pos))            &#123;                n = *(int64_t*)lua_touserdata(L, pos);            &#125;            break;        default:            return luaL_typerror(L, pos, &quot;long&quot;);    &#125;        return n;&#125;\n\n正确做法：\nlocal a = int64.new(1000)local b = 0.01print(a:toDouble() + b) -- 1000.01print(a:toDouble() * b) -- 10\n\nstatic int _int64todouble(lua_State* L)&#123;    if (!toluas_isint64(L, 1))    &#123;        return luaL_typerror(L, 1, &quot;long&quot;);    &#125;    int64_t n = toluas_toint64(L, 1);    lua_pushnumber(L, (double)n);    return 1;&#125;\n","categories":["Lua"],"tags":["Lua","bug"]},{"title":"OpenGL with Xmake","url":"/2024/06/20/355478969c9d/","content":"\n    \n\n\n\n\n目录结构|-- dependence    |-- glew-2.1.0    |-- glfw-3.4.bin.WIN32    |-- glfw-3.4.bin.WIN64        |-- include        |-- ...        |-- lib-static-ucrt            |-- glfw3.dll            |-- glfw3dll.dll|-- src    |-- HelloOpenGl.cpp|-- xmake.lua\n\nxmake 配置set_project(&quot;OpenGL Tutorial&quot;)add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)target(&quot;HelloOpenGL&quot;)    set_kind(&quot;binary&quot;)    add_files(&quot;src/*.cpp&quot;)    add_includedirs(&quot;/dependence/glfw-3.4.bin.WIN64/include&quot;) -- include 文件    add_includedirs(&quot;/dependence/glew-2.1.0/include&quot;)    add_linkdirs(&quot;/dependence/glfw-3.4.bin.WIN64/lib-static-ucrt&quot;) -- gcc 编译的静态链接库目录    add_linkdirs(&quot;/dependence/glew-2.1.0/lib/Release/Win32&quot;)    add_linkdirs(&quot;/dependence/glew-2.1.0/bin/Release/x64&quot;)    add_links(&quot;glfw3dll&quot;, &quot;glew32&quot;) -- 链接 glfw 和 glew    add_syslinks(&quot;opengl32&quot;) -- 链接系统库\n\nNotes\n顶点着色器\n每个顶点运行一次\n确定位置\n\n\n片段 / 像素着色器\n填充三角形的每个像素计算一次\n\n\n为什么索引缓冲是 unsigned int 无符号的\n错误处理\nglGetError\n宏定义\n\n\nuniform 变量\nVAO vertex array object\n当空间中有多个对象、网格、顶点缓冲区等，每个都要进行绑定着色器、绑定顶点缓冲区 、 设置顶点布局 、 绑定索引缓冲区、调用 DrawCall 进行绘制\n绑定顶点缓冲区之后还要声明顶点缓冲区的布局，不同的顶点缓冲区有不同的布局\n实际上都是和 VAO 有关系\nVAO 它将所有顶点绘制过程中的这些设置和绑定过程集中存储在一起\nVAO 是否生效由配置文件类型决定的 The compalibility profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all\n什么时候使用 VAO\n如果使用核心配置，就必须使用自定义的 VAO\n如果只使用兼容性配置，有一个默认的 VAO\n\n\n\n\n着色器处理的步骤\n传入文件或者字符串，可以编译为着色器\n绑定和解绑着色器\n可以设置着色器中的不同的uniform\n\n\n渲染器类\n调用 Draw Call 时需要顶点数组、索引缓冲区、着色器\n解绑不是必要的，解绑只会浪费性能\n正常会用材质替换着色器\n\n\n如何通过 OpenGL 将硬盘中的 png 图片显示到屏幕上（png 并不是引擎直接使用的格式，大多数引擎都有自己的纹理格式）\n将图像加载到内存中——stb_image\n获取像素的数组，然后传到显存中——OpenGL\n通过着色器来读取纹理，并计算出真正的像素值——像素 / 片段着色器（绑定纹理）\n在 OpenGL 中，用 slots 来绑定纹理，可以一次性绑定多个纹理\n在 Windows 上有 32 个 slots\n在移动设备，Android 或 IOS 上可能会有 8 个 slots\n\n\nOpenGL 加载纹理是从左下角开始，即左下角的坐标是(0, 0)，正常加载的图片是从左上角开始遍历，所以加载图片后需要垂直翻转\n纹理坐标\n指定每个顶点对应的纹理是什么，根据顶点对应的  纹理坐标  进行采样\n片段着色器会根据要渲染的像素的位置，进行插值计算具体的颜色值\n\n\n\n\n混合\nBlending determies how we combine our output color with what is already in our target buffer\nOutput: the color we output from our fragment shader 从片段着色器中输出的颜色 SRC\nTarget buffer: the buffer our fragment shader is drawing to 已经存在的缓冲区上的颜色 DEST\n\n\n如何控制混合\nglEnable、glDisable\nglBlendFunc(src, dest)\nsrc: how the src RGBA factor is computed (default is GL_ONE) 默认是 1，每个通道都是单独计算的\ndest: how the dest RGBA factor is computed (default is GL_ZERO) 默认是 0，也就是说 src 会覆盖到 dest 上面\n\n\nglBlendEquation(mode)\nmode: how we combine the src and dest colors\nDefault value is GL_FUNC_ADD\n\n\n\n\n\n\n投影矩阵\n投影就是在多维空间中确定坐标系\n将场景中三维空间中的坐标转换到 NDC（Normalized Device Coordinates），即标准空间\n在窗口中渲染的内容的坐标范围必须从左到右在 [-1, 1] 之间，从上到下在 [-1, 1] 之间\n投影矩阵的作用就是决定坐标空间是什么样的\n无论是正交（Orthographic）处理后的顶点，还是透视（Perspective）处理后的顶点，最终都会映射到标准空间中\n\n\n\n\n视图矩阵 相机的变换（位移和方向）\n模型矩阵 对象的变换（位移、旋转、缩放，TRS）\nImGui\n测试框架\n声明周期\n封装 ImGui\n\n\n\n\n批渲染\n在一次 DrawCall 中渲染多个对象\n\n\n\n\n    \n\n\n纹理的批渲染\n颜色是 uniform 变量可以放到顶点缓冲中，但是不能把纹理放到顶点缓冲区中\n但是可以像颜色一样提供纹理索引，这个索引在渲染 Quad 时，从顶点着色器传到片段着色器\n片段着色器用作纹理数组和采样数组这些 uniform 的索引\n\nC++ 代码中定义\n// (x, y, x) 表示坐标// (r, g, b, a) 表示颜色// (u, v) 表示纹理// texture_index 就是上面说的纹理索引，对应纹理槽位float vertices[] = &#123;  x, y, z, r, g, b, a, u, v, texture_index_1,  ...  x, y, z, r, g, b, a, u, v, texture_index_2,&#125;\n\nShader 中的定义\n// vertex.shaderlayout (location = 0) in vec3 position;layout (location = 1) in vec4 color;layout (location = 2) in vec2 texCoord;layout (location = 3) in float texIndex;...out vec4 _color;out vec2 _texCoord;out float _texIndex;// fragment.shaderlayout (location = 0) out vec4 color;uniform sampler2D textureSamplers[2];in vec4 _color;in vec2 _texCoord;in float _texIndex;void main()&#123;  int index = int(_texIndex);  color = texture(textureSamplers[index], _texCoord); // 根据索引进行采样&#125;\n\n将纹理和槽绑定，利用 uniform 传递数据到 shader\nglBindTextureUnit(0, texture1);glBindTextureUnit(1, texture2);auto loc = glGetUniformLocation(shader-&gt;GetRenderId(), &quot;textureSamplers&quot;);int samplers[2] = &#123; 0, 1 &#125;;glUniform1iv(loc, 2, samplers);\n\n动态顶点缓冲  预先分配好最大的顶点缓冲区的大小（比如 1KB）\n\n将顶点数组用结构化的方式表示\n\nstruct Vertex&#123;  float Position[3];  float Color[4];  float TexCoords[2];  float TexId;&#125;\n\n\n绑定缓冲数据时使用 GL_DYNAMIC_DRAW 类型\n绑定顶点属性时 offset 使用内置函数 offsetof 来确定每种数据类型的偏移量\n\nglBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * 1000, nullptr, GL_DYNAMIC_DRAW);...glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Position));glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Color));glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexCoords));glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexId));\n\n\n动态绑定顶点缓冲\n\n// 一个 quad 需要四个点std::array&lt;Vertex, 4&gt; CreateQuad(float x, float y, float texId)&#123;  Vertex v0;  ...  Vertex v1;  ...  Vertex v2;  ...  Vertex v3;  ...  return &#123; v0, v1, v2, v3 &#125;;&#125;auto q0 = CreateQuad(-1.5f, -0.5f, 0.0f);auto q1 = CreateQuad(0.5f, -0.5f, 1.0f);// 通过内存拷贝的方式直接将 `std::array` 中的内容拷贝到一维数组中Vertex vertices[8];memcpy(vertices, q0.data(), q0.size() * sizeof(Vertex));memcpy(vertices + q0.size(), q1.data(), q0.size() * sizeof(Vertex));...glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);\n\n动态索引缓冲\n首先确定绘制的最大的 Quad 的数量maxQuadCount\n由 maxQuadCount 确定顶点数量（maxQuadCount * 4）和索引数量（maxQuadCount * 6）\n\nuint32_t indices[maxQuadCount * 6];uint32_t offset = 0;for (size_t i = 0; i &lt; maxQuadCount * 6; i += 6)&#123;  indices[i + 0] = 0 + offset;  indices[i + 1] = 1 + offset;  indices[i + 2] = 2 + offset;  indices[i + 3] = 2 + offset;  indices[i + 4] = 3 + offset;  indices[i + 5] = 0 + offset;  offset += 4;&#125;\n\n\n更改 CreateQuad 函数，传入预先定义好大小的顶点数据结构数组，如std::array&lt;Vertex, 1000&gt;，同时增加顶点索引数量\n\nVertex* CreateQuad(Vertex* target, float x, float y, float textureId)&#123;  target-&gt;Position = &#123; x, y, 0.0f &#125;;  target-&gt;Color = &#123; 0.18f, 0.6f, 0.96f, 1.0f &#125;;  target-&gt;TexCoors = &#123; 0.0f, 0.0f &#125;;  target-&gt;TexId = textureId;  target++;  ...  return target;&#125;size_t indexCount = 0std::array&lt;Vertex, 1000&gt; vertices;Vertex* buffer = vertices.data();for (int y = 0; y &lt; 5; y++)&#123;  for (int x = 0; x &lt; 5; x++)  &#123;    buffer = CreateQuad(buffer, x, y, (x + y) % 2);    indexCount += 6;  &#125;&#125;glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size() * sizeof(Vertex), vertices.data());...glDrawElements(GL_TRIANGLE, indexCount, GL_UNSIGNED_INT, nullptr);\n\nAPIs\nglGenBuffers: Generate buffer object names 生成缓冲区的标识\n\nn: Specifies the number of buffer object names to be generated 需要缓冲区标识的数量\nbuffers: Specifies an array in which the generated buffer object names are stored 用于存放缓冲区标识\n\n\nglBindBuffer： Bind a named buffer object 绑定缓冲区标识的对象类型\nglBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with target set to one of the accepted symbolic constants and buffer set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name buffer exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.glBindBuffer函数将缓冲对象绑定到 OpenGL 上下文环境中，调用 glBindBuffer 函数，需要将 target 设置为一个符号常量（指定缓冲对象的类型），将 buffer 设置为缓冲对象的标识符，这样就将缓冲对象和标识符进行绑定了。如果标识符没有关联缓冲对象，就创建一个缓冲对象。当缓冲对象已经确定好对象类型，之前绑定的类型就会失效\nBuffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.因为缓冲区对象标识符是无符号类型的整数（非负整数），如果标识符是 0 意味着缓冲区对象类型没有绑定任何缓冲区对象，这样可以将 buffer 参数设置为 0 表示从缓冲区对象类型和缓冲区解绑，同时也会清除原来缓冲区中的内容。\n\ntarget: Specifies the target to which the buffer object is bound\nGL_ARRAY_BUFFER: Vertex attributes\nGL_ATOMIC_COUNTER_BUFFER: Atomic counter storage\nGL_COPY_READ_BUFFER: Buffer copy source\nGL_COPY_WRITE_BUFFER: Buffer copy destination\nGL_DISPATCH_INDIRECT_BUFFER: Indirect compute dispatch commands\nGL_DRAW_INDIRECT_BUFFER: Indirect command arguments\nGL_ELEMENT_ARRAY_BUFFER: Vertex array indices\nGL_PIXEL_PACK_BUFFER: Pixel read target\nGL_PIXEL_UNPACK_BUFFER: Texture data source\nGL_QUERY_BUFFER: Query result buffer\nGL_SHADER_STORAGE_BUFFER: Read-write storage for shaders\nGL_TEXTURE_BUFFER: Texture data buffer\nGL_TRANSFORM_FEEDBACK_BUFFER: Transform feedback buffer\nGL_UNIFORM_BUFFER: Uniform block storage\n\n\nbuffer: Specifies the name of a buffer object\n\n\nglBufferData: 用来把用户定义的数据复制到当前绑定缓冲的函数\n\nGLenum target: 目标缓冲的类型\nGLsizeiptr size: 传输数据的大小（以字节为单位），一般用 sizeof() 函数\nconst void * data: 实际数据\nGLenum usage: 显卡如何管理给定的数据\nGL_STATIC_DRAW: 数据不会或几乎不会改变\nGL_DYNAMIC_DRAW: 数据会被改变很多\nGL_STREAM_DRAW: 数据每次绘制时都会改变\n\n\n\n\nglVertexAttribPointer: 将 CPU 的数组缓冲区绑定到 GPU 的顶点缓冲区\n\nGLuint index: Specifies the index of the generic vertex attribute to be modified 顶点属性的位置\nGLint size: Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4 顶点每个属性的元素数量，一定是 1，2，3，4 中的一个数。当 type 为GL_BGRA时，初始值是 4\nGLenum type: Specifies the data type of each component in the array. 顶点每个属性的元素的数据类型枚举\nGLboolean normalized: Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed 如果设置为 GL_TRUE，所有数据都会被映射到[0, 1] 之间（对于有符号类型的数据是 [-1, 1] 之间）\nGLsizei stride: Specifies the byte offset between consecutive generic vertex attributes. If stride​ is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0 在顶点若干属性中两个相同属性之间的步长，如果步长是 0\nconst void * pointer: Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0. 每个顶点属性相对于起始属性的偏移量的指针的位置\n\n\nglGetError: 返回错误标志的值。每个可检测的错误都分配有数字代码和符号名称。发生错误时，错误标志将设置为相应的错误代码值。在调用 glGetError（返回错误代码）之前，不会记录其他错误，并将标志重置为GL_NO_ERROR。如果对glGetError 的调用返回 GL_NO_ERROR，则自上次调用glGetError 或自 GL 初始化以来，没有可检测到的错误\n\nglGenTextures: generate texture names\nglGenTextures returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenTextures 能够保证在调用 glGenTextures 前返回的标识符是没有被用过的\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound 生成的纹理是没有维度的，假定纹理的维度是第一次绑定的维度（不是很理解）\nTexture names returned by a call to glGenTextures are not returned by subsequent calls, unless they are first deleted with glDeleteTextures 连续调用 glGenTextures 不会返回表示符了，除非先调用 glDeleteTextures 删除纹理\n\nglBindTexture： 将一个纹理标识符绑定到一个纹理对象上Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. 对于当前的 GL 渲染上下文中的共享对象空间，纹理名称以及它们对应的纹理内容是局部的；只有在显式开启上下文之间的共享，两个渲染上下文才可以共享纹理名称\n\nglTexParameteri\n\nglTexImage2D\n\nglActiveTexture\n\nglClear\n\n不调用 glClear 的话，下一帧的内容会和上一帧的内容重叠在一起，上一帧的物体还在原来的地方\nglClearColor\n指定刷新颜色缓冲区时所用的颜色\nglClearColor只是设置缓冲区颜色，并不不会清除缓冲区的颜色，需要在设置好颜色之后调用 glClear 才会刷新缓冲区的颜色\nglClearColor并不是必须的\n\n\n\n\nglUniform1iv\n\n\n","categories":["Learning OpenGL"],"tags":["OpenGL","图形学"]},{"title":"满堂花醉三千客，一剑霜寒十四州","url":"/2024/07/12/4b66769f26f4/","content":"\n\n\n","categories":["相册"],"tags":["安徽","台州"]},{"title":"面经","url":"/2024/05/13/cf86467b04aa/","content":"波克城市  协程是否共享堆栈\n进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度\n线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度（标准线程是的）\n协程和线程  一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度\n\n透明物体位于 Unity 哪个渲染阶段  已知法向纹理，如何还原法线向量  如何计算 MipMap 个数  描述 Blooming 方法  如何解决 AssetBundle 依赖 B 站 图集是怎样生成的  资源加载 Unity AssetDatabase 和Resources资源管理Unity 常用的资源大概有以下几类：\n\n纯资源（material，texture，shader，audio，…）这些资源不能直接拖到场景里使用\n预置（prefab），这种资源需要实例化之后才能使用\nscene 也是一种资源\n脚本对象，文本文件，unity 自己内置的资源（像新建粒子时的默认材质之类的）\n\nUnity 管理这些资源分为两种：\n\n在编辑器内管理，使用 AssetDatabase 加载卸载资源\n在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用\n\n\n运行时管理，简单化使用Resources，复杂化使用 AssetBundle\n在运行时管理资源，简单的方法就是使用 Resources 接口。这种方式控制资源的管理效率高，资源需要放在 Resources 文件夹下。这就说明 Unity 在打包时只会打包 Resources 文件夹下的资源到终端上。 加载这个文件夹下的资源不需要扩展名。最好不要建立多个 Resources 文件夹，否则 Unity 可能会不知道要加载哪一个\n\n\n\n叠纸一面 C# 调用 Lua GC 是如何产生的，如何避免 GCUGUI 自适应大小 如何避免装箱拆箱 Lua 元表是什么 原表是 Lua 中元表（Metatable）的一种特殊类型。元表是一种可选的附加到表上的表，用于控制表的行为。当我们进行特定的操作时，例如访问表中不存在的键、进行算术运算或比较等，Lua 会在元表中查找相应的元方法并执行相关的操作。\n元表通过定义元方法来定义特定操作的行为。元方法是一组预定义的函数，以特定的键存储在元表中。当执行相关操作时，Lua 会检查元表中是否存在对应的元方法，并根据元方法的定义来处理操作。\n以下是一些常见的元方法及其对应的操作：\n\n__index：该元方法用于处理当访问表中不存在的键时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__index 元方法。如果存在，Lua 会调用该元方法，并将表和被访问的键作为参数传递给它。该元方法可以返回一个值来作为访问的结果，或者可以是一个函数，以便进行进一步的操作。\n__newindex：该元方法用于处理当对表中不存在的键进行赋值时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__newindex 元方法。如果存在，Lua 会调用该元方法，并将表、被赋值的键和赋予的值作为参数传递给它。我们可以在该元方法中自定义处理逻辑，例如捕获赋值操作并执行自定义的操作或者抛出错误。\n__add、__sub、__mul、__div等：这些元方法用于重载表的算术运算符。当进行相应的算术运算时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的操作。我们可以在这些元方法中实现自定义的算术运算逻辑。\n__eq、__lt、__le：这些元方法用于重载表的比较运算符。当进行相应的比较操作时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的比较逻辑。我们可以在这些元方法中实现自定义的比较逻辑。要将元表关联到表上，我们使用 setmetatable 函数。通过将表作为第一个参数，元表作为第二个参数传递给 setmetatable 函数，即可将元表关联到表上。\n\n原表的应用非常广泛，可以用于实现面向对象的特性，例如继承、多态等。我们可以通过定义元方法来自定义对象的行为，同时还可以通过原表来实现一些高级功能，如代理（Proxy）、属性访问、事件触发等。通过定义适当的元方法，我们可以拦截和重定义对表的操作，从而实现各种定制化的行为。\n以下是一个更具专业性的示例，演示了如何使用原表来实现代理模式：\n-- 原始对象local realObject = {  value = 42,  getName = function(self)    return \"Real Object\"  end}-- 代理对象local proxyObject = {  value = 0,  getName = function(self)    return \"Proxy Object\"  end}-- 定义代理的元表local proxyMetatable = {  __index = function(table, key)    -- 当访问值时，代理返回代理对象的值    if key == \"value\" then      return table.value    end    -- 当调用方法时，代理返回原始对象的方法    if key == \"getName\" then      return realObject.getName    end  end,  __newindex = function(table, key, value)    -- 代理只允许修改代理对象的值，而不影响原始对象    if key == \"value\" then      table.value = value    end  end}\n\nTimeLine 和 AnimatorAnimator 是组件，而 Timeline 是资产\nAnimator 这个组件，是用来实现“使用某种动画数据来驱动所在 GameObject 及其子物体的各种参数随时间推移而发生变化”这一功能的。比如：Animator 告诉 Transform 组件将 position 和 rotation 设置到某一个数值，而这个数值的来源就是我们的动画片段（Animation clip，也就是。anim 文件资产）\n但 Animator 这个组件并不直接读取。anim 资产的数据，而是通过 Animator Controller 资产来间接获取。Animator Controller 是一个状态机，可以设置一系列参数来控制多个多个动画片段之间的融合过渡。有了 Animator Controller 的参与，Animator 组件就不需要直接控制很多很多的动画片段了（特别特别麻烦），只需要控制相应的“参数”就可以达到控制很多动画片段之间的融合过渡的目的\nAnimator Controller 是用来整合。anim 数据的资产，Timeline 一定程度上也是。Timeline 的 Animation Track 做到事情，就是将多个动画片段按时间顺序连接起来（你可以把 Timeline 理解成一个非线性动画编辑器），这样我们就不需要手动控制这些动画片段的播放时间，只需要在需要的时候播放 Timeline 即可。当然，使用 Animator Controller 也能达到类似的目的，比如将多个片段“串起来”，但 Timeline 的整合显然更直观更好用\nAnimator 如何解决帧数冲突 Lua 插入哈希表还是数组readonly 和const区别\nconst修饰符\n初始化时机：编译时，即编译程序时将值已经嵌入代码中；\n值状态：不允许动态修改\n修饰范围：字段、局部变量\n主要应用场景：主要应用于程序运行中不需要改变的变量的值，比如数学符号 PI；\n\n\nstatic修饰符\n初始化时机：运行时，可以声明时赋值，也可以在构造函数，或使用时赋值\n值状态：允许修改\n修饰范围：类、字段、属性、方法、运算符、事件、构造函数（不能用于索引器、析构函数或类以外的类型）\n主要应用场景：主要作用于类的公共属性\n\n\nreadonly修饰符\n初始化时机：运行时，可以声明时赋值或在类中的构造函数中赋值\n值状态：允许修改，但只能在构造函数中修改\n修饰范围：字段\n主要应用场景：主要作用于实例化的对象的只读属性\n\n\nstatic readonly修饰符\n初始化时机：运行时，是两个关键字的组合\n值状态：允许修改，声明时赋值或者静态构造函数中赋值\n修饰范围：字段\n主要应用场景：\n和 const 相比，它主要应用于引用性变量；而 const，只能用于string 类型的引用性变量；\n类的只读公共属性  总结：\n\n\n\n\nconst是静态的、编译期变量，只能在声明变量的时候赋值。\nreadonly是运行时变量，可以在声明的时候或在构造函数内赋值。\nstatic readonly变量就变成了静态的、编译期变量。只能静态构造函数中进行初始化。\n同时 static readonly 可以理解为是最简单的一种单例模式实现方式。\nconst是静态常量，readonly是动态常量。const高效，readonly灵活！但实际开发中我们经常用 static readonly 来代替 const, 以平衡const 在灵活性上的不足\n\n叠纸二面 Used Total 和 Reserved Total 在 Profiler 工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 Used Total（使用总内存）和 Reserved Total（预定总内存）。Used Total 和 Reserved 均是物理内存，其中 Reserved 是 unity 向系统申请的总内存，Unity 底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的 Reserved 内存，而运行时，unity 所使用的内存首先是向 Reserved 中来申请内存，当不使用时也是先向 Reserved 中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total 越大，则 Reserved Total 越大，而当 Used Total 降下去后，Reserved Total 也是会随之下降的（但并不一定与 Used Total 同步）\n如何实现历史记录 EditorWindow 生命周期\n    \n\n\nAnimation Clip数据结构  协程的原理 yield 和IEnumerator什么关系 yield 是 C# 的关键字，其实就是快速定义迭代器的语法糖。只要是 yield 出现在其中的方法就会被编译器自动编译成一个迭代器，对于这样的函数可以称之为迭代器函数。迭代器函数的返回值就是自动生成的迭代器类的一个对象\n试试想象如果没有 yield 关键字，我们每定义一个迭代器，就要创建一个类，实现 IEnumerator 接口，接口包含的属性与方法都要正确的实现，是不是很麻烦？而利用 yield 关键字，只需要下面简单的几行代码，就可以快速定义一个迭代器。诸如迭代器类的创建，IEnumerator接口的实现工作编译器通通帮你做了\n// 由迭代器函数定义的迭代器IEnumerator Test(){    yield return 1;    Debug.Log(\"Surprise\");    yield return 3;    yield break;    yield return 4;}\n\nUnity 协程机制的实现原理  协程是一种比线程更轻量级的存在，协程可完全由用户程序控制调度。协程可以通过 yield 方式进行调度转移执行权，调度时要能够保存上下文，在调度回来的时候要能够恢复。这是不是和上面“停住”代码然后又原位恢复的执行效果很像？没错，Unity 实现协程的原理，就是通过 yield return 生成的 IEnumerator 再配合控制何时触发 MoveNext 来实现了执行权的调度\n具体而言，Unity 每通过 MonoBehaviour.StartCoroutine 启动一个协程，就会获得一个 IEnumerator（StartCoroutine 的参数就是 IEnumerator，参数是方法名的重载版本也会通过反射拿到该方法对应的IEnumerator）。并在它的游戏循环中，根据条件判断是否要执行MoveNext 方法。而这个条件就是根据 IEnumerator 的Current属性获得的，即 yield return 返回的值。\n在启动一个协程时，Unity 会先调用得到的 IEnumerator 的MoveNext一次，以拿到 IEnumerator 的Current值。所以每启动一个协程，协程函数会立即执行到第一个 yield return 处然后“停住”。\n对于不同的 Current 类型（一般是 YieldInstruction 的子类），Unity 已做好了一些默认处理，比如：\n\n如果 Current 是null，就相当于什么也不做。在下一次游戏循环中，就会调用 MoveNext。所以yield return null 就起到了等待一帧的作用\n如果 Current 是WaitForSeconds类型，Unity 会获取它的等待时间，每次游戏循环中都会判断时间是否到了，只有时间到了才会调用 MoveNext。所以yield return WaitForSeconds 就起到了等待指定时间的作用\n如果 Current 是UnityWebRequestAsyncOperation类型，它是 AsyncOperation 的子类，而 AsyncOperation 有isDone属性，表示操作是否完成，只有 isDone 为true时，Unity 才会调用 MoveNext。对于 UnityWebRequestAsyncOperation 而言，只有请求完成了，才会将 isDone 属性设置为true。\n\n也因此我们才可以使用下面的同步代码，完成本来是异步的网络请求操作。\nusing(UnityWebRequest webRequest = UnityWebRequest.Get(\"https://www.cnblogs.com/iwiniwin/p/13705456.html\")){    yield return webRequest.SendWebRequest();    if(webRequest.isNetworkError)    {        Debug.Log(\"Error\" + webRequest.error);    }    else    {        Debug.Log(\"Received\" + webRequest.downloadHandler.text);    }}\n\nLua 协程 Lua 协程的相关函数封装在 coroutine 中，对应的 C API 为lua_newthread，lua_resume 等。Lua 文档中的 thread 和 coroutine 是一个概念，但与操作系统的线程是两个东西。C API 通过 lua_State 维护一个协程的状态（以及 Lua 虚拟机状态的引用），协程的状态主要指协程上下文（如交互栈），Lua 虚拟机状态是全局的，可被多个协程共享\n当调用 lua_newstate 时，实际上分为两步\n\n创建并初始化一个 Lua 虚拟机global_State\n创建一个主协程运行于虚拟机中，并返回主协程的执行上下文 LuaState\n\n调用 lua_newthread 时，将在已有 Lua 虚拟机上，创建另一个协程执行环境，该协程与已有协程共享虚拟机状态（同一个 Lua 虚拟机中的不同协程共享global_State)，并返回新的执行上下文。因此将 LuaState 理解为协程执行上下文可能更合适，LuaState 本身也是一个类型为 thread 的 GCObject，无需手动释放\n游卡 LoopScrollViewUI 框架 表格加载  莉莉丝C# 字符串优化\n使用 string.Empty 给一个空字符串变量赋初始值，String.Empty是一个指代，而 \"\" 是具体的实现\n\n使用 str.Length == 0 做空串比较\n\n避免不必要的字符串 ToUpper、ToLower 类操作\n\nToUpper、ToLower这类方法均会重新生成字符串对\nString.Compare可实现忽略字符串大小写\n\n// 不推荐的写法if(s1.ToUpper() == s2.ToUpper())// 推荐的写法if(String.Compare(s1, s2, true) == 0)\n用 StringBuilder 进行字符串拼接操作\n\n创建 StringBuilder 应指定初始大小\n\n避免滥用StringBuilder\n\n类似 str1 + str2 + str3 + str4 的字符串拼接操作会被编译为 String.Concat(str1, str2, str3, str4)，效率反而高于StringBuilder。String.Concat 会一次性确定字符串长度，StringBuilder需要做 Resize，适用于多次生成string 对象的情况\n\n\n通过直接设置 .Length = 0 来初始化StringBuilder\n\n不要使用 .Length = 0 来释放 StringBuilder 占用的内存\n\n\n图片压缩  术语\n内存 ：例如A8R8G8B8 格式中一个像素占 4 字节，如果是 512x512 分辨率内存就占用512 * 512 * 4B = 1048576B = 1MB，这种内存消耗在低端设备上根本无法接受\n带宽：在渲染 3D 场景时，会有大量的贴图被传输到 GPU，若不限制，总线带宽很快就会成为瓶颈\n有损：表示对于渲染来说，有损压缩是可以接受的，一般选择压缩格式时需要在纹理质量和文件大小上寻求一个平衡\n固定速率压缩：因为 GPU 需要能够高效的随机访问一个像素，这意味着对任意像素，解码速度不该有太大的变化。因此，见的贴图压缩算法都是固定速率压缩。相反的例如 zip 则是一种可变速率压缩\n向量量化（Vector Quantization，VQ）：此技术原用于资料压缩，透过分割大数量的资料点（函数），让每个小群集都有相同的资料点，而这些小群集的所有资料就由其正中央的点作为代表\n编码和解码速度：一般来说编码速度慢没关系，因为通常纹理压缩只需要在游戏打包时进行一次，对于用户运行时体验完全没有影响。但解码速度必须足够快，而且基本上不能影响到渲染性能\n压缩比：通常以比特率或每像素的平均比特数（bits per pixel，bpp）表示，常见的为 2~8bpp。一般 RGB 原生纹理的像素指 24 位，4bpp 表示每像素占 4 位，所以也可以认为 4bpp 表示压缩比为 6:1\n\nETC基本思想  将图片分成 4x4 的若干个像素块，每个像素块按照一定规则编码成为一个 64 位 (8 字节）的数据，大概的想法是计算像素块的平均颜色，然后记录这个平均颜色和每个像素相对平均颜色的差值，平均颜色只耗费了一个像素的数据，而差值也并不记录完全真实的差值，而是从一个固定的静态数据中找到最接近的差值（RGB 三个通道差值一样），每个像素只需要记录其差值在静态数据中的索引即可\n\n压缩比：对于 RGB24 图片，每个块的数据由 4x4x3 = 48 字节，压缩为 8 字节，压缩比为 6:1，针对 Alpha 图片，由 4x4x1 = 16 字节 压缩为 8 字节，所以，对于普通的 RGBA 分离为 RGB24 和 Alpha 之后分别进行 ETC1 压缩的图片，整体压缩比为 (48 + 16) : (8 + 8) = 4:1\n文件头数据：除了编码后的数据块之外，还会存储一部分文件头数据，用来表示文件的特征码、宽高等\n\n像素块编码思想\n将 4x4 的像素块分为两个 4x2 的子块，有水平和竖直两种分法。使用 1 位数据 flipbit 来表示是哪一种分法，还剩下 63 位数据\n\n\n    \n\n\n\n分别计算两个分块中 8 个像素颜色的平均值，根据两个块颜色平均值的差值，确定使用 individual 模式还是 differential 模式。使用 1 位数据 diffbit 来表示是哪种模式，还剩下 62 位数据\n存放两个子块的平均颜色信息，individual 模式用 R4G4B4 的格式分别表示两个子块的平均颜色，differential 模式使用 R5G5B5 格式表示第一个子块的平均颜色，R3G3B3 格式表示第二个子块与第一个子块平均颜色的差值。这里使用了 8 * 3 = 24 位数据，还剩下 62 - 24 = 38 位数据\n所有的图片共享一个全局的映射表数据，这个数据是固定的全局静态数据，并不会进入到编码数据中，这个表是一个 8 x 4 的二维数组，使用 3 位数表示第一个子块在映射表中查询的第一维索引，需要 3 位来表示 0 - 7 的下标，第二个子块同样需要 3 位数来表示，还剩下 38 - 3 * 2 = 32 位数据\n4 x 4 像素块中的每个像素，使用 2 位数来表示该像素在映射表中查询的第二维索引，需要 2 位数来表示 0 - 3 的下标，所以消耗了 4 x 4 x 2 = 32 位数据\n\n内存布局和解码过程  以 RGB555 基本色和 RGB3333 颜色差表示的编码为例，每个 4x4 像素块经过 ETC1 编码后的 64 位数据的内存布局大概是这样\n\n    \n\n\n假如编码前像素块表示为下图，需要得到图中编号 2 对应像素的颜色，需要进行如下的解码步骤：\n\n    \n\n\n\n获取目标所在的子块：根据第 32 位 flipbit 标志位，知道这个像素块采用的是横版划分子块，2 号像素处在子块 2 中\n获取子块 1 基本颜色：首先根据第 33 位 diffbit 标志位得知，这里采用的是 R5G5B5 基本色 + R3G3B3 差值的方式。分别从 59-63 位 (11100)、51-55 位 (00100) 和 43-47 位 (00011) 读取子块 1 基本色 RGB1=(11100, 00100, 00011) = (28, 4, 3)\n获取子块 2 的颜色差值：这里是 differential 模式，所以需要读取子块 2 的颜色差值，从 56-58 位 (100)、48-50 位 (010) 和 40-42 位 (000) 获得颜色差值 RGB_offset=(100, 010, 000) = (-4, 2, 0)，注意这里的 3 位数据中最高位是符号位，所以差值部分的取值范围是 [-4, 3]\n计算子块 2 的基本色：将子块 1 基本色和子块 2 差值相加，得到子块 2 的基本色，RGB2=RGB1 + RGB_offset = (28 - 4, 4+2, 3+0) = (24, 6, 3)，转为 5 位二进制表示为 RGB2=(11000, 00110, 00011)\n扩展子块 2 基本色分量为 8 位：对 5 位标识的基本色补位为 8 位表示，得到 RGB1 = (11000110, 00110110, 00011011) = (198, 54, 27)，这就是子块 2 的基本色\n补位规则：\n\nindividual 模式，直接将 4 位数复制到尾部，得到 8 位\ndifferential 模式，将 5 位中的高 3 位复制到尾部，得到 8 位\ndifferential 模式，一定是将子块 1 基本色和子块 2 偏移值相加后再进行补位\n\n\n\n获得目标像素的颜色偏移值：目标像素下标为 2，在编码数据的第 2 位得到映射表的下标的低位 (lsb) 为 1，第 18 位得到映射表的下标高位 (msb) 为 1，假如使用如下的映射表，则可以得到映射表下标为(lsb, msb) = (1, 1)，对应下标为-b\n\n\n    \n\n\n  上面知道目标像素位于子块 2，这里还需要从编码数据的 34-36 获得子块 2 的修正表索引，得到索引为 (1, 1, 0) = 6，根据上面的映射表，根据下标(6, -b) 可以索引到像素的颜色差值为 -106\n\n计算目标像素的最终颜色值：这里 RGB 三个分量的差值相同，目标像素最终的颜色值为子块 2 的基本颜色 + 目标像素的颜色偏移值：RGB_target = RGB2 + (-106, -106, -106) = (198 - 106, 54 - 106, 27 - 106)，修正后得到目标颜色值RGB_target = (92, 204, 177)\n\n编码过程\n将图划分为 4x4 的像素块，如果不够 4x4，则将这些像素填充在 4x4 块的左上角\n针对每个 4x4 的像素块尝试以下编码，取解码后和原像素差值最小的那种编码作为结果\n确定 flipbit，并计算两个子块的平均颜色值，这里我猜测是先将 8 个像素的R8G8B8 取均值得到像素的平均值，然后将每个分量的后三位直接抛弃，得到R5G5B5\n根据两个子块颜色值的差值，确定 diffbit，根据上面得到的两个子块的R5G5B5，计算差值，如果差值在[-4, 3] 之间，说明差值可以用 3 位带符号的二进制数表示，可以用 differential 模式，否则用 individual 模式\n枚举不同的子块索引，确定每个子块使用映射表中的哪一组偏移值\n枚举每个像素的映射下标，确定像素使用映射表中的哪一个偏移值\n针对第 3 步和第 4 步的枚举，可以得到很多组不同的编码，将编码结果解压后和原始像素数据对比，取相差最小的一组编码作为最终结果\n\n\n将图片中各个像素块编码合并\n\nUnity 的几种 ETC 纹理压缩格式\nRGB ETC1 4 bit：4 bits/pixel，对 RGB 压缩比 6:1，不支持 Alpha，绝大部分安卓设备都支持\nRGB ETC2 4 bit：4 bits/pixel，对 RGB 压缩比 6:1。不支持 Alpha，ETC2 兼容 ETC1，压缩质量可能更高，但对于色度变化大的块误差也更大，需要在 OpenGL ES 3.0 和 OpenGL 4.3 以上版本\nRGBA ETC2 8bit：8 bits/pixel，对 RGBA 压缩比 4:1。支持完全的透明通道，版本要求同上\nRGB +1bit Alpha ETC2 4bit：4 bits/pixel。支持 1bit 的 Alpha 通道，也就是只支持镂空图，图片只有透明和不透明部分，没有中间的透明度\n\nDXTDXT 是一种有损纹理压缩算法，微软的 Direct 中支持，DXT 的格式包括 DXT1~DXT5，其中 DXT1 和 DXT5 较为多见\n\n    \n\n\nDXT 算法非常容易理解，而且整体看上去效果不错，但如果对局部特写，会发现在细节上会有很多丢失，这也是算法本身导致的，毕竟每个块只有两个颜色，而其他颜色都是在这两个颜色区间的差值，如果当前区域内还有其他显著颜色则必然会有丢失\n这种信息的丢失主要集中在比较细的边界中，但 DXT1 在压缩率上是 RGB 的 6 倍，这种问题可以通过提高纹理分辨率的方式来解决，高宽放大 41%(1.41 * 1.41 = 1.9881)，这样整个纹理是以前的 2 倍，但压缩率还能保持为 3 倍，也是可以接受的。在 DXT 中还有一个主要的损失，就是 RGB 的 24 位转为了 16 位颜色，16 位中 R&amp;B 各占 5 位，但是 G 占了 6 位，这是因为人眼对绿色最为敏感\n\n    \n\n\n另外一个问题就是 DXT3 和 DXT5 之间的对比，相比 DXT1 不支持透明度（但支持是否透明），DXT5 要大一倍（多了 64bit），和之前颜色保存方案一样对透明度也保存了两个 16 位的颜色和对应的调色板，对 RGBA 的效果也得到了保证，但 DXT3 思路不一样，它是对每一个像素保存了 4bit 的透明度，同样也是多了 64bit，但此时毕竟只有 16 个透明度选项，相比 DXT5，在压缩率上相当，但对透明色的处理不够细腻，因此在实用性上并不推荐 DXT3\nPVRTCPVRTC 不同于 DXT 和 ETC 这类基于块的算法，而将整张纹理分为了高频信号和低频信号，低频信号由两张低分辨率的图像 A 和 B 表示，这两张图在两个维度上都缩小了 4 倍，高频信号则是全分辨率但低精度的调制图像 M，M 记录了每个像素混合的权重。要解码时，A 和 B 图像经过双线性插值（Bilinearly）宽高放大 4 倍，然后与 M 图上的权重进行混合\n\n    \n\n\nPVRTC 4-bpp 模式下，每 4x4 像素占一个 64 位数据块，2-bpp 模式下每 8x4 像素会有一个 64 位数据块。4-bpp 模式下，A 图和 B 图缩小后都只保存一个颜色值，如下图所示，Color A 比 Color B 少 1 位，但两张图都可以选择以 RGB 或 ARGB 的方式存储（最高位决定为哪种），Color A 可以用 RGB554 或 ARGB3443 格式编码，Color B 可以用 RGB555 或 ARGB3444 格式编码\n\n    \n\n\n在解码时，为了解码任意像素，必须读取 4 个相邻的 PVRTC 块，使用这 4 个块来解码一个 5x5 块\n\n    \n\n\n使用双线性过滤来对 A 和 B 图进行扩大，然后 A 和 B 图根据 M 图与 Mode 位进行混合，这里的 Mode 位为 1 时，M 图中 10 值像素被看作是开启了 punch-through alpha，Alpha 通道会被强制清零，是为了兼容旧应用程序\n\n    \n\n\nASTC以下每个用例都对压缩方案有自己的要求：\n\n支持从 1 到 4 个分量的纹理。虽然单通道纹理也可以使用 BC7、PVRTC2 或 ETC2 来存储，但空通道上大量 bit 被浪费掉了。\n在通道之间数据无相关性的情况下，拥有可以接受的质量。这对于法线图和 RGBA 图像来说非常重要。\n支持 LDR 和 HDR。BC6H 可用于 HDR 纹理压缩，但它不支持 alpha 通道。\n跨平台。特别是：PVRTC 只在 iOS 平台上可用，BC6H/BC7 在移动设备中缺失，ETC 不被桌面级 GPU 所支持。对于跨平台应用程序的开发者来说，有诸多不便。比特率 / 质量比的灵活性。根据纹理类型，不同程度的压缩伪影是可以接受的，因为不同图像的可压缩性是不同的。前文中提到的格式里，能提供的比特率 / 质量选项的不超过两个 (BC1/BC7 或 PVRTC 4bpp/2bpp) 。如果不能使用 5bpp 的压缩级别 （如果 4bpp 的质量略显不足） ，就必须使用 8bpp 的选项。带宽增加了一倍，但质量却没有明显改善。\n支持 2D 和 3D 纹理。\n\n概念上讲，ASTC 类似于 S3TC/BC7：一个压缩块中最多存储四个端点对和插值权重，只支持预定义的分区，特定的分区由分区 ID 指定，也存储在一个块中。在弱相关的情况下，该通道会存储一个独立的索引表。每个独立的编码被称为一个平面。或许 ASTC 最主要、最有趣的创新是用小数位编码整数值的技术，称为 BISE。同时，BISE 可以在硬件中有效实现\n有界整数序列编码 (Bounded Integer Sequence Encoding, BISE)有界整数序列编码，或称 BISE，解决了如下抽象问题：从大小为  的字母表中给定等概率的符号序列， 找到一种编码，使得能够在常数时间复杂度内使用最少的硬件消耗提取第  个符号，并允许相同硬件设计能够用于多种不同大小的字母表，同时具备存储效率\n例如，考虑一个由 5 个整数组成的序列，其中每个整数可以是 0，1 或 2（译者注：5 位的 3 进制数）。使用标准二进制编码时，需要为每个值分配 2 位，总共 10 位。但不同序列的数量是，小于。因此，可以用 8 比特对整个序列进行编码，每个值的比特率为 1.6。换句话说，可以用 8 比特来表示 5 位的 3 进制数\n现在，考虑任意长度的序列，其中每个值都属于范围 ，其中。每个值都可以用一个三进制位和 个比特来表示。假设 ，那么满足该条件的任何值都可以用以下形式表示：，其中 是一个三进制位，和  是比特位。整个序列可以被划分为五组值，最后一组会在必要时填充 。二进制形式下，一个特定的组可以表示为一个比特串，其中 是一个三进制位的  比特表示，是一个值的剩余比特位（译注：即上文中的  和)。只要三进制位与比特信息保持这种相关性，就可以用比特串  保存这五组值。其中  为的各个比特，这段数据要比原先短  比特\n事实证明，这种编码能够保留尾部的零。例如，如果我们序列中的最后一组被填充了两个零 （所以  和是零） ，那么  和是零，它们不需要被存储。因此，任何长度的序列，假如其数值范围从  到，都可以用接近于理论上的最小的比特率进行编码。同时，其中的任意值能以最小的硬件消耗容易的提取出来\n同样的推理也可以应用于  的序列。这里，个五进制数 （基数为  的数字） 可以用  位来编码，因为  小于。因此，使用三进制数和五进制数的 BISE 技术在存储方面都是是有效率的\n\n    \n\n\n其他改进ASTC 还改进了分区模式。BC6H 和 BC7 压缩方案也使用了预定义的分区集表，但这种方法不适合 ASTC，因为它支持大量的瓦片尺寸，支持更多的区域，还增加了分区 ID 字段的大小 (10 位，而 BC7 是 6 位） 。ASTC 的分区模式是用一个特殊的哈希函数生成的，它为每个纹素分配一个分区索引。这个函数将纹素在瓦片中的位置、分区 ID、瓦片大小和分区数量作为输入，并输出一个分区索引。该函数很简单，可以用硬件实现。该函数也用于 3D 纹理。图中描述了 8x8 瓦片的所有分区模式\n\n    \n\n\nASTC 的一个更显著的特点是内插权重的编码方式。S3TC 系列方案使用每个顶点的索引来设置插值权重。根据块的类型，索引的大小可以是 2、3 或 4 比特。然而，对于 12x12 瓦片来说，即使每个像素使用 1bit 的索引，也无法存储在一个 128 位块。因此，ASTC 为权重和纹素提供独立的网格大小。例如，对于 12x12 的瓦片，只能存储 4x6 的权重网格。在解码阶段，权重网格被双线性地放大到瓦片大小。不过虽然看起来像，但是它和简单的瓦片缩放并不一样。例如，平滑的梯度通常可以用一个小的权重网格来表示，如 2x2。因此有更多的比特可用于端点。同时尖锐的边缘和颜色过渡可以用适合的分区模式进行编码。权重网格的大小是根据每个块来选择的。因此某些具有强烈垂直特征的瓦片，可以用 4x2 或 8x4 的权重网格进行编码\n所有这些配置数据 （网格大小、分区数量、端点格式） 都必须存储在一个压缩块中。虽然不得不牺牲一些颜色数据位，因而可能降低图像质量，但这种方法带来了很好的灵活性，并且大大增强了压缩质量。ASTC 允许在每个块中进行不同的比特权衡，任意瓦片都可以在分区、端点和权重之间的分布选用最合适的比特分布进行编码。事实证明，即使在较低的比特率下，ASTC 也能够提供比 PVRTC、BC1-BC5 和 ETC 更好的质量。PSNR （译注：峰值信噪比） 增益平均为 1.5dB 至 2dB，大多数观察者 （译注：推测此处数值为 ASTC 对比其他压缩格式获得的增益 ) 大约能察觉 0.25dB 的增益。BC6H 的质量与之相当，而 BC7 平均比 ASTC 多出 0.5dB。不过在 8bpp 时，ASTC 和 BC7 压缩图像的 PSNR 质量都在 45dB 左右，这种差异很难从视觉上发现\n此外，ASTC 是第一个支持 3D 纹理的标准压缩方案，它利用了所有三个维度的颜色相关性。nVidia 的 OpenGL(26) 的 VTC 扩展也是针对 3D 纹理的，但它只是把一个 3D 瓦片分成 2D 片，使用 BC1 方案进行压缩。ASTC 则使用 3D 权重网格和分区，利用分区模式生成器来压缩整个 3D 瓦片。不过权重网格是用单线法而非三线插值法进行放大的 (67) 。整个 3D 瓦片的压缩比分片压缩的 PSNR 高出 2dB\n另外，ASTC 的所有特征都是 “正交 “的，即任何特征都可以独立使用，例如可以用两个弱相关的 HDR 通道来压缩一个三维纹理\nASTC 块  首先是一些全局解码参数，这些参数对任何特定的纹理都是一样的。因此，没有必要在压缩块中存储这些\n\n动态范围 (LDR/HDR)\n纹理尺寸 (2D/3D)\n瓦片尺寸\n输出色彩空间 (sRGB/RGB)\n\n而每块指定的数据如下\n\n权重网格大小\n权重范围 （用于 BISE 解码）\n权重值\n分区的数量\n分区模式 ID\n颜色端点模式\n颜色端点数据\n平面的数量 (1 或 2)\n平面到通道的分配\n\n纹理可以被编码为单通道、双通道、三通道或四通道图像。但解码后的值总是以 RGBA 格式输出。在 LDR sRGB 模式下，颜色值以 8 位整数返回，否则以 16 位浮点数返回。图 40 展示了 ASTC 块的布局\n\n    \n\n\n除了 BlockMode 和 Part 字段，所有字段的长度都是可变的。\nPart 字段指定了分区的数量 （减一） 。在双平面模式下，分区的数量必须是 1、2 或 3。BlockMode 字段指定了平面数、权重范围和权重网格的大小。ConfigData 和 MoreConfigData 字段指定每个端点对的端点模式。\n如果是 2D 瓦片，BlockMode 由 5 个字段组成。A、B、R、D、H。 特殊的 void-exten 模式有一个单独的编码，用于单色瓦片。void-exten 块还允许识别附近的单色区域。可以缩短获取相同的块的过程，并进一步减少内存带宽占用\n\n    \n\n\nA、B 字段分别指定权重网格的宽度 (N) 和高度 (M) 。D 位 （双倍） 被设置为表示双平面模式。R 字段 （范围） 和 H 位 （高精度） 指定重量范围 （见表 14) 。注意，由于 R 字段的编码，为了避免产生歧义，位  和不能同时为零\n\n    \n\n\nConfigData 和 MoreConfigData 指定了端点对的编码，每个端点对都可以有独立的编码模式。共有 16 种编码模式：10 种 LDR 格式和 6 种 HDR 格式。然而，HDR 纹理可以使用其中任何一种。所有这些端点格式都是基于以下基本方法之一：\n\n独立性。两个 k 位的值直接存储。\nbase + offset（类似于 ETC 的差分编码） 。第一个值为 base, 用 (k+1) 位存储。第二个值为 offset, 用 (k-1) 位存储。\nbase + scale。两个 RGB 值由四个数值 (R、G、B、s) 表示。颜色一等于(R，G，B)，颜色二等于(sR，sG，sB)\n\n从概念上讲，ASTC 块的解码是这样进行的。BlockMode 字段用于确定权重范围和权重网格的大小。权重数据从压缩块的尾部读取，并使用 BISE 进行解包。之后，权重被反量化为 [0, 64] 范围。如果权重网格的尺寸小于瓦片的尺寸，则使用双线性插值进行升格。\n之后，Part 字段用于指定分区的数值。分区模式 ID 从块中读出，然后针对每个纹素生成哈希作为分区索引。给定分区数量，还可以利用 ConfigData 和 MoreConfigData 字段计算标量的总值，该值会被用于端点编码 （端点可以有不同数量的通道，不同的端点存储模式下会使用不同数量的值） 。然而，这些标量值的范围在 BISE 解码时必须是已知的，因为该范围并没有被明确指出。在权重和分区数据解码阶段之后，就可以知道可用于彩色端点数据的比特数。颜色端点的值会使用适用于上述比特数的最大范围的值来存储。端点被解压缩和反量化。端点对会根据分区索引来选择。端点的颜色则使用插值权重来混合\n叠纸三面C#内存分配C# 开发三个重要的内存区域：托管堆内存、非托管堆内存和栈内存\n\n    \n\n\n托管堆内存（Managed Heap Memory）\n    \n\n\n托管堆内存是由 .NET 运行时（CLR）自动管理的内存区域，用于存储对象实例和数组等引用类型数据。在堆上分配的内存会通过垃圾回收器（Garbage Collector）进行自动回收，对象的创建和销毁都是由垃圾回收器负责管理\n非托管堆内存（Unmanaged Heap Memory）\n    \n\n\n非托管堆内存是由本机代码或外部资源分配的内存区域，通常用于与非托管代码进行交互、进行底层的系统编程或使用特定的外部库。需要手动分配和释放内存，没有自动垃圾回收的机制，可以使用 Marshal 类或unsafe 上下文来进行非托管内存的操作\n栈内存（Stack Memory）\n    \n\n\n栈内存用于存储局部变量、方法调用和执行上下文等信息，存储的是值类型数据和引用类型数据的引用。栈内存的分配和释放是由编译器自动完成的，具有较高的效率，栈内存的作用域仅限于所属的代码块或方法\n优化技巧  托管堆内存优化\n使用对象池：避免频繁地创建和销毁对象，可以使用对象池来重复利用对象实例\n减少装箱和拆箱：尽量使用泛型集合（如List）来避免值类型的装箱和拆箱操作\n及时释放资源：手动释放不再使用的托管内存，如调用对象的 Dispose() 方法或使用 using 语句来确保及时释放资源\n\n非托管堆内存优化\n尽量避免直接使用非托管内存：推荐优先使用托管内存，仅在必要时与非托管代码交互，并使用 Marshal 类的相关方法来管理非托管内存的分配和释放\n避免内存泄漏：确保将非托管内存正确释放，避免内存泄漏问题\n\n栈内存优化\n尽量使用局部变量：将数据存储在栈上的局部变量中，而不是使用类的实例变量。这样可以减少托管堆内存的压力，同时也提高访问速度\n使用值类型：对于小型数据，考虑使用值类型而不是引用类型来减少内存开销和垃圾回收的成本\n\n其他优化技巧\n避免使用过多的字符串拼接操作：频繁的字符串拼接可能会导致内存碎片和性能下降，尽量使用 StringBuilder 类来处理大量字符串拼接\n缓存重复计算结果：如果有一些计算结果会被重复使用，可以将结果缓存起来，避免重复计算和内存消耗\n使用合适的数据结构：选择适当的数据结构和算法来优化内存和性能，如使用哈希表、集合等数据结构\n使用性能分析工具：使用性能分析工具（如。NET Memory Profiler）来检测内存泄漏、高内存使用和潜在性能问题\n\n堆和栈的访问速度  栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构 / 操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多\n红点系统  米哈游一面 Top K 问题 小顶堆  可以通过构造一个前  个最大元素小顶堆来解决，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。具体步骤如下：\n\n从数组中取前  个数（到  位），构造一个小顶堆\n从  位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。\n遍历完成后，堆顶的数据就是第  大的数据\n\n代码实现let findKthLargest = function(nums, k) {    // 从 nums 中取出前 k 个数，构建一个小顶堆    let heap = [,], i = 0    while(i &lt; k) {       heap.push(nums[i++])     }    buildHeap(heap, k)        // 从 k 位开始遍历数组    for(let i = k; i &lt; nums.length; i++) {        if(heap[1] &lt; nums[i]) {            // 替换并堆化            heap[1] = nums[i]            heapify(heap, k, 1)        }    }        // 返回堆顶元素    return heap[1]};// 原地建堆，从后往前，自上而下式建小顶堆let buildHeap = (arr, k) =&gt; {    if(k === 1) return    // 从最后一个非叶子节点开始，自上而下式堆化    for(let i = Math.floor(k/2); i&gt;=1 ; i--) {        heapify(arr, k, i)    }}// 堆化let heapify = (arr, k, i) =&gt; {    // 自上而下式堆化    while(true) {        let minIndex = i        if(2*i &lt;= k &amp;&amp; arr[2*i] &lt; arr[i]) {            minIndex = 2*i        }        if(2*i+1 &lt;= k &amp;&amp; arr[2*i+1] &lt; arr[minIndex]) {            minIndex = 2*i+1        }        if(minIndex !== i) {            swap(arr, i, minIndex)            i = minIndex        } else {            break        }    }}// 交换let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}\n\n快速选择（Quick Select）算法  快排  快排使用了分治策略的思想，所谓分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。\n快排的过程简单的说只有三步：\n\n首先从序列中选取一个数作为基准数\n将比这个数大的数全部放到它的右边，把小于或者等于它的数全部放到它的左边 （一次快排partition）\n然后分别对基准的左右两边重复以上的操作，直到数组完全排序\n\n具体按以下步骤实现：\n\n创建两个指针分别指向数组的最左端以及最右端\n在数组中任意取出一个元素作为基准\n左指针开始向右移动，遇到比基准大的停止\n右指针开始向左移动，遇到比基准小的元素停止，交换左右指针所指向的元素\n重复 3，4，直到左指针超过右指针，此时，比基准小的值就都会放在基准的左边，比基准大的值会出现在基准的右边\n然后分别对基准的左右两边重复以上的操作，直到数组完全排序\n\n代码实现let quickSort = (arr) =&gt; {  quick(arr, 0 , arr.length - 1)}let quick = (arr, left, right) =&gt; {  let index  if(left &lt; right) {    // 划分数组    index = partition(arr, left, right)    if(left &lt; index - 1) {      quick(arr, left, index - 1)    }    if(index &lt; right) {      quick(arr, index, right)    }  }}// 一次快排let partition = (arr, left, right) =&gt; {  // 取中间项为基准  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],      i = left,      j = right  // 开始调整  while(i &lt;= j) {        // 左指针右移    while(arr[i] &lt; datum) {      i++    }        // 右指针左移    while(arr[j] &gt; datum) {      j--    }        // 交换    if(i &lt;= j) {      swap(arr, i, j)      i += 1      j -= 1    }  }  return i}// 交换let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}// 测试let arr = [1, 3, 2, 5, 4]quickSort(arr)console.log(arr) // [1, 2, 3, 4, 5]// 第 2 个最大值console.log(arr[arr.length - 2])  // 4\n\n快速选择  仅仅需要在每执行一次快排的时候，比较基准值位置是否在  位置上\n\n如果小于 ，则第 个最大值在基准值的右边，我们只需递归快排基准值右边的子序列即可；\n如果大于 ，则第 个最大值在基准值的做边，我们只需递归快排基准值左边的子序列即可；\n如果等于 ，则第 个最大值就是基准值\n\n代码实现let findKthLargest = function(nums, k) {    return quickSelect(nums, nums.length - k)};let quickSelect = (arr, k) =&gt; {  return quick(arr, 0 , arr.length - 1, k)}let quick = (arr, left, right, k) =&gt; {  let index  if(left &lt; right) {    // 划分数组    index = partition(arr, left, right)    // Top k    if(k === index) {        return arr[index]    } else if(k &lt; index) {        // Top k 在左边        return quick(arr, left, index-1, k)    } else {        // Top k 在右边        return quick(arr, index+1, right, k)    }  }  return arr[left]}let partition = (arr, left, right) =&gt; {  // 取中间项为基准  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],      i = left,      j = right  // 开始调整  while(i &lt; j) {        // 左指针右移    while(arr[i] &lt; datum) {      i++    }        // 右指针左移    while(arr[j] &gt; datum) {      j--    }        // 交换    if(i &lt; j) swap(arr, i, j)    // 当数组中存在重复数据时，即都为 datum，但位置不同    // 继续递增 i，防止死循环    if(arr[i] === arr[j] &amp;&amp; i !== j) {        i++    }  }  return i}// 交换let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}\n\nRebatch 和 Rebuild 的作用  术语\nCanvas 是 Unity 渲染系统给层状几何体 (layered geometry) 提供的可以被画入、被放在上面或者放在世界空间的底层 Unity 组件。Canvas 负责将它包含的几何体组合成 batch，生成合适的渲染命令发送给 Unity 图形系统。这个过程在底层的 C++ 代码中完成，这个过程被称为一次 rebatch 或者一次 batch build。当一个 Canvas 被标记为包含需要 rebatch 的几何体时，这个 Canvas 被认为是 dirty 的。layered geometry , 由 Canvas Renderer 组件提供给 Canvas。Canvas 负责进行渲染，Canvas Renderer 负责采集 / 接收\n\n动静隔离 一个子 Canvas 仅仅是一个嵌套在父 Canvas 中的组件，子 Canvas 将它的子物体和它的父 Canvas 隔离，一个子 Canvas 下 dirty 的子物体不会触发父 Canvas 的 rebuild，反之亦然（这些在某些特殊情况下是不确定的，比如说改变父 Canvas 的大小导致子 Canvas 的大小改变）\n\nGraphic 是 UGUI 的 C# 库提供的一个基类。它是 UGUI 所有类的基类，给所有的 UGUI 类提供可以画在 Canvas 系统上的几何图形。大多数 Unity 内置的继承 Graphic 的类都是通过继承一个叫 MaskableGraphic 的子类来实现，这使得他们可以通过 IMaskable 接口来被隐藏。Drawable 类的子类主要是 image 和 text，已经提供了同名的组件\n\nLayout 组件控制着 RectTransform 的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠 RectTransform，只影响与其相关的 RectTransform 的属性。这些 layout 组件不依赖于 Graphic 类，可以独立于 UGUI 的 Graphic 组件之外使用\n\nCanvasUpdateRegistry Graphic 和 Layout 组件都依赖于 CanvasUpdateRegistry 类，它不会在 Unity 编辑器的界面中显示。这个类追踪那些 Graphic 和 Layout 组件必须被更新的时候，还有与其对应的 Canvas 触发了 willRenderCanvases 事件的时候。更新 Graphic 类和 Layout 类叫做Rebuild\n\n\n\n在使用 UGUI 制作 UI 时，请牢记 Canvas 中所有几何体的绘制都在一个透明队列中，这就意味着由 UGUI 制作的几何体将从始至终伴随着 alpha 混合，所以从多边形栅格化的每个像素都将被采样，即使它被完全不透明的物体所覆盖。在手机设备上，这种高等级的过度绘制将迅速超过 GPU 填充频率的承受能力\n\nBatch 构建过程（Canvas）\nBatch 构建过程是指 Canvas 通过结合网格绘制它所承载的 UI 元素，生成适当的渲染命令发送给 Unity 图形流水线。Batch 的结果被缓存复用，直到这个 Canvas 被标为 dirty，当 Canvas 中某一个构成的网格改变的时候就会标记为 dirty\nCanvas 的网格从那些 Canvas 下的 CnavasRenderer 组件中获取，但不包含任何子 Canvas\n计算 Batch 要求按照深度排序网格，测试它们是否有重叠，共享材质等等。这个过程是多线程的，在不同的 CPU 架构下性能表现非常不同，特别是在手机芯片（通常 CPU 核心很少）和现代桌面 CPU（通常拥有四核心或者更多）之间非常不同\n\nRebuild 过程（Graphics）Rebuild 过程是指 Layout 和 UGUI 的 C# 的 Graphic 组件的网格被重新计算，这是在 CanvasUpdateRegistry 类中执行的。这是一个 C＃类，它的源码可以在 Unity 的 Bitbucket 上找到。CanvasUpdateRegistry 类中，PerformUpdate 方法，当一个 Canvas 组件触发它的 WillRenderCanvases 事件时，这个方法就会被执行。这个事件每帧调用一次。PerformUpdate 函数运行的三个步骤：\n\n通过 ICanvasElement.Rebuild 函数，请求 rebuild 被 Dirty 的 Layout 组件\n所有被注册的裁剪组件（例如 Mask），对需要被裁剪的组件进行剔除。这在 ClippingRegistry.Cull 中执行\ndirty 的 Graphic 组件被要求 rebuild 其图形元素\n\nLayout 和 Graphic 的 Rebuild\nLayout Rebuild 要重新计算一个或者多个 Layout 组件所包含的 UI 组件的适当位置（以及可能的大小），有必要对 Layout 应用层次的排序。在 GameObject 的 hierarchy 中靠近 root 的 Layout 可能会影响改变嵌套在它里面的其他 Layout 的位置和大小，所以必须首先计算。 为此，UGUI 根据层次结构中的深度对 dirty 的 Layout 组件列表进行排序。层次结构中较高的 Layout（即拥有较少的父 transform）将被移到列表的前面。然后，排序好的 Layout 组件的列表将被 rebuild，在这个步骤 Layout 组件控制的 UI 元素的位置和大小将被实际改变\nGraphic Rebuild 当 Graphic 组件被 rebuild 的时候，UGUI 将控制传递给 ICanvasElement 接口的 Rebuild 方法。Graphic 执行了这一步，并在 rebuild 过程中的 PreRender 阶段运行了两个不同的 rebuild 步骤：\n如果顶点数据已经被标为 Dirty（例如组件的 RectTransform 已经改变大小），则重建网格\n如果材质数据已经被标为 Dirty（例如组件的 material 或者 texture 已经被改变），则关联的 Canvas Renderer 的材质将被更新。Graphic 的 Rebuild 不会按照 Graphic 组件的特殊顺序进行，也不会进行任何的排序操作\n\n\n\n前向渲染和延迟渲染  正向渲染  正向渲染 (Forward Rendering) 或者正向着色法 (Forward Shading)，它是我们渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。它非常容易理解，也很容易实现，但是同时它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个需要渲染的片段进行迭代，这是非常多的！因为大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度（多个物体重合在一个像素上）浪费大量的片段着色器运行时间。延迟着色法 (Deferred Shading)，或者说是延迟渲染 (Deferred Rendering)，为了解决上述问题而诞生了，它大幅度地改变了我们渲染物体的方式\n延迟着色法基于我们延迟 (Defer) 或推迟 (Postpone) 大部分计算量非常大的渲染（像是光照）到后期进行处理的想法。它包含两个处理阶段 (Pass)：\n\n在第一个几何处理阶段 (Geometry Pass) 中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做 G 缓冲 (G-buffer) 的纹理中；位置向量 (Position Vector)、颜色向量 (Color Vector)、法向量 (Normal Vector) 和 / 或镜面值 (Specular Value)。场景中这些储存在 G 缓冲中的几何信息将会在之后用来做（更复杂的）光照计算。下面是一帧中 G 缓冲的内容\n\n\n    \n\n\n\n第二个光照处理阶段 (Lighting Pass) 中使用 G 缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用 G 缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对 G 缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和我们以前一样，但是现在我们需要从对应的 G 缓冲而不是顶点着色器（和一些 uniform 变量）那里获取输入变量了\n\n\n    \n\n\n这种渲染方法一个很大的好处就是能保证在 G 缓冲中的片段和在屏幕上呈现的像素所包含的片段信息是一样的，因为深度测试已经最终将这里的片段信息作为最顶层的片段。这样保证了对于在光照处理阶段中处理的每一个像素都只处理一次\n当然这种方法也带来几个缺陷， 由于 G 缓冲要求我们在纹理颜色缓冲中存储相对比较大的场景数据，这会消耗比较多的显存，尤其是类似位置向量之类的需要高精度的场景数据。 另外一个缺点就是他不支持混色（因为我们只有最前面的片段信息）， 因此也不能使用 MSAA 了\nG 缓冲G 缓冲 (G-buffer) 是对所有用来储存光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。在正向渲染中照亮一个片段所需要的所有数据：\n\n一个 3D 位置向量来计算（插值）片段位置变量供 lightDir 和viewDir使用\n一个 RGB 漫反射颜色向量，也就是反照率 (Albedo)\n一个 3D 法向量来判断平面的斜率\n一个镜面强度 (Specular Intensity) 浮点值\n所有光源的位置和颜色向量\n玩家或者观察者的位置向量\n\n光源的位置，颜色，和玩家的观察位置可以通过 uniform 变量来设置，但是其它变量对于每个对象的片段都是不同的。如果我们能以某种方式传输完全相同的数据到最终的延迟光照处理阶段中，我们就能计算与之前相同的光照效果了\nwhile(...) // 游戏循环{    // 1. 几何处理阶段：渲染所有的几何 / 颜色数据到 G 缓冲     glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    gBufferShader.Use();    for(Object obj : Objects)    {        ConfigureShaderTransformsAndUniforms();        obj.Draw();    }      // 2. 光照处理阶段：使用 G 缓冲计算场景的光照    glBindFramebuffer(GL_FRAMEBUFFER, 0);    glClear(GL_COLOR_BUFFER_BIT);    lightingPassShader.Use();    BindAllGBufferTextures();    SetLightingUniforms();    RenderQuad();}\n\n延迟光照处理阶段  现在我们已经有了一大堆的片段数据储存在 G 缓冲中供我们处置，我们可以选择通过一个像素一个像素地遍历各个 G 缓冲纹理，并将储存在它们里面的内容作为光照算法的输入，来完全计算场景最终的光照颜色。由于所有的 G 缓冲纹理都代表的是最终变换的片段值，我们只需要对每一个像素执行一次昂贵的光照运算就行了。这使得延迟光照非常高效，特别是在需要调用大量重型片段着色器的复杂场景中\n网易 C++ 构造函数可以是虚函数吗 为什么构造函数不可以是虚函数  从内存的角度看  虚函数对应一个虚函数表，虚函数表是存储在对象的内存空间中的。而调用虚函数使用过调用虚函数表来实现的。如果构造函数是虚函数，那么就需要通过虚函数表来调用，但是对象是通过构造函数实例化的，在调用构造函数之前，虚函数表内存空间还没有被创建，无法找到虚表。所以构造函数不能是虚函数\n从使用的角度看  虚函数是通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。但是构造函数是通过创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以规定构造函数不能是虚函数\n为什么析构函数可以是虚函数  一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++ 不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于基类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。C++ 不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和 C 语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员\n渲染流程，CPU 阶段的剔除操作有哪些  剔除有视锥体剔除（Frustum Culling）、层级剔除（Layer Culling Mask）、遮挡剔除（Occlusion Culling）等步骤，目的是将不想被摄像机看到的物体剔除掉，减少不必要的性能开销，提高渲染效率\n视锥体剔除  在 Unity 中，摄像机的可视区域是一个横放的金字塔形称为视锥体，由近裁面、远裁面、视场角三个参数控制，通过计算这个视锥体与场景中的模型是否相交，没有相交就说明位于可视区域外，这样的模型就应该进行剔除\n\n    \n\n\n由于模型一般面数较多，因此会采用给模型创建包围体再计算包围体与可视区域是否相交的方式简化计算。包围体有多种计算方法，常用的有 OBB（Oriented Bounding Box，有向包围盒）、AABB（Axis-Aligned Bounding Box，轴对齐包围盒）、球形包围体（外接球）等，其中 AABB 因为计算方便而更为常用\n\n    \n\n\n层级剔除Unity 中的模型可以设置自身所处的层级（Layer），而摄像机则可以设置需要剔除掉的层级，从而跳过特定物体的渲染\n\n    \n\n\n遮挡剔除  在渲染时，如果物体有前后顺序并且后方的物体完全被前方物体遮挡住，此时后方物体在摄像机中完全看不见，也就没有必要进行计算，可以进行剔除\n\n    \n\n\nLRU 算法LRU（Least recently used，最近最少使用）是缓存置换策略中的一种常用的算法。其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存队列已满时，新的元素加入队列时，需要从现有队列中移除一个元素，LRU 策略就是将最近最少被访问的元素移除，从而腾出空间给新的元素。\n当对 key 进行访问时（一般有查询，更新，增加，在 get() 和set()两个方法中实现即可）时，将该 key 放到队列的最前端（或最后端）就行了，这样就实现了对 key 按其最后一次访问的时间降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。\n普通实现  借助于普通 dict 和 list 来实现，dict 保存键值对，list 保证插入的有序（借助列表来记录插入的顺序）\n# 基于普通 dict 和 list 实现class LRUCache(object):    def __init__(self, size=5):        self.size = size        self.cache = dict()        self.key_list = []     def get(self, key):        if key in self.cache:            self.key_list.remove(key)            self.key_list.insert(0, key)            return self.cache[key]        else:            return None     def set(self, key, value):        if key in self.cache:  # 更新            self.key_list.remove(key)          elif len(self.cache) == self.size:  # 删除插入            old_key = self.key_list.pop()            self.cache.pop(old_key)        self.cache[key] = value       # 一般插入        self.key_list.insert(0, key)\n\n使用 hash 表来定位结点位置，get()和 set() 的时间复杂度均为，空间复杂度为\n借助OrderedDictpython 中有一个标准库的类的OrderedDict（有序字典），该类有以下两个方法用来实现 LRU 算法就十分简单：\n\npopitem(last=True)：有序字典的 popitem() 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对\nmove_to_end(key, last=True)：将现有 key 移动到有序字典的任一端。 如果 last 为真值（默认）则将元素移至末尾；如果 last 为假值则将元素移至开头。如果 key 不存在则会触发 KeyError`\n\nfrom collections import OrderedDict, defaultdict class LRU:    def __init__(self, capacity=128):        self.capacity = capacity    # 缓存容量        self.cache = OrderedDict()  # 有序字典缓存     def put(self, key, value):        if key in self.cache:            # 若数据已存在，表示命中一次，需要把数据移到缓存队列末端            self.cache.move_to_end(key)            return        if len(self.cache) &gt;= self.capacity:            # 若缓存已满，则需要淘汰最早没有使用的数据            self.cache.popitem(last=False)        # 录入缓存        self.cache[key]=value     # 遍历 key    def travel(self):        for key in self.cache.keys():            print(key)     def get(self, key):        if key in self.cache:            val = self.cache.pop(key)            self.cache[key] = val        else:            val = None         return val\n\n缓存算法 FIFO 算法 如果一个数据最先进入缓存，则应该最早淘汰掉\n\nget(key)：如果 Cache 中存在该 key，则返回对应的 value 值，否则，返回 -1\nset(key,value)：如果 Cache 中存在该 key，则重置 value 值；如果不存在该 key，则将该 key 插入 Cache，若 Cache 已满，则淘汰最早进入 Cache 的数据\n\nLRU：Least Recently used如果数据最近被访问过，那么将来被访问的几率也更高\nLFU：Least Frequency Used如果数据过去被访问多次，那么将来被访问的频率也更高。注意 LFU 和 LRU 的区别，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数\n为了能够淘汰最少使用的数据，LFU 算法最简单的一种设计思路就是：利用一个数组存储数据项，用 hashmap 存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来，在插入数据和访问数据的时候都能达到  的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为 。 另外还有一种实现思路就是利用小顶堆 +hashmap，小顶堆插入、删除操作都能达到  时间复杂度，因此效率相比第一种实现方法更加高效\n骏梦 Unity 资源管理 在 Unity 中，一般来说，资源加载方式主要分为 Resources 加载和 AssetBundle 加载。Unity 有个特殊文件夹 Resources，放在这个文件夹下的资源可以通过 Resources.Load() 来直接加载。即 Resources 加载资源方式。当获得 AssetBundle 之后，也可以调用 AssetBundle 对应 的 API 来加载资源\nAB 包全名 AssetBundle（资源包）。是一种 Unity 提供的用于存放资源的包。通过将资源分布在不同的 AB 包中可以最大程度地减少运行时的内存压力，并且可以有选择地加载内容\n为什么要用 AB 包\n热更新（要热更新需要确保 AB 包打出来的资源具有唯一性，且相同资源的 AB 包检验码相同）\nResources 加载虽然简单方便，但是也有很多问题\n对内存管理造成一定的负担\n在打开应用时加载时间很长\nResources 文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型 AB 包有什么问题它就有什么问题），对资源优化有一定的限制\n不建议大量使用 Resources\n\n\n\n获取 AB 包方法AssetBundle.LoadFromFile(string path)AssetBundle.LoadFromFileAsync(string path)AssetBundle.LoadFromMemory(byte[] binary)AssetBundle.LoadFromMemoryAsync(byte[] binary)AssetBundle.LoadFromStream(Stream stream)AssetBundle.LoadFromStreamAsync(Stream stream)WWW.AssetBundle\n\n\nLoadFromFile是从文件中加载 AB 包，它从一个给定的路径来加载 AB 包。如果 AB 包是 LZ4 加载方式，它只会加载 AB 包的 Header，之后需要什么资源再加载那部分的 AB 包 chunk。极大的减少了内存占用。\nLoadFromFileAsync是它的异步版本\n\n\nLoadFromMemory是从内存中加载 AB 包，它从内存中的 byte[] 中加载 AB 包。它会完整的把 AB 包加载出来\nLoadFromMemoryAsync是它的异步版本\n\n\nLoadFromStream是从流中加载 AB 包，它从一个 Stream 中加载 AB 包。跟 LoadFromFile 一样，如果 AB 包是 LZ4 加载方式，它也是只会加载 AB 包的 Header。\nLoadFromStreamAsync是它的异步版本\n\n\nWWW 是 Unity 中的跟网络相关的类，可以通过该类从网络中下载资源，之后加载成 AB 包\n\n加载资源方法AssetBundle.LoadAsset(string assetName, Type resType)AssetBundle.LoadAssetAsync(string assetName, Type resType)\n\nLZMA 和 LZ4LZMA 是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载 AB 包时，需要将整个包解压，会造成卡顿和额外内存占用。\nLZ4 是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。如果需要实时解压随机读取，块压缩是比较好的选择。LoadFromFile()和 LoadFromStream() 都只会加载 AB 包的 Header，相对 LoadFromMemory() 来说大大节省了内存\n内存占用 AB 包内的资源需要通过AssetBundle.Load() 来加载到内存中\n\n对于 GameObject 来说，通常情况下需要对其进行改动，所以它是完全复制一份该资源来进行的实例化。也就是说，当 AB 包中的 GameObject 从内存中卸载后，实例化的 GameObject 不会因此丢失。并且对实例化对象的修改不会影响到 GameObject 资源\n对于 Shader 和 Texture 来说，通常情况下不需要对其进行改动，所以它是通过引用来进行的实例化。也就是说，当 AB 包中的 Shader 和 Texture 资源从内存中卸载后，实例化的 Shader 和 Texture 会出现资源丢失的情况。并且对实例化对象的修改会影响到 Shader 和 Texture 资源\n对于 Material 和 Mesh 来说，有时候可能需要对其进行改动，所以它是通过引用 + 复制来进行的实例化。也就是说，当 AB 包中的 Material 和 Mesh 资源从内存中卸载后，实例化的 Material 和 Mesh 会出现资源丢失的情况。并且对实例化对象的修改不会影响到 Material 和 Mesh 资源\n\n\nAB 包先要从硬盘或者网络中加载到内存中，然后将 AB 包内的每一份资源加载到内存中，再之后在内存中实例化这些资源。每种资源有其自己不同的实例化方式，卸载资源的时候需要注意\n\nAB 包内部结构\nAssetBundleFileHeader：记录了版本号、压缩等主要描述信息\nAssetFileHeader：包含一个文件列表，记录了每个资源的 name、offset、length 等信息\nAsset1：\nAssetHeader：记录了 TypeTree 大小、文件大小、format 等信息\nTypeTree（可选）：记录了 Asset 对象的 class ID。Unity 可以用 class ID 来序列化和反序列化一个类（每个 class 对应了一个 ID，如 0 是 Object 类，1 是 GameObject 类等，具体可在 Unity 官网上查询）\nObjectPath：记录了 path ID（资源唯一索引 ID）等\nAssetRef：记录了 AB 包对外部资源对引用情况\n\n\nAsset2\n…\n\n依赖问题  依赖问题，通俗的话来说就是 A 包中某资源用了 B 包中的某资源。然而如果 A 包加载了，B 包没有加载，这就会导致 A 包中的资源出现丢资源的现象。在 Unity5.0 后，BuildAssetBundleOptions.CollectDependencies永久开启，即 Unity 会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。因为这个特性，有些情况下，如果没指定某公共资源的存放在哪个 AB 包中，这个公共资源就会被自动打进引用它的 AB 包中，所以出现多个不同的 AB 包中有重复的资源存在的现象。这就是资源冗余。\n要防止资源冗余，就需要明确指出资源存放在哪个 AB 包中，形成依赖关系。所以对于一些公共资源，建议单独存放在一个 AB 包中。在加载的时候，如果 AB 包之间相互依赖，那么加载一个 AB 包中的资源时，先需要加载出另一个 AB 包的资源。这样就会导致不必要的消耗。所以说尽可能地减少 AB 包之间的依赖，并且公共资源尽量提前加载完成\n细粒度问题  细粒度问题即每个 AB 包分别放入多少资源的问题，一个好的策略至关重要。加载资源时，先要加载 AB 包，再加载资源。如果 AB 包使用了 LZMA 或 LZ4 压缩算法，还需要先给 AB 包解压。\n\nAB 包数量较多，包内资源较少；AB 包数量较少，包内资源较多\n加载一个 AB 包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长；加载一个 AB 包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快\n热更新灵活，要更新下载的包体较小；热更新不灵活，要更新下载的包体较大\nIO 次数过多，增大了硬件设备耗能和发热压力；IO 次数不多，硬件压力小\n\n简单策略：\n\n经常更新和不经常更新的对象拆分到不同的 AB 包中\n同时加载的对象放在一个 AB 包中\n不可能同时加载的对象拆分到不同的 AB 包中\n根据项目逻辑功能来分组打 AB 包\n根据同一类型对象来分组打 AB 包\n公共资源和非公共资源拆分到不同的 AB 包中\n\n卸载问题\n当调用 Resources.UnloadAsset() 时，虽 Object 被销毁，但 Instance ID 被保留且包含有效的 GUID 和 Local ID 引用\n当调用 AssetBundle.Unload(true) 时，不仅 Object 被销毁，而且 Instance ID 的 GUID 和 Local ID 引用变无效\n当调用 AssetBundle.Unload(false) 时，虽 Object 不被销毁，但 Instance ID 的 GUID 和 Local ID 引用变无效。场景中的物体会与该 AB 包分离链接。即该物体的 Instance ID 引用的 GUID 和 Local ID 会断开引用，无法再通过该 Instance ID 找到 GUID 和 Local ID\n如果再次加载该 AB 包时，分离了链接的物体不会受该新加载的 AB 包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity 中有 Resources.UnloadUnusedAssets() 方法可以很好地解决这个问题\n\n各种 ID\n序列化后，资源用 GUID 和 Local ID 管理\nGUID 对应 Asset，GUID 存在。meta 文件中，提供了文件特定位置的抽象，是一种映射，无需关心资源在磁盘上的存放位置\nLocal ID 对应 Asset 内的每一个 Object\n虽然 GUID 和 Local ID 比较好用，但是毕竟因为存在磁盘上，读取比较耗时。因此 Unity 缓存一个 Instance ID 对应 Object，通过 Instance ID 快速找到 Object。Instance ID 是一种快速获取对象实例的 ID，包含着对 GUID 和 Local ID 的引用。解析 Instance ID 可以快速返回 Instance 表示的已加载对象，如果为加载目标对象，则可以将文件 GUID 和 Local ID 解析为对象源数据，从而允许 Unity 即时加载对象。每次 AB 包重新加载时，都会为每个对象创建新的 Instance ID\n\nLua 弱表  弱表是用来告诉 Lua 虚拟机，被弱表引用的对象，不应该阻止他们被 gc 回收。与弱表相对的是强表。对于强表来说，所有被强表引用到的 gc 对象，都会被标记，从而不会被 gc 机制回收，哪怕这些变量再也没被使用到。因此，对于强表来说，如果你希望被它引用的对象能够被 gc 回收，那么你需要将它的值设置为 nil。对于弱表来说，但凡被设置为弱引用的对象，均不会被 gc 标记，当再也没有其他地方引用该对象时，它们会从弱表中被清除\nt = {}-- 使用一个 table 作为 t 的 key 值key1 = {name = \"key1\"}t[key1] = 1key1 = nil-- 又使用一个 table 作为 t 的 key 值key2 = {name = \"key2\"}t[key2] = 1key2 = nilfor key, value in pairs(t) do    print(key.name .. \":\" .. value)end-- 强制进行一次垃圾收集-- 此时 key1 和 key2 表都被置 nil，但是并没有被强制回收，换句话说，虽然 key1 本身为 nil，但是他先前指向的内容并没有被删除，因为这个内容被保存在了 t 中collectgarbage()for key, value in pairs(t) do    print(key.name .. \":\" .. value)end\n\nt = {}-- 给 t 设置一个元表，增加__mode 元方法，赋值为 \"k\"setmetatable(t, {__mode = \"k\"});-- 使用一个 table 作为 t 的 key 值key1 = {name = \"key1\"}t[key1] = 1key1 = nil-- 又使用一个 table 作为 t 的 key 值key2 = {name = \"key2\"}t[key2] = 1key2 = nilfor key, value in pairs(t) do    print(key.name .. \":\" .. value)end-- 强制进行一次垃圾收集collectgarbage()for key, value in pairs(t) do    print(key.name .. \":\" .. value)end\n\n以上代码在创建了表 t 后，立即将 t 设置为元表，元表里面有一个 __mode 字段，值为 k，在执行collectgarbage() 之前，能够输出 t 中的元素，但是执行垃圾回收之后，就不能再次输出 t 中的元素的，这是因为将表设置为元表后，通过 __mode = \"k\" 将其指定为对键的弱引用，也就是说，一旦表中的某个键被垃圾回收，t中会删除这个键对应的元素\n弱表的用途\n缓存机制添加自动回收功能  当外部通过 getFromCache 获取到 tbl[key] 的值之后，如果一直持有，那么这个值就会一直在 tbl 缓存中，如果外部不再引用 tbl[key] 值时，那么它会在下一轮 gc 的时候从 tbl 被清理。这样，我们就不用去实现相对复杂的 LRU 机制，来对 tbl 的内存进行限制和处理了\n\nlocal mt = {__mode=\"v\"}local tbl = setmetable({}, mt)local function getFromCache(key)    if tbl[key] then        return tbl[key]    end    tbl[key] = loadFromDB(key)    return tbl[key]end\n\n\n弱表实现默认值\n\nlocal defaults = {}setmetatable(defaults, {__mode = \"k\"})local mt = {__index = function(t) return defaults[t]  end} function setDefault(t, d)    defaults[t] = d    setmetatable(t, mt)end\n\nlocal metas = {}setmetatable(metas, {__mode = \"v\"}) function setDefault(t, d)    local mt = metas[d]    if mt == nil then        mt = {__index = function() return d  end}        metas[d] = mt    end    setmetatable(t, mt)end\n\nC# 委托和 event 区别  委托 delegate 其实就是函数的模版，这个模版可以用来放入各种格式和他相同的函数，也就是这些真实函数的引用  当声明委托时，在编译阶段会自动生成一个类，并且继承自 MulticastDelegate，MulticastDelegate 继承自 Delegate。当对委托+= 操作时候其实是调用了 Delegate.Combine() 函数，当对委托 -= 操作时候其实是调用了 Delegate.Remove() 函数，一旦执行Invoke，便调用所有的回调函数\n事件就是委托的一种特殊封装，事件本身其实就是一种特殊的委托。如果加了 event 的情况下，在其他类中使用带 event 字段的委托是不能直接使用 = 赋值符号的，只能使用 +=，注意这里说的是其他类中，如果直接在声明event 的类中还是可以直接使用 = 赋值的，当在委托声明的时候加了 event 字段之后，直接赋值的操作会变成 private 权限，那么自然在其他类中就无法直接赋值了，+=和 -= 重写变成了 add 和remove的方法，是 public 的，所以可以在外部调用\nLambda 表达式的捕获变量 Lambda 表达式可以捕获其所在作用域中的变量。这些变量将作为 Lambda 表达式的外部变量，在 Lambda 表达式内部被引用。但是，Lambda 表达式只能捕获引用类型的变量，而不能捕获值类型的变量（除非阀门是局部变量并且被标记为readonly 或在 Lamda 表达式之前赋值）\nLua 空表大小\ndebug.tablemem(t)函数用于获取 table 自身占用内存空间的大小，该函数返回四个字段：table占用内存大小、数组部分长度、以 2 为底哈希表部分长度的对数、哈希表部分是否为假节点。debug.tablemem\n\nlocal tbl = {}print(debug.tablemem(tbl)) --&gt; 56   0   0   true\n\n// luaobject.htypedef union lua_Value {    struct GCObject* gc;    void* p;    int b;    lua_Interger i;    lua_Number n;    lua_CFunction f;} Value;typedef struct lua_TValue {    Value value_;    int tt_;} TValue;// lua Tabletypedef union TKey {    struct {        Value value_;        int tt; // 用来标记 value_是什么类型        int next;    } nk;    TValue tvk;} TKey;typedef struct Node {    TKey key;    TValue value;} Node;struct Table {    CommonHeader;               // GC 部分    TValue* array;              // 数组部分    unsigned int arraysize;     // 数组大小    Node* node;                 // hash 部分    unsigned int lsizenode;     // hash 大小，实际大小为 2&lt;sup&gt;lsizenode    Node* lastfree;             // 空闲指针    struct GCObject* gclist;    // GC 部分}\n\nC# 字典原理private int[] buckets;  // Hash 桶private Entry[] entries; // Entry 数组，存放元素\n\n字典内部有两个主要的数组\n\nEntry结构体数组：其中存储 hash 值、键值对、发生冲突指向的上一个 Entry 位置\nbuckets数组：存放对应 Entry 下标\n\nC# 变量赋值\n值类型变量的赋值： 值类型变量中保存的是实际数据，在赋值的时候只是把数据复制一份，然后赋给另一个变量\n\nint var1 = 2;int var2 = var1; // 编译器会先复制 var1 的值，然后把它赋给 var2. 很明显 var2 的值也为 2\n\n\n引用类型变量的赋值： 引用类型变量中保存的是“指向实际数据的引用指针”。在进行赋值操作的时候，它和值类型一样，也是先有一个复制的操作，不过它复制的不是实际的数据，而是引用（真实数据的内存地址）所以引用类型的变量在赋值的时候，赋给另一变量的实际上是内存地址\n\nclass MyClass{    public int val;}struct MyStruct {    public int val;}class Program {    static void Main(string[] args)    {        MyClass objectA = new MyClass();        MyClass objectB = objectA; // 引用变量的赋值 赋值操作完成后，两个变量都指向同一内存地址         objectA.val = 10; // 给 objectA.val 赋值 =10 由于 objectB 和 objectA 指向同一内存地址，所以 ojbectB.val 的值也为 10        objectB.val = 20; // 给 objectB.val 赋值 =20 由于 objectB 和 objectA 指向同一内存地址，所以 objectA.val 的值也为 20        MyStruct structA = new MyStruct();        MyStruct structB = structA; // 结构是值类型 赋值操作完成后，两个结构中的结构信息一致。注意是“结构中的信息”一致。        structA.val = 30;        structB.val = 40;        Console.WriteLine(\"objectA.val={0}\", objectA.val); // 输出结果是 20        Console.WriteLine(\"objectB.val={0}\", objectB.val); // 输出结果是 20        Console.WriteLine(\"structA.val={0}\", structA.val); // 输出结果是 30        Console.WriteLine(\"structB.val={0}\", structB.val); // 输出结果是 40    }}\n\n腾讯Unity 中影响渲染顺序的因素\n    \n\n\n\nCanvas\n不同 Canvas 之间可以用以下两个属性控制渲染层级\nSorting Layer\nOrder in Layer\n\n\n\n\nHierarchy 中顺序\n在同一个 Canvas 中，Hierarchy 的顺序决定了控件的层级关系\n\n\n\n模型深度的控制\n空间深度：对于 3D 物体的显示先后就是完全按空间的先后来的，当然可以在 fragment shader 中关闭深度测试，或进行其他影响帧缓冲区的操作\nRenderQueue：RenderQueue 是对 unity 中所有可以渲染的物体都适用\n\n粒子特效渲染层级的控制\n空间深度：和 3D 模型一致\nRenderQueue：和 3D 模型一致\nSorting Order：粒子系统本身是一个 Renderer 组件，它渲染的是一个一个精灵，是一个一个片，该属性有效\n\nC# 垃圾回收  检查回收对象GC 能够了解某个实体目前是否依旧被应用程序的某些活动对象所引用；对于那些没有被任何活动对象直接或间接引用的对象，GC 会将其判断为垃圾。GC 在其专门的线程中运行，默默地为程序清除不再使用的内存。压缩托管堆（将当前仍旧使用的对象放在连续的内存中，可以利用局部性原理提高性能），因此空余的空间也会是一块连续的内存\n垃圾回收器采用的是 mark-and-compact 算法（标记和更改对象的同步块索引中的一个位 bit），在执行垃圾回收的时候，GC 不是枚举所有访问不到的对象；相反，它是通过压缩所有相邻的可达对象来执行垃圾回收。这样，由不可访问的对象占用的内存就会被覆盖\n代  自上一次垃圾收集以来，新创建的对象属于第 0 代对象，而若是某个对象在经过过一次垃圾收集之后仍旧存活，那么它将成为第 1 代对象。两次及两次以上垃圾收集后仍旧没有被销毁的对象就变成了第 2 代对象。（第 0 代对象大多属于局部变量，而成员变量和全局变量（CLR 允许全局变量的定义，即便 C# 中不支持）则会很快成为第 1 代对象，直至第 2 代）\n每一代都会有一个预算容量（以 KB 为单位），如果分配一个新对象造成超出预算，就会启动一次垃圾回收。CLR 垃圾回收器是自调节的，所以会根据回收垃圾对象的数量动态设置预算容量的大小。 一般来说，大概 10 个周期的 GC 中，会有一次同时检查第 0 代和第 1 代对象，大概 100 个周期的 GC 中，会有一次同时检查所有对象\n非托管资源 .Net 提供了两种控制非托管资源生命周期的机制：终结器（finalizer）和 IDisposable 接口\n终结器\n终结器将由 GC 调用，调用将发生在对象成为垃圾之后的某个时间（无法确定其发生的具体时间），因此 .Net 并不能保证析构操作的确切时间\n依赖终结器还会带来性能上的问题。当 GC 发现某个对象属于垃圾，但该对象需要执行终结操作时（定义了析构函数），就不能将其直接从内存中移除。首先，GC 将调用其终结器，而终结器并不在执行垃圾收集的线程上执行。GC 将把所有需要执行终结的对象放在专门的队列中，然后让另一个线程来执行这些对象的终结器。这样，GC 可以继续执行其当前的工作，在内存中移除垃圾对象。而在下一次的 GC 调用时，才会从内存中移除这些已被终结的对象。因此需要调用终结器的对象将在内存中多停留一次 GC 周期的时间，如果终结对象进入第 1 代或第 2 代，那么将停留更长的 GC 周期\n\n因此，尽量不要使用终结器来释放非托管资源\nIDisposable接口 IDisposable.Dispose() 方法的实现中需要完成如下 4 个任务\n\n释放所有非托管资源\n释放所有托管资源，包括释放事件监听程序\n设置一个状态标志，表示该对象已经被销毁，若是在销毁之后再次调用对象的公有方法，那么应该抛出 ObjectDisposed异常。\n跳过终结操作，调用 GC.SuppressFinalize(this) 即可\n\n由于很多非托管资源都非常宝贵（如数据库和文件句柄），所以它们应尽可能快地被清除，而不能依靠垃圾回收的发生。.Net 中使用了一种标准的模式能够在使用者正常调用是通过 IDisposable 接口释放掉非托管资源，也会在使用者忘记的情况下使用终结器释放。这个模式和 GC 配合，可以保证仅在最糟糕的情况下才调用终结器，尽可能降低其带来的性能影响\n如何进行内存优化\n类中存在空的 Update、LateUpdate 和FixedUpdate方法\nUnity 中的脚本其实默认都是继承自这个 Monobehavior。Update、LateUpdate 和FixedUpdate属于 Monobehaviour 类的“Messages”，虽然不由 Monobehavior 类继承而来，但是在 Monobehaviour 类的脚本中会生效——如果脚本中写上了这些方法，相应的脚本放到场景中，并且 enable 为true，那么游戏运行过程中每帧都会对其进行调用。即使这些方法为空，在运行时，它们依然会因为被调用而造成 CPU 时间的开销，其原因主要有两点\n\n这些方法是 Native 层对托管层的调用，C++ 与 C# 之间的通信本身存在一定的开销\n当调用这些方法时，Unity 会进行一系列安全检测（比如确保 GameObject 没有被销毁等）导致 CPU 时间的消耗\n\n\n对纹理 SetPixels 的调用\nSetPixels可用于对纹理特定的 mipmap 层的像素进行修改，它会将一组数组的像素值赋值到贴图的指定 mipmap 层，调用 Apply() 后会将像素传至显卡。需注意的是，由于 Color32 比Color类型所占的空间更小，使用 SetPixels32 比SetPixels造成的 CPU 耗时也更小。所以在效果允许的情况下，我们推荐使用 SetPixels32() 方法来取代SetPixels()\n\n从内存分配上讲，该函数会在托管堆中分配内存，用以存储纹理数据的像素信息，但引擎不会对其进行缓存。所以如果在频繁调用的函数中使用，就会造成持续性的堆内存分配\n从耗时上讲，擅长执行大规模并行运算的 GPU 来处理图片信息是非常容易的，但 CPU 在进行逐个像素信息的获取时，就显得有些吃力了。并且 GetPixels() 在实现上是由 CPU 同步执行的，所以耗时会较高，同时会阻塞调用的线程，从而可能会造成卡顿。因此在非必要的情况下，并不建议使用GetPixels()\n\n\nGetComponentsInChildren和 GetComponentsInParent 的调用\nGetComponentsInChildren用于获得  当前 GameObject 及其  子节点  的所有给定类型的组件，返回的是一个包含所有符合条件的对象的数组；而 GetComponentsInParent 则是用于获得  当前  对象及其  父节点  上的所有给定类型的组件\n这两者的使用都会涉及到较大范围内的搜索遍历，会挤占 CPU 较大的计算资源，所以应当尽量减少相关的调用，可以尝试缓存调用的结果，避免使其出现在 Update 这样的频繁调用的函数当中。此外，对于这两个函数，建议使用接受 List 类型的引用作为参数的版本，这样就可以避免每次调用都造成堆内存的分配\n\nLinq相关函数的调用\nLinq相关的函数一般都用于对数据的查询和处理。功能上简单来讲，就是对一堆数据进行各种 if 判断和 for 循环处理。使用 Linq 提供的 API，可以写出 SQL 语句风格的代码来进行集合数据的处理，这能够明显提升代码的简明性、可读性，维护上也更方便，从而提升编写效率，但是这些优点是以性能的开销为代价的\nLinq在执行过程中会产生一些临时变量，而且会用到委托（lambda表达式）。如果使用委托作为条件的判定方法，时间开销就会很高，并且会造成一定的堆内存分配。所以在一般的 Unity 游戏项目开发中，不推荐使用 Linq 相关的函数。在编辑器功能开发中，才常常把 Linq 和Reflection进行配合使用\n\n对 Renderer 进行 Material/Materials 的获取\n在 Unity 中，如果对 Renderer 类型调用 .material 和.materials，那么 Unity 就会生成新的材质球实例。其主要影响如下：\n\n通过.material，创建材质实例，并修改属性的方式实现多样的渲染效果，时间开销会较高\n使用相同 Shader，但因为 Material 实例不同的GameObject，所以无法进行合批，导致 Draw Call 增加，变相造成了 CPU 耗时的增加\n每次对新的 GameObject 的Renderer调用 .material，都会生成一个新的Material 实例，且 GameObject 销毁后，Material实例无法自动销毁，这会对资源管理造成一定的成本，想要处理的话就需要手动调用 UnloadUnusedAssets 来卸载，但这样就造成了性能开销；管理不好可能会造成材质球大量冗余甚至泄露，极端情况下甚至会导致过高的内存\n\n\n\nUI 如何降低 Draw Call\n每个单独的材质 / 纹理的渲染一定是会产生 DrawCall 的，将多张小图打包成一个图集，在渲染 UI 时就可使用同一个材质 / 纹理，即可有效降低 Draw Call 的产生\n从功能角度划分图集，例如将公共 UI 打包成一个图集，将每个系统的 UI 分别打成单独的图集，主要原则是将显示上密切相关的图片打包到一起\n避免将无关联的东西打包在一个图集里，特别是那些不可能同时出现的元素，这样不但无法减少 DrawCall，还会增加内存消耗\n控制图集大小，不要让图集太大\n\n\n合并 UI 元素\nUGUI 的渲染过程是通过 Canvas 组件实现的。每个 Canvas 都有一个 Sorting Layer 和一个 Order in Layer 属性，用于控制 UI 元素的渲染顺序。如果 UI 元素在同一个 Sorting Layer 和 Order in Layer 下，它们就会被合并成一个 DrawCall。可以将相同的 UI 元素放在同一个 Sorting Layer 和 Order in Layer 下，以减少 DrawCall 的数量\n\n\n\n合批的规则UGUI 在合批之前，会根据节点的 Depth、Material InstanceID 、Texture InstanceID、RendererOrder 进行排序，之后对相邻的节点进行检测，判断 Material InstanceID 和 Texture InstanceID 是否相同，如果相同则可以进行合批处理，如果这两个 UI 的 Material InstanceID 和 Texture InstanceID 都相同，但是不连续，中间有其他不同 Material InstanceID 或 Texture InstanceID 的 UI 则会打断合批\nDepth 排序\n\n筛选掉 Depth 为 -1 的值，这部分默认不渲染\n判断是否该元素底部是否有物体，如果没有则赋值 Depth 为 0，如果盖住物体（这块是通过 Mesh 进行判断，判断 Mesh 是否相交）则等于底部盖住的 UI 元素中 Depth 最大的值 +1\n如果两个相邻元素通过了合批测试，则这两个相邻元素的深度值相等\n\n深度排序之后，就会根据 Texture InstanceID 进行排序，如果材质相同则对 Texture InstanceID 进行排序，如果也相同，那会根据 Inspection 面板上的 RendererOrder，最后真正进行 UI 的合批\nMask 影响合批\n在 StencilMaterial.Add 的时候为这个节点增加了一个新的材质，导致了 Mask 内的物体无法和外部同样材质的物体合批\nMask 会进行两次 Pass，第一步是对在模板缓冲中的值进行赋值，将要显示的部分缓存值设置为 1，不显示的部分设置为 0，在第二个 Pass 绘制时对模板缓冲值为 0 的部分进行剔除，所以这两个 Pass 也会带来两个 Draw Call 的生成\n\n所以添加一个 Mask 最起码会增加 3 个 Draw Call\n\n不同的 Mask 之间是可以合批的，虽然 Mask 会对原来的材质进行替换，添加一个新的材质，但是两个 Mask 添加的材质是相同的就支持合批（前提是两个 Mask 不重叠，当他们重叠时，因为被剔除的部分参与了运算，发现 Depth 不同并且 Material InstanceID 也不同，就无法进行合批）\n\nRectMask2D 与 Mask 的区别  和 Mask 不同的是，RectMask2D 并不会产生两额外的 Pass 增加两个 Draw Call 的消耗。RectMask2D 是通过 canvasRender 里面进行了 ClipRect 的剔除，这样相比于 Mask 会带来以下不同\n\nRectMask2D 之间无法进行合批\n被 RectMask2D 隐藏的物体不会参与合批计算\nRectMask2D 组件上挂载的 Image 可以参与外部的合批\n\nLua 中的 pcall 和xpcall\npcall(f, arg1, ···)：在保护模式下，用给定的参数调用函数 f，这意味着f 内部的任何错误，都会被 pcall 捕获，而不会传播出去。pcall的第一个返回值是 boolean 类型的状态码。如果 f 内部没有发生错误，那么 pcall 返回 true 加调用 f(arg, ...) 返回的所有值，否则返回 nil 加错误信息\nxpcall (f, err, ...)：与 pcall 类似，但是可以设置一个错误处理函数。xpcall在保护模式下，用给定的参数调用函数 f，使用err 作为错误处理函数。在 f 内部发生的任何错误，都会被 xpcall 捕获，而不会传播出去。当函数 f 内部发生错误时，会使用原始的错误信息调用 err 函数，xpcall返回 false 加err函数的第一个返回值；否则，返回 true 加调用 f(...) 返回的所有值\n\n雷火  动画资源是如何加载的 Animator 和 Animation 区别GPU Instance 材质相同，材质的参数不同可以进行动态合批吗  状态机和行为树的区别 Playable 的使用 顶点动画  多个实体如何处理动画  快手 Unity 中 C# 与 Lua 的交互Lua 与宿主语言是通过栈进行交互的。在 c 中通常以lua_State* L 的形式表示指向栈的一个指针，在 C# 中以 System.IntPtr L 的形式存在。栈的元素用过 index 进行索引。以负数表示从顶向底索引，以正数表示由底向顶索引\nLua 是获取一个 C# 对象  主要是通过 PushUserObject 来获取\nstatic void PushUserObject(IntPtr L, object o){    Type type = o.GetType();    int reference = LuaStatic.GetMetaReference(L, type);    if (reference &lt;= 0)    {        reference = LoadPreType(L, type);    }                    PushUserData(L, o, reference);}\n\n通过一个 GetMetaReference 方法获取了一个 reference 值，这个是 C# 类导出 Wrap 文件时创建的 Wrap 类对应的元表引用（因为元表是 Lua 的东西，C# 里不能直接获取元表，所以这里只能拿到元表在内存中的引用 Id)\npublic static void PushUserData(IntPtr L, object o, int reference){    int index;    ObjectTranslator translator = ObjectTranslator.Get(L);    if (translator.Getudata(o, out index))    {        if (LuaDLL.tolua_pushudata(L, index))        {            return;        }        translator.Destroyudata(index);    }    index = translator.AddObject(o);    LuaDLL.tolua_pushnewudata(L, reference, index);}\n\nLua 从 C# 获取对象的时候，实际上获取的是一个 userdata，这个 userdata 以 C# 导出的 Wrap 类为元表，以实现 Lua 对 C# 方法的调用。Lua 从 C# 这边获取的对象，都将被缓存到 ObjectTranlator 中的 LuaObjectPool 中\n当 Lua 调用 C# 方法的时候，C# 需要获得对象的实例。通过调用 C API tolua_rawnetobj，从 Lua 调用栈中拿到 userdata 的值，也就是前面说的 LuaObjectPool 中缓存的索引值，根据这个索引值从 ObjectTranslator 中拿回缓存的 C# 对象\nC# 执行 Lua 代码 C# 从 Lua 获取的对象主要是 Lua 方法和table。获取 Lua 方法一般都是 Lua 这边绑定一个方法到 C# 的委托。通过CheckDelegate 方法获取到 Lua 方法对象。调用 ToLuaFunction 从 Lua 栈中获取到方法引用并创建一个对应 C# 的LuaFunction\npublic static LuaFunction ToLuaFunction(IntPtr L, int stackPos){    LuaTypes type = LuaDLL.lua_type(L, stackPos);    if (type == LuaTypes.LUA_TNIL)    {        return null;    }    stackPos = LuaDLL.abs_index(L, stackPos);    LuaDLL.lua_pushvalue(L, stackPos);    int reference = LuaDLL.toluaL_ref(L);    return LuaStatic.GetFunction(L, reference);}\n\nToLuaFunction会创建一个当前栈顶的对象的引用并返回 reference，lua_pushvalue 接口调过之后，将 Lua 方法的栈索引重新压栈，也就是说创建的当前栈顶的引用，这个 reference 现在是指向的是 Lua 方法的栈索引。之后再以这个 reference 调用 GetFunction 方法，获取LuaFunction\npublic LuaFunction GetFunction(int reference){    LuaFunction func = TryGetLuaRef(reference) as LuaFunction;    if (func == null)    {        func = new LuaFunction(reference, this);        funcRefMap.Add(reference, new WeakReference(func));        if (LogGC)            Debugger.Log(\"Alloc LuaFunction name , id {0}\", reference);          }    RemoveFromGCList(reference);    return func;}\n\n若当前 Lua 方法没有缓存，这里就会以这个 Lua 方法的栈索引引用创建一个 LuaFunction 对象。并缓存到 funcRefMap 中。注意这里缓存的是 LuaFunction 的弱引用对象，这样 LuaFunction 对象就不会因为被 funcRefMap 持有引用而导致无法被 C# GC 回收，也就是说这个 funcRefMap 纯粹是用来做一个缓存，避免同一个 LuaFunction 的反复创建用，不会干扰 LuaFunction 的内存释放。\nGC 的处理  当 Lua 从 C# 获取一个对象的时候，C# 会把这个对象缓存到 ObjectTranslator 中的 LuaObjectPool 中，从而实现 C# 端可以根据 Lua 传递的 Wrap 对应的 userdata 拿回对应的 C# 对象。并且也保证了当 Lua 端持有 userdata 引用的时候 C# 对象不会因为在 C# 端无其它引用而被 C# GC 回收掉。缓存在 ObjectPool 中的引用将会在 lua 端 GC 清理了 userdata 之后，由 userdata 的元方法 __gc 触发移除缓存，从而释放 C# 对象的内存\n当 C# 获取一个 Lua 对象的时候， 将会在 C# 端建立一个 LuaBaseRef 对象，并调用 C API 在 Lua 端创建一个对象引用，并持有在 C 环境，从而保证了在 C# 端持有 Lua 对象的时候，Lua 对象不会因为在 Lua 端无其它引用而被 Lua GC 回收掉。 C API 创建的引用将在 C# 端 GC 清理了 LuaBaseRef 引用或手动调用 Dispose() 方法之后解除，从而释放 Lua 对象的内存\n泊松  笔试 #include &lt;xxx.h&gt;和 #include \"xxx.h\" 有什么差别\n用引号，代表编译程序会优先在程序的本地目录搜索这个文件，找不到再搜索系统目录\n用尖括号，代表编译程序只会在系统目录（系统环境变量和编译本身设置的默认搜索目录）搜索这个文件\n\n被 static 修饰的变量 / 函数有什么作用\n修饰变量\n局部变量\n静态局部变量保存在全局数据区（静态存储区），而不是保存在栈中，每次的值保持到下一次调用，直到下一次赋新值\n静态局部变量值初始化一次；若不赋初值，在初始化的时候会自动赋值为 0；只对定义自己的函数体始终可见；把局部变量改变为静态变量是改变了他的存储方式即改变了他的生存周期\n\n\n全局变量\n全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同\n两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的\n静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它\n\n\n\n\n修饰函数\n如果这个静态函数出现在类里，那么它是一个静态成员函数，调用这个函数不会访问或者修改任何对象（非static）数据成员\n如果它不是出现在类中，那么它是一个普通的全局的静态函数。用 static 修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是 extern 的，也就是说它可以被其它代码文件调用\n\n\n\n在 C++ 工程里面引入 C 语言库的时候为什么要用”extern C”由于 C 和 C++ 编译器对函数的编译处理是不完全相同的，尤其对于 C++ 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的\n例如函数 void fun(int, int) 编译后的可能是 _fun_int_int 不同编译器可能不同，但都采用了相似机制，用函数名和参数类型来命名编译后的函数名；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是 _fun 这样的名字\n说出 const 的作用\n修饰变量\n当 const 修饰变量时，该变量将被视为只读变量，即不能被修改\n\n\n修饰函数参数，表示函数不会修改参数\n修饰函数返回值\nconst修饰函数返回值时，表示函数的返回值为只读，不能被修改。这样做可以使函数返回的值更加安全，避免被误修改\n\n\n修饰指针或引用\n指向只读变量的指针\n只读指针\n只读指针指向只读变量\n常量引用\n\n\n修饰成员函数\n当 const 修饰成员函数时，表示该函数不会修改对象的状态（就是不会修改成员变量）\n\n\n\n字符串拷贝函数的形式是 char* strcpy(char* dst, const char* src) 请编写逻辑实现，并说明为什么要返回 char* 类型char* strcpy(char* dst, const char* src){    assert((dst != nullptr) &amp;&amp; src != nullptr);    char* res = dst;    while ((&amp;dst++ = *src++ != '\\0'))    {    }    return res;}\n\n为了实现链式表达式int length = strlen(strcpy(dst, \"xxxxx\"));\nc++ 工程使用动态链接库，最后一步连接的时候提示找不到符号\n链接时缺失了相关目标文件（.o）\n链接时缺少相关的库文件（.a/.so）\n链接的库文件中又使用了另一个库文件\n多个库文件链接顺序问题\n定义与实现不一致\n在 c++ 代码中链接 c 语言的库\nC++ 中类中静态变量没有在类外初始化\ninline函数\nGCC 的 visibility 属性隐藏\n\n异常会跨线程吗C++ 主线程无法捕获子线程异常\n\n在主线程中声明一个变量，将该变量传递到子线程中\n在子线程抛出异常的时候，修改变量的值为异常值\n然后在主线程中捕获异常\n\n在主线程中声明了一个 std::promiss&lt;void&gt; 类型的变量，并传递到子线程中，然后在子线程中使用 try catch 语句捕获异常然后设置给 std::promise&lt;void&gt; 变量；而在主线程中我们使用 std::future 获取到 std::promise 的future，然后使用 try catch 成功捕捉到设置到 std::promise&lt;void&gt; 变量中的异常\n以下代码有什么问题void getMemory(char** p, int num) {    *p = (char*)malloc(num);}void testMethod() {    char* src=NULL;    getMemory(&amp;src, 100);    strcpy(src, \"hello\");    print(src);}\n\nvoid func() {    std::vector&lt;int&gt; arr = {1,2,3,4,5,6};    for (auto it = arr.begin(); it!=arr.end(); ++it) {        if (*it &gt; 2) {            arr.erase(it);        }    }    for (auto it = arr.begin(); it!=arr.end(); ++it) {        std::cout &lt;&lt;*it &lt;&lt;std::endl;    }}\n\n\n以上代码有什么问题？\n应该怎么修改？\n还有其他类型数据结构会出此类问题吗？\n出现上述问题的本质是什么？\n\nvector 迭代器失效\n当容器调用 erase() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。\n当容器调用 insert() 方法后，当前位置到容器末尾元素的所有迭代器全部失效。\n如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。\n\n编译  编译流程  预处理 Preprocessing在编译器开始编译之前，会先进行预处理。预处理器会处理代码中的所有预处理指令，例如 #include 和 #define 等。它会将这些指令替换成对应的代码，生成一个新的文本文件。这个新的文本文件就是编译器的输入。在预处理的过程中，还会进行条件编译，即根据条件来选择是否编译某些代码块。预处理完成后，会生成一个没有宏定义和条件编译的中间文件\n预处理器的主要作用是解决代码中的宏定义，它会将宏定义展开成对应的代码。此外，预处理器还会处理 #include 指令，将指定的头文件插入到源文件中，以便让编译器能够对头文件中的函数和变量进行编译\n\n预处理器还会在代码中插入记号，使编译器能分辨出每一行来自哪个文件，以便在调试过程中能生成对应的错误信息\n\n编译 Compilation编译器将预处理后的文件作为输入，对其进行词法分析、语法分析和语义分析等处理。这些处理会将代码转化成中间代码，中间代码是一种类似于  汇编语言  的低级代码。编译器将代码分成多个模块，每个模块编译成一个对象文件。在编译的过程中，编译器会对代码进行优化，以提高程序的运行效率和节省内存空间\n汇编 Assembly中间代码会被汇编器转化成机器语言指令，这些指令可以被计算机直接执行。汇编的过程将每个对象文件转换成机器语言的目标文件。每个目标文件包含机器指令和数据，以及其他的控制信息。目标文件可以被链接器用于构建可执行文件\n链接 Linking在编译过程中，可能会用到其他的库文件和对象文件。链接器会将这些文件与生成的可执行文件进行链接，生成最终的可执行文件。链接器的主要任务是解决符号引用问题，即通过在不同的目标文件中查找符号的定义，使得所有的符号都能够正确地被解析和链接。链接器还会对代码进行优化和压缩，以减小可执行文件的体积，并提高程序的运行效率\n静态链接和动态链接  链接过程主要包含了三个步骤\n\n地址与空间分配 Address and Storage Allocation\n符号解析 Symbol Resolution\n重定位 Relocation\n\n两步链接（Two-pass Linking）的方法\n\n地址与空间分配\n扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系\n\n\n符号解析与重定位\n使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位\n\n\n\n\n    \n\n\n地址与空间分配  可执行文件中的 segment 是由目标文件中的 section 合并而来的，对于多个输入目标文件，链接器如何将它们的各个 section 合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件\n按序叠加\n    \n\n\n\n然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86 硬件的对齐要求是 4KB。如果一个节的大小只有 1 个字节，它也要在内存在重用 4KB。这样会造成大量内部碎片。所以不是一个好的方案\n\n合并相似节  一个更加实际的方法便是合并相同性质的 section，比如：将所有输入文件的.text section 合并到输出文件的 text segment\n\n    \n\n\n其中 .bss 节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义：\n\n在输出的可执行文件中的空间\n在装载后的虚拟地址中的空间\n\n对于有实际数据的节，如 .text 和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于 .bss 来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。这里的空间分配只关注于虚拟地址空间的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大\n在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了程序头表（Program Header Table）结构\n\n    \n\n\n链接前目标文件中所有节的 VMA（Virtual Memory Address）都是 0，因为虚拟空间还没有分配。链接后，可执行文件中各个 section 被分配到了相应的虚拟地址。在 Linux x86-64 系统中，代码段总是从 0x0000000000400000 开始的，另外 .text section 之前还有ELF Header、Program Header Table、.init 等占用了一定的空间，所以代码段的地址不是从 0x0000000000400000 开始的\n符号解析  链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字\n然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止\n另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义\n多重定义的全局符号解析  链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？\nLinux 编译系统采用如下的方法解决多重定义的全局符号解析：\n在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。\n根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：\n\n规则 1：不允许有多个同名的强符号\n规则 2：如果有一个强符号和多个弱符号同名，则选择强符号\n规则 3：如果有多个弱符号同名，则从这些弱符号中任意选择一个\n\n另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：\n\n情况 1：两个或两个以上的强符号类型不一致\n情况 2：有一个强符号，其他都是弱符号，出现类型不一致\n情况 3：两个或两个以上弱符号类型不一致\n\n其中，情况 1 由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 COMMON 块（Common Block）的机制来处理。其过程如下：\n首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况 3，最终链接时选择最大的类型。对于情况 2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告\n重定位  事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。链接器通过重定位表（Relocation Table）用来处理重定位相关的信息\n对于可重定位的 ELF 文件来说，它必须包含重定位表，用来描述如何修改相应的 section 的内容。对于每个要被重定位的 ELF section 都有一个对应的重定位表。如果 .text section 需要被重定位，则会有一个相对应叫.rel.text 的 section 保存了代码 section 的重定位表；如果 .data section 需要被重定位，则会有一个相对应的.rel.tdata 的 section 保存了数据 section 的重定位表\n静态链接  静态链接就是在程序运行前，链接器通过对象文件中包含的重定位表，完成所有重定位操作，并最终形成一个在运行时不需要再次进行依赖库的加载和重定位操作（因为所有的依赖库在运行前都被链接到程序中了）\n动态链接  静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等；关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序\n动态链接指的是主程序对动态共享库或对象中符号的引用，是等到程序运行后再加载并进行重定位操作。程序的主体部分也称为主程序还是静态链接的，这部分链接是不会将依赖的动态共享库或对象链接进主程序的\n动态链接的基本实现  动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化\n目前，主流操作系统都支持动态链接。在 Linux 中，ELF 动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以 .so 为后缀；在 Windows 中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以 .dll 为后缀\n动态链接程序运行时地址空间分布  对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。\n关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：\n\n静态共享库 Static Shared Library\n地址固定\n静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间\n因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态\n\n\n动态共享库 Dynamic Shared Libary\n地址不固定\n\n采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）\n\n在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成\n一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位\n\n\n但是这种方式也存在一些问题\n\n态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的\n\n\n地址无关代码\n\n把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本\n\n共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用\n\n类型 1：模块内部的函数调用\n由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的\n\n\n类型 2：模块内部的数据访问，如模块中定义的全局变量、静态变量\n一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了\n\n\n类型 3：模块外部的函数调用\n模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF 的实现方法是：在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用\n\n\n类型 4：模块外部的数据访问，如其他模块中定义的全局变量\n对于模块间函数调用，同样可以采用类型 3 的方法来解决。与上面的类型有所不同的是，GOT 中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过 GOT 中的项进行间接跳转\n\n\n\nstatic int a;extern int b;extern void ext();void bar() {    a = 1;      // 类型 2：模块内部数据访问    b = 2;      // 类型 4：模块外部数据访问}void foo() {    bar();      // 类型 1：模块内部函数调用    ext();      // 类型 4：模块外部函数调用}\n\n\n\n\n\n静态链接是否将所有函数都链接到可执行文件中\n动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统的 dll 文件中，当程序运行时直接从操作系统中找\n静态链接就是把所有用到的函数全部链接到 exe 文件中\n动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入\n而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了\n\n动态库抛出异常可以捕获到吗  同一个编译器编译出来的 dll 和 exe 是可以的\n关键字和操作符 extern 关键字含义\n当它与 \"C\" 一起连用时，如extern \"C\" void fun(int a, int b);，则编译器在编译 fun 这个函数名时按 C 的规则去翻译相应的函数名而不是 C++ 的\n当它不与 \"C\" 在一起修饰变量或函数时，如在头文件中，extern int a;，它的作用就是声明函数或变量的作用范围的关键字，其声明的函数和变量可以在本编译单元或其他编译单元中使用\n\n静态全局变量\n注意使用 static 修饰变量，就不能使用 extern 来修饰，即 static 和extern不可同时出现\n\nstatic修饰的全局变量的声明与定义同时进行，即当在头文件中使用 static 声明了全局变量，同时它也被定义了。static修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值\n多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储\n\n一般定义 static 全局变量时，都把它放在。cpp 文件中而不是。h 文件中，这样就不会给其他编译单元造成不必要的信息污染\n\n如何使用全局变量\n在同一文件中定义了全局变量，需要在前面使用，这时在定义之前用 extern 关键字对其进行声明\n\n// a.cppextern int a;void SetA(){    a = 100;}int a;int main(){    ...}\n\n\n在一个源文件文件中定义了全局变量，需要在其他文件中使用，这时需要在其他文件中需要使用的地方之前用 extern 声明下\n\n// a.cpp 文件，a 的定义文件int a;  // 全局变量 a 的定义int main(){    ...}\n\n// b.cpp 文件extern int a;  // 声明void setA(){    a = 100;}\n\n如何更改变量的 const 属性\n强制类型转换\n\nC++ 中的强制类型转换可以将 const 类型转换为非 const 类型\nint main() {    const int a = 10;    int &amp;b = const_cast&lt;int &amp;&gt;(a);    b = 20;    cout &lt;&lt; a &lt;&lt; endl; // output: 20    return 0;}\n\nconst_cast只能在类型上进行强制转换，但不能去掉变量的实际限定符。因此，如果要去掉指向 const 对象的指针或引用的 const 限定符，必须先解除指针或引用的 const 属性，然后再进行强制类型转换\n\n使用 mutable 关键字\n\nclass Foo{public:    mutable int count = 0;    void bar() const    {        count++;    }};int main() {    Foo foo;    foo.bar(); // count = 1    return 0;}\n\n如何初始化 const 成员变量\nconst成员变量初始化在构造函数的初始化列表里进行，不可以通过赋值来初始化\n若有多个构造函数，则必须每个构造函数都必须要为 const 成员变量赋初值\n\nnew和 delete 运算符\nnew\n调用 operator new 函数申请空间\n在申请的空间上执行构造函数，完成对象的构造\n\n\ndelete\n在空间上执行析构函数，完成对象中资源的清理工作\n调用 operator delete 函数释放对象的空间\n\n\n\nPlacement 技术  系统默认的 new 关键字除了分配堆内存外还进行构造函数的调用。而实际中可能有一些已经预先分配好的内存区域，想在这些已经分配好的内存中来构建一个对象。还有一种情况是不希望进行频繁的堆内存分配和释放而只是对同一块内存进行重复的对象构建和销毁\n面向对象  多继承情况下成员变量和函数的内存分布  单继承class Base {public:    int a;    int b;    virtual void func1();    void func2();};class Derive: public Base {public:    int c;    virtual void func3();};\n\n在 msvc 环境下，首先编译源文件 cl /EHsc main.cpp，生成.obj 文件\n基类的内存分布cl /d1 reportSingleClassLayoutBase main.cpp\n\nclass _s__RTTIBaseClassDescriptor       size(28):        +--- 0      | pTypeDescriptor 4      | numContainedBases 8      | _PMD where20      | attributes24      | pClassDescriptor        +---class _s__RTTIBaseClassArray    size(1):        +--- 0      | arrayOfBaseClassDescriptors        +---class Base      size(12):        +--- 0      | {vfptr} // 存在虚函数，需要分配虚表指针的内存大小是 4 个字节 4      | a 8      | b        +---Base::$vftable@:        | &amp;Base_meta        |  0 0      | &amp;Base::func1Base::func1 this adjustor: 0\n\n\n    \n\n\n派生类的内存分布class Derive    size(16):        +--- 0      | +--- (base class Base) 0      | | {vfptr} 4      | | a 8      | | b        | +---12      | c        +---Derive::$vftable@:        | &amp;Derive_meta        |  0 // 地址偏移量 0      | &amp;Base::func1 1      | &amp;Derive::func3Derive::func3 this adjustor: 0\n\n\n    \n\n\n多继承class Base1 {public:    int a;    int b;    virtual void func1();};class Base2 {public:    int c;    virtual void func2();};class Derive: public Base1, Base2 {public:    int d;    virtual void func3();};\n\nclass Derive    size(24):        +--- 0      | +--- (base class Base1) 0      | | {vfptr} 4      | | a 8      | | b        | +---12      | +--- (base class Base2)12      | | {vfptr}16      | | c        | +---20      | d        +---Derive::$vftable@Base1@:        | &amp;Derive_meta        |  0 0      | &amp;Base1::func1 1      | &amp;Derive::func3Derive::$vftable@Base2@:        | -12 // 地址偏移量，有的是 -8，有的是 -12；当继承第三个类的时候是 -24 0      | &amp;Base2::func2Derive::func3 this adjustor: 0\n\n\n\n独有的虚函数放到第一个虚函数表中\n只有第一个虚函数表包含元数据行\n继承后派生类自己没有虚函数指针\n\n\n虚继承class Base {public:    int a;    int b;    virtual void func1();};class Derive: virtual Base {public:    int c;    virtual void func2();};\n\nclass Derive    size(24):        +--- 0      | {vfptr} 4      | {vbptr} 8      | c        +---        +--- (virtual base Base)12      | {vfptr}16      | a20      | b        +---Derive::$vftable@Derive@:        | &amp;Derive_meta        |  0 0      | &amp;Derive::func2Derive::$vbtable@: 0      | -4 1      | 8 (Derived(Derive+4)Base)Derive::$vftable@Base@:        | -12 0      | &amp;Base::func1Derive::func2 this adjustor: 0vbi:       class  offset o.vbptr  o.vbte fVtorDisp            Base      12       4       4 0\n\n\n    \n\n\n虚基类表指针（vbptr），该指针指向了一个虚基类表，虚表中记录了虚基类与本类的偏移地址。通过偏移地址，这样就可以找到虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，从而节省了存储空间\n基类和派生类指针相互赋值\n在公有派生的情况下，派生类的指针可以直接赋值给基类指针\n即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有而派生类中有的成员\n\n\n基类的指针不能赋值给派生类的指针\n但是通过强制类型转换，也可以将基类指针强制转换成派生类指针后再赋值给派生类指针\n只是在这种情况下，需要保证被转换的基类指针本来就指向一个派生类的对象，这样才是安全的，否则很容易出错\n\n\n\n#include &lt;iostream&gt;using namespace std;class CBase{protected:    int n;public:    CBase(int i) :n(i) {}    void Print() {cout &lt;&lt; \"CBase:n=\" &lt;&lt; n &lt;&lt; endl; }};class CDerived :public CBase{public:    int v;    CDerived(int i) :CBase(i), v(2 * i) {}    void Func() {};    void Print()    {        cout &lt;&lt; \"CDerived:n=\" &lt;&lt; n &lt;&lt; endl;        cout &lt;&lt; \"CDerived:v=\" &lt;&lt; v &lt;&lt; endl;    }};int main(){    CDerived objDerived(3);    CBase objBase(5);    // 使得基类指针指向派生类对象    // pBase-&gt;Func(); // 错，CBase 类没有 Func() 成员函数    // pBase-&gt;v = 5;  // 错 CBase 类没有 v 成员变量    CBase * pBase = &amp;objDerived;     pBase-&gt;Print();    cout &lt;&lt; \"1)------------\" &lt;&lt; endl;    //CDerived * pDerived = &amp; objBase; // 错，不能将基类指针赋值给派生类指针    CDerived * pDerived = (CDerived *)(&amp;objBase);    pDerived-&gt;Print();  // 慎用，可能出现不可预期的错误    cout &lt;&lt; \"2)------------\" &lt;&lt; endl;    objDerived.Print();    cout &lt;&lt; \"3)------------\" &lt;&lt; endl;    pDerived-&gt;v = 128;  // 往别人的空间里写入数据，会有问题    objDerived.Print();    return 0;}\n\n在函数参数中使用未定义的类\n前向声明：可以声明一个类而不定义它，这个声明被称为前向声明 (forward declaration)\n声明后的类是一个不完全类型（incompete type），不完全类型只能以有限方式使用\n不能定义该类型的对象\n只能用于定义指向该类型的指针及引用\n用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数\n\n\n类的前向声明只适用于指针和引用的定义，如果是普通类的类型就得使用include\n\n如何实现接口  首先给接口类下了定义\n\n接口类应该是只提供方法声明，而自身不提供方法定义的抽象类\n接口类自身不能实例化，接口类的方法定义 / 实现只能由接口类的子类来完成\n\n而对于 C++，其接口类一般具有以下特征：\n\n最好不要有成员变量，但可以有静态常量 static const或enum\n要有纯虚接口方法\n要有虚析构函数，并提供默认实现\n不要声明构造函数\n\nclass InterfaceTest{public:    static const int START = 1;    static const int STOP = 2;     virtual void test() = 0;     virtual ~InterfaceTest() = default;}\n\nstruct可以定义虚函数吗  就编译器而言，除了默认的可访问性外，struct和 class 之间没有区别。它们只是定义同一事物的两个不同关键字。所以，结构可以有构造函数、析构函数、基类、虚函数等等\n使用 struct 来处理没有这些东西的类（特别是 POD ) 是一个常见的约定，或者更进一步使用 struct 仅适用于根本没有用户定义的成员函数，只有 public 数据成员的类\n\nPOD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.\n\n生命周期  声明变量会分配内存吗\n函数或变量在声明时，并没有给它实际的物理内存空间\n函数或变量在定义时，它就在内存中有了实际的物理空间\n函数或变量可以声明多次，但定义只能有一次\n\n函数栈中包含的内容  函数栈  当进程被加载到内存时，会被分成很多段\n\n代码段：保存程序文本，指令指针 EIP 就是指向代码段，可读可执行不可写，如果发生写操作则会提示 segmentation fault\n数据段：保存初始化的全局变量和静态变量，可读可写不可执行\nBSS：未初始化的全局变量和静态变量\n堆 (Heap)：动态分配内存，向地址增大的方向增长，可读可写可执行\n栈 (Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，可读可写可执行\n环境 / 参数段（environment/argumentssection）：用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell 名称、主机名等信息。该节是可写的，因此在缓冲区溢出（buffer overflow）攻击中都可以使用该段\n\n寄存器\nEAX：累加（Accumulator）寄存器，常用于函数返回值\nEBX：基址（Base）寄存器，以它为基址访问内存\nECX：计数器（Counter）寄存器，常用作字符串和循环操作中的计数器\nEDX：数据（Data）寄存器，常用于乘除法和 I/O 指针\nESI：源变址寄存器\nDSI：目的变址寄存器\nESP：堆栈（Stack）指针寄存器，指向堆栈顶部\nEBP：基址指针寄存器，指向当前堆栈底部\nEIP：指令寄存器，指向下一条指令的地址\n\n栈帧 Stack Frame其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，局部变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP（栈指针）就是一直指向栈顶的。用 %ebp 指向栈底，也就是基址指针；用 %esp 指向栈顶，也就是栈指针\n\n    \n\n\n一般来说，将 %ebp 到%esp之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧 。在函数调用过程中，将调用函数的函数称为 调用者（caller），将被调用的函数称为  被调用者（callee）。\n\n调用者  需要知道在哪里获取  被调用者  返回的值\n被调用者  需要知道传入的参数在哪里，返回的地址在哪里\n需要保证在  被调用者  返回后，%ebp、%esp等寄存器的值应该和调用前一致，需要使用栈来保存这些数据\n\n线程个数由什么决定  线程数和 CPU 核心数可以没有任何关联，但当需要利用线程充分发挥多核威力时，通常情况下创建的线程数与核数要保持一种线性关系，最佳系数通常需要测试才能得到\nRAII 的用途RAIIRAII 是 Resource Acquisition Is Initialization 的缩写，即“资源获取即初始化”。它是 C++ 语言的一种管理资源、避免资源泄漏的惯用法，利用栈对象自动销毁的特点来实现，可以通过构造函数获取资源，通过析构函数释放资源\n\n将每一种资源封装在一个 RAII 类中\n所有资源在构造函数中获取，例如：分配内存、打开文件、建立数据库连接等；如果无法完成则在构造函数中抛出异常\n所有资源在析构函数中释放，例如：释放内存、关闭文件、销毁数据库连接等；不应该抛出任何异常\n\n\n通过 RAII 类实例获取资源\n具有自动生命管理周期或临时对象生命周期\n其生命周期与第一种绑定\n\n\n\n为什么要使用 RAII在 C++ 中，通过 new 运算符动态申请内存，例如：\nFoo* ptr = new Foo(1);// ...delete ptr;\n\n在这段代码中，new运算符在计算机内存的堆上申请了一块 Foo 类型的内存，然后将其地址赋值给存储在栈上的指针 ptr。为了能够释放内存资源，需要使用完new 运算符申请的内存后，手动调用 delete 运算符释放内存。但是，情况并不总是如此简单\nFoo* ptr = new Foo(1);f(ptr);  // --&gt;① may throw exceptionif(ptr-&gt;g()) {    // ... --&gt; ② may forget to delete ptr    return;}// ...delete ptr;\n\n\n忘记 delete 释放内存。比如释放原指针指向的内存前就改变了指针的指向\n程序抛出异常后导致无法 delete。比如上面的①处，如果f 函数抛出异常，没有机会运行delete，从而导致内存泄漏\n需求变更后，修改了函数，新增了分支，提前返回，②处却没有delete\n现实情况代码复杂的话可能没有这么显而易见\n而通过 RAII 这样一种机制，可以使其自动释放内存\n\nC++ STL 中 RAII 的应用  智能指针  智能指针是 RAII 的一种实现，它是一种模板类，用于管理动态分配的对象。智能指针的主要作用是自动释放内存，从而避免内存泄漏。C++ 11 中提供了三种智能指针：unique_ptr、shared_ptr和 weak_ptr。以unique_ptr 为例，它的构造函数如下：\ntemplate&lt; class T, class Deleter = std::default_delete&lt;T&gt; &gt; class unique_ptr;\n\nunique_ptr的析构函数会自动释放内存，因此，可以通过 unique_ptr 来管理动态分配的内存，从而避免内存泄漏\n// release memory when ptr is out of scopestd::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(1);\n\n互斥锁  在多线程编程中，std::lock_guard, std::unique_lock, std::shared_lock等也利用了 RAII 的原理，用于管理互斥锁。当这些类的等对象创建时，会自动获取互斥锁；当对象销毁时，会自动释放互斥锁\nstd::lock_guard的构造函数如下：\ntemplate&lt; class Mutex &gt; class lock_guard;\n\nstd::lock_guard的析构函数会自动释放互斥锁，因此，可以通过 std::lock_guard 来管理互斥锁，从而避免忘记释放互斥锁\nstd::mutex mtx;std::lock_guard&lt;std::mutex&gt; lock(mtx); // unlock when lock is out of scope\n\n不使用 RAII 的情况下，需要手动释放互斥锁，如下所示：\nstd::mutex mtx;mtx.lock();// ...mtx.unlock();\n\n文件操作 std::ifstream, std::ofstream 等 C++ 标准库的 IO 操作都是 RAII 的实现\n事务处理  数据库事务处理中，如果在事务结束时没有提交或回滚，就会导致数据库连接一直被占用，从而导致数据库连接池耗尽。因此，需要在事务结束时自动提交或回滚，从而释放数据库连接。这一过程也可以通过 RAII 来实现\nC++ 新特性  智能指针  模板 typename 和class的区别 typename 独有的功能  由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 Type::foo 的写法具体指的是一个类型还是类内成员\n例如在以下代码中，类模板 Bar 的原意是使用类 Foo 实例化，而后引用其中的 bar_type 定义名为 bar 的类内成员。然而，就 T::bar_type 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 typename 关键字来辅助编译器的判断\nclass Foo {public:    typedef int bar_type;};template&lt;typename T&gt;class Bar{    /* typename */    T::bar_type bar;};\n\nclass独有的功能 C++ 的标准模板库中有名为std::stack 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为\ntemplate &lt;typename T, typename Containter = std::deque&lt;T&gt; &gt;class stack;\n\n因此，在使用中，可以使用 std::stack&lt;int&gt; 来声明一个以 std::deque&lt;int&gt; 保存整型变量的栈；也可以使用 std::stack&lt;int, std::vector&lt;int&gt; &gt;来声明一个以 std::vector&lt;int&gt; 保存整型变量的栈。是否有可能以类似 Stack&lt;int, std::vector&gt;的形式，来达到同样的目的？需要有类似这样的声明\ntemplate &lt;typename T,    template &lt;typename E, typename = std::allocater&lt;E&gt; &gt; class Container = std::deque&gt;class Stack;\n\n由于 Container 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，Container之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器\n此处 class 特有的功能，体现在 class Container 之处。此处虽然是在声明 Stack 这个类模板，但是此处的 class 不能替换为typename，否则编译器会报错\n\n指定  模板模板  时，必须使用 class 关键字，在这种情况下，它不能与 typename 互换\n\n模板泛化、特化、偏特化\n模板特化按对象类型可分为类模板特化和全局模板函数函数特化\n按特化类型可分为全特化和偏特化\n偏特化包括范围偏特化和参数数量偏特化\n全局模板函数不支持偏特化，因为函数有重载，所以函数偏特化都是重载\n\n\n特化的优先级高于泛化\n编译器会先去匹配特化和偏特化，后去匹配泛化\n\n\n\n类模板特化template &lt;typename T1, typename T2&gt;class testFun {public:    testFun(T1 t1, T2 t2) : a(t1), b(t2)     {        cout &lt;&lt; \"类模板\" &lt;&lt; endl;    }private:    T1 a;    T2 b;};// 全特化template &lt;&gt;class testFun&lt;int, string&gt;{public:    testFun(int t1, string t2) : a(t1), b(t2)    {        cout &lt;&lt; \"全特化\" &lt;&lt; endl;    }private:    int a;    string b;};// 参数数量偏特化template &lt;typename T2&gt;class testFun&lt;int, T2&gt;{public:    testFun(int t1, T2 t2) : a(t1), b(t2)    {        cout &lt;&lt; \"参数数量偏特化\" &lt;&lt; endl;    }private:    int a;    T2 b;}; template &lt;typename T1, typename T2&gt;class testFun&lt;T1*, T2*&gt;{public:    testFun(T1* t1, T2* t2) : a(t1), b(t2)    {        cout &lt;&lt; \"范围偏特化，指针偏特化\" &lt;&lt; endl;    }private:    T1* a;    T2* b;}; template &lt;typename T1, typename T2&gt;class testFun&lt;T1 const, T2 const&gt;{public:    testFun(T1 t1, T2 t2) : a(t1), b(t2)    {        cout &lt;&lt; \"范围偏特化，const 偏特化\" &lt;&lt; endl;    }private:    T1 a;    T2 b;};\n\n函数模板特化// 函数模板template&lt;typename T1, typename T2&gt;void testfun(T1 ta, T2 t2) {    cout &lt;&lt; \"模板函数\" &lt;&lt; endl;}// 全特化 1，会被重载，退化为偏特化template&lt;&gt;void testfun(char ta, string t2) {    cout &lt;&lt; \"全特化\" &lt;&lt; endl;}// 全特化 2，不会被重载template&lt;&gt;void testfun(int ta, string t2) {    cout &lt;&lt; \"全特化\" &lt;&lt; endl;}// 偏特化（重载）template&lt;typename T2&gt;void testfun(int t1, T2 t2) {    cout &lt;&lt; \"偏特化\" &lt;&lt; endl;}/* 不支持 const 范围偏特化template&lt;typename T1, typename T2&gt;void testfun(T1 const t1, T2 const t2) {    cout &lt;&lt; \"const 偏特化\" &lt;&lt; endl;}*/template&lt;typename T1, typename T2&gt;void testfun(T1* t1, T2* t2) {    cout &lt;&lt; \"指针偏特化\" &lt;&lt; endl;}\n","categories":["面试"],"tags":["Unity","C#"]},{"title":"现代 C++ 基础","url":"/2024/06/03/56ae950785e9/","content":"Basics ReviewArray Type\nMultidimensional array 多维数组\n除了第一维其它维必须明确指出大小（explicit size）\n不可以全部 decay\nDynamic allocation\nmalloc in C and new/new [] in C++\nnew和 malloc 返回都是指针\n释放\n\n\n\n\n\nFunction\n函数返回类型不能是函数或者数组（但是可以是它们的引用）\n\n不应该返回局部变量的指针或者引用（超出了局部变量生命周期的范围）\ne.g. int&amp; Test() { int a = 1; return &amp;a;}\n\n\n声明为 static 的局部变量具有全局性\n\n\nFunction pointers 函数指针\n\nvoid(*)(int)\n\nclockwise/spiral rule\n\nType alias 用 C++ 11 中的using\nusing MyFuncType1 = int(*)(float);using MyFuncType2 = int(*)(int);using MyFuncType3 = int(*)(MyFuncType1);\nC 语言中可以用 typedef，但是没有using 强大\n\n\n\n\nAttribute\n[[attribute]] C++ 11，[[attribute(\"reason\")]] C++ 20\n[[deprecated]]和[[deprecated(\"reason\")]] C++ 14\n[[noreturn]] C++ 11\n[[maybe_unused]] C++ 17\n\ne.g.\n[[nodiscard]] int Add(int a, int b) {return a + b; }int main(){    Add(1, 2); // int res = Add(1, 2);    return 0}\n\nwarning: 放弃具有 [[nodiscard]] 属性函数的返回值\nEnumeration\n一个被限制取值的类\n\n\n比较像使用全局变量\n同时进行整形运算也没有安全检查\nC++ 11 引入了 scoped enumeration 提高安全性\n\ne.g.\n// enum Day {Monday};enum class Day {Monday};int main(){    // int a = Monday;    Day a = Day::Monday    return 0;}\n\n\n可以使用 std::underlying_type&lt;Day&gt;::type 或者std::underlying_type_t&lt;Day&gt; C++ 14 转成整数类型\nC++ 23 中也可以使用std::to_underlying&lt;Day&gt;(day)\n\n\n可以使用 Day day{1}; 初始化 C++ 17，但是不能直接赋值Day day = 1; 或day = 1;\n可以使用位操作符\n\nExpression\n运算符和表达式三个重要概念\nPrecedence 优先级\nAssociativity 结合性\nOrder 顺序\n\n\nFrom the view of compiler, an expression is in fact a tree, determined by associativity and precedence. e.g. 9 / 3 / 2 + 2 * 3\nPrecedence is used to split terms first.\nAssociativity determines how the tree will grow.\nThen, it’s order of expression evaluation that computes the whole tree. 但是顺序是不确定的\nf1() + f2() + f3()，f1()，f1()，f1()哪一个先被 evaluated 是不确定的\n\n\n\n\nThere are some rules\nFor &amp;&amp; and ||, since they have short-circuit property, the first part will be fully evaluated.\nFor a function call, all parameters (including a for e.g. a.Func() or a-&gt;Func()) are fully evaluated before entering the function.\n三目运算\n逗号表达式\nC++ 17\nParameters in function are evaluated indeterminately, i.e. every sub-tree represented by te parameter is fully evaluated in a non-overlap way 不会以交叠的形式 evaluated\n运算符重载，和 build-in 运算符的 evaluated 顺序一致，而不是被当作普通函数\nMore useful examples: chained call\n\n\n\n\n\nstd::string s = \"I have it even works if you don't believe\";s.replace(0, 8, \"\").replace(s.find(\"even\"), 4, \"sometimes\").replace(s.find(\"you don't\"), 9, \"I\");\n\nclassCtor &amp; Dtor\n拷贝构造函数\n赋值构造函数\nThe recommended way is member initializer list:\nmember1{...}, member2{...}, ... {/* function body */}\n{} is used since C++ 11\n\n\n默认构造函数建议使用Class() = default;\n如果成员变量有默认值，就不建议使用上面的构造函数的形式，而是直接用默认值初始化\n\nInitialization of Object\nSince C++ 11, Uniform Initialization is introduced\n所有的初始化都可以用{}\n相比于 () 更安全 Narrowing Conversion 缩窄变换检查\nthe converted type cannot represent all values\nuint32_t类型用 uint16_t 初始化，编译器会报错\n\n\nthe facilitates type safety\n\n\n\n\nValue initialization: No parameter for initialization T a()， T a{}， new T{}， new T()\nDirect initialization: T a(x, y, ...)，T(x, y, ...)，new T(x, y, ...)，T a{x, y, ...}\nCopy initialization: T a = xx;，T a[] = { xx, ...};\nCtors that use explicit cannot use this way\nBefore C++ 17, this also requires available copy ctor.\n\n\n\nclass A {public: explicit A(int a) {}};void Func(A a) {}int main(){    A a = 1;    // error    A a = A(1);    Func(1);    // error    Func(A(1));     return 0}\n\n\nList initialization\nAggregate initialization\n\nMember Functions\n所有的成员函数都隐式有一个 this 指针\n如果期望函数不能更改成员变量，可以使用 const 关键字 make this to be const\n静态成员函数\n没有 this 指针\n\n\n\nAccess Control\nprivate、protected、public，默认是private\nprotected用在继承中\n友元\n\nInheritance\n子类 / 派生类、父类 / 基类\n子类 / 派生类可以访问父类中所有 public 和protected成员\n继承和组合\n派生类可以隐式的转化成基类\n\nSlicing Problemint main(){    Student student1{...}, student2{...};    Person&amp; student1Ref = student1;    student1Ref = student2;    return 0;}\n\n\nThere exists implicit conversion in student1Ref = student2 so actually it calls Person::operator=(const Person&amp;)\nCan decorating operator= with virtual help\nPerson::operator= needs const Person&amp; but Student::operator= accepts const Student&amp; 参数都不一样，虚函数都不生效\n\n\nThis is called “slicing” because such operation will only affect the base slice but not the initial object as whole 只影响了一小片\nPolymorphic base class should hide their copy &amp; move functions if it has data member, otherwise deleting them 对于具有多态属性的基类，应该隐藏它们的拷贝和移动函数\nMake copy &amp; move functions protected so derived class can call them\n\nMultiple Inheritanceclass Elephant {};class Seal {};class ElephantSeal : public Elephant, public Seal {};\n\n\nDreaded diamond\nC++ introduces virtual inheritance\nAll virtual bases will be merged and seen as the same\n\n\n\nclass Animal {public: int weight; };class Elephant : public virtual Animal {};class Seal : virtual public Animal {}; // virtual 和 public 顺序是不重要的class ElephantSeat : public Elephant, public Seal {};\n\n\nThat is, you define many ABCs, which tries to reduce data members and non-pure-virtual member functions as much as you can 定义很多抽象类，尽可能减少成员变量和非纯虚函数的数量，最好是没有\nThey usually denote “-able” functionality 这样展现出来的就是就有某种能力\n\nPolymorphism 多态\nyou can use the base class to load the derived object and call its own methods 使用基类的指针 / 引用，承载派生类的对象，从而调用派生类的方法\nvirtual pointer and virtual table\nEvery object whose class has a virtual method will have a virtual pointer, which points to virtual table of its class 每个类中都有一个指向虚表的指针，虚表内容就是声明为 virtual 函数的地址\nIn C++ 11, it’s recommended to use override 子类没有 override 编译器会报错\nfinal It means override, and the derived class cannot override again 继承链中的最后一个节点\nclass A final {...}; 让类不能被继承\n去虚化，编译优化\n\n\nabstract class 抽象类\n抽象类不能被实例化\n可以是使用抽象类的指针，指向的都是派生类的对象\nC++ 通过纯虚函数实现抽象类 virtual void PrintInfo() const = 0;\n派生类继承自抽象类必须实现纯虚函数，否则仍然是抽象类\nDon’t call any virtual function and any function that calls virtual function in ctor &amp; dtor 在构造函数和析构函数中不要调用任何虚函数，也不要掉调用任何可能调用虚函数的函数\nYou should usually make dtor of base class virtual 通常将析构函数声明为虚函数\ndeleting Base* that cast from Derived* will lead to correct dtor 派生类指针赋给基类，当调用 delete 时，如果不基类不是虚析构函数，就会调用基类的析构函数\n\n\n构造函数不能是纯虚函数\n\n\n\nSome Covert Facts in Inheritance\noverride不止表示复写虚函数的含义，对于非虚函数的复写也叫“override”\nprivate inheritance usually denotes the relation of has-a\n虚函数的返回类型可以有些许改变：you can use Base* to both accept Base* and Derived* 复写虚函数的返回值可以是指向基类的指针，也可以是指向派生类的指针\n智能指针不能有“协变”\n\n\n当虚方法有默认参数的时候，用什么类型的指针调用时，就会返回该类型内的默认值\n默认的参数在编译期间被识别，虚表是在运行时跳转的\n\n\n\ne.g.\nvoid Parent::Go(int i = 2) {std::cout &lt;&lt; \"Base's go with i = \" &lt;&lt; i &lt;&lt; \"\\n\"; }void Child::Go(int i = 4) {std::cout &lt;&lt; \"Derived's go with i =\" &lt;&lt; i &lt;&lt; \"\\n\"; }Child child;child.Go(); // Derived's go with i = 4Parent&amp; childRef = child;childRef.Go();  // Base's go with i = 2\n\n\n可以更改虚方法的访问属性（但是不建议）\n\nstruct\n和 class 基本上一样，除了 struct 默认的访问控制是public\n不应该有成员函数，最多有 ctor、dtor 和运算符重载\nWith these constraints (except for ctor), struct will be an aggregate, which can use aggregate initialization\nSince C++ 20, aggregate can also use designated initialization 指定初始化\n\n\n\n\n\ne.g.\nstruct Priority {int cal; }struct Point{    int x, y;    Priority priority[2];}int main(){    Point p{.x = 1, .y = 2, .priority = {{ .val = 1}, {.val = 2 } } };    return 0;}\n\nFunction Overloading 函数重载\nC++ 中就是相同的函数名不同的参数\nC 中是禁止的\n\n\nThis is done by compilers using a technique called name mangling\nOperator Overloading 运算符重载\n+，-，*，/，%，|，&amp;，^，&lt;&lt;，&gt;&gt;：推荐使用在全局函数中\n+=，-=，*=，/=，|=，&amp;=，^=，&lt;&lt;=，&gt;&gt;=：必须是成员函数 since the first operand must be a “named” object; return reference (i.e. *this)\nPrefix++ &amp; Prefix--：必须是成员函数 return *this\nPostfix++ &amp; Postfix-- have an unused parameter int, which is used to distinguish the prefix and postfix\n*，-&gt;：usually used in e.g. some wrapper of pointers\n&amp;&amp;，||：short-circuit 特性会失效\n&lt;=&gt;：三路比较运算符\n()\n[]\nSince C++ 23, you can use multidimensional subscript in operator[]\n\n\n\n\n\nLambda Expression\n本质上是一个匿名的 struct，重载了operator() const 方法\nBasic format: auto func = [captures](params) -&gt; ReturnType {function body;};\nCaptures are actually members of the struct\nReturnType, params and function are for operator()\nEvery lambda expression has its unique type\n不传任何参数 () 可以省略掉\n\n\n建议将 Lambda 表达式中的捕获的东西明确写出来\nstatic 和 global 变量是不需要被捕获的\n捕获 this 指针\nthis by reference, since only copy pointer\n*this really copy all members\n包括私有成员也可以捕获\n\n\nYou may add specifiers after ()\nmutable: since C++ 17, remove const in operator()\nstatic: since C++ 23, same as static operator()\nconstexpr、consteval、noexcept\n\n\n\nint main(){    int i = 0;    auto m = [i] {i = 1; return 0; }; // 不允许修改 i = 1，因为重载的 operator() 是 const    auto m = [i]() mutable {i = 1; return 0; }; // 修改的不是外面定义的变量，本质上修改的是 i 的拷贝}\n\n\nIt’s also legal to add attributes between [] and ()\n函数也可以写成 Lambda 表达式的形式 auto Foo(params) -&gt; ReturnType {function body;}\n\nCode Block With Initializer\nauto it = table.find(1);if (it == table.end())    //else    //\n\n\nit会泄露出去，下面如果继续判断会再定义迭代器类型的变量\nSince C++ 17, you mey code like\n\nif (auto it = table.find(1); it == table.end())    //else    //\n\n\nSince C++ 20, range-based for loop can also add an additional initializer, e.g. for (auto vec = GetVec(); auto&amp; m : vec);\nSince C++ 23, type alias declaration can also be initializer, e.g. if (using T = xx; ...)\n\nTemplate\nSince C++ 17, CATD(class template argument deduction) is introduced, meaning that the argument of ctor can deduce the template parameter of class. e.g. std::vector v{1, 2, 3, 4}\nLambda expression can also use template\n\nContainer\nstd::size_t: the type of sizeof() 意味着对象的大小不能超过 std::size_t 所表示的范围\n也意味着数组的大小不能超过 std::size_t 所表示的范围\n容器的大小也不能超过std::size_t\n\n\nstd::ptrdiff_t：两个指针相减得到的类型\n\nIterators\nInput/Output iterator\nFor output *it = val, it++, ++it, ‘it1 = it2’\nFor input ==, !=, -&gt;\n\n\nForward iterator: e.g. linked list\nBidirectional iterator: --it, it-- e.g. double linked list, map\nRandom access iterator: +, -, +=, -=, [], &lt;, &gt;, &lt;=, &gt;=, != e.g. deque\nContiguous iterator (since C++ 17): 保证地址空间是连续的\nIMPORTANT: Iterator are as unsafe as pointers 线程不安全的\nAll containers can get their iterators by:\n.begin(), .end()\n.cbegin(), cend() read-only access\n\n\n双向链表等还提供了倒序的遍历迭代器\n.rbegin(), .rend(), .crbegin(), crend()\n\n\n还可以使用全局的方法得到迭代器\nstd::begin(vec), std::end(vec)\nC++ 20 建议使用std::ranges::begin\n只有类似 int arr[5] 传入到 std::begin() 或std::end()中才有效，指针传入进来是无效的\n\n\nThere are also general methods of iterator operations, defined in &lt;iterator&gt;\nstd::advance(InputIt&amp; it, n): it += n\nstd::next(InputIt it, n = 1): return it + n\nstd::prev(InputIt it, n = 1): return it - n\nstd::distance(InputIt it1, InputIt it2): return it2 - it1 不同的容器时间复杂度不一样\n\n\n\nIterator traits（显著的特点，特征）\nIterators provide some types to show their information:\nvalue_type: The type of elements referred to\ndifference_type: The type that can be used to represent the distance between elements (usually ptrdiff_t) 迭代器之间的距离所表示的类型，一般就是ptrdiff_t\niterator_category: e.g. input_iterator_tag, continuous_iterator_tag\npointer &amp; reference: only available in container iterators 只有在容器中才会有的特性\n可以使用 std::iterator_traits&lt;IteratorType&gt;::xxx 获取\n\n\n\n\n\nStream iterator\nstd::istream_iterator&lt;T&gt; &amp; std:ostream_iterator&lt;T&gt;\nThe default constructed istream_iterator is end() 默认的构造函数表示终止的迭代器\n\nIterator adaptor有两种类型的迭代器适配器\n\nOne is created from iterators to preform different utilities:\nE.g. reversed iterators 反向迭代器，++ 的本质上是 –，所以可以用 begin() 初始化，即std:::reverse_iterator r{p.begin() }\nYou can get the underlying iterator by .base(), which actually returns the iterator that points to the elements after the referred one 调用 .base() 实际上是指向当前指向位置的下一个元素\nrbegin().base() == end()\n\n\n\n\nAnother is created from containers to work more than “iterate”\nstd::back_insert_iterator{container}: *it = val will call push_back(val) to insert\nstd:front_insert_iterator{container}: call push_front(val) to insert\nstd::insert_iterator{container, pos}: call insert(pos, val) to insert\n\n\nNotice that inserting/assigning a range directly is usually better than inserting one by one for vector or deque\n\nSequential ContainerArray\nE.g. int a[5] will decay to int* when passing to function, and the size information is dropped 以参数的方式传递到函数中会退化成指针，并且大小也被舍弃了\nstd::array&lt;T, size&gt; the same as T[size]. It always preserves size, can copy from another array, and can do more things like bound check\nIt’s allocated on stack\nBut if you new std::array, then it;s still allocated on heap\n\n\n特殊的构造函数需要额外的 {} e.g. struct S {int i; int j;} 初始化时是std::array&lt;S, 2&gt; arr{{{1, 2}, {3, 4}}}\n第一个 {} 是array本身初始化的{}\n第二个 {} 是数组初始化的{}\n\n\nFor member accessing 成员访问\noperator[]\nat() will check the bound\nfront(), back(): get the first/last element of vector 首先要保证非空\nIf you want to get the raw pointer of array content, you can use .data()\n\n\nAdditional methods\n.swap()\noperator=, operator&lt;=&gt; 三路比较运算符\n.fill() 将整个数组填充为某个特定值\nstd::to_array(C-style array)\n\n\nSize operations\n.size(): return size_t\nempty()\n.max_size(): get maximum possible size in this system(usually useless)\n\n\n\nvector\n动态数组\n支持随机访问，占据连续空间\nWhen inserting and removing elements at the end (i.e. pushing/poping back), the complexity is amortized（均摊） \nIf not at end, it’ll be \n\n\n在 cache 上的效果非常不错，对 cache 利用率非常显著\n实现思路\n准备一部分空间，这样在 pushing 或者 poping 的时候时间复杂度才是\n当容量不够的时候在重新分配（reallocation），重分配的均摊复杂度也要求是\nThe element number is called size; total space is called capacity\n重分配的策略\nThe easiest strategy is increasing space linearly\nE.g. 0 -&gt; 4 -&gt; 8 -&gt; 12 -&gt; 16 -&gt; …\nEvery  operations will trigger reallocation an copy  elements\nSo, the amortized complexity is \nConsidering that  is an constant, this is still \n\n\n\n\nSo, what about exponentially（指数）?\nE.g. 1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 16 -&gt; 32 -&gt; …\nEvery  operations will trigger reallocation an copy  elements\nSo, the amortized complexity is \n\n\n\n\nFinally, why is the exponent 2?\n可以证明任何大于 1 的指数最后的均摊复杂度都是\nThis is a trade-off between space and time 空间和时间的权衡\nIn MS（微软）, it’s 1.5\n\n\n\n\nvector 不会自动的进行缩容（shrink），但是会暴露出接口手动缩容\nInsert 是从后向前的（move backwards）\nRemoval is similar, but move forwards from the end of deletion to the deletion point, and finally destruct the last several elements\nstd::initializer_list\nFor member accessing (same as array)\noperator[],at(): accessing by index;at()will check th bound, i.e. if the index is greater than size,std::out_of_range` will be thrown\nfront(), back(): get the first/last element of vector\nIf you want to get the raw pointer of array content, you can use .data()\n\n\nFor capacity operations (i.e. adjust memory)\n.capacity(): get capacity (return size_t)\n.reserve(n): 直接分配 n 大小的内存，如果比当前 capacity 小就什么都不做，size 是不会改变的\n作用是前提知道需要分配的数量，一次性分配，就不需要有扩容的操作了\n\n\n.shrink_to_fit: request to shrink the capacity so that capacity == size\n\n\nFor size operations\n.size()\n.empty()\n.resize(n, obj = Object{})\n.clear(): remove all things; size will be 0 after this\n\n\n.push_back(obj)\n.emplace_back(params): insert an element constructed by params at the end 就地根据 params 构造元素\nSince C++ 17, it returns reference of inserted element (before it’s void)\n\n\n.pop_back()\n.insert(const_iterator pos, xxx)\n.erase(const_iterator pos), .erase(const_iterator first, const_iterator last): erase a single element/elements from [first, last)\ninsert/erase will return next valid iterator of inserted/erase elements\n\n\nInteract with another vector\n.assign\n.swap(vec)\n\n\nSince C++ 23, ranges-related methods are added\n.assign_range(Range)\ninsert_range(const_iterator pos, Range)\nappend_range(Range)\n\n\n\n\n\nIterator Invalidation\n迭代器就是指针的包装，但是指针是不安全的\n\n导致不安全的情况\n\nreallocation 重分配，造成原来保存的指针悬垂\nInsertion &amp; removal 插入和删除\n\n\nFor vector\n\nIf the capacity changes, all iterators are invalid\n#include&lt;vector&gt;int main(){    std::vector{1, 2, 3, 4};    auto it = v.begin();    v.reserve(10086); // 会导致上一行的 `it` 失效    it = v.begin(); // 必须进行重新获取}\nIf the capacity doesn’t change, but some elements are moved, iterators after the changed points are invalid\n\n\n\n\nSpan\n视图 View means that it doesn’t actually hold the data; it observes the data\nSpan is a view for contiguous memory (e.g. vector, array, string, C-style array initializer list, etc.)\n可以像 array 一样操控 span\n.first(N)/.last(N)\n.subspan(beginPos(, size))\nspan is just a pointer with a size\n\nDequeue Double-Ended Queue 双端队列\n最主要的特点就是\n on insertion &amp; removal of elements at the front or the back\nRandom access\n\n\nOther properties are just like vector\npush_front\nemplace_front\npop_front\nprepend_range C++ 23\n\n\nCircular queue\nWhen enqueue, tail moves forward\nWhen dequeue, head moves forward\nIf tail == head i.e. the queue is full, overwrite the element at head, both tail and head move forward\n\n\nDequeue 相当于动态的循环队列，当队列满的时候需要进行扩容\n扩容是做到均摊复杂度是\n可以做到随机访问的原理是 e.g. deque[i] is just vec[(head + i) % size]\n\n\n实现方式\n降低拷贝的代价\n通常的实现方式是使用动态循环队列（called map），里面的元素是指针\n指针指向一个 block，block 中存储对象\nblock 的大小是固定的\n\n\nDequeue 中的数据结构\nThe map and its size\nThe block size\nThe global offset of the first element off\nWe can use off / block_size to know the position of head\n\n\nElement numbers\n\n\n重新分配的时候只需要拷贝指针\nMap reallocation in dequeue\n假设新加的 block 的大小是count\n需要使得循环队列仍然是连续的\nFirst, copy all elements from vec[head, vecEnd] to newVec[head, currEnd]\nThen, if head &lt;= count, copy [0, head) to [currEnd, ...)\nElse, copy after currEnd as mush as possible, and the rest is arranged to the newVecBegin\nFinally, set all the rest to nullptr\n\n\n\n\n\n\nDequeue iterator invalidation\nAll iterators are seen as invalid after insertion 插入之后所有的迭代器都是失效的，还包括\nresize\nshrink_to_fit\nclear\n\n\n\n\n\nList\nDouble linked list\nProperties\n insertion and removal\n splice 融合另一个 list 的一部分元素\n不支持随机访问\n\n\n每个节点都已一个数据 T data、prev、next，并且第一个节点的prev 指向 nullptr，最后一个节点的next 指向nullptr\n微软用循环 list 实现的\n引入了哨兵节点 sentinel node，是 prev 指针的前一个节点，next指针的后一个节点\n不需要特判 nullptr`\n\n\nThere are two methods to move nodes from another list\n和 insert(pos, it1, it2) 有区别，insert只是拷贝，没有清除操作\n.merge(list2)/.merge(list2, cmp)，通常用在已排序的 list 中\n.splice(pos, list2, ...)\n(): insert the total list2 to pos\n(it2): insert it2 to pos (and remove it from list2)\n(first, last): insert [first, last) to pos (abd remove them from list2)\n\n\n\n\n\nFroward list\nSingle linked list\nForward list 的目的是为了减少存储空间，所以不提供 .size() 函数\n只存储头部节点\n\nContainer adaptors\n容器适配器是对已经存在的容器进行包装，通常情况下不提供迭代器\n\nStack\nStack is a LIFO data structure\nThe provide container show have push_back, emplace_back, pop_back, so vector, deque and list are all OK\nAPIs\n.pop()\n.push(val), .emplace(params)\n.push_range(params) C++ 23\n.top()\n.empty(), .size()\n.swap(s2)\noperator=\noperator&lt;=&gt;\n\n\n\nQueue\nQueue is a FIFO data structure\n.front()\n.end()\n\nPriority queue\nIt’s defined in &lt;queue&gt;\nIt’s in fact max heap\n插入或者弹出元素的时间复杂度是\n建堆的时间复杂度是\nPercolation is the core algorithm\n插入的时候进行上滤 percolate up\n删除的时候进行下滤 percolate down\n\n\n\n\n\nFlat containers\nThe only defect of map/unordered_map/… is that they’re really cache-unfriendly\nFlat containers 对缓存利用率更高\nThe functionality is same as set/map\nBut it’s in fact an ordered “vector”\n没有冗余的数据，对 cache 更友好\n本质上是两个 “vector”\n\n\n\n\nThe whole definition is std::flat_map&lt;Key, Value, Compare = std::less&lt;Key&gt;, ContainerForKey = std::vector&lt;Key&gt;, ContainerForValue = std::vector&lt;Value&gt;&gt;\n也可以使用 deque 作为容器\nThe complexity\nFor lookup,  二分查找\nFor insertion/removal, \nFor iterator++, \n\n\n\nAssociative containers\nThey’re called associative because they associate key with value\nThe value can also be omitted\n\n\nThere exist ordered one and unordered one\n有序的需要比较函数 less than\nBBST (balanced binary search tree) 查找、插入、删除的时间复杂度都是\nRB tree\nAVL\n\n\n\n\n无序的需要提供哈希函数和判断是否相等的函数\n查找、插入、删除的时间复杂度都是\n\n\n\n\n\nMap\nThe key is unique; a single key cannot be mapped to multiple values\nstd::map&lt;Key, Value, CMPForKey = std::less&lt;Key&gt;&gt;\n默认是小于号\nCMPForKey should be able to accept const key\n\n\nFor member accessing\noperator[], at()\nBidirectional iterators\nNotice that the worst complexity of ++/-- is \n对 BBST 进行中序遍历就能得到有序的序列\n.begin() is just the leftmost node and .rbegin() is just the rightmost node\n\n\n\n\n\n\nNote\noperator[] will insert a default-constructed value if the key doesn’t exits\n如果 key 不存在并且默认构造的值也不是真正需要的，用 insert_xxx 效率更高\nconst map不能用operator[]\n如果 value 是不能被默认构造的（例如没有默认构造函数）也是不能用operator[]\n\n\nKey-value pair is stored in RB tree, so iterator also points to the pair\nYou can use structured binding to facilitate iteration\n\n\n\nstd::map&lt;string::string, int&gt; scoreTable{    {\"Li\", 99 },    {\"God Liu\", 99 },    {\"Saint Liu\", 99 },    {\"Liang\", 99 },};for (auto&amp; [name, score] : scoreTable)    std::cout &lt;&lt; name &lt;&lt; '' &lt;&lt; score &lt;&lt; '\\n';\n\n\nAPIs\n\n.lower_bound(key): find it that prev(it)-&gt;key &lt; key &lt;= it-&gt;key\n\nUse key as a lower bound to make [it, end) &gt;= key\n\n\n.lower_bound(key): find it that prev(it)-&gt;key &lt;= key &lt; it-&gt;key\n\nUse key as a lower bound to make [begin, it) &lt;= key\n\n\n.equal_range(key): find it pair with the same key as key in range\n\nInsertion\n\n因为键是唯一的，插入的时候如果 key 存在会失败；无论失败成功都返回pair&lt;iterator, bool&gt;\n\nIf succeed, iterator refers to inserted element and bool is true\nIf fail, iterator refers to the element with the same key and bool is false`\n\n\n插入失败会有多个处理方式\n\nLeave it unchanged\n.insert({key, value})\n.emplace(params)\n\n\nOverwrite it (C++ 17)\n.insert_or_assign(key, value): return pair&lt;iterator, bool&gt;\n\n\nLeave it unchanged and even not construct the inserted value (C++ 17)\n.try_emplace(key, params): same as emplace, except that the params are used to construct value, and emplace is not forbidden to construct the pair in failure 构造 value 非常昂贵的时候使用\n\n\n\n\nYou can also provide a hint iterator for insertion\n\nhint iterator 在被插入元素后面的时候会有效率提升，在前面的话会使效率降低\n\nHint is often used in idiom blow\nauto pLoc = someMap.lower_bound(someKey);if (pLoc != someMap.end() &amp;&amp; !(someMap.Key_comp()(someKey, pLoc-&gt;first)))    return pLoc-&gt;second;else {    auto newValue = expensiveCalculation();    someMap.insert(pLoc, make_pair(someKey, new Value));    return newValue;}\n\n\n\n\nErasure\n\n.erase(...)\n(key)\n(iterator pos)\n(iterator first, iterator last)\n\n\n\n\n.extract(key), extract(iterator pos): extract out the node from the map\n\n.insert(node_type&amp;&amp;): insert the node to the map\n\n.merge(another map/multimap)\n\n\n\n\n\nStructured binding\n\nStructured binding is just auto&amp; [...]{xx}\n\n{xx} can be (xx) or =xx\n\nauto&amp; can be anything\n\nxx can be a pair; it can also be\n\nAn object with all public data members, which will be bound on them\nA C-style array or std::array, which will be bound on elements arr[i]\nA tuple-like thing, which will be bound on every element\n\n\nNote\n\npair and std::array is also somewhat tuple-like thing and can use some tuple methods, e.g. std::get pair 和 std::array 也可以像 tuple 一样，访问的时候也可以使用访问 tuple 的方法\n\n结构化绑定时一个新的声明，不能绑定已经存在的变量，如果想绑定已存在的变量可以使用std::tie(name, score) = pair\n\n结构化绑定的本质是匿名结构体，结构体中的变量是别名\n  std::tuple&lt;int, float&gt; a{1, 1.0f };const auto&amp; [b, c] = a;decltype(b) m = 0; // const int m  = 0;\nStructured binding is usually more efficient than novice/careless programmers 建议使用结构化绑定\n\n\n\n\n\n\nTuple\n\nstd::tuple&lt;int, float, double&gt; t{1, 2.0f, 3.0};\nIt can only be accessed by an index that can be determined in compile time 下标访问的下标只能在编译时确定\nstd::get&lt;0&gt;(tuple) to get the int 1\nC++ 14 可以使用类型获取相应的值，前提是类型不能重复 e.g. std::get&lt;int&gt;(tuple)\nstd::tuple_cat\n\n\n\n\nSet\nSet is just a map without value\nThe only difference with amp is that it doesn’t have operator[] and .at()\nThe iterator points to only key instead of key-value pair\n\nMultimap\n把 key 的唯一性取消了\n不能使用 operator[] 和.at()\n相等的值的顺序取决于插入时的顺序\n插入永远都是成功的\nNodes of multimap and map can be exchanged 两个容器的节点是可以相互替换的\n\nMultiset\nExcept for only key and no value, same as multimap\nYou can also exchange nodes of multiset and set\n\nUnordered map\nstd::unordered_map&lt;Key, Value, Hash = std::hash&lt;key&gt;, Equal = std::equal_to&lt;Key&gt;&gt;\nMany types have std::hash&lt;Type&gt;, e.g. std::string, float, etc.\nThe hash value of different keys may be same, so we need Equal to judge which key is wanted\n微软的实现在解决冲突的时候用双向链表，并且链接相邻的 Bucket 延申出来的双向链表，并添加一个哨兵节点\n当插入数据太多的时候，每个 bucket 也会链接很多数据\n这样会增加查找的复杂度\n is called load factor 装载因子\n装载因子过大时，需要对 bucket array 进行扩容\nRehash 重哈希\n\n\nAPIs\n.bucket_count(): size of bucket array\n.load_factor(): size() / bucket_count()\n.max_load_factor(): when load factor exceeds this limit, refresh will happen\n.rehash(n): make bucket_count() = max(n, ceil(size() / max_load_factor())) and rehash\n.reserve(n)\n.bucket(key): get the bucket index of the key\n.begin(index), .cbegin(index), .end(index), .cend(index): get the iterator of the bucket at index\n.bucket_size(index): get the size of bucket at index\n\n\nYou can also extract nodes and insert them\n\nRanges\nUsing ranges is very like functional programming\n\nThere are three important components in ranges:\n\nRange: A type provides a begin iterator and end sentinel, so that it can be iterated over\nView: A range that can be moved in , copied in  (or cannot be copied) and destructed in \nRange adaptor\n\n\nNote\n\nRange 可以按照迭代器进行分类\n计算是惰性计算\n\n\nThey’re all defined in &lt;range&gt;; all views are defines as std::ranges::xx_view, and all range adaptors are defined as std::views::xx\n\n一般用别名来简化定义 namespace stdr = std::ranges 和namespace stdv = std::views\nstdr::iota_view{lower, upper = INF}, stdv::iota(lower, upper = INF): 和 python 中的 range(a, b) 类似\n\nfor (const auto oddNum : stdv::iota(1, 10)  | stdv::filter([](int num) {return num % 2 == 1; })  | stdv::take(3)){    std::cout &lt;&lt; oddNum &lt;&lt; '';}\nWritable\n\nstdv::filter(Pred): drop the element if the predicate function Pred returns false\nstdv::take(x): take first x elements (but not exceed end)\nstdv::take_while(Pred): take elements until Pred return false (or end)\nstdv::drop(x): drop first x elements\nstdv::drop_while(Pred): drop elements until Pred returns false\nstdv::reverse\nstdv::keys: get the first element from a tuple-like thing\nstdv::values\nstdv::elements&lt;i&gt;: get the ith element from a tuple-like thing\nstdv::stride(k): use k as stride to iterate\ne.g. stdv::iota(1, 0) | stdv::stride(2) gets {1, 3, 5, 7, 9}\n\n\nstdv::join: flattens the ranges to a single range 需要用 | 连接\nstdv::join_with(xx): fill the interval with xx 需要用 | 连接\nstdv::zip(r1, r2, ...): zip values from ranges to a tuple\nstdv::cartesian_product(r1, r2, ...): return a tuple of elements from the cartesian product of these ranges\nstdv::enumerate: return std::tuple&lt;Integer, T&amp;&gt;; Integer is index whose tpe is diff type of iterator\nstdv::slide(width): slide the range in a sliding window of width\ne.g. std::vector v{1, 2, 3, 4, 5}; v | stdv::slide(3) gets {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}\n\n\nstdv::adjacent&lt;width&gt;: same as stdv::slide(width)\nstdv::pairwise: i.e. stdv::adjacent&lt;2&gt;\nstdv::chunk(width): partition the range by width\nstdv::chunk_by(pred2): partition the range by pred2, i.e. a view sill stop when pred2(*it, *next(it)) return false\nstdv::split(xx)\nstdv::lazy_split(xx)\n\n\nRead-only\n\nEither make the view const, i.e. std::as_const; this will return const T&amp; or tuple&lt;const T&amp;, ...&gt;\n\nOr return value, i.e. transform-related, which will return T or tuple&lt;T, ...&gt;\n\nstdv::zip_transform(TransformN, r1, r2, ...): return a view of TransformN(ele1, ele2, ...)\n\nstdv::adjacent_transform&lt;N&gt;(TransformN): return a view of TransformN(...), where ... is the elements of the sliding windows\n\nstdv::transform(Transform): transform element to another element\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5 };int cnt = 0;auto r = v | stdv::transform([&amp;cnt](const int ele) {    std::cout &lt;&lt; std::format(\"cnt={}, ele={}\\n\", cnt, ele);    cnt++;    return cnt + ele;}) | stdv::take_while([](const int ele) {return ele &lt; 10; });for (const auto&amp; i : r);// output:// cnt=0, ele=1// cnt=1, ele=1// cnt=2, ele=2// cnt=3, ele=2// cnt=4, ele=3// cnt=5, ele=3// cnt=6, ele=4\n\n\n++ will trigger transform since take_while needs the transformed value to advance the iterator (i.e. by Pred(*it))\nconst auto&amp; ele = *it will trigger it again\nThat’s because the result doesn’t reference some existing elements, but generate from temporary; every time you need it, lazy evaluation generate it again 太 lazy 了\nSometimes, you may want to convert a range to a e.g. container, which needs to eagerly evaluate all\nstdr::to, e.g. stdr::to&lt;std::vector&gt;()\n\n\n\n\n\n\n\n\nThere are also some naïve range factories\n\nstdv::single(obj): make a view that copies/moves an object, i.e. the view owns only a single element\nstdv::empty&lt;T&gt;: create an empty view\nstdv::repeat(r, k = INF): repeat a range r for k times, i.e. like a range [r, r, r, ...]\nstdv::istream&lt;xxx&gt;(stream): similar to istream_iterator; it caches value\nstdr::subrange(first, last)\n\n\n\nGeneratordef func(end):    begin = 0    while begin != end:        yield begin        begin += 1generator = func(10)for num in generator:    print(num)\n\nWhen the function reaches yield, it will pause and return the number; when iterator moves forward, the function will resume and continue to execute until the next yield or real return\n\nSince C++ 23, generator is also supported by coroutine\nCoroutines cooperates with each other and yield their execution flow themselves 协程之间是相互配合的控制流\nBy contrast, for threads, they usually compete with each other and are interrupted by OS to give other threads chances to execute 线程则是抢占式的\n\n\n\n\nGenerator is just the same; when you need the next value , you just yield your execution flow to the generator function; when the generator function completes its task, it will give back the right of execution\nGenerator is also an input_range and view; it provides begin() and end() to iterate, and ++ the iterator will resume the function\nNOTICE: Call .begin() will start the coroutine\n\n\n\ne.g.\nstd::generator&lt;int&gt; func(int end){    std::cout &lt;&lt; \"Ahh...\";    for (int begin = 0; begin &lt; end; begin++)        co_yield begin;    co_return;}auto generator = func(3);for (auto it = generator.begin(); it != generator.end(); it++)    std::cout &lt;&lt; *it;// orfor (auto&amp; num : generator)    std::cout &lt;&lt; num;\n\n\nSome notes\nOne generator can only be used once 只能使用一次\nGenerator has operator=\nco_return can be omitted\nSaving contexts also needs memory, so an allocator can also be provided as the last template parameter\n\n\n\nFunction 函数Pointer to member functions\nMember functions can be static or non-static\nStatic ones are just normal functions with some Class::, their pointers are same as normal ones\nNon-static ones are always bound to some specific objects, i.e. there is a this pointer as a parameter\n\n\n\ne.g.\nclass Person{    public: unsigned int age;    void AddAge(unsigned int n) {        age += n;    }}using FuncPtr = void (Person::*)(unsigned int);int main(){    Person p{0 }, *pointer = &amp;p;    FuncPtr ptr = &amp;Person::AddAge;    (p.*ptr)(5);    (pointer-&gt;*ptr)(5);    // C++ 17    std::invoke(ptr, p, 5);    std::invoke(ptr, pointer, 5);    return 0;}\n\n\nDefine a pointer to member function is Ret (Class::*)(params)\nstd::invoke define in &lt;functional&gt; since C++ 17\nSince C++ 23, std::invoke_r&lt;Result&gt; is provided\n\nCallable parameterFunction as parameter\n函数指针也可以实现将函数视为参数来传递，但是有两个问题\n有时候函数指针的参数类型有严格的限制，例如 int can be converted to double, func(double) is also acceptable\nIn C++, usually what you need is just “something callable”, i.e. a functor is allowed 有时候只是想传入一个可调用的类型\n\n\n有两种方式解决\nUse a template parameter &lt;algorithm&gt;常用的方法采用模板参数接受可调用的参数\nUse a std::function defined in &lt;functional&gt;\nstd::function&lt;RetType(Args...)&gt; can adopt almost all callable that have the return type convertible to RetType and accept Args\nThe member function even preserves polymorphism\nAfter getting the std::function, you can just use operator() to call it\nEven more powerful, you can bind some parameters to get new functors\nE.g. you can use std::bind(any_callable, params) to get a std::function std::bind已经没有用了，完全可以用 Lambda 表达式绑定\n\n\nThere are two defects\nPerformance: It roughly causes 10% - 20% performance loss compared with direct function call\n有可能会用 new/delete 自定义ctor/dtor\n解决方式是使用 SOO(small object optimization)，在栈上准备一块小的 buffer 用于分配函数空间\n如果绑定的 Lambda 表达是太大可以使用 auto lambda = xx;，然后再通过std::ref(lambda) 传给 std::function 的构造函数（但是要注意声明周期），但是不可以使用std::ref(&amp;&amp;xx)(){...}，lambda 表达式会立马失效\n\n\nThe second defect of std::function is that it cannot really accept all functors 并不是支持所有的可调用类型\nWhen the functor is not copiable (e.g. move-only, like std::unique_ptr) 仿函数不能拷贝的就不能接受\nThus, since C++ 23, std::move_only_function is introduced\n\n\n\n\n\n\n\n\nReference wrapper\nstd::(c)ref() in fact create std::reference_wrapper&lt;(const) T&gt;, which can be seen as an instantiated reference\n例如容器中不可能存储引用类型的，如果想储存引用类型可以使用std::vector&lt;std::reference_wrapper&lt;T&gt;&gt;\nIt’s in fact a wrapper of pointer, but it cannot be null, just like reference\nDifferent from reference, it can be bound to another object by operator=, just like pointer 引用是不可以换绑的，但是 std::ref() 可以\n\n\nIt’s also used to denote “it should be a reference” explicitly in some methods in standard library, e.g. std::bind_back or std::bind_front\n\n\n\n\nThere are also some predefined template functors in &lt;functional&gt;\nArithmetic functors: plus, minus, multiplies, divides, modulus, negate\nComparison functors: equal_to, not_equal_to, greater, less, greater_equal, less_equal, compare_three_way\nLogical functors: logical_and, logical_or, logical_not\nBitwise functors: bit_and, bit_or, bit_xor, bit_not\nThese Functor&lt;T&gt; all have auto operator()(const T&amp;, const T&amp;) const\n\n\n\nLambda expression\nWe call lambda expression without capture stateless lambda; otherwise stateful lambda\n可以使用 decltype(...) 去推断 lambda 表达式的类型\n理论上可以使用推断出来的仿函数的类型进行声明，但是只有再 C++ 20 之后才是合法的\nE.g. auto l = [](int a, int b) {return a + b;}; using T = decltype(l); T l2{};\n只适用 stateless lambda\n\n\n\nAlgorithmsAlgorithms’ Consist\nIterator pairs 迭代器对，或者直接传入 ranges\nPredicate function / transform function 判别函数或者变换函数，通常情况下变换都是const&amp;，或者对于比较小的类型传入拷贝\n大部分算法都返回一个范围迭代器\n从来都不会改变序列的大小\nCallables of algorithm are of value type instead of reference type 判别函数或者变换函数都是传递值类型，不是引用类型\n\nSearch\n两种搜索算法\nLinear search\nFind single value\nstd::find\nstd::find_if\n\n\nFind one of values in a range\nstd::find_first_of\n\n\nFind a sub-sequence in a sequence (Pattern matching)\nstd::search\nstd::find_end\n\n\nOthers\nstd::adjacent_find(begin, end[, Pred2]): 相邻元素相等的位置\nstd::search_n(begin, end, count, value, [, Pred2])\n\n\n\n\nBinary search, which is applied on sorted sequence\nstd::binary_search: return bool, denoting whether value exists in [begin, end)\nstd::lower_bound: return it so that value is the lower bound of [it, end)\nstd::upper_bound: return it so that value is the lower upper of [begin, end)\nstd::equal_range: return an iterator pair (it1, it2) so that value is equal to [it1, it2)\n\n\n\n\n\nComparison\nstd::equal(begin1, end1, ..., [, Pred2]): return a bool\nstd::lexicographical_compare(begin1, end1, begin2, end2[, Pred2]): return bool; Pred2acts asoperator&lt;&gt;`\nCompare until ele1 &lt; ele2 || ele2 &lt; ele1\n\n\nstd::lexicographical_compare_three_way(begin1, end1, begin2, end2[, Pred2]): return an ordering; Pred2 acts as operator&lt;=&gt;\nstd::mismatch(begin1, end1, ...[, Pred2]):  return an iterator pair (it1, it2) denoting the first occurrence of mismatching\nThese algorithms are all \n\nCounting\nstd::all_of/any_of/none_of(begin, end, Pred)\nstd::count(begin, end, value)\nstd::count_if(begin, end, Pred)\nThese algorithms are all \n\nGenerating and Transforming\nstd::fill(begin, end, value)\nstd::fill_n(begin, count, value)\nstd::generate(begin, end, Gen): for each element in [begin, end), ele = Gen()\nstd::for_each(begin, end, Transform): for each element in [begin, end), call Transform(ele)\nstd::transform: There are unary/binary transforms\n(begin, end, dstBegin, Transform): unary 一元\n(begin, end, begin2, dstBeing, Transform): binary, the transformation is Transform(*it1, *it2)\n\n\n\nModifying\nstd::remove(begin, end, value)/std::remove_if(begin, end, Pred): return the iterator so that [begin, it) has no element that is equal to value or make Pred return true\n不会真的擦除迭代器\nSince C++ 20, they’re integrated as methods std::erase/std::erase_if\n\n\nstd::unique(begin, end[, Pred2]): return the iterator so that [begin, it) has not adjacent equal element; Pred2 acts as operator== 使得在 [begin, it) 区间内没有相邻且相等的元素\nThese algorithms are all , by the technique of dual pointers 算法用双指针实现\n定义两个指针 before 和after\n两个指针一开始都指向begin\n先前进after\n判断 *before == *after；相等只前进after，不相等则前进before，并将after 指向的值和 before 交换，前进after\n直到after == end\n需要考虑 begin == end 和整个序列就是 unique 的情况\n\n\nstd::replace(begin, end, oldValue, newValue)/std::replace_if(begin, end, Pred, newValue)\nstd::swap(x, y)\nstd::iter_swap(it1, it2)\nstd::swap_range(begin1, end1, begin2)\nstd::reverse(begin, end)\nstd::rotate(begin, mid, end): left rotate [begin, mid)\n2, 3, 4, 4, 5 -&gt; 4, 5, 2, 3, 4 相当于左移\nRotate is also \nbrute-force method: swap each element ot its position (just like bubble sort). This will be  一个一个的交换，需要两层循环\n可以考虑将第一个元素拿出来，再确定序列中哪一个元素会再下一步出现在第一个位置，然后进行替换，以此类推完成旋转\n但是这种方式对 cache 不友好\n\n\nswap all groups together\nThe complexity is \n    \n\n\n\nreverse\nIn fact, reverse is the basis of many algorithms\n[begin, mid - 1]``[mid, end - 1]\nReverse two sub-sequences, get [mid - 1, being]``[end - 1, mid]\nReverse the total sequence, get [mid, end - 1]``[begin, mid - 1]\nThe complexity is \n\n\n\n\n\n\nstd::shift_left/right(begin, end, n): the dropped elements are permanently dropped (invalid)\n\nCopying\nstd::copy(begin1, end1, dstBegin)\nstd::copy_if(begin1, end1, dstBegin[, Pred])\nstd::copy_n(begin1, n, dstBegin)\nstd::copy_backward(begin1, end1, dstBegin)\n\nPartition and SortPartitionPartition denotes that a range is divide into two parts; assuming predicate function Pred, then there exists an iterator it (i.e. partition point 轴点） so that all elements in [begin, it) make Pred return true while [it, end) make Pred return false 左边的都小于轴点（使得 Pred 函数返回 true），右边的都大于轴点（使得Pred 函数返回false）\n\nstd::is_partitioned(begin, end, Pred)\nstd::partition(begin, end, Pred)\nstd::stable_partition(begin, end, Pred): each sub-partition preserves the original order 保证 partition 后的结果和原序列的顺序一致\n原序列 {0, 1, 9, 4, 5, 2, 7, 8}, Pred为 [](const int ele) {return ele % 2;} 左边是奇数右边是偶数\nstd::partition: {7, 1, 9, 5, 4, 2, 0, 8}\nstd::stable_partition: {1, 9, 5, 7, 0, 4, 2, 8}\nImplementation:\nWhen the memory is enough （内存足够）, prepare a buffer; move the false range to the buffer and move the true range to be consecutive (just like preform std::remove_if(), with removed range saved in buffer). Then move the buffer elements back\nWhen the memory is not enough （内存不够）, divide the sequence into two halves and stable partition each half\nThis will from [true, false], [true, false] sequence 最终都会变成这样的序列\nRotate the middle [false, true] so that the final result is totally partitioned\n, to it’s overall \n\n\n\n\n\n\nstd::partition_point(begin, end, Pred): assume the range is a partition 前提是序列已经是 partition\n\nSort\nstd::is_sorted(begin, end[, Pred2]) \nstd::is_sorted_until(begin, end[, Pred2]) \nstd::sort(begin, end[, Pred2]) \nstd::stable_sort(begin, end[, Pred2])\n space complexity,  time complexity\nIf space is insufficient,  time complexity\n\n\nSince std::sort requires the complexity exactly , quick sort is not enough 快排只是平均意义上的，最坏的情况是\nC++ 标准库广泛使用的排序算法是 Introspective Sort(IntroSort)\nIt integrates insertion sort, heap sort and quick sort 结合了插入排序，堆排序和快排\nWhen the element number is low enough, insertion sort is used\nWhen the recursion is too deep, heap sort is used\n避免快排的最坏情况\n堆排序是稳定\n堆排序速度不是很快，对 cache 也不是很友好\n\n\n\n\nstd::partial_sort(begin, mid, end)\nstd::nth_element(begin, mid, end): rearrange [begin, end) so that *mid is sorted (i.e. same as the *mid in the full sorted range) and the whole range is partitioned by it 在排好序的中第 n 个位置的元素\nstd::merge(begin1, end1, begin2, end2, dstBegin[, Pred2])\nstd::inplace_merge(begin, mid, end)\n\nHeap\nstd::is_heap(_until)(begin, end[, Pred2])\nstd::make_heap(begin, end[, Pred2]): Floyd algorithm \nstd::push_heap(begin, end[, Pred2])\nstd::pop_heap(begin, end[, Pred2])\nstd::sort_heap(begin, end[, Pred2])\n\nSet OperationsSet operations are used on sorted range, including set\n\nstd::includes(begin1, end1, begin2, end2[, Pred2]): check whether th second range is subset of the first range\n    \n    \n\nstd::set_intersection(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_union(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_symmetric_difference(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_difference(begin1, end1, begin2, end2, dstBegin[, Pred2]): \n\nMinMax\nstd::min/max/minmax(a, b[, Pred2]): return (pair of) reference of the smaller/bigger element\nstd::min_element/max_element/minmax_element(begin, end[, Pred2]): return the iterator of the minimum/maximum value in the range\nstd::clamp(value, low, high)\n\nPermutationPermutation means that two sequence are unorderly equal\n\nstd::is_permutation(begin, end1, begin2[, Pred2])\n\n\n\nstd::prev/next_permutation(begin, end[, Pred2]): return the sequence to the previous/next permutation\n\nNumeric AlgorithmsThey are all \n\nFor the most basic ones:\nstd::iota(begin, end, beginVal): fill in [begin, end) with {beginVal, ++beginVal, ...}\nstd::adjacent_difference(begin, end, dstBegin, Op = std::minus): as its name, output {val[0], val[1] - val[0], val[2] - val[1], ...}\nstd::accumulate(begin, end, initVal, Op = std::plus): accumulate all values, return \nstd::partial_sum(begin, end, dstBegin, Op = std::plus): output {val[0], val[0] + val[1], val[0] + val[1] + val[2], ...}\nstd::inner_product(begin1, end1, begin2, initVal, Op1 = std::plus, Op2 = std::multiplies): finally get initVal + a[0] * b[0] + a[1] * b[1] + ...\nstd::reduce(begin, end, initVal, Op = std::plus): same as accumulate\nstd::inclusive_scan(begin, end, dstBegin, Op = std::plus[, initVal]): same as partial sum\nstd::transform_reduce(begin1, end1, begin2, initVal, ReduceOp = std::plus, BiTransformOp = std::multiplies): same as inner product\nstd::exclusive_scan(begin, end, dstBegin, initVal, Op = std::plus): similar to partial, but exclude the element itself, i.e. the sequence is {initVal, initVal + val[0], ..., initVal + val[0] + ... + val[n - 2]}\nstd::transform_inclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])\nstd::transform_exclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])\n\n\nstd::gcd(a, b): 最大公约数\nstd::lcm(a, b): 最小公倍数\nstd::midpoint(a, b): since C++ 20, return a + (b - a) / 2\n\nParallel Algorithm\nThere are two kinds of parallelism\nSIMD: single instruction multiple data 单指令多数据\nSIMT: single instruction multiple threads\n\n\nSince C++ 17, parallel-version algorithms are added\nDefined in &lt;execution&gt;\nThere are four execution policies defined in std::execution\nseq: sequenced policy 完全不并行\npar: parallel policy 并行\nunseq: unsequenced policy (since C++ 20) 算法可以适应 SIMD\npar_unseq: parallel and unsequenced policy\n\n\n\n\nThere are four kinds of data dependencies\nRAR: read after read 可以使用par_unseq\nE.g. std::adjacent_find\n\n\nRAW: read after write, e.g. a[j] = a[j - 1] + 1\nWAR: write after read, e.g. a[j - 1] = a[j] + 1\nWAW: write after write\n\n\nParallel algorithms\nstd::partition, std::nth_element\nstd::merge\nstd::inplace_merge\n\n\nThere are also some algorithms that cannot be parallelized\nThose who only operate on several values, e.g. std::min/max/minmax/clamp, std::swap/iter_swap\n随机算法\nstd::search\nstd::push/pop/make/sort_heap\n排列算法\n二叉搜索算法\nOrdered numeric algorithms, i.e. std::iota/accumulate/inner_product/partial_sum\n\n\n\nRange-version Algorithms算法中需要声明迭代器，当操作的是一整个容器时，就需要 begin 和end，所以可以使用ranges。range-version 算法也可以叫做 constrained algorithms，使得算法操作更加灵活\n\nYou can additionally specify projection as the last parameter, i.e. transformation of elements before entering the real function 最后一个参数可以指定一个映射，例如使用 transform 在传入函数前进行变换\nThis just changes criteria（标准；条件）, the element itself is unchanged\nMultiple ranges may specify multiple projections\n\n\n\nstd::vector vec{-1, 2, -3, 4, -5, 6 };auto print = [](int i) {    std::cout &lt;&lt; i &lt;&lt; \",\";};std::cout &lt;&lt; \"with abs() projection: \\n\";std::ranges::sort(vec, {}, [](int i) {return std::abs(i); });std::range::for_each(vec, print);\n\n\nRange-version algorithms also have these advantages\n使用了 C++20 中的 concept\nThe range doesn’t need to be comma (i.e. begin/end with the same type) begin和 end 不要求类型相同\n更加安全\n有些算法被加强了\n新的方法加入进来\n用模板方法更容易\n\n\nThere are also some defects\n不能使用并行算法\n一些算法被削弱了\n返回值类型并不和 std:: 相同，返回值改变有以下几种形式\nstdr::in_in_result&lt;I1, I2&gt;: 本来返回两个迭代器，现在返回了一个结构体，里面的成员变量是两个迭代器\nstdr::in_out_result&lt;I, O&gt;\nstdr::in_in_out_result&lt;I1, I2, O&gt;\nstdr::set_union/intersection/symmetric_difference\nstdr::merge\nbinary stdr::transform\n\n\nstdr::in_out_out_result&lt;I1, I2, O&gt;\nstdr::partition_copy\n\n\nstdr::in_found_result&lt;T&gt;\n\n\n\n\n\nLifetimeStorage duration 存储持续性There are four kinds of storage duration\n\nStatic storage duration: global variables, static variables in a function/class\nAutomatic storage duration: variables that belong to a block scope ro function arguments 定义的时候构造，退出的时候析构\nDynamic storage duration: you can create objects by using or some other allocation functions\nThread storage duration: 线程创建的时候构造，线程退出的时候析构\n\nThe lifetime of an object begins when storage with proper alignment and size is allocated and the object is initialized 合适的对齐，合适的大小，以及初始化\nThe lifetime of an object ends when it’s destroy, or the dtor is called, or its storage is released or reused by non-nested object 析构函数被调用，存储被释放，被重用（float类型的变量通过某些手段被 int 类型变量占用）\nTemporary objects are only alive until the statement ends (i.e. until ;) 临时变量的声明周期只到语句结束之前，也就是 ; 分号之后才结束\n\n函数中的参数传递 const&amp; 或std::function_ref是安全的\n返回临时变量可以延长对象的生命周期，例如const&amp;struct A{};A bar() {return A{};};const A&amp; a = bar();\n\nIn modern C++, pointer is far beyond address; it has type T*, and you can hardly ever access some address by it when there are no underlying objects of type T alive 指针的功能远远超出寻址的语义，指针是带有类型的概念；如果指针指向的地址不符合指针具有的类型，如果再用指针访问相应的元素就会是无效的\nPlacement new“就地初始化” ConstructOnBuffet, which won’t allocate memory, but only create the object at the place 不在重新分配内存，直接在现有已开辟的内存空间中创建对象\nalignas(T) unsigned chat buf[sizeof(T)];T* tptr = new(buf) T;tptr-&gt;~T();\n\n\nnew(buffet) Type Initializer, where Initializer is optional\nOf course, you need to make sure the alignment satisfies the requirement of the type, so you can use keyword alignas  为了保证类型对齐需要用到在 C++ 11 引入的关键字alignas\n\n\n\nstd::byte: defined in &lt;cstddef&gt; since C++ 17; it’s just an enumeration class and explicitly represents a byte (before we may use unsigned char)\nTrivial dtor\nIt’s implicitly declared or declared with =default 隐式生成（编译器）的或者被定义为default\nIt’s non-virtual and all non-static data members have trivial dtor 所有的非静态成员都有 trivial dtor，并且成员不能是虚的\nFor example\n✅struct A{int a; float b;};\n✅class A{int a; public: float b; ~A() = default };\n✅class A{int a; public: float b; virtual ~A() = default };\n❎class B : public A{};\n❎class A{~A() {}};\n❎class A{std::unique_ptr&lt;int&gt; ptr;};\n\n\n\n\n\n\nCorner Cases\nCase1: if you construct an object that has the same type as the original object, and they occupies exactly same storage, then the original name, pointers and references are still valid 就像赋值符号一样\nCase2: it’s best to reuse storage of plain types like int or classes that have trivial dtor 如果要重用内存尽量使用简单的类型，例如 int 或者带有 trivial dtor 的类，对于其他类型编译器会在退出当前 scope 时候会自动调用析构函数\nCase3: it’s illegal to reuse memory of const objects that have determined their value in the compilation time\nCase4: unsigned char/std::byte array is explicitly regulated to be able to provide storage 这两个类型的数组是明确地可以提供 storage 的\nCase5: It’s legal to access the underlying object by pointers without the same type in these cases (type punning/aliasing 类型堆叠 / 类型别名） 在少数情况下可以使用不同类型的指针访问一些对象\nadd/remove cv-qualification int类型的指针可以使用 const int 类型的指针访问\ndecayed array 用指针访问数组的元素\nif the underlying type is integer, then using the pointer of its signed/unsigned variant to access it is OK\nconvert it to (unsigned) char*/ std::byte* 允许将对象视作字节数组 byte array\n\n\nCase6:If you have an old pointer where you’ve constructed a new object, but you want to use the old pointer to get the new pointer, you can use std::launder（洗涤；洗钱） defined in &lt;new&gt; since C++ 17\nstd::launder(reinterpret_cast&lt;A*&gt;(buffer)) to get the actual valid pointer 用旧的指针获得指向新的对象的指针\n\n\n\nStrict Aliasing RulesStrict aliasing rules, if pointers are not aliased or not contained as member, then compilers can freely assume that they’re different objects 本质上就是检查两个指针指向的区域有没有可能重叠\nstruct T{    uint8_t* target;    char* source;    void Unpack(int size)    {        while (size &gt; 0)        {            uint64_t t;            std::memcpy(&amp;t, source, sizeof(t));            target[0] = t &amp; 0x7;            target[1] = (t &gt;&gt; 3) &amp; 0x7;            target[2] = (t &gt;&gt; 6) &amp; 0x7;            target[3] = (t &gt;&gt; 9) &amp; 0x7;            source += 6, size -= 6, target += 16;        }    }};\n\n\nCompared with non-member version (i.e. Unpack(uint8_t* target, char* src, int size)), it’s 15% slower\ntarget is an alias of this. It will then always reload target[i] instead of caching a qword to prevent change of target 编译器认为 target 是this的别名\n\nOthers\nAttention to lambda lifetime\nLambda lifetime should always be shorter than reference captures\nIf you capture in the class, then this only captures members by this, which may be invalid after destruction 如果 this 被析构掉，就算是把 this 拷贝出来，还是失效的\n\n\nAttention to view lifetime\nSometimes you mey return a view generated by range adaptor in a function (e.g. v | std::reverse)\nFor lvalue, it’s same as the lvalue itself, i.e. v here\nFor rvalue, it’ll same as return a value, so that it’s always safe 临时值\n\n\n所有的 range adaptors 在调用之前都会调用 stdv::all 尝试将 range 转换成 view；但是对于 view 来说不做任何事情\nFor lvalue range, it’ll create a stdr::ref_view\nFor rvalue range, it’ll create a stdr::owning_view\n\n\n\n\n\nType SafetyImplicit Conversion\nSome implicit conversions are automatic (standard conversions), and others are user-defined 很多隐式的转型都是自动的\nE.g. operator float(). If you declare it as explicit, then implicit conversion will be disabled\n\n\nStandard conversions\nLvalue-to rvalue conversion, array-to-pointer conversion, function-to-pointer conversion\nDecay actually means\nArray/Function -&gt; pointer\nOr for other types, remove remove references first, remove cv-qualifiers(const &amp; volatile) next\nYou can use std::decay_t&lt;T&gt; to get the decayed type\nauto a = xx; will also decay the deduced type, while auto&amp; will not\nBut structured binding auto [a, b] = xx; “seems” not decay decay 看似没发生，其实是发生在结构化绑定的实现上，相当于 auto anonymous = xx;，a 和b是成员变量的别名，decay 发生在 anonymous 中\n\n\n\n\n\n\nNumeric promotions and conversions\nPromotion: promotion has higher precedence and will not lose precision\nb + c where b and c are unsigned short will in fact silently promote them to int and then do + 先提升到 int 然后再做加法\n至少提升到int\nfloat can be promoted to double\n\n\nSigned value has negative values while unsigned ones don’t, but conversion may happen\nfloat cannot represent all int/... but int can be converted to float implicitly\nAny scalar types can be converted to bool\nPointers can be converted to void* to base class, and nullptr can be converted to pointer directly\nPointer to member of derived class can also be converted to pointer to member of base class, i.e. Derived::int* -&gt; Base::int*\nThere are also some numeric conversions that need explicit cast 数值上的转换需要显示的转换\nNarrow integer conversion will mod  例如 int -&gt; short，long long -&gt; int 会把高位的位数截断\nNarrow floating conversion will be rounded\nFloating to integer will truncate the digits after dot; UB if truncated integer is not representable by converted type\n\n\n\n\n(Exception-specified) function pointer conversion\n可以把 noexcept 的函数指针转换成没有 noexcept 的函数指针\n\n\nQualification conversions\nYou can convert a non-const/non-volatile to const/volatile one\n\n\n\n\n\nStatic Caststatic_cast is the most powerful one, which can process almost all of normal conversion,defined as static_cast&lt;TargetType&gt;(Exp)\n\nStandard-layout\n\n所有的成员都有相同的访问属性\n没有虚函数\nThe base class is not the type of the first member data 基类对象不能是子类第一个成员变量\n整个继承结构，只能有其中一个类是有非静态的变量\n\n\n\nAll implicit conversions can be explicitly denoted by static_cast 可以做任何一种隐式的转换，也会允许逆操作 e.g. int -&gt; short, double -&gt; float\nScoped enumeration can be converted to/from integer or floating point, which is same as the underlying integer type\nInheritance-related conversions\nupcast 向基类转换；更安全的\ndowncast 向派生类转换；有点危险\n\n\nFor static_cast, besides inheritance-related pointer conversion, it also processes void*\nYou can convert any object pointer to void* (this is also implicit conversion)\nYou can also convert explicitly void* to any object pointer 前提是对象潜在的类型 U 和指针的类型 T 有某种特殊的关系——pointer-interconvertible\nT == U\nU is a union type, while T is type of its member\nU is standard-layout, while T is type of its first member or its base class\nOr all vice versa/transitivity\n\n\n\n\n并不保证地址是相同的\nConvert to void: just discard value, nothing happens\nConstruct new object: if the object ctor can accept a single parameter, which is convertible from the expression, then it in fact constructs a new object. E.g. static_cast&lt;A&gt;(a) for A(int)\nTransform value category\nstatic_cast can be used to specify which overload of functions is used by function-to-pointer conversion\n\nDynamic Cast and RTTIDynamic Caststatic_cast在继承链中检查是非常弱的（可以说是不做检查），即便转换的对象不是派生类的类型仍然会做转换，只是会带来 undefined behavior。dynamic_cast尝试解决这个问题，如果转换不合适会失败\n\n引用上转换失败会抛出异常throw std::bad_cast\n指针上转换失败会返回nullptr\n比 UB 更强，更容易定位 bug\n\n为了做了运行时检查，C++ 编译器会在文件中保留运行时的类型识别（RTTI, Run-Time Type Information/Identification），dynamic_cast只能用在多态的类型转换中，因为 RTTI 依赖于虚指针等特性。但是 dynamic_cast 性能上要比 static_cast 慢 10 倍甚至百倍\n\nYou can do downcast in polymorphic types\n被转换的对象，潜在的对象类型必须和基类的类型相同，否则不能转换成功\ndynamic_cast不能用在当前类构造函数和析构函数中，因为当前类的虚指针不是完整的\n\n\nYou can also do sidecast in polymorphic types with multiple inheritance\n\nRTTIC++ 提供了一种方式可以直接得到类型的信息，定义在 &lt;typeinfo&gt;，同样要限制使用，会造成性能上的问题。可以使用typeid(xxx) 得到 const std::type_info，类似于sizeof 操作符。type_info是只读的，不能通过拷贝或者构造，只能通过 typeid 获得或者引用。可以使用 .name() 进行 debug\n\n.name()\n.hash_code()\n.before()\n\nRTTI is unfriendly to shared library 对动态链接库不是友好的\n\nSince GCC 3.0, symbols are compared equality by address instead fo names. So to preserve only one symbol across many .obj file, it  merges them when linking (like in static library) 符号使用地址比较相等性，而不是通过名字比较相等性；即使两个符号的名字是相等的，地址不相等，当出现在不同的 .obj 文件中的时候，会将名字相等的符号进行地址合并\nSo to load shared library quickly, many procedures are omitted, which includes resolving different RTTI symbols 为了快速链接动态链接库，很多步骤都要被省略，其中也包括 RTTI 符号的合并\n\nConst Cast\nIt tries to drop the cv-qualifiers\n明确的知道了原来的对象就是非 read-only，然后接收到的对象是 const 类型的\nThe author forgets the const in parameter, but it in fact doesn’t write it\n\n\nvolatile is similar 把 volatile 去掉会有 cache 的风险，volatile要求每次使用都要到内存中重新去读\n一般情况下用不到\n\nReinterpret Castreinterpret_cast is used to process pointers of different types, which is dangerous because of life time\n\nConverting from an object pointer to another type, i.e. reinterpret_cast&lt;T*&gt;(xxx)\nThis is same as static_cast&lt;T*&gt;)(static_cast&lt;(cv) void*&gt;(xxx))\nstd::launder\n\n\nConverting from a pointer to function to another type of pointer to function; or pointer to member to another one\nConverting pointer to integer or vice versa （反之亦然）\nA pointer can be converted to integer by reinterpret_cast if the integer is large enough (std::uintptr_t)\nThis integer can be converted back to get the original pointer\nreinterpret_cast from 0/NULL is UB\nReference is also convertible 引用和指针一样\n\n\n\nType-safe union and void*\nSince C++ 17, &lt;variant&gt; and &lt;any&gt; are introduced to guarantee the safety\n\nstd::variant can be seen as a union with a size_t index, which will inspect whether the member is  in its lifetime when getting\nstd::variant&lt;int, float, int, std::vector&lt;int&gt;&gt; v{1.0f };// 类似于union Union {    int _1;    float _2;    int _3;    std::vector&lt;int&gt; _4;};\n\n\nFor construction\nBy default, the first alternative is value-initialized 默认第一个位置被初始化\nYou can also assign a value with the same type of some alternative, then this’s the active alternative\nYou can also construct the member in place,i.e. by (std::in_place_type&lt;T&gt;, args...)\nYou can construct by index, i.e. (std::in_place_index&lt;Index&gt;, args...)\n\n\nTo access or check the existence of alternative\n.index(): return the index of active alternative\nThese methods need the examined type unique in type params\nstd::hold_alternative&lt;T&gt;(v): return Boolean that denotes whether the active alternative is of type T\nstd::get&lt;T&gt;(v): return the active alternative of type T 传入引用\nstd::get_if&lt;T&gt;(v): return the pointer to the active alternative of type T 传入指针\n\n\nIf not unique, you can also use index-based access: std::get&lt;I&gt;(v), std::get_if&lt;I&gt;(v)\n\n\nBesides type safety, the most important extension of std::variant than union is that it implements visitor pattern\n\n\nstd::any can be seen as a void* with the original type “stored” magically, so that you’ll fail to grasp（理解；领会） the inner object with the wrong type 可以加载任意的对象\nstd::any a{1 };a = 2.0f;a = \"test\";\n\n\n承载的对象必须有构造函数，类型会 decay\nYou can also default-construct it or call .reset(), then it holds nothing\n.has_value()\n(std::in_place_t&lt;T&gt;, args...)\nWhen you need to get the underlying object, you need to use std::any_cast&lt;T&gt;(a) or (&amp;a)\nstd::any can have SBO (small buffer optimization) like std::function 标准库会给 std::any 在栈上分配比较小的 buffer，存储一些非常小的对象，而不是在堆上分配内存\n.swap/std::swap/.emplace\n.type()\nstd::make_any, same as constructing std::any\n\n\n\n\n\nProgramming in Multiple FilesRemember the compilation procedures of C\n\nPreprocess, where comments are stripped and macros are processed (so that your #include can get the file correctly)\nCompile, where each source file is compiled independently 编译\nAssemble; this is not something we care since it just translate assembly to object file 汇编\nLink, to locate symbols that are referred in other TUs(Translation unit) 链接\n\nPreprocessor 预处理器To be specific, preprocessing can be divided into 6 phases\n\nRead files and map them to translation character set, which guarantees UTF-7 to be supported 读文件 映射\nBackslashes as the end of line are processed to concatenate two physical lines into a single logical line 处理反斜杠\\\nComments and macros are extracted, and the whole file is parsed\nPreprocessor runs to process all macros\nString literals are encoded as specified by the prefix 处理字符串常量，按照指定的前缀进行编码\nAdjacent string literals are concatenated ；邻近的字符串拼接\n\nA preprocessing directive begins with #. There are four kinds of directives\n\n#include ..., which copies all file content into the current file\n\n#include &lt;...&gt;\n#include \"...\"\n\n\n#define i.e. macros, which does pure text replacement\n\n#define FUNC(a, b) a + b\n\nParameters of macros can be blank\n\nParameters of macros are directly parsed by commas when no paratheses surrounded, e.g. FUNC(SomeFunc&lt;int, double&gt;()) -&gt; SomeFunc&lt;int + double&gt;() 用 , 直接进行分词，遇到 , 就会替换\n\nYou need to add an additional pair of paratheses to help parse, e.g. FUNC((SomeFunc&lt;int, double&gt;()), 3)\n\nYou can use ... for parameters of any number, and reference them by __VA_ARGS__ 变长参数的替换\n\nSince C++ 20, you can use __VA_OPT__(content), which will be enabled only when __VA_ARGS__ is not empty\n\n# can be used to turn parameters to strings, and  ## can be used to concatenate parameters to make them a whole token\n#define NameToStr(a, b) #a #bauto str = NameToStr(1, aa)#define ConcatName(a, id) a ## idint ConcatName(a, 1) = 0;std::cout &lt;&lt; a1;\n\n\nYou need #undef to drop the definition of the macro 取消宏定义\n\n\n\nConditional choice of code\n\n#ifdef, (#elifdef since C++ 23), #else\n#ifndef, (#elifndef since C++ 23), #else\n#if defined xx is equivalent to #ifdef xx\n#endif\n#if, #elif, #else\n\n\n#pragma is in fact a macro for implementation-defined usage 需要查看编译器文档或者其他相关文档才能知道具体的用途\n\n#pragma once, #pragma pack\n\n\n#line: specify the line number manually\n\n\nCompileDeclaration &amp; Definition\nTranslation unit (TU)\n每一个源文件都是单独进行编译，最后通过连接器去链接未知的符号，每个源文件通过预处理将其他符号加到当前文件中，这一整个处理结果就是 TU\nC++ 要求先声明再使用，所以每个 TU 首先要看到所使用的声明\nC/C++ has One-Definition Rule (ODR), meaning that each entity should have only one definition in a TU or even in a program 一个实体只能定义一次\n\n\n典型的声明和定义\nFunction prototype &amp; one with function body 函数签名和具有函数体的函数，也包括类的成员函数\nclass A;, class A{...}, struct 类的声明和定义\nenum class A (: Type)\n\n\n类的声明是一个比较特殊的实体，对于函数来说只需要暴露函数的签名就可以使用，但是对于类来说声明是远远不能够使用类\nIt only requires the class to be defined only once in a TU\nBesides, class definition requires to fully see all definitions of its members &amp; base classes 类的定义必须要求有完整的定义，包括类的成员和基类\nYou cannot class Vector3; class A {Vector3 v;};\nThis is because compilers need to determine the layout of the class; if definition of some members are unknown, its sizeof is unclear 编译器必须知道类的大小\n\n\nWe can use mere class declarations in these cases 只需要使用类的声明的情况\nAs an argument of prototype; its members and layout are not used 做为函数的参数\nWhen you only needs a pointer or reference as members 用指针或者引用指向类\n\n\nNotes\nIt’s allowed to put definition of methods into class definition\nReturn types and parameter types of declarations and definitions of methods should be the same\nfriend will implicitly declares the class or function\nClass members in class definition is in fact definition instead of just simple declaration, so we don’t need to define it again in .cpp\nDefault parameters of functions should be put into declaration, and shouldn’t be put into definition\nType alias (like using) and static_assert are also declarations\nheader guard 解决定义出现两次的问题 #pragma once\n\n\nTemplate 的声明和定义\nTemplate will not preserve its information to object file\n在头文件中写声明和定义\nFunction template in class should also be put into header\n\n\n\nNamespace\nWhen code base is large, name conflicts usually happen 解决命名冲突，C 语言中解决方式是加大量的前缀\n\nusing namespace xx is like from xx import *\n\nusing yy::xx is like from yy import xx\n\nYou should never put using namespace xxx or using xx into header files\n\nInline namespace has nothing to do with inline. It’ll expose contents into the parent namespace, as if there is a using namespace xx 和关键字 inline 毫无关系，目的是把所包含的内容暴露到上层命名空间中\nnamespace Test6{    inline namespace Implv1    {        void Func();    }}namespace Test6::Implv1{    void Func()    {        std::cout &lt;&lt; \"This is v1.\\n\";    }}// 调用的时候完全可以将 `Implv1` 忽略掉Test6::Func();\n\n\n老代码需要兼容，新代码可以平滑过渡\n\n\n\nInline\nRecall procedures of function calls\nCaller saves registers on the stack\nJump to the calling position 跳转到函数所在的地址\nCallee saves registers, execute code, and restores registers 对于函数本身来说也会保存寄存器，并执行代码，在把寄存器中的内存恢复\nJumping back by popping up the return address\nCaller restores registers on the stack\n\n\nIf we can fuse function body into the caller and optimize together, then register saving / restoring and jumping will be almost eliminated 直接将内联函数插入到调用的地方，寄存器的保存和恢复，以及跳转的开销会被消除以达到优化的目的\nInline function should be put into header files 因为每个源文件都需要知道内联的函数体\ninline也会造成其他问题\nThe code size may bloat（膨胀）, since the function body is inserted everywhere\nUtility of instruction cache may be lower, since the same function has different addresses 对 i-cache 的利用率降低，相同的代码具有完全不一样的地址\nInline function won’t create their function address, so you cannot “jump to the next” when debugging 进行 debug 时把整个函数跳过去了\n\n\ninline is just an suggestion to compiler, and compiler may choose to not inline the body\n递归调用\n函数本身逻辑比较复杂\n不知道什么时候使用 inline 合适\n\n\nSince C++ 17, inline variables are introduced 内联变量，可以直接把内联变量放到头文件中\nThis mainly facilitates header-only libraries, since they hope to use some global variables without source files\nInline variables can also be in class definitions, so that static variable can be unnecessary to split definition and declaration 静态变量就不需要分开声明和定义了\n\n\nInline functions/variables may cause double symbols in shared libraries 内联函数 / 变量会在动态链接是造成双定义\n静态链接库是需要完全的符号合并\n但是动态链接库的符号是未必进行合并的 RTTI\n在链接库的内外会存在两个版本的变量\n\n\n\nLinkageExternal linkage: Linker can always find the symbol in other TUs 链接器在大多数情况下都能在其他的 TU 中找到相关符号，这种的叫做外部链接，几乎所有的实体在不加关键字的情况下，都是 external linkage\n\nClass members\nFunctions\nFunctions declared by friend\nEnumerations\nTemplates\nNon-const variables, volatile variables and inline variables\n\nInternal linkage: 但是有的时候不想暴露实体，使用外部链接会让其他 TU 窃取实现的私密性\n\nstatic in introduced to force internal linkage 用 static 关键字声明内部链接性实体\nUnlike static member functions, static that denotes linkage is necessary in definition 在函数定义时需要带上static，成员函数则不需要\n外部链接性和模板实例化不会冲突，完全是两个不相干的概念\n\n\nAnother way is to define things in an anonymous namespace 需要定义大量的内部链接性实体时候可以使用\nThere are some special cases where entities are born with internal linkage\nconst global variables\nAnonymous unions\n\n\n\nSingleton\nReason\nThe sequence of initializing global variables across TU isn’t determined 全局变量初始化的顺序在同一个 TU 中可以保证，但是在不同的 TU 中不能保证\nSide effects caused by global variables may not be executed\n\n\n\n// singleton.h#pragma onceclass Singleton{public:    static Singleton&amp; GetInstance();private:    Singleton() = default;}// singleton.cpp#include \"singleton.h\"Singleton&amp; Singleton::GetInstance(){    static Singleton* instance = new Singleton();    return *instance;}\n\n\nNo linkage 无链性\nThis happens for static local variables (i.e. static variables in functions) and normal local variables\nYou can even define a class inside the block scope, which also has no linkage\n\n\n\nXMakeXMake acts as both a build tool and a package manager\n\n(Optional) Project name, project version and required xmake version\nset_project(\"Programming in Multiple Files\")set_xmakever(\"2.8.1\")set_version(\"0.0.0\"\nModes and language version\nadd_rules(\"mode.debug\", \"mode.release\")set_languages(\"cxx20\")\nSome other options\nset_policy(\"build.warning\", true)set_warning(\"all\")\n\n\nset_policy(\"build.warning\", true) means that report warning even if compile success\n\n\nAdd required packages add_requires(\"ctre 3.8.1\", \"catch2\")\n\nSpecify the building target\ntarget(\"example\")    set_kind(\"binary\")    add_headerfiles(\"example1/*.h\")    add_files(\"example1/*.cpp\")\n\n\ntarget(name)\nset_kind(...)\nbinary will compile the executable\nstatic static library\nshared stared library/dynamic-linked library\nphony empty, just used to combine targets like libraries\nheader_only for projects that only have header files\n\n\nadd_files(...)\nadd_headerfiles(...)\n\n\nxmake to compile all targets\n\nxmake -b xx to compile specific targets\nxmake run xx to run specific executable\n\n\n\nModules\nThere are several problems in headers\n\nNon-inline functions cannot be defined to keep ODR\n#include always requires the preprocessor to copy all contents, which makes the real file huge and drags the compilation stage\nIf marcos aren’t undef, they will be leaked\n\n\nEvery module has only one primary interface unit\n\nBegin with export module Name 在文件开始时声明\n\nIt regulates that entities are visible to other modules by export 文件中的其他实体都可以加 export 关键字\n\nModule interface files have no determined suffix\n\nmsvc - ixx\nclang - cppm\ngcc - don’t care\nIt can also be mmp, mmx\n\n\nexport import 字面意义\n\nModules 也允许声明和定义分离，原理是 module implementation unit\n\nIt begins with module Name; and shouldn’t have any export\nA module can have multiple implementation files, as long as they all begin with module Name; 一个模块可以有多个源文件去实现\nYou can directly import \"xxx.h\"; they’re called header unit\nC++ uses global module fragment\nIt begins before export module Name; or module Name;\n\n\n\nmodule; // global module fragment#define NEED_PARAM#include \"Old.h\"module Person; //\n\n\nYou can partition either interface or implementation 如果模块太大也可以进行拆分\n\nInterface partition unit: begin with export module Name:SubName;\nImplementation partition unit: begin with module Name:SubName2;\n分区时模块内部的概念，对其他模块是透明的\nInside the module, it can use import :SubName to import the partition\nBut in other modules, they cannot use import Name:SubName\n\n\nUnlike module implementation, implementation partition is not implementation of interface partition 模块的实现分区和模块的接口分区并不是实现的对应关系，不能在出现同名的分区了\nIf there exists module A:B; there shouldn’t exist export module A:B\n\n\nPartitions cannot have partitions (depth == 1) 分区不能再进行分区\n\n\n\nError HandlingError code extensionOptional\nIt uses an additional bool to denote “exist or not” 用 bool 值来表示是否存在\n\nEmpty value then introduced as std::nullopt, which essentially makes the underlying bool to be the false\ntemplate&lt;typename Key, typename Val&gt;std::optional&lt;Val&gt; Get(const std::map&lt;Key, Val&gt;&amp; map, const Key&amp; key){    if (auto it = map.find(key); it != map.end()        return it-&gt;second;    return std::nullopt;}\n\n\nCtor, operator=, swap, emplace, std::swap, std::make_optional\n\nCtor can also accept (std::in_place, Args to construct T)\n\n\noperator&lt;=&gt;\n\nstd::hash; unlike std::variant, it’s guaranteed for std::optional to have the same hash as std::hash&lt;T&gt; if it’s not std::nullopt\n\nYou can just use std::optional as a nullable pointer\n\noperator-&gt;/operator*/operator bool, as if a T*\nThe behavior is undefined for -&gt;/* if it’s in fact std::nullopt\n\n\n.has_value(), .value() (which will throw std::bad_optional_access instead of std::nullopt)\n.value_or(xx) can provide a default value\n\n\nNote\n\nMost of types in Java and C# are nullable, which makes them “optional” automatically 像是 Java 和 C# 语言大部分的变量类型都是自动的”optional”，但是也会有效率上的问题\nstd::optional, std::expected, std::any and std::variant are sometimes called “vocabulary type” 它们都不能用作引用类型去实例化模板 std::optional&lt;int&amp;&gt;\nThough std::optional only store an additional bool, this alignment and padding will make it in fact larger\n\n\n\nExpected\nIt uses an Error type (i.e. std::expected&lt;T, E&gt;) instead of null to denote absent value 用第二个模板参数来表达错误类型，更被建议用作错误处理\n\nstd::expected&lt;double, std::errc&gt; parse_number(std::string_view&amp; str){    double result;    auto begin = str.data();    auto [end, ec] = std::from_chars(begin, begin + str.size(), result);    if (ec != std::errc{})        return std::unexpected{ec};    if (std::isinf(result))        return std::unexpected{std::errc::result_out_of_range};    str.remove_prefix(end - begin);    return result;}\n\nMonad\n&lt;T1, E1&gt;.and_then(T1) needs to return &lt;T2, E1&gt;\nFor std::optional, it’s obligated to return std::optional&lt;T2&gt;\n\n\n&lt;T1, E1&gt;.transform(T1) needs to return T2, which will construct &lt;T2, E1&gt; automatically\nFor std::optional, it’s obligated return T2, which will construct &lt;T2&gt;\n\n\n&lt;T1, E1&gt;.or_else(T1) needs to return &lt;T1, E2&gt;\nFor std::optional, it’s obligated return std::optional&lt;T1&gt;\n\n\n&lt;T1, E1&gt;.transform_error(E1) needs to return E2, which will construct &lt;T1, E2&gt; automatically\n\nauto process = [](std::string_view str){    std::print(\"str: {:?},\", str);    parse_number(str).transform([](double val)    {        std::println(\"value: {}\", val);        return val;    }).transform_error([](std::errc err)    {        if (err == std::errc::invalid_argument)            std::println(\"error: invalid input\");        else if (err == std::errc::result_out_of_range)            std::println(\"error: overflow\");        return err;    });}for (auto src : {\"42\", \"32abc\", \"meow\", \"inf\" })    process(src);\n\nException\nException is a technique that will automatically propagate to the caller if it’s omitted 异常可以将调用者忽略的错误自动地传递给更上层的调用者\nFor example, function chain A -&gt; B -&gt; C -&gt; D, if D throws an exception, and D doesn’t catch it, then C needs to do so; if C doesn’t, B needs to do so; etc.\n\n\ntry - catch block to catch an exception\n\ntry{    Test();}catch (const std::out_of_range&amp; error){    std::cout &lt;&lt; \"Encountering error:\";    std::cout &lt;&lt; error.what() &lt;&lt; \"\\n\";}catch (const std::invalid_argument&amp; error){    // ...}catch (...) {/* ... */}\n\n\n.what() is a virtual method of std::exception\n\n\nNote\nYou only need to catch exception when this method can handle it\nThough you can throw any type, it’s recommended to throw a type inherited from std::exception\nReason: base class can also match derived class exception to catch it, so you can always catch(const std::exception&amp;) and print .what() to know information\n\n\nCatch block is matched one by one catch 块是线性的进行的\nThough it’s allowed to catch with or without const/&amp;, exception should definitely be caught by const Type&amp;\nIf you’re in a catch block and find that the caught exception still cannot be handled, you can use a single throw; to throw this exception again 不能处理异常可以继续往上抛出，最好不抛出异常对象\nIf another exception is thrown during internal exception handling (e.g. dtor throw an exception during stack unwinding), std::terminate will also be called 在处理异常的时候由出现了异常会直接终结，不可能在异常中再重新抛出异常了\n\n\n\nException Safety\nException safety means that when an exception is thrown and caught, program is still in a valid state and can correctly run 当异常被抛出并且被捕获后，程序依然处于有效状态并且正确运行\n\nNo guarantee 没有异常安全性\n\n资源或内存泄漏\n不变量被破坏\n内存发生了损毁，一片内存写了一部分就发生了损坏并退出了程序\n\n\nBasic guarantee: at least program can run normally, no resources leak, invariants are maintained, etc\n\nRAII is a really important technique for basic guarantee\n\n解决方案是使用析构函数 use destructor\n\nRAII (Resource acquirement is initialization): acquire resources in ctor and release them in dtor 在构造函数里申请资源，在析构函数里释放资源，这就是 RAII\n\nstd::unique_ptr to manage heap memory instead of new/delete\nstd::lock_guard to manage mutex instead of lock/unlock\nstd::fstream to manage file instead of FILE* fopen/fclose\n自己编写的类也要符合 RAII 的原则\n\n\nTo sum up, all members that have been fully constructed will be destruct, but dtor of itself won’t be called 只有在构造函数中完全初始化（没有异常）析构函数才会执行\nMyData(int id) : ptr1{nullptr }, someData{nullptr } {    auto init_ptr1 = std::unique_ptr&lt;int&gt;{new int {id} };    auto init_someData = std::unique_ptr&lt;int&gt;{new int {id} };    // will never throw below    ptr1 = init_ptr1.release(); // release ownership, so dtor of    someData = init_someData.release(); // unique_ptr does nothing}~MyData() { delete ptr1; delete someData; }\n\n\n指针抛出的异常是std::bad_alloc\nnew(std::nothrow) will return nullptr instead of throwing exception. e.g. new(std::throw) int{id} 但是仍然需要判断nullptr\n\n\n\n\nStrong exception guarantee 强异常保证，当函数抛出异常后，程序能够回滚到原来的状态\n\nMost of methods in STL obey strong exception guarantee\n\nstd::vector::push_back(), std::vector has same elements as before even if exception is thrown 当插入元素失败的时候，原来 vector 中的元素还存在\n\n\nA technique to maintain strong exception guarantee in assignment operator is copy-and-swap idiom 拷贝交换惯用法\ntemplate&lt;typename T&gt;class Vector{public:    Vector(std::size_t num, const T&amp; val)    {        std::unique_ptr&lt;T[]&gt; arr{ new T[num] };        std::ranges::fill(arr.get(), arr.get() + num, val);        first_ = arr.release();        last_ = end_ = first_ + num;    }    std::size_t size() const noexcept {return last_ - first_; }    auto&amp; operator[](std::size_t idx) noexcept {return first_[idx]; }    const auto&amp; operator[](std::size_t idx) const noexcept {return first_[idx]; }    Vector(const Vector&amp; another)    {        auto size = another.size();        std::unique_ptr&lt;T[]&gt; arr{ new T[size] };        std::ranges::copy(another.first_, another.last_, arr.get());        first_ = arr.release();        last_ = end_ = first_ + size;    }private:    T* first_, *last_, *end_;};\n\n如何实现operator=\nVector&amp; operator=(const Vector&amp; another){    delete[] first_; // 只是放指针所指向的内存    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    first_ = arr.release();    std::ranges::copy(another.first_, another.last_, first_);    last_ = end_ = first_ + size;    return *this;}\n\n如果 new 抛出异常，尽管内存已经释放掉了，但是 first_ 和end_仍然不变，所以 .size() 依然不变\nVector&amp; operator=(const Vector&amp; another){    delete[] first_;    first_ = last_ = end_ = nullptr; // 将指针也释放掉    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    first_ = arr.release();    std::ranges::copy(another.first_, another.last_, first_);    last_ = end_ = first_ + size;    return *this;}\n\n如果 std::ranges::copy 出现了异常，那么 first_ ，last_，end_ 状态又是不一致的，first_` 被先赋值的\nVector&amp; operator=(const Vector&amp; another){    delete[] first_;    first_ = last_ = end_ = nullptr; // 将指针也释放掉    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    std::ranges::copy(another.first_, another.last_, first_);    // only release when all exceptions are possibly thrown!    first_ = arr.release();    last_ = end_ = first_ + size;    return *this;}\n\n满足了基本异常安全的保证，但是不满足强异常安全性的保证，必须保证释放资源是在所有可能抛出异常语句的后面\nVector&amp; operator=(const Vector&amp; another){    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    std::ranges::copy(another.first_, another.last_, first_);    delete[] first_;    first_ = arr.release();    last_ = end_ = first_ + size;    return *this;}\n\n除了 delete[] 其他的和构造函数几乎一样，可以换一种方式实现\nfriend void swap(Vector&amp; vec1, Vector&amp; vec2) noexcept{    std::range::swap(vec1.first_, vec2.first_);    std::range::swap(vec1.last_, vec2.last_);    std::range::swap(vec1.end_, vec2.end_);}Vector&amp; operator=(const Vector&amp; another){    Vector vec{another};    swap(vec, *this);    return *this;}\n\n\nAllocating memory before releasing, which increases peak memory\nSwap cost it slightly higher than direct assignment\nMay be not optimal for performance\n\n\nException safety of containers\n\nAll read-only &amp; .swap() don’t throw at all 所有只读方法和 .swap() 都不抛出异常，除了故意抛出异常的函数\nFor std::vector, .push_back(), emplace_back(), or .insert/emplace/insert_range/append_range() only one element at back provide strong exception guarantee\nFor std::list/forward_list, all strong exception guarantee 因为内存不是连续的，所有的方法都会保证强异常安全性\nFor std::deque, it’s similar to std::vector, adding push at front\nFor associative containers, .insert/... a node only a single element has strong exception guarantee\n\n\n\n\nStrongest exception safety 最强异常安全性：一个方法永远都不会抛出异常可以加上 noexcept 标识符\n\nIf your function is labeled as noexcept but it throws exception, then std::terminate will be called\nnoexcept is also an operator 也是一个运算符，用 evaluate 函数是否标记了 noexcept 标识符\nIMPORT: destructor &amp; deallocation is always assumed to be noexcept by standard library 标准库永远假设析构函数和释放行为不会抛出异常\nDtor is the only function by default noexcept without any explicit specifier if all dtors of members are noexcept\n编译器自动生成的构造函数或赋值函数也是noexcept\n\n\nSince C++ 17, noexcept function pointer is also supported C++ 17 支持了函数指针用 noexcept 标识 e.g. using Ptr = void(*)(int) noexcept; Ptr ptr = square; 不能指向可以抛出异常的函数\nGeneral rule: for normal methods, only when the operation obviously doesn’t throw should you add noexcept\nMerely read-only methods in containers (like .size()) are marked as noexcept\n\n\n\n\n\n\n\nWhen to use exception\nException is relatively costly compared with other error handling mechanisms, like it relies on heap allocation 相对于其他错误处理机制代价更高，需要保证抛出异常发生情况是极少数的情况；只有在抛出和捕获的时候才有开销\nBesides, in current typical implementations, stack unwinding of exception needs a global lock, which is really unfriendly to multi-threading programs 对多线程不友好\nAlso, exception is highly dependent on platform (just like RTTI)\n\nAssertionAssertion is a technique to check expected behaviors of functions or code segments when debugging\n\nWhen the parameter is evaluated to false, program will be aborted\nstd::abort() is the default behavior of std::terminate(), but latter can change its behavior by std::set_terminate_handler(...)\nIt’s a macro defined in &lt;cassert&gt;\n\n\nassert用作没有副作用行为的条件检查\nassert is done in runtime; if you want to determine in compile time, you can use keyword static_asset(xx, msg), msg can be omitted since C++ 17\n通常用于内部的方法，检查已应过滤掉，但是仍然会出现的非法的情况，用于在 debug 中定位问题\nAssertion 在安全检查方面是非常有限的\nContract C++ 26 is likely to add contract, which will enrich it a lot\n\nDebug Helpers\nSource Location\n\nBefore C++ 20, we may use maros __FILE__ and __LINE__, which will be substituted to source file name and line number\nstatic void CheckError(cudaError_t error, const char* file, int line){    if (error == cudaSuccess)        return;    std::cerr &lt;&lt; \"Cuda Error at file\" &lt;&lt; file &lt;&lt; \"line :\" line &lt;&lt; \":\" &lt;&lt; cudaGetErrorString(error);    exit(EXIT_FAILURE);}#define CHECK_ERROR(error) (CheckError((error), __FILE__, __LINE__))\n\n__FILE__和 __LINE__ 是不能用在 CheckError 的默认参数中的，因为这两个宏是在预处理的时候确定的，而不是在调用的时候确定的\n\nSince C++ 20, &lt;source_location&gt; is added to solve it\n\nvoid logError(std::string_view errorInfo, std::ostream&amp; logFile = std::cerr, const std::source_location&amp; location =  std::source_location::current());\n\nvoid logError(std::string_view errorInfo, std::ostream &amp;logFile = std::cerr, const std::source_location &amp;location = std::source_location::current()){    logFile &lt;&lt; std::format(\"In file {} function {} - line {}, Error :\\n{}\\n\",        location.file_name(), location.function_name(), location.line(), errorInfo);    return;}\n\n\nstacktrace\n\nSince C++ 23, in &lt;stacktrace&gt;\nSimilar to source_location, you need std::stacktrace::current to get it; but you may print it directly\n\n\ndebugging, Since C++ 26, in &lt;debugging&gt;\n\n\nUnit TestCatch2A C++ unit test framework - Catch2\n\nCatch2 uses macro, so still remember to add paratheses for comma\nCatch2 overloads operator&amp;&amp; and operator||, so using them won’t be short-circuit\nThus, you may need to split it to multiple REQUIRE\n\n\nSECTION can be generated dynamically; you just need to ensure they have different names\n\nString and String View\n常量字符串类型 const char[] 赋值给 auto 类型会退化为 const char*，C++ 中不能将const char[] 赋值给char*，除非使用const_cast\n可以使用空格或换行来连接两个字符串常量 e.g. \"123\" \"456\"和 \"123456\" 一样，编译器编译的时候会进行拼接\nRaw strings: 任意字符都不会被转义 escaped\n\\\\\\n\\\"在普通字符串解释为 \\\\n\"，但是用裸字符串表示R\"(\\\\\\n\\\")\" 就是 6 个字符\n例如 Windows 系统中的文件路径\n裸字符解析主要是通过匹配 \"( 和')\"'，但是可以在 \" 和(或 ) 之间加入任意其他通配符配合将中间的字符部分解析为裸字符串 e.g. R\"+(I want a)\"!)+\"\n\n\n\nString\nstd::string是 std::vector&lt;char&gt; 的加强版\n很多方法和 std::vector 一模一样\n提供了 .length() 函数，和 .size() 一样，只是 length 是更常见命名习惯\n.append, .append_range和 insert(str.end(), ...) 一样，但是不能插入一个字符串，返回值是对 string 的引用\n.assign, .insert, .erase, .append都提供了下标的版本\n.starts_with, ends_with (C++ 20); contains (C++ 23)\n.substr(index(, count)): 从 index 开始到 count 结束，count默认是std::string::npos，会创建新的对象\n.replace: replace part of the string with a new string same as sub-string\n.data(), .c_str(): get the underlying pointer\nC++ 17 之后 .data() 返回的是char*，而不是const char*\n.c_str()返回的是const char *\n\n\nSearch\n如果找不到则返回 std::string::npos，也就是static_cast&lt;size_t&gt;(-1) 一个很大的数\n.find(),rfind(): 正向查找或逆向查找\nfind_first_of(), find_first_not_of(), find_last_of(), find_last_not_of()\n\n\nNotes\nfind()时，使用不等号来判断是否找到，而不是用&gt;, &gt;=, &lt;, &lt;=\nstd::string guarantees the underlying string is null-terminated\nstd::string可以存储'\\0'\n\n\nstd::string has SSO (small string optimization) 段字符串优化\n当 string 非常小的时候可以放到栈上而不是放到堆上，降低内存分配\n具体 string 在栈上可以容纳多少字符是由标准库实现的；在 x64 libstdc++/VC 上是 15，在 libc++ 上是 22\n\n\nC++ 23 introduces another optimization for resizing\nResize 通常需要用固定的字符（例如 '\\0'）去填充，通常需要reserve 和insert两个步骤，性能上会有损耗\n.resize_and_overwrite(newSize, Op)意义更明确，并且是覆盖\n\n\n和数字进行相互转换\nstd::stoi/sto(u)l/sto(u)ll(string, std::size_t* end = nullptr, int base = 10)\nIt will stop at the end of the first parsed number, and try to write the stop index to *end 在结束之前解析好，解析失败会抛出异常std::invalid_argument\n\n\nBase（进制） can be 2 - 36 按照字母表的顺序添加；base=0时会根据字符串前缀自动解析进制大小\n前缀时 0 是八进制\n前缀是 0x 是十六进制\n\n\nstd::stof/stod/stold(string, std::size_t* end = nullptr)\nstd::to_string()\n\n\n\n\n\nString View如果在函数中仅仅是读取一个 string，就会用 const std::string&amp; 作为参数，如果传入的是 C-string 类型，就会构造一个临时的 string 对象，这种情况可以使用std::string_view（C++ 17）。可以理解为本身就存储了一个const char*\n\n.substr返回的仍然是 std::string_view 而不是std::string\n不支持operator+\nstd::string_view is not required to be null-terminated 都是通过 length 识别长度的\nThe pointer it contains can be nullptr\nC++ 23 开始不能使用 nullptr 进行构造\n\n\n当 std::string_view 做为返回值时，注意指针悬垂的问题\n返回 std::string 是安全的\n\n\n作为模板参数时也要注意声明周期\n\nUser-defined literals 用户定义自变量\n类似数值类型 1ull 表示数字 1 是unsigned long long 类型的，字符串对象也可以使用用户自定义变量\nstd::string: \"PKU\"s\nstd::string_view: \"PKU\"sv\n1s for seconds, 1.1ms for milliseconds, 1d for a day\n1i for pure imaginary number 复数，1.2if, 2.5id\nRemember using namespace std::literals; in your local scope\n也可以自己定义用户定义自变量\nconstexpr unsigned int operator\"\" _KB(unsigned long long m) {return static_cast&lt;unsigned int&gt;(m) * 1024; }\nThe parameter type is limited 参数类型的限制\n对整数来说只支持unsigned long long，最大的整数类型\n对浮点数只支持long double\n对字符char\n对 C-stringsconst CHAR*, std::size_t\n最后兜底（fallback）类型是const char*\n\n\n\n\n\ncharconv\nstoi/to_string will create new std::string; we may want to provide storage ourselves\n\nE.g. stoi(std::string{view}) is costly, since we only read the string 耗费资源\nAlso, they may throw exceptions, which are expensive sometimes 抛出异常也很耗费资源\n\n\nYou can use std::from_chars and std::to_chars in &lt;charconv&gt;\n\nstd::from_chars(const char* begin, const char* end, val) will try to save the result into val (an integer or a floating point)\nIt returns std::from_chars_result, which includes .ptr as stopping point and .ec as error code\nWhen ec == std::errc{}, success; it’s also possible that ec == std::errc::invalid_argument, or std::errc::result_out_of_range\nYou can use structured binding, e.g. if(auto [ptr, ec] = xx; ec != std::errc{}).\n\n\nstd::from_chars(const char* begin, const char* end, val) will try to save the result into val 必须以数字开头\n\nbase/std::chars_format 进制或格式\n\n\nstd::to_chars(const char* begin, const char* end, val) will try to write val (an integer or a floating point) into [begin, end)\n\nbase/std::chars_format\n\n\n\nUnicode\nUTF-32: make each character occupy 32 bits; it’s direct but useful, since at most 4 billion characters can be used\nBut it may occupy too much space, e.g. abc needs only 4 bytes before, but currently 16 bytes!\nIt also needs BOM\n\n\nUTF-8: to solve space waste, UTF-8 uses code with varying length\nDifferent character length has different coding prefix (like Huffman tree that we’ve learnt) to ensure no ambiguity\nThis makes it waste some code space, so some characters may need more than 4 bytes\nFor example, ASCII characters, including null-termination ‘\\0’, still occupy 1 byte in UTF-8 (the coding is same too) 兼容之前的 ASCII 字符的\nUTF-8 is the most commonly used character set in modern systems\n\n\n\n\n            Notice that UTF8 doesn’t need BOM, but Windows identifies Unicode by BOM long long before (UCS-2 needs that), and it has been part of Windows and hard to change, so Windows may require you to give UTF8 a BOMUTF-8 是单字节并不需要 BOM，但是 Windows 需要 BOM 去识别是不是 Unicode\n          \n\n\nUnicode has these basic elements:\nByte, i.e. computer representation\nCode unit, i.e. (byte count ÷ minimal bytes) used to represent a character (1 for UTF-8, 2 for UTF-16, 4 for UTF-32) 一个 code unit 并不一定是合法的字符\nCode point, i.e. each Unicode character\nText element, i.e. what humans really see on the screen\n\n\n\nUnicode Support in C++\nThere are char8_t/char16_t/char32_t for UTF-8/16/32, but it’s used as one code unit, instead of one code point\nThey’re at least 8/16/32 bits to hold one code unit 表示 code unit 比较合适\nYou can use u8/u/U as prefix separately\n\n\n\n\n            But one code point may (and usually) have more than one code unit, so some weird things may happenchar8_t ch1 = u8'A'; // correctchar8_t ch2 = u8'刘'; // cannot be represented in 1 byte, compile errorconst char8_t str1 = u8\"刘\"; // correct, but sizeof(str1) = 3, 2 for 刘 and 1 for null-terminationThere are also types like std::u8string, but they are all in code unitsThis makes traversal really hard, e.g. for(auto ch : std::u8string{u8\"刘\"}) will not get 刘, but several code units 遍历实际上得到的也是 code unit.size(), .find_first_of() … are also for code unit\n          \n\n\nSo in fact, e.g. std::string, std::string_view are just instantiation of template std::string和 std::string_view 实际上是模板的实例化\nMore specifically, i.e. std::basic_string&lt;char&gt; and std::basic_string_view&lt;char&gt;\nSo, e.g. std::u8string, std::u8string_view are just std::basic_string&lt;char8_t&gt; and std::basic_string_view&lt;char8_t&gt;\nSince char8_t itself is code unit, the string represents vector of code units too\nIt also accepts Traits = std::char_traits&lt;charT&gt; as the second template parameter, which regulates operations used by basic_string like comparison of characters. So theoretically (but usually not used) you can define you own character type as long as it’s standard-layout and trivial, then give a YourString with the NewTraits&lt;NewCharType&gt;\nYou can also provide an allocator, just like STL\n\n\nWeak Unicode support is mostly due to its complexity C++ 本身提供 Unicode 的支持不是很好，所以需要 Unicode 官方的标准库，或者使用其他的标准库\nC++ core guideline recommends you to use ICU (International Components for Unicode), Boost.Locale, etc. for complete Unicode support\nYou may also use utf8cpp, which operates UTF-8 by code point, since ICU is too large for small project\n\n\nBesides, input/output Unicode is troublesome in C++ 在 C++ 中 Unicode 的输入输出比较麻烦\nThere is also a wide character wchar_t in C/C++ 宽字符类型（C++ 11 之前）\nIt’s platform dependent, only regulated that “it has the same property with one of integer types” 内部的表示由平台决定，用正数类型表示其大小\nIt’s UTF-16 on Windows, while UTF-32 on Linux\nPrefix for wide character/string literals is L, e.g. L\"爱情可以慷慨又自私\"\nAnd, you can also use std::wcout/wcin/wstring(_view)\n\n\n\ntemplate&lt;typename T&gt;void DecomposeToByte(const T&amp; str) {    for (int i = 0; i &lt; str.size(); i++) {        auto ch = static_cast&lt;unsigned int&gt;(str[i]);        unsigned int mask = (1 &lt;&lt; CHAR_BIT) - 1;        for (int j = 0; j &lt; sizeof(str[0]); j++) {            std::cout &lt;&lt; std::format(\"{:02x}\", (mask &amp; ch));            ch &gt;&gt; 8;        }        std::cout &lt;&lt; \"=&gt;\";    }    std::cout &lt;&lt; \"\\n\";    return;}std::wstring s1 = L\"\\U0001F449\";std::u8string s2 = u8\"\\U0001F449\";std::u16string s3 = u\"\\U0001F449\";std::u32string s4 = U\"\\U0001F449\";\n\n\n            In fact, C-string or std::string is more like a byte array instead of an ASCII string 事实上 C-string 或者 std::string 本质上是字节数组而不是 ASCII\n          \n\nLocale\nLocale is used for localization\nEach std::locale contains information for a set of culture-dependent features by std::facet objects\nStandard facets are divided into six categories:\nCollate: i.e. how characters are compared, transformed or hashed 字符如何进行比较，变换或哈希\nNumeric: num_get, num_put, numpunct\nnum_get will affect how std::cin works, num_put -&gt; std::cout, numpunct only affect punctuation 标点符号\nFor example, in German, 1.234,56 means 1234.56; if you use Germany locale, then inputting 1.234,56 will correctly get it instead of 1.234\n\n\nTime: time_get/time_put\nMonetary: money_get/money_put/moneypunct 财政的；货币的\nMessage: transform some error message to another language\nCtype: ctype/codecvt, how characters are classified and converted, e.g. is upper 字符如何进行分类，其他字符集如何向其进行转化\n\n\nLocale 会影响输入输出流、字符识别和匹配\n\n\n\n\n    \n\n\n\n            每个 locale 创建出来都会指向一个实现  复制的时候只是复制指针  每个实现的数据结构都是 vector&lt;facet*&gt;facet 可以复用\n          \n\n\nLocale is cheap to copy; it uses reference count when copied and points to same set of facets 拷贝的代价很小\n\nFacets use the address of a static member id to group; e.g. if you want a new facet, you need to inherit from std::locale::facet and have static std::locale::id id 不同的类的实现会\n\nFacet will be deleted when it’s never referenced, so new is correct. It also uses reference count facet不需要担心内存泄漏的问题，通过引用计数来管理的\n\nCreate a new group of facet 如何创建新的 facet\nclass Umlaut : public std::locale::facet {//1public:    static std::locale::id id;                               //2    Umlaut(std::size_t refs=0): std::locale::facet(refs) {}  //3    bool is_umlaut(char c) const {return do_isumlaut(c);}    //4protected:    virtual bool do_isumlaut(char) const;                    //5};\n\n","categories":["C++"],"tags":["C++","现代 C++"]},{"title":"哈希表","url":"/2021/11/08/f312d56c7828/","content":"哈希表  哈希表，也叫散列表，它是基于快速存取的角度设计的，是一种典型的“空间换时间”的做法。它可以提供快速地插入和查找操作。\n哈希表函数的构造方法  直接定址法 （、 为常数），即取关键码的某个线性函数值为哈希地址，不会产生冲突，但要求地址集合与关键码集合大小相同。因此，对于较大的关键码集合不适用。\n除留余数法 （ 是一个整数），即取关键码除以  的余数作为哈希地址。使用除留余数法，选取合适的  很重要，若哈希表表长为 ，则要求，且接近 或等于 。 一般选取质数，也可以是不包含小于 20 质因子的合数。\n数字分析法  设关键码集合中，每个关键码均由  位组成，每位上可能有  种不同的符号。\n平方取中法  对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址。\n处理冲突的方法  开放寻址法  ，其中 为散列函数，为散列表长，为增量序列，可有以下三种去法：\n\n，称线性探测再散列；\n称二次探测再散列；\n伪随机数序列，称伪随机探测再散列。\n\n再散列法 ， 是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。\n链地址法（拉链法）当存储结构是链表时，多采用拉链法。用拉链法处理冲突的办法是：把具有相同散列地址的关键字（同义词）值放在同一链表中，称为用一次链表。有  个散列地址就有  个链表，同时用指针数组 T[0...m - 1] 存放各个链表的头指针，凡事散列地址为  的记录都以结点方式插入到以 T[i] 为指针的单链表中。\n建立一个公共溢出区  设哈希函数产生的哈希地址集为，则分配两个表：一个基本表ElemType baseTbl[m]；每个单元只能放一个元素；一个溢出表ElemType overTbl[k]；只要关键码对应的哈希地址在基本表上产生冲突，则所有这样的原色一律存入该表中。\n哈希表的查找\n理想情况下我们根据关键字 key, 通过造表时候的哈希函数求得哈希地址，该表此位置上的记录的关键字与我们给定的关键字 key 相等，则查找成功。\n但是如果有冲突，即该表此位置上的记录不是我们要查找的记录，则根据造表时候设定的冲突处理方法寻找“下一个地址”，一直到哈希表的某一个位置为“空”或者表中记录的关键字为我们给定的关键字 key。\n\n","categories":["数据结构"],"tags":["数据结构","哈希表"]},{"title":"术语","url":"/2024/07/18/6aa64a608435/","content":"\n    \n      \n        ▶generic composition\n      \n      \n        \n          “generic composition”可以拆分为两部分来解释，即“generic”和“composition”。Generic：含义：通用的、普遍的。应用领域：计算机编程：用于描述可以处理不同种类数据类型的程序或类。商业领域：许多公司选择采用通用的配件或原材料来生产物品，以扩大市场并保证生产成本的可控性。药品：非处方药品也被称为 Generic 药品，即它们没有品牌名称，但成分与一些有品牌的药品一致，具有同样的疗效。Composition：含义：抽象的行为：作曲、创作、写作。具体的成果：作文、作品。其他：构图、布置、妥协、和解。词源：直接源自拉丁语的 compositus，意为合成物。实用场景：学习作曲艺术。土壤的化学成分。董事会的组成。贝多芬的音乐作品。结合两者，generic composition可能指的是一种通用的或普遍的创作、组合或构成方式。在编程中，它可能指的是一种通用的、能够处理多种数据类型的程序结构或代码组成。在艺术或写作中，它可能指的是一种通用的创作方法或技巧，适用于多种题材或领域。在商业或产品设计中，它可能指的是一种通用的产品组合或设计，能够满足广泛的市场需求。总之，“generic composition”是一个结合了“通用性”和“创作、组合”含义的短语，其具体含义和应用领域需要根据上下文来判断。\n        \n      \n    \n\n\n    \n      \n        ▶traits technique\n      \n      \n        \n          traits technique（特性萃取技术）是一种在编程中广泛使用的技术，特别是在 C++ 的泛型编程（Generic Programming）中。这项技术主要用于提取“被传进的对象”对应的返回类型，让同一个接口能够实现对应的功能。下面是对 traits technique 的详细解释：基本概念 ：Traits 技术，也被称为特性萃取技术，它允许程序员为不同的类型定义不同的行为或属性。 在 C++ 中，traits 通常用于模板元编程，帮助编译器在编译时确定类型信息，从而优化代码的执行效率。主要应用 ： 当算法和容器是分离的，并且需要通过迭代器进行链接时，traits 技术可以帮助算法确定被传入对象的类型，从而调用适当的方法。Traits 技术在 STL（Standard Template Library，标准模板库）中被广泛应用，用于隐藏一些实现细节，并协助调用合适的方法。实现方式 ：Traits 通常使用 enum、typedef 和模板（部分）特化（template specialization）等技术来实现。Enum 用于将在不同类型间变化的标示统一成一个。Typedef 则用于定义模板类支持特性的形式。 模板（部分）特化被用于提供针对特定类型的正确的或更合适的版本。通过这些技术，traits 可以提取类中定义的特性，并根据不同的特性提供不同的实现。作用 ：Traits technique 可以使代码更加灵活，支持多种数据类型。 通过萃取技术，可以隐藏一些复杂的实现细节，使得接口更加简洁明了。Traits technique 还可以提高代码的可读性和可维护性，降低出错的可能性。总结来说，traits technique 是一种强大的编程技术，它允许程序员为不同的类型定义不同的行为或属性，并在编译时确定类型信息以优化代码执行效率。在 C++ 的泛型编程中，traits technique 被广泛应用，并成为了许多高效库和框架的基石。\n        \n      \n    \n\n\n    \n      \n        ▶In-Place Transformations\n      \n      \n        \n          “In-Place Transformations”（原地变换）在计算机科学中，通常指的是一种算法设计技巧，它指的是在变换数据或执行操作时，尽可能地使用少量的额外空间，甚至是不使用任何额外空间，而是在原数据上进行直接修改。这样的算法设计可以有效地减少内存使用，提高算法的效率。以下是关于“In-Place Transformations”的详细说明：定义 ： 原地变换是一种算法策略，其中输入数据在算法执行过程中被直接修改，以产生所需的输出。这意味着算法不需要额外的空间（或仅需要极少的额外空间）来存储中间结果或最终输出。特点 ： 空间效率 ：原地变换的主要优点之一是它们能够显著减少内存使用。这在处理大型数据集或内存受限的环境中尤为重要。 直接修改 ：由于直接在原数据上进行操作，原地变换通常比非原地变换更快，因为它们避免了数据的复制和移动。 挑战性 ：设计原地变换算法通常比设计非原地变换算法更具挑战性，因为需要仔细考虑如何在不引入额外空间的情况下进行数据的修改和重新组织。 示例 ： 矩阵转置 ：矩阵的原地转置是一个常见的原地变换示例。在某些情况下，可以通过使用循环和交换元素的方式，在不分配额外内存的情况下实现矩阵的转置。 数组排序 ：许多排序算法（如快速排序、堆排序等）也可以被设计为原地算法，它们通过在数组中直接交换元素来排序，而不需要额外的数组来存储中间结果。 注意事项 ： 虽然原地变换具有显著的优点，但在某些情况下，它们可能不适合使用。例如，如果算法需要保留原始数据的副本以供后续使用，则无法使用原地变换。原地变换算法的正确性通常更加难以验证和调试，因为它们直接修改了原始数据。总之，“In-Place Transformations”是一种重要的算法设计策略，它可以帮助我们更加有效地利用内存和计算资源，特别是在处理大型数据集或内存受限的环境中。然而，设计原地变换算法需要仔细考虑和精心规划，以确保算法的正确性和效率。\n        \n      \n    \n\n\n    \n      \n        ▶Trivial Types\n      \n      \n        \n          Trivial types（平凡类型）在 C++ 中是一个重要的概念，特别是在处理对象复制和内存布局时。以下是对 Trivial types 的详细解释：定义 ：Trivial types 指的是在内存中表示连续的一片空间，可以像内置类型或者 C 的结构体、联合体一样进行操作的对象。它可以是一个类（class）或结构体（struct）。 它拥有编译器生成的默认构造、析构、拷贝构造和赋值运算符，这些函数都是平凡的（即它们没有执行任何额外的操作，仅仅是按照内存布局进行复制或销毁）。特性 ： 平凡类型的对象可以直接拷贝到 char 或unsigned char数组，然后再拷贝回来，其类型仍然保持不变。这意味着它们可以安全地进行序列化和反序列化。平凡类型通常用于需要对数据进行底层操作和通过 memcpy 等内存复制函数进行快速复制的情况。条件 ： 一个类型要被认为是 Trivial type，它必须满足以下条件：有默认构造、析构、拷贝构造、赋值运算符，这些函数可以是编译器自动生成的，也可以是用户显式地通过 default 关键字声明的。没有虚函数、虚基类和虚继承。与其他类型的关系 ：Trivial types 是标准布局类型（Standard Layout Types）的一个子集，它们除了满足标准布局类型的条件外，还需要满足上述的平凡性条件。POD（Plain Old Data）类型在 C++11 之前是一个更广泛的概念，它包含了 Trivial types 和标准布局类型。但从 C++11 开始，POD 的概念逐渐被更细致的 Trivial types 和 Standard-Layout types 概念所替代。 用途 ： 由于其平凡性，Trivial types 在内存管理和对象复制方面提供了很大的灵活性。它们可以直接通过内存操作函数（如 memcpy、memmove）进行复制，而无需考虑对象的内部结构和状态。 这种类型在与其他语言或系统交互时特别有用，因为它们具有确定的内存布局和简单的复制语义。示例 ： 一个只包含基础数据类型（如 int、float）和 / 或平凡类型的数组作为成员的类，可以被视为一个 Trivial type。 总之，Trivial types 是 C++ 中一个非常重要的概念，它们在内存管理、对象复制以及与其他系统交互等方面具有重要的作用。\n        \n      \n    \n\n\n    \n      \n        ▶Thread Engine\n      \n      \n        \n          Thread Engine（线程引擎）在计算机科学中是一个负责管理和调度线程执行的组件或系统。它对于实现多线程编程、提高程序并发执行效率至关重要。\n        \n      \n    \n","categories":["日常"],"tags":["翻译","Terminology"]},{"title":"笔试题","url":"/2024/07/13/b58e8789ec87/","content":"反转链表  描述  给定一个单链表的头结点 pHead（该头节点是有值的，比如在下图，它的 val 是 1)，长度为 n，反转该链表后，返回新链表的表头。\n数据范围：\n要求：空间复杂度，时间复杂度。\n如当输入链表 {1, 2, 3} 时，经反转后，原链表变为 {3, 2, 1}，所以对应的输出为{3, 2, 1}。 以上转换过程如下图所示：\n\n    \n\n\nSolution/** * struct ListNode { *  int val; *  struct ListNode *next; *  ListNode(int x) : val(x), next(nullptr) {} * }; */class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param head ListNode 类      * @return ListNode 类     */    ListNode* ReverseList(ListNode* head) {        // write code here        if (head == nullptr || head-&gt;next == nullptr)            return head;        auto p = head-&gt;next;        head-&gt;next = nullptr;        while (p) {            auto q = p-&gt;next;            p-&gt;next = head;            head = p;            p = q;        }        return head;    }};\n\n二叉树遍历\n前序遍历：根节点、左子节点、右子节点\n中序遍历：左子节点、根节点、右子节点\n后序遍历：左子节点、右子节点、根节点\n\n\n            根据根节点的位置确定遍历的类别\n          \n\n前序遍历  给你二叉树的根节点 root ，返回它节点值的前序遍历。\n数据范围：二叉树的节点数量满足，二叉树节点的值满足，树的各节点的值各不相同\n\n    \n\n\nSolution/** * struct TreeNode { *  int val; *  struct TreeNode *left; *  struct TreeNode *right; *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param root TreeNode 类      * @return int 整型 vector     */    vector&lt;int&gt; preorderTraversal(TreeNode* root) {        // write code here        vector&lt;int&gt; res;        if (!root)            return res;        stack&lt;TreeNode*&gt; container;        container.push(root);        while (!container.empty()) {            auto node = container.top();            res.push_back(node-&gt;val);            container.pop();            if (node-&gt;right) container.push(node-&gt;right);            if (node-&gt;left) container.push(node-&gt;left);        }        return res;    }};\n\n合并两个有序数组  给你两个按非递减顺序排列的整数数组 nums1 和nums2，另有两个整数 m 和n，分别表示 nums1 和nums2中的元素数目。\n请你合并 nums2 到nums1中，使合并后的数组同样按非递减顺序排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1的初始长度为 m+n，其中前m 个元素表示应合并的元素，后 n 个元素为 0，应忽略。nums2 的长度为n。\n\n            示例 1：输入：nums1=[1,2,3,0,0,0],m=3,nums2=[2,5,6],n=3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和[2,5,6]。合并结果是 [1,2,2,3,5,6]，其中斜体加粗标注的为nums1 中的元素。\n          \n\n\n            示例 2：输入：nums1=[1],m=1,nums2=[],n=0输出：[1]解释：需要合并 [1] 和[]。合并结果是[1]。\n          \n\n\n            示例 3：输入：nums1=[0],m=0,nums2=[1],n=1输出：[1]解释：需要合并的数组是 [] 和[1]。合并结果是 [1]。 注意，因为 m=0，所以nums1`` 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。\n          \n\nSolutionclass Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int i = m - 1;        int j = n - 1;        int p = m + n - 1;        while (p &gt;= 0 &amp;&amp; j &gt;= 0) {            if (i &lt; 0) {                nums1[p] = nums2[j];                p--;                j--;            }            else if (nums2[j] &gt;= nums1[i]) {                nums1[p] = nums2[j];                p--;                j--;            }            else {                swap(nums1[i], nums1[p]);                p--;                i--;            }        }    }};\n\nclass Solution {public:    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {        int i = m - 1; // nums1 的有效部分的最后一个元素的索引        int j = n - 1; // nums2 的最后一个元素的索引        int k = m + n - 1; // 合并后数组的最后一个位置的索引        // 从后往前合并        while (i &gt;= 0 &amp;&amp; j &gt;= 0) {            if (nums1[i] &gt; nums2[j]) {                nums1[k--] = nums1[i--];            } else {                nums1[k--] = nums2[j--];            }        }        // 如果 nums2 中还有剩余的元素，继续放入 nums1        while (j &gt;= 0) {            nums1[k--] = nums2[j--];        }    }};\n\n完全平方数  给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n\n            示例 1：输入：n = 12输出：3解释：12 = 4 + 4 + 4\n          \n\n\n            示例 2：输入：n = 13输出：2解释：13 = 4 + 9\n          \n\n思路及算法  我们可以依据题目的要求写出状态表达式：表示最少需要多少个数的平方来表示整数。\n这些数必然落在区间。我们可以枚举这些数，假设当前枚举到，那么我们还需要取若干数的平方，构成。此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程。\n\n其中  为边界条件，实际上我们无法表示数字 0，只是为了保证状态转移过程中遇到  恰为  的情况合法。\n同时因为计算  时所需要用到  的状态仅有，必然小于 ，因此我们只需要从小到大地枚举 来计算  即可。\nSolutionclass Solution {public:    int numSquares(int n) {        vector&lt;int&gt; f(n + 1);        for (int i = 1; i &lt;= n; i++) {            int minn = INT_MAX;            for (int j = 1; j * j &lt;= i; j++) {                minn = min(minn, f[i - j * j]);            }            f[i] = minn + 1;        }        return f[n];    }};\n\n把数字翻译成字符串  有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。\n现在给一串数字，返回有多少种可能的译码结果\n思路及算法  动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果\n思路：\n对于普通数组 1-9，译码方式只有一种，但是对于 11-19，21-26，译码方式有可选择的两种方案，因此我们使用动态规划将两种方案累计。\n具体做法：\nstep 1：用辅助数组 dp 表示前 i 个数的译码方法有多少种。step 2：对于一个数，我们可以直接译码它，也可以将其与前面的 1 或者 2 组合起来译码：如果直接译码，则 dp[i] = dp[i − 1]；如果组合译码，则dp[i] = dp[i − 2]。step 3：对于只有一种译码方式的，选上种dp[i−1] 即可，对于满足两种译码方式（10，20 不能）则是 dp[i − 1] + dp[i − 2]step 4：依次相加，最后的dp[length] 即为所求答案。\n图示：\n\n    \n\n\nSolutionclass Solution {public:    int solve(string nums) {        // 排除 0        if(nums == \"0\")              return 0;        // 排除只有一种可能的 10 和 20        if(nums == \"10\" || nums == \"20\")              return 1;        // 当 0 的前面不是 1 或 2 时，无法译码，0 种        for(int i = 1; i &lt; nums.length(); i++){            if(nums[i] == '0')                if(nums[i - 1] != '1' &amp;&amp; nums[i - 1] != '2')                    return 0;        }        // 辅助数组初始化为 1        vector&lt;int&gt; dp(nums.length() + 1, 1);          for(int i = 2; i &lt;= nums.length(); i++){            // 在 11-19，21-26 之间的情况            if((nums[i - 2] == '1' &amp;&amp; nums[i - 1] != '0') || (nums[i - 2] == '2' &amp;&amp; nums[i - 1] &gt; '0' &amp;&amp; nums[i - 1] &lt; '7'))               dp[i] = dp[i - 1] + dp[i - 2];            else                dp[i] = dp[i - 1];        }        return dp[nums.length()];    }};\n\n最小区间  你有 k 个非递减排列的整数列表。找到一个最小区间，使得 k 个列表中的每个列表至少有一个数包含在其中。\n我们定义如果 b - a &lt; d - c 或者在 b - a == d - c 时a &lt; c，则区间 [a, b] 比[c, d]小。\n\n            示例 1：输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]输出：[20,24]解释：列表 1：[4, 10, 15, 24, 26]，24在区间 [20,24] 中。列表 2：[0, 9, 12, 20]，20在区间 [20,24] 中。列表 3：[5, 18, 22, 30]，22在区间 [20,24] 中。\n          \n\n\n            示例 2：输入：nums = [[1,2,3],[1,2,3],[1,2,3]]输出：[1,1]\n          \n\n思路  给定  个列表，需要找到最小区间，使得每个列表都至少有一个数在该区间中。该问题可以转化为，从  个列表中各取一个数，使得这  个数中的最大值与最小值的差最小。\n假设这  个数中的最小值是第  个列表中的 ，对于任意，设第 个列表中被选为  个数之一的数是 ，则为了找到最小区间， 应该取第  个列表中大于等于  的最小的数，这是一个贪心的策略。贪心策略的正确性简单证明如下：假设  也是第  个列表中的数，且 ，则有，同时包含 和的区间一定不会小于同时包含  和的区间。因此，其余  个列表中应该取大于等于  的最小的数。\n由于  个列表都是升序排列的，因此对每个列表维护一个指针，通过指针得到列表中的元素，指针右移之后指向的元素一定大于或等于之前的元素。\n使用最小堆维护  个指针指向的元素中的最小值，同时维护堆中元素的最大值。初始时，个指针都指向下标 0，最大元素即为所有列表的下标 0 位置的元素中的最大值。每次从堆中取出最小值，根据最大值和最小值计算当前区间，如果当前区间小于最小区间则用当前区间更新最小区间，然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值。\n如果一个列表的指针超出该列表的下标范围，则说明该列表中的所有元素都被遍历过，堆中不会再有该列表中的元素，因此退出循环。\nSolutionclass Solution {public:    vector&lt;int&gt; smallestRange(vector&lt;vector&lt;int&gt;&gt;&amp; nums) {        int rangeLeft = 0, rangeRight = INT_MAX;        int size = nums.size();        vector&lt;int&gt; next(size);                auto cmp = [&amp;](const int&amp; u, const int&amp; v) {            return nums[u][next[u]] &gt; nums[v][next[v]];        };        priority_queue&lt;int, vector&lt;int&gt;, decltype(cmp)&gt; pq(cmp);        int minValue = 0, maxValue = INT_MIN;        for (int i = 0; i &lt; size; ++i) {            pq.emplace(i);            maxValue = max(maxValue, nums[i][0]);        }        while (true) {            int row = pq.top();            pq.pop();            minValue = nums[row][next[row]];            if (maxValue - minValue &lt; rangeRight - rangeLeft) {                rangeLeft = minValue;                rangeRight = maxValue;            }            if (next[row] == nums[row].size() - 1) {                break;            }            ++next[row];            maxValue = max(maxValue, nums[row][next[row]]);            pq.emplace(row);        }        return {rangeLeft, rangeRight};    }};\n\nWater给定四个空杯子，容量分别为 S1 S2 S3 S4，允许进行以下操作：\n\n将某个杯子接满水\n将某个杯子里的水全部倒掉\n将杯子 A 中的水倒进杯子 B，直到 A 倒空或者 B 被倒满\n\n问最少要多少步操作才能使得这四个杯子装的水分别为 T1 T2 T3 T4\n\n            输入例子：0 2 3 40 1 2 4输出例子：6例子说明：    (0,0,0,0) -&gt;    (0,2,0,0) -&gt;    (0,2,3,0) -&gt;    (0,2,0,3) -&gt;    (0,0,2,3) -&gt;    (0,2,2,3) -&gt;    (0,1,2,4)\n          \n\nSolution#include&lt;bits/stdc++.h&gt;using namespace std;bool mem[64][64][64][64] = {false };bool equal(int s[4], int T[4]) {    return (s[0] == T[0]) &amp;&amp; (s[1] == T[1]) &amp;&amp; (s[2] == T[2]) &amp;&amp; (s[3] == T[3]);}int bfs(int S[4], int T[4]) {    queue&lt;tuple&lt;int,int,int,int&gt;&gt; q;    auto x = make_tuple(0, 0, 0, 0);    q.push(x);    mem[0][0][0][0] = true;    int step = 0, cap[4] = {0 };    while (!q.empty()) {        int size = q.size();        while (size--) {            tie(cap[0], cap[1], cap[2], cap[3]) = q.front(); q.pop();            if(equal(cap, T)) {                return step;            }            for (int i = 0; i &lt; 3; ++i) {                switch (i) {                    case 0: // 将某个杯子倒满                        for (int j = 0, tmp = 0; j &lt; 4; ++j){                            tmp = cap[j];                            cap[j] = S[j];                            x = make_tuple(cap[0], cap[1], cap[2], cap[3]);                            if(!mem[cap[0]][cap[1]][cap[2]][cap[3]]) {                                mem[cap[0]][cap[1]][cap[2]][cap[3]] = true;                                q.push(x);                            }                            cap[j] = tmp;                        }                        break;                    case 1: // 将某个杯子倒空                        for (int j = 0, tmp = 0; j &lt; 4; ++j) {                            tmp = cap[j];                            cap[j] = 0;                            x = make_tuple(cap[0], cap[1], cap[2], cap[3]);                            if(!mem[cap[0]][cap[1]][cap[2]][cap[3]]) {                                mem[cap[0]][cap[1]][cap[2]][cap[3]]=true;                                q.push(x);                            }                            cap[j] = tmp;                        }                        break;                    case 2: // 将杯子 j 倒向杯子 z                        for (int j = 0; j &lt; 4; ++j) {                            int tmp1,tmp2,need;                            for (int z = 0; z &lt; 4; ++z){                                if (j == z) continue;                                tmp1 = cap[j], tmp2 = cap[z];                                need = min(cap[j], S[z]-cap[z]);                                cap[j] -= need;                                cap[z] += need;                                x = make_tuple(cap[0], cap[1], cap[2], cap[3]);                                if (!mem[cap[0]][cap[1]][cap[2]][cap[3]]) {                                    mem[cap[0]][cap[1]][cap[2]][cap[3]] = true;                                    q.push(x);                                }                                cap[j] = tmp1, cap[z] = tmp2;                            }                        }                }//end switch            }        }//end inner while        ++step;    }//end outer while    return -1;}int main(){    int S[4] = {0}, T[4] = {0};    cin &gt;&gt; S[0] &gt;&gt; S[1] &gt;&gt; S[2] &gt;&gt; S[3];    cin &gt;&gt; T[0] &gt;&gt; T[1] &gt;&gt; T[2] &gt;&gt; T[3];    if (S[0] == 0 &amp;&amp; S[1] == 0 &amp;&amp; S[2] == 0 &amp;&amp; S[3] == 0 &amp;&amp; !equal(S,T)) {        cout &lt;&lt; -1 &lt;&lt; endl;    } else {        int ret = bfs(S, T);        cout &lt;&lt; ret &lt;&lt; endl;    }    return 0;}\n\n分割后处理  研究地球空间科学的永强想研究海岸线的长度和海岸线面积之间的关系，为此他找来了很多航拍图像。在航拍图像上利用图像分割的方法，把图像的每个像素标记成陆地（1）和水面（0）。\n示例图片：\n\n    \n\n\n现在永强想知道每张图中陆地部分的面积。\n已知每张图最底部的一条边都是陆地，并且在一张图上陆地都是四邻域联通的。\n但是永强发现分割的结果有很多的噪声，于是他定义了如下规则试图去除噪声：\n\n如果一个水面区域被陆地包围，则将这个区域记为陆地；\n在 a 的基础上如果一个陆地区域不和底边的陆地相连，那么这是一个岛屿，不计入陆地的面积。\n\n\n            输入例子：5 61 0 0 1 0 00 0 1 0 1 01 1 1 1 1 01 0 0 1 1 11 1 1 1 1 1输出例子：21\n          \n\n思路\n从边缘且为水的位置开始遍历，将所有没有被陆地包围的水标记为 2\n1 2 2 1 2 22 2 1 0 1 2 1 1 1 1 1 2 1 0 0 1 1 1 1 1 1 1 1 1\n将被陆地包围的水标记为 1（陆地）\n1 2 2 1 2 2 2 2 1 1 1 2 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 1 1 1\n从下边缘且为陆地的位置开始遍历，标记所有陆地为 3，同时计算面积\n1 2 2 3 2 22 2 3 3 3 2 3 3 3 3 3 2 3 3 3 3 3 3 3 3 3 3 3 3\n\n此时岛屿标记为 1，水标记为 2，陆地标记为 3\nSolution#include &lt;bits/stdc++.h&gt;using namespace std;int result = 0;void surround(vector&lt;vector&lt;int&gt;&gt;&amp; pic, int i, int j) {    if (i &lt; 0 || i &gt;= pic.size() || j &lt; 0 || j &gt;= pic[0].size() || pic[i][j] == 1 || pic[i][j] == 2) return;    pic[i][j] = 2;    int dx[4] = {-1, 1, 0, 0};    int dy[4] = {0, 0, -1, 1};    for (int k = 0; k &lt; 4; k++) {        surround(pic, i + dx[k], j + dy[k]);    }}void cal_area(vector&lt;vector&lt;int&gt;&gt;&amp; pic, int i, int j) {    if (i &lt; 0 || i &gt;= pic.size() || j &lt; 0 || j &gt;= pic[0].size() || pic[i][j] == 2 || pic[i][j] == 3) return;    pic[i][j] = 3;    result++;    int dx[4] = {-1, 1, 0, 0};    int dy[4] = {0, 0, -1, 1};    for (int k = 0; k &lt; 4; k++) {        cal_area(pic, i + dx[k], j + dy[k]);    }}int main() {    int m, n;    cin &gt;&gt; m &gt;&gt; n;    vector&lt;vector&lt;int&gt;&gt; pic(m, vector&lt;int&gt; (n, 0));    for (int i = 0; i &lt; m; i++) {        for (int j = 0; j &lt; n; j++){            cin &gt;&gt; pic[i][j];        }    }    // 1. 从边缘且为水的位置开始遍历，将所有没有被陆地包围的水标记为 2    for (int i = 0; i &lt; m; i++) {        for (int j = 0; j &lt; n; j++){            bool edge = i == 0 || i == m - 1 || j == 0 || j == n - 1;            if (pic[i][j] == 0 &amp;&amp; edge) {                surround(pic, i, j);            }        }    }    // 2. 将被陆地包围的水标记为 1（陆地）    for (int i = 0; i &lt; m; i++) {        for (int j = 0; j &lt; n; j++){            if (pic[i][j] == 0) {                pic[i][j] = 1;            }        }    }    // 3. 从下边缘且为陆地的位置开始遍历，标记所有陆地为 3，同时计算面积    for (int i = 0; i &lt; m; i++) {        for (int j = 0; j &lt; n; j++){           bool bottom = i == m - 1;           if (pic[i][j] == 1 &amp;&amp; bottom) {               cal_area(pic, i, j);            }        }    }    cout &lt;&lt; result &lt;&lt; endl;    return 0;}\n\n删除有序链表中重复的元素 I 删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次  例如：给出的链表为 1 → 1 → 2, 返回1 → 2 给出的链表为1 → 1 → 2 → 3 → 3, 返回1 → 2 → 3\nSolution/** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : val(x), next(nullptr) {} * }; */class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param head ListNode 类      * @return ListNode 类     */    ListNode* deleteDuplicates(ListNode* head) {        // write code here        if (head == nullptr)            return head;        auto p = head;        auto q = p-&gt;next;        while (q) {            if (p-&gt;val == q-&gt;val) {                p-&gt;next = q-&gt;next;            }            else {                p = p-&gt;next;            }            q = q-&gt;next;        }        return head;    }};\n\nII给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。例如：给出的链表为 1 → 2 → 3 → 3 → 4 → 4 → 5, 返回1 → 2 → 5 给出的链表为1 → 1 → 1 → 2 → 3, 返回2 → 3\n\n    \n\n\nSolution/** * struct ListNode { *  int val; *  struct ListNode *next; *  ListNode(int x) : val(x), next(nullptr) {} * }; */class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param head ListNode 类      * @return ListNode 类     */    ListNode* deleteDuplicates(ListNode* head) {        // write code here        if (head == nullptr)            return head;        auto p = head;        auto q = head-&gt;next;        if (q == nullptr)            return head;        auto* h = new ListNode(0);        h-&gt;next = head;        head = h;        while (q) {            if (p-&gt;val != q-&gt;val) {                h = p;                p = q;                q = q-&gt;next;            }            else {                while (q &amp;&amp; q-&gt;val == p-&gt;val) {                    q = q-&gt;next;                }                h-&gt;next = p = q;                if (q) q = q-&gt;next;            }        }        return head-&gt;next;    }};\n\nclass Solution {public:    ListNode* deleteDuplicates(ListNode* head) {        // 空链表        if(head == NULL)             return NULL;        ListNode* res = new ListNode(0);        // 在链表前加一个表头        res-&gt;next = head;         ListNode* cur = res;        while(cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;next != NULL){            // 遇到相邻两个节点值相同            if(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val){                int temp = cur-&gt;next-&gt;val;                // 将所有相同的都跳过                while (cur-&gt;next != NULL &amp;&amp; cur-&gt;next-&gt;val == temp)                     cur-&gt;next = cur-&gt;next-&gt;next;            }            else                 cur = cur-&gt;next;        }        // 返回时去掉表头        return res-&gt;next;     }};\n\n岛屿数量  给一个 01 矩阵，1 代表是陆地，0 代表海洋， 如果两个 1 相邻，那么这两个 1 属于同一个岛。我们只考虑上下左右为相邻。岛屿：相邻陆地可以组成一个岛屿（相邻：上下左右） 判断岛屿个数。例如：输入  对应的输出为 3（注：存储的 01 数据其实是字符’0’,’1’)\n\n    \n\n\nSolutionclass Solution {public:    void dfs(int i, int j, size_t height, size_t width, vector&lt;vector&lt;char&gt;&gt;&amp; grid) {        grid[i][j] = '0';        if (i + 1 &lt; height &amp;&amp; grid[i + 1][j] == '1') {dfs(i + 1, j, height, width, grid); }        if (j + 1 &lt; width &amp;&amp; grid[i][j + 1] == '1') {dfs(i, j + 1, height, width, grid); }        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == '1') {dfs(i - 1, j, height, width, grid); }        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == '1') {dfs(i, j - 1, height, width, grid); }    }    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     * 判断岛屿数量     * @param grid char 字符型 vector&lt;vector&lt;&gt;&gt;      * @return int 整型     */    int solve(vector&lt;vector&lt;char&gt; &gt;&amp; grid) {        // write code here        int res = 0;        size_t height = grid.size();        if (height == 0)            return 0;        size_t width = grid[0].size();        for (auto i = 0; i &lt; height; i++) {            for (auto j = 0; j &lt; width; j++) {                if (grid[i][j] == '1') {                    res++;                    dfs(i, j, height, width, grid);                }            }        }        return res;    }};\n\n判断是不是完全二叉树  给定一个二叉树，确定他是否是一个完全二叉树。\n完全二叉树的定义：若二叉树的深度为 ，除第 层外，其它各层的结点数都达到最大个数，第  层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第  层可能包含  个节点）\n\n\nSolution/** * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * }; */class Solution {public:    /**     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可     *     *      * @param root TreeNode 类      * @return bool 布尔型     */    bool isCompleteTree(TreeNode* root) {        // write code here        if (!root) return true;        if (root-&gt;left &amp;&amp; (!root-&gt;left-&gt;left || !root-&gt;left-&gt;right) &amp;&amp; root-&gt;right &amp;&amp; (root-&gt;right-&gt;left || root-&gt;right-&gt;right)) // 对应左子树不完全，右子树完全            return false;        if (root-&gt;left &amp;&amp; root-&gt;left-&gt;left &amp;&amp; !root-&gt;right) return false; // 对应只包含左子节点的情况        if (!root-&gt;left &amp;&amp; root-&gt;right) return false; // 正常非完全的情况        return isCompleteTree(root-&gt;left) &amp;&amp; isCompleteTree(root-&gt;right);    }};\n\n\n    \n\n\nclass Solution {  public:    bool isCompleteTree(TreeNode* root) {        // 空树一定是完全二叉树        if(root == NULL)             return true;        queue&lt;TreeNode*&gt; q;        // 根节点先访问        q.push(root);         // 定义一个首次出现的标记位        bool flag = false;         // 层次遍历        while(!q.empty()){            int sz = q.size();            for (int i = 0; i &lt; sz; i++) {                TreeNode* cur = q.front();                q.pop();                // 标记第一次遇到空节点                if (cur == NULL)                     flag = true;                 else{                    // 后续访问已经遇到空节点了，说明经过了叶子                    if (flag) return false;                    q.push(cur-&gt;left);                    q.push(cur-&gt;right);                }            }        }        return true;    }};\n","categories":["面试"],"tags":["LeetCode","牛客网","算法题","动态规划","链表"]},{"title":"Reinforcement Learning II","url":"/2024/07/16/3c18f3adbff3/","content":"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n","categories":["强化学习"],"tags":["RL","数学","笔记","手写"]},{"title":"Reinforcement Learning I","url":"/2024/07/16/436fe966f14f/","content":"\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n","categories":["强化学习"],"tags":["RL","数学","笔记","手写"]},{"title":"Markov Decision Processes","url":"/2024/07/30/990e4273260f/","content":"Basics\n\n有的地方写作\n: state space, : initial state\n在代码就是s0 = mdp.reset()\n\n\n: action space,  applicable in each state 当前状态  下允许的动作\n转移概率（trasition probabilities），对于\n也可以写作：\n是概率化的（即 probabilistic state model），而非确定性的（deterministic）的\n如果是确定性的，那就是一个经典的序列决策问题了\n\n\n: reward function，可以为正（奖励）；也可以为负（惩罚）\n设计一个 MDP 环境，很大一部分是在设计 reward function\n: 确定性的情况下\n: 是在不确定的情况下产生的奖励，就好像抛硬币，不知道下一次出现的是正面还是反面，这时就需要用概率分布来计算了\n\n\n: discount factor\n\n一般又把这种 MDP 称之为 discounted reward MDP\n\n\nMDP 的求解是一个序列决策问题（sequence decision making）\n\nProbabilistic State Model\n抛硬币：正面朝上的概率是，反面朝上的概率也是\n掷 2 个骰子计算点数和：和为 2 的概率是，和为 2 的概率是，和为 4 的概率是，，和为 12 的概率是\n机械臂去拿一个东西：成功的概率是，失败的概率是\n打开一个网页：404 的概率 1%，200 的概率 99%\n\n\nDiscounted Reward\n如果 agent 在与环境交互中得到一些列的 reward ，则有\n  \n\n递归定义，体现子问题的结构（可以使用动态规划）\n的价值通过  折到现在\n因为要最大化 discounted reward，所以  会隐式地得到一个更短路径\n另外一个角度是：aciton 会有 cost\n\n\n\n\n\nGrid World\n    \n\n","categories":["强化学习"],"tags":["RL","MDP","tutorials"]},{"title":"高质量实时渲染","url":"/2021/11/08/5456f6418caa/","content":"\n    \n\n\n\n\nOpenGLVertex Shader &amp; Fragment Shader\nFor each vertex in parallel 每一个顶点都要做\n在 OpenGL 中调用程序定义的 vertex shader：做顶点变换，包括 MVP 变换、需要插值的属性输出给 fragment shader\n\n\nFor each primitive, OpenGL rasterizes 对每一个片元，OpenGL 进行  打成一堆像素\nGenerates a fragment for each pixel the fragment covers\n\n\nFor each fragment in parallel 每一个片段都要做\n在 OpenGL 中调用程序定义的 fragment shader：做着色和光照计算\n\n\n\nShadow MappingRender from Light &amp; Eye\nPass 1: Output a “depth texture” from the light source 从光源的角度出发生成一幅深度图\nPass 2: Render a standard image from eye\n\nProject to light for shadows\nProject visible points in eye view back to light source 连向光源，比较场景上的深度和 Shadow Map 中的深度的大小\n\nIssues in Shadow MappingSelf Occlusion\n    \n\n\n从光源的角度看场景所形成的 shadow map 是一个离散的图，shadow map 上一个像素所覆盖的区域是的  深度值  则为一个  常数，也就是说 shadow map 记录的深度不是连续的，与实际场景不符。当进行第二次 Pass 时，从场景某一点出发看向光源，就会被遮挡住，如图中黑色部分\n\n如果光源方向从上往下垂直照向平面的时候没有自遮挡的问题，如果光源方向几乎平行与平面时自遮挡的问题最严重\n\n\nAdding a (variable) bias to reduce self occlusion\n如果实际的深度与  光源深度  的差值小于某个阈值就不算遮挡，相当于遮挡物距场景长的点足够小就忽略这个遮挡物。这个阈值可以不是一个常数，可以根据光源的角度变化。也可以从下图去理解这个 Shadow Bias。\n\n    \n\n\n但是可能回造成悬浮（Peter Panning）的问题，因为物体看起来轻轻悬浮在表面之上。\n解决方案（目前没有完美的解决方案）：\n\n找到一个合适的 Shadow Bias——工业界的解决方法\n\nSecond-dpeth shadow mapping——实际中没有人用\n\nUsing the midpoint between first and second depths in shadow map\nrequires objects to be waterlight\nthe overhead may not worth it\n\n\n\n\n\nAlias实时渲染中阴影背后的数学知识There are a lot of useful inequalities in caculus\n设  和在  上都可积，则：\n\nSchwarz 不等式\n\nMinkowksi 不等式\n\n\n在实时渲染中不太关心不等，关心的是近似相等，贯穿整个实时渲染的一个重要的不等式如下：什么时候上述不等式更加准确：\n\n的 support 足够小\n是足够光滑的\n\nPercentage Closer Soft Shadows\nPercentage Closer Filtering\n\nPerform multipule(e.g. ) depth comparisons for each fragment\nThen, averages result of comparisons\n\n\n过滤或平均的是什么？\n平均的是任意 shading point 做的很多次阴影深度比较的结果，既不是对 shadow map 做模糊操作，也不是对最后的阴影图做模糊操作\n\n\nFilter size &lt;-&gt; blocker distance 如何确定 filter 的大小\n\n\n\n    \n\n\n\nThe complete algorithm of PCSS\nStep 1: Blocker search (getting the average blocker depth in a certain region)\nStep 2: Penumbra estimation (using the average blocker depth to determine the filter size)\nStep 3: Percentage Closer Filtering\n\nWhich region to perform blocker search? 如何确定 blocker 的大小\n    \n\n\n光源看去生成一个 shadow map，假设 shadow map 放在视锥体的近平面上，从 shading point 连向光源，计算在 shadow map 上覆盖的区域即为 blocker size\nVariance Soft Shadow MappingA Deeper Look at PCF\nFilter / Convolution\n\nIn PCSS每一个 shadow map 上  点的深度和场景上  点的深度比较，按照某种形式加权平均起来\n\nTherefore, PCF is not filtering the shadow map then compare 并不是对 shadow map 做模糊然后比较\n\nAnd PCF is not filtering the resulting image with binary visibilities 也不是最后的阴影图做模糊操作\n\n\nVariance Soft Shadow MappingWhich step(s) can be slow?\nStep 1\nStep 3\n\nVariance Soft Shadow Mapping\nPCF 可以理解为在一场考试中知道自己多少分，想知道自己的排名在百分之几，就需要把所有的人的成绩都统计出来，VSSM 则不需要知道所有人的成绩，就好比知道成绩的分布，然后根据自己的成绩就知道所在位置了\n\n\nKey Idea: Quickly compute the mean and variance of depths in an area\n\nMean\n\nHardware MIPMAPing\nSummed Area Tables(SAT)\n\n\nVariance\n\n 利用期望和方差关系的公式，可以由另外一个 shadow map，这个 shadow map 记录的时所有深度值的平方，在 OpenGL 中可以将这个深度平方的值记录在其他通道中（纹理由 R、G、B、A 四个通道，shadow map 占用一个通道）\nJust generate a “square-depth map” along with the shadow map\n\n\nPercentage of texels that are closer than the shading point 知道了期望和方差如何计算深度比 shading point 更近点的占比\n可由单边切比雪夫不等式更快的算出来：是均值，是方差，只要知道均值和方差即可带入上述公式，但是必须满足，可以直观感受切比雪夫不等式\n\n    \n\n\nBlocker search\n    \n\n\n假设 shading point 的深度是 7，已经知道了  区域大小的平均深度，但是小于 7 的遮挡物的平均深度是未知的\n\nKey idea\nBlocker（的部分，蓝色部分）的平均值记为\nNon-blocker（的部分，红色部分）的平均值记为\n满足\n根据切比雪夫可以估计：，\n又做了个假设：，例如大多数的阴影接受物体是一个平面\n\n\nStep 1 solved with negligible additional cost\n\nSAT for Range Query\nNeed to quickly grab  and  from an arbitrary range (rectangular) 需要快速计算出任意矩形范围内的均值和方差\n\n对于均值，MIPMAP 和 Summed Area Table 都可以来计算，MIPMAP 存在误差的问题，并且不能查询非正方形的区域\nClassic data structure and algorithm (prefix sum) 经典数据结构——前缀和  一维\n    \n\n\n二维\n    \n\n\nMoment Shadow Mapping\n    \n\n\nMoments\n最简单的矩：\nVSSM is essentially using the ﬁrst two orders of moments\n\nWhat can moments do?\nConclusion: first  orders of moments can represent a function with  steps\nUsually, 4 is good enough to approximate the actual CDF of depth dist\n\nEnvironment MappingDistance Field Soft Shadow\nDistance function: At any point, giving the minimun distance (could be signed distance) to the closest location on an object 在空间中的任何一个点，到某个物体表面的最小距离（距离场可以是有向的，比如在物体内部为负，在物体外部为正）\n\nAn Example: Blending (linear interp.) a moving boundary\n\n    \n\n\nThe Usages of Distance Fields\nRay marching (Sphere tracing) to perform ray-SDF intersection\n任何一个点上都相当于定义了一个安全距离（safe distance），利用这个安全距离可以近似求出光线与场景中物体的交点\n\nUse SDF to determine the (approx.) percentage of occlusion\n把安全距离延申为安全角度（safe angle），最后转换为阴影的值\n\n\nHow to compute the safe angle?利用反三角函数：，图形学中不提倡计算反三角函数（计算量很大），可以通过距离的比值来表示角度的近似，即：，用来控制阴影的软硬程度\nShading from Environment LightingHow to use it to shade point (without shadows)?\n    \n\n\n不考虑 visibility，任何一个 Shading Point 都要求解这个渲染方程，计算量特别大，不能用在实时渲染中，即如果存在采样（sample）的操作，就很难应用在实时渲染中\nThe Split Sum: 1st Stage\nRecall: the approximation\n\n\nConditions for acceptable accuracy? 这个公式什么时候会比较准确\n\n的 support 比较小的情况下→BRDF is glossy\n或者  的值比较 smooth 的情况下→BRDF is diffuse\n\n\n于是就可以把光源项拆出来  拆出来的项相当于把 Light 对应区域积分并归一化，也就是把 IBL 表示的一张图进行  模糊\n为什么要做 pre-filtering：Then query the per-filtered environment lighting at the (mirror reflected) drection\n\n\nThe Split Sum: 2nd Stage\n如何避免对 BRDF 积分的采样，即\n\nIdea：Precompute its value for all possible combinations of variables roughness, color(Fresnel term), etc. 预计算所有的参数的可能性\n基于微表面的 BRDF 需要考虑的参数：\n\nfresnel term 菲尼尔项\nNDF 微表面的法线分布\n\n\nRecall : Microfacet BRDF\n\n    \n\n\n菲尼尔项可以用 Schlick’s 方法近似：：初始反射率\n：入射角度\n法线分布可以使用 Beckmann distribution：：物体的粗糙度\n：半程向量和法线的夹角\n\n    \n\n\n由于两个类型的角度可以近似，预计算的维度为三维，但仍然需要降维。可以把菲尼尔项的近似形式——Schlick’s 带入到积分中：Each integral produces one value for each (roughness, incident angle) pair\n在实时领域、工业界通常写为求和，所以也被称为 split sum 方法：\n\n\n\n\nShadow from environment lighting\nIn general, very difficult for real-time rendering 环境光照下的阴影做不到\n\nDifferent perspectives of view\nAs a many-light problem 环境光照可以认为是很多光源，每一个光源都要生成一个 Shadow Map 代价非常大\nAs a sampling problem 通过解渲染方程需要大量的采样，求解 Visibility Term 项是最难的，只能盲目的采样\n\nIndustrial solutionGenerate one (or a little bit more) shadows 从最亮的一个或几个光源下生成阴影\nPrecomputed Radiance TransferBackground knowledgeFourier TransformRepresent a function as a weighted sum of sines and cosines 一个函数可以写成若干  项和  项的组合\nA general understandingAny product integra can be considered as filtering 两个函数相乘再积分就认为是滤波操作\nBasis FunctionsA set of functions that can be used to represent other functions in general 一个函数可以描述为其他函数的线性组合\n\nThe Fourier series is a set of basis functions\nThe polynomial series can also be a set of basis functions ()\n\nReal-time environment lightingSpherical Harmonics\n定义：A set of 2D basis functions  defined on the sphere 一系列定义在球面上的二维基函数，“球面上”表示方向\n\n\n    \n    Alternative picture for the real spherical harmonics\n\n&gt; 到底是什么？\n&gt;\n&gt; 一堆函数，每一阶拥有一种频率，阶越高对应的基函数的数量越多\n\n\nEach SH basis function  is associated with a (Legendre) polynomial\n\nProjection: obtaining the coefficient of each SH basis function 已知任何一个二维的函数 ，任何一个基函数对应的系数可以通过 Product Integral 获得，求系数的过程就叫做 投影\n\n\nAnalytic Irradiance Formula\n    \n    用 SH 描述BRDF\n\n\n用不同阶的 SH 描述  全局光照\n\n    \n\n\n\n对于任何的光照条件，只要材质是 Diffused，都可以用前三阶的 SH 来  描述光照\n\nA Brief Summarization\nUsage of basis function\nRepresenting any function (with enough #basis) 足够多的基函数可以表示一个函数\nKeeping a certain frequency contents (with a low #basis) 保留一些低频信息，可以用前几阶的基函数\nReducing integrals to dot products\n\n\nBut here it’s still shading from environment lighting\nNo shadows yet 仍然没有加入阴影\n\n\n\nPrecomputed Radiance TransferRendering under environment lighting\n\n：Ligghting Term 环境光\n：Visibility Term 从一点往四面八方看，结果要么是 0，要么是 1\n：BRDF Term 原本是四维的，但是从某个地方看即表示知道观察方向，也就知道了入射方向，就可以用二维变量描述\n\n\n, incoming directions\n,view directions\n\nBrute-force computation 这三项都可以描述成二维的球面函数，如果这样计算量会特别大\nBasic idea of PRT\n假设：场景中其他所有的都不变，只有光照会发生变化，在这种情况下 light transport 也可以当作球面函数\n\n\nApproximate lighting using basis functions 把光照拆成 basis functions\n\n\n\nPrecomputation stage\ncompute light transport, and project to basis function space\n\n\nRuntime stage\ndot product (diffuse) or matrix-vector multiplication (glossy)\n\n\n\nDiffuse Case\nBRDF——是一个常值\n\n\n\n一种理解方式\n\n上式中的  就是 light transport 的球面函数投影到某个基函数上的  系数\n\nReduce rendering computation to dot product 就是两个向量的点乘\n\n\n\n另一种理解方式\n\nSeparately precompute lighting and light transport\n光照项分别为 lighting coefficient 和 basis functions\n\n\n\n光照传输项分别为 lighting transport coefficient 和 basis functions\n\n\n\n\nWhy is it a dot product? (This seems to be  rather than ?)\n虽然看起来像是二维的求和，但是根据 SH 的正交性，只有当  时积分不为 0；相当于计算二维矩阵对角线上的值\n\n\n\nGlossy Case\n与 Diffuse 的区别在于 BRDF，Diffuse 的 BRDF 是一个常数，Glossy 的 BRDF 表示不同方向入射光线照到物体表面，反射到不同的方向的结果，所以 Glossy 的 BRDF 是一个  四维  的向量。给定任意观察方向 ，light transport 都会投影出来一组完全不同的向量，所以在任意观察方向上 light transport 不是个常数，而是 的函数\n\nGlossy 的物体有一个非常重要的性质——和视点有关 ，Diffuse 的物体和 视点无关\n\nInterreflections and Caustics\n\nL：Light 光照\nE：Eye 眼睛\nG：Glossy\nD：Diffuse\nS：Specular\n\n\nRuntime is independent of transport complexity\nL(D|G)*E、LS*(D|G)*E 起点都是光照，终点都是视角，中间的部分都可以认为是 Light Transport，所以运行时的复杂度和 Light Transport 的复杂度无关\nBasis Functions Properties 性质\northonormal 正交性\n\nsimple projection/reconstruction 投影易算\n\nProjection to SH space\n\nReconstruction\n\n\n\nsimple rotation 旋转任意一个基函数某个角度，都可以被同阶的基函数线性组合得到\n\nsimple convolution\n\nfew basis functions: low freqs\n\n\nMore basis functions\nSpherical Harmonics (SH)\nWavelet 定义在二维平面上\n2D Haar wavelet\nProjection\nWavelet Transformation\nRetain a small number of  non-zero coefficients  保留了一小部分非零的基函数的系数\n\n\nA non-linear approximation 保留非零或最大的数值\nAll-frequency representation 支持全频率表示\n不支持快速旋转\n\n\nZonal Harmonics\nSpherical Gaussian (SG)\nPiecewise Constant\n\nPrecomputation\nlight transport 投影到任何一个基函数上，相当于用 basis functions 所描述的环境光照，照亮各个物体，从而计算物体各个点上 shading 的值，相当于 render equation\n\n\nRun-time Rendering\n\nRendering at each point is reduced to a dot product\nFirst, project the lighting to the basis to obtain \nOr, rotate the lighting instead of re-projection\nThen, compute the dot product\n\n\nReal-time: easily implemented in shader\n\nReal-Time Global IlluminationReflective Shadow Maps (RSM)\nWhich surface patches are directly lit? 什么样的表面能都被光源直接照射到\n\nPerfectly solved with a classic shadow map 可以通过 Shadow Map 计算出\nEach pixel on the shadow map is a small surface patch Shadow Map 上的每一个像素都是一片次级光源\nAssumption\nAny reflector is diffuse 假设任何次级光源的材质都是 Diffuse\nTherefore, outgoing radiance is uniform toward all directions\n\n\n\n\nWhat is the contribution from each surface patch to \n\n    \n\n\n\nAn integration over the solid angle covered by the patch\nCan be converted to the integration on the area of the patch\n\n\n\nFor a diffuse reflective path\n\n\n\n\n\nTherefore\n\n\n\nNot all pixels in the RSM can contribute\n\nVisibility 可见性\nOrientation 方向\nDistance 距离\n\n\nWhat is needed to record in an RSM?\n\nDepth\nWorld coordinate\nNormal\nflux\netc.\n\n\n\nLight Propagation Volumes (LPV)\n\nKey problem\nQuery the radiance from any direction at any position 从任何一个方向到达任意一点的 radiance 是多少\n\nKey Idea\nRadiance travels in straight line and does not change radiance 在传播过程中不会衰减\n\nKey solution\nUse a 3D grid to propagate radiance from directly illuminated surfaces to anywhere else\n\n\n\nSteps\nGeneration of raidance point scene representation 哪些点作为次级光源（哪些点接收到直接光照）\n\nThis is to find directly lit surfaces 哪些 surface 被直接照亮\nSimply applying RSM would suffice 可以利用 RSM\nMay use a reduces set of diffuse sufface patches (virtual light sources) 不必要所有的 patch 都当作次级光源，可以利用采样等方法降低 patch 的数量\n\n\nInjection of point cloud of virtual light sources into radiance volume 把场景中接收到直接光照的点放到场景中划分好的格子中\n\nPre-subdivide the scene into a 3D grid 首先场景中有一个三维的格子，工业界大多数用三维纹理\nFor each grid cell, find enclosed vitual light sources 每个格子内都有朝向不同的次级光源\nSum up their directional radiance distribution 把这些次级光源的 radiance 累加\nProject to first 2 orders of SHs (4 in total) 利用 SH 对每个格子内的次级光源的分布进行压缩\n\n\nVolumtric radiance propagation\n\nFor each grid cell collect the radiance received from each of its 6 faces\n\n    \n\nSum up, and again use SH to represent\n\nRepeat this propagation several times till the volume becomes stable 迭代\n\n\n\nScene lighting with final light propagation volume 传播完成后就知道了场景中每个格子上的 radiance，直接拿去渲染\n\nFor any shading point, find the grid cell it is located in\nGrab the incident radiance in the grid cell (from all directions)\nShade\n\n\n\nLight leaking\n    \n    \n\n\n\n假设  点是次级光源，但是无论如何都不会有从  点反射出去的 radiance 到右边的情况，但是由于把场景划分成格子，这两个点都在一个格子里面，所以这两个点的 radiance 是一样的。如果格子划分的特别小是可以解决 light leaking 的问题，但是计算时间和存储的问题，工业界会用不同分辨率的格子——cascade\n\nVoxel Global Illumination (VXGI)\n\nStill a two-pass algorithm\nTwo main diffetences with RSM\nDirectly illuminated pixels -&gt; (hierachical) voxel 从 RSM 的像素表示的微小的表面到整个场景划分出来具有层次结构的格子\nSampling on RSM -&gt; tracing reflected cones in 3D (Note the inaccuracy in sampling RSM) RSM 和 LPV 做传播都是 ray-tracing（每个点用一个光线传播），VXGI 是 cone-tracing（每个点用锥形的形式进行光线传播）\n\n\n\n\nReal-Time Global Illumination (Screen Space)What’s is “screen space”?\n\nUsing information only from “the screen”\nIn other words, post processing on existing renderings\n\nScreen Space Ambient Occlusion (SSAO)Why AO? 为什么要Ambient Occlusion\nCheap to implement\nBut enhances the sense of relative positions 通过阴影的方式，物体的立体感的更加明显了\n\nWhat is SSAO?\nAn approximation of global illumination 对全局光照的近似\nIn screen space\n\nTheory\nStill, everything starts from the rendering equation\n\nAnd again\n\nSepatating the visibility term 把 visibility 项拆除去\n\n乘号  左边一项可以写为（the weight-averaged visibility  from all directions）：\n乘号  右边一项可以写为（constant for AO）：\n\nA deeper understanding 1the average  in the support of \n\nA deeper understanding 2\n\nWhy can we take the cosine term with ?\n\n\nProjected solid angle \n将单位球上的面积投影到一个单位圆上\n\nunit hemisphere -&gt; unit disk\nintegration of peojected solid angle -&gt; the area of the unit disk\n\n\n    \n\n\n\nActually, a much simpler understanding\n\nUniform incident lighting -  is constant\n\nDiffuse DSDF -  is also constant\n\nTherefore, taking both out of the integral:\n\n\n\n\nAmbient occlusion using the z-buffer\n    \n\n\n\nUsing the readily available depth buffer as an approximation of the scene geometry 任何一个 Shading Point 都以自身为中心，半径为  的球内部采样一些点，判断采样点能否被 Shading Point 看到\nTake samples in a sphere around each pixel and test against buffer\nIf more than half the samples are inside, AO is applied, amount depending on ratio of samples that pass and fail depth test\nUses sphere instead of hemisphere, since normal information isn’t available 所有的渲染方程的定义域都是半球，那为什么 AO 用整个球？因为 Camera 渲染出来不能既知道深度有知道法线，不知道法线就无法用半球来估计\nApproximation of the scene geometry, some fails are incorrect. The one behind the red line for example. False occlusions.\nSamples are not weighted by , so not physically accurate, but looks convincing.\n\nHorizon based ambient occlusion (HBAO)\nAlso done in screen space.\nApproximates ray-tracing the depth buffer\nRequires that the normal is know, and only samples in a hemisphere\n\n\n    \n\n\nScreen Space Directional Occlusion (SSDO)Very similar to path tracing\nAt shading point , shoot a random ray\nif it does not hit an obstacle, direct illumination\nIf it hits one, indirect illumination\n\nComparison with SSAO\nAO: indirect illumination +  no indirect illuminatino\n在 AO 中，红色圈内的表示能接收到间接光照，橙色圈内的表示没有间接光照\n\nDO: no indirect illumination +  indirect illuminatino\n在 DO 中，红色圈内则表示直接光照，橙色圈内则表示能接收到间接光照\n\n\n\n    \n\n\nConsider unoccluded and occluded directions separately\nSSDO similar to HBAO\n\n\n从  点往 、、、 方向看能不能被挡住，还做之前的假设——不管从  到能不能被挡住，只考虑从相机到  能不能被挡住（非常大胆的假设，但一定程度上是有效的）。右面的一幅图可以理解为对  有贡献的点的和，点由于被遮挡所以不计算在内。这样假设也会出现一些大问题，如第三幅图的情况——从相机视角被一个悬浮的物体挡住了，但是  点是可以直接看到  点。\nIssues\nGI in a short range 只能解决一个小的范围内的全局光照\n\nVisibility 对于可见性不准确\n\nScreen space issue: missing informaiton from unseensurfaces 丢失看不见部分的信息\n\n    \n\n\nScreen Space Reflection (SSR)What is SSR?\nStill, one way to intoduce Global Illumination in RTR 实时渲染中实现全局光照的一种方式\nPerforming ray tracing 屏幕空间上的光线追踪\nBut does not require 3D primitives (triangles, etc.) 不需要三维空间中的各种信息\n\nTwo fundametal tasks of SSR\nIntersection: between any ray and scene\nShading: contribution from intersected pixels to the shading point\n\nBasic SSR Algorithm - Mirror Reflection\nFor each fragment\n\nCompute reflection ray\nTrace along ray direction (using depth buffer)\nUse color of intersection point as reflection color\n\n\nLinear Raymarch (Find intersection point)\n\n    \n\n\n\nAt each step, check depth value\nQuality depends on step size\nCan be refined\n\n\nGenerate Depth Mip-Map\n\n    \n\n\n\nUse min values instead of average\n\n    \n\n\n\n和正常的 Mip-Map 的做法不一样的地方在于，上一层的 4 个像素不再是下一层的平均值，而是最小值，也就是深度离场景最近的位置\n\n\n\nWhy Depth Mipmap\nVery similar to the hierarchy(BVH, KD-tree) in 3D 对场景建立一个层次结构\nEnabling faster rejecting of non-intersecting in a bunch 很容易跳过不可能相交的像素\nThe min operation guarantees a conservative logic 这个最小的操作就会得到一个保守的逻辑\nIf a ray does not even intersect a larger node, it will never intersect any child nodes of it 如果一个像素不和其上层的像素相交，也不可能和下层的像素（子节点）相交\n\n\n\n\n    \n\nmip = 0;while (level &gt; -1){    step through current cell;    if (above Z place) ++level;    if (below Z plane) --level;}\n\n\n\nProblem\nHidden Geometry Problem 对场景的理解只到外面的“壳”\nEdge Cutoff 会出现明显的 cut\nEdge Fading 根据反射光走的距离做衰减，虚化边缘\n\n\n\nShading using SSR\nAbsolutely no difference from path tracing 从在三维场景中的光线追踪到场景中“壳”的光线追踪\n\nJust again assuming diffuse reflections / secondary lights\n\n\nRequirements\n\nSharp and blurry reflections\nContact hardening\nSpecular elgonation\nPer-pixel roughness and normal\n\n\nImprovements\n\nBRDF importance sampling\n\n\n\nReal-Time Physically-Based Materials (surface models)Microfacet BRDF 微表面PBR and PBR Materials\nPhysically-Based Rendering(PBR)\nEverything in rendering should be physically based\nMaterials, lighting, camera, light transport, etc.\nNot just materials, but usually referred to as materials :)\n\n\nPBR materials in RTR\nThe RTR community is much behind the offline community 在实时渲染中的 PBR 材质要落后于离线渲染\n“PB” in RTR is usually not actually physically based :) 在实时渲染中提到的“Physically-Based”基本都不是“Physically-Based”\nFor surfaces, mostly just micorfacet models (used wrong so not PBR) and disney principled (artist friendly but still not PBR)\nFor volumes, mostly focused on fast and approximate single scattering and multiple scattering (for clound, hair, skin, etc.)\n\n\n\nMicrofacet BRDF\n Fresnel term\n从一个角度看过去，有多少能量被反射。当站在河边：\n垂直水面看下去反射的光就会少\n看水面远处的地方反射的光会增加\n\n\nAccurate: need to consider polarization 精确的方程式需要考虑到极化\nApproximate: Schlick’s approximation 简单的估计\n\n 基础反射率\n\n\n\n: shadowing-masking term: distribution of normals NDF(Normal Distribution Function) 法线的分布\nConcentrated &lt;==&gt; flossy\nSpread &lt;==&gt; diffuse\n\nNormal Distribution Function (NDF)\nhas noting to do with the normal distribution in stats 不同于统计学中的正态分布\nVarious models to describe it: Beckmann, GGX, etc.\n\nBeckmann NDF\n\nSimilar to a Gaussian\n\n\nBut defined on the slope space 坡度空间\n\n\n\n\n使用  作为参数可以永远保证不存在面朝下的微表面\n\n\n\n: roughness of the surface (the samller, the more like mirror/specular) 相当于正太分布的标准差\n: angle between half vector  and normal \nGGX (or Trowbridge-Reitz)\nTypical characteristic: long tail 明显的特点：“长尾”\n在 grazing angle 的时候还是有能量\n\nExtending GGXGTR (Generalized Trowbridge-Reitz), even longer tails 更长的“拖尾”\nShadowing-Masking TermOr, the geometry term \n\nAccount for self-occlusion of microfacets 解决的是微表面之间自遮挡的问题以及 grazing angles 的问题\nShadowing – light, masking – eye 从 light 的角度看，微表面自遮挡的现象——Shadowing 从眼睛的角度看，看不到微表面的现象——Masking\nProvide darkening esp. around grazing angles 需要提供一个变暗的操作\n\nA commonly used shadowing-masking term\nThe Smith shadowing-masking term\nDecupling shadowing and masking 将 shadowing 和 masking 分开\n\n\nKulla-Conty Approximation for Multiple Bounces\nMissing energy 能量损失\n\nEspecially prominent when roughness is high 随着粗超度增大能量损失越明显\n微表面越粗糙度，沟壑越大，当光线打到微表面的时候，反射的光越容易被其他的微表面挡住，损失的能量越多\n\n\nAdding back the missing energy\n\nHeitz et al. 2016 基于模拟的方法\nBut can be too slow for RTR\n\n\nThe Kulla-Conty Approximation\n\nWhat’s the overall energy of an outgoing 2D BRDF lobe[1]?\n\n\n\n\nKey Idea 设计了一种 BRDF，使得丢失的能量正是原来丢掉的部分\n\nWe can design an additional lobe that intergrates to  有多少能量被遮挡掉\n\nThe outgoing BRDF lobe can be different for different incident dir.\n\nConsider reciprocity, it should be of the form \n\nTherefor,  \n\nPrecompute / tabulate\n\nWhat if the BRDF has color?\n\n有颜色意味着有能量被吸收，意味着能量有损失\nSo we’ll just need to compute the overall energy loss 由于颜色造成的能量损失\n\n\nDefine the average Frensel (how much energy is reflected) 不管入射角多大，计算平均每次反射会损失多少能量  \n\nTherefor, the proportion of energy (color) that 最后能看到的能量的构成\n\nYou can directly see: \nAfter one bounce then be seen: \n…\nAfter  bounces then be seen: \n\n\nAdding everything up, we have the color term 级数求和得到最终的结果\n\nWhich will be directly multiplied on the uncolored  additional BRDF\n\n\n\n\n\n\n\n\n\nShading Microfacet Models using Linearly Transformed Cosines (LTC)\nSolves the shading of microfacet models\n\nMainly on GGX, though others are also fine\nNo shadows 不考虑阴影\nUnder polgon shaped lighting 多边形光源\nSplit Sum 本质上是做环境光下的 Shading\n\n\nKey Idea\n\nAny outgoing 2D BRDF lobe can be transformed to a cosine\nThe shape of the light can be transformed along\nIntegration the transformed light on a cosine lobe is analytic 转换后的积分是有 解析解 的\n\n\nObservations 任何 cosine 的 lobe 都可以通过  变换，变换成 BRDF 的 lobe\n\nBRDF  Cosine\nDirection: \nDomain to integrate: \n\n\n\n\n    \n\n\n\nApproach\n\nA simple change of variable 替换变量 \n\n\n\n渲染方程有三个部分：入射光、Cosine、BRDF，表示把 Cosine 和 BRDF 合到了一起，在多边形覆盖的立体角内进行积分\n通过这个变换把  变成 Cosine\n引入 Jacobi 项\n给定一个 GGX 模型的法线分布，已知出射的 BRDF 的 lobe，变换成 Cosine；从不同的方向观察得到不同的 BRDF 的 lobe，每一种 lobe 都要变换成 Cosine，对于常见的 lobe 可以预计算一个变换矩阵\n各项异性的表面可以用 LTC，各项异性：有一根光线打入后，根据不同的观察方向，会有不同的 BRDF\n\n\nDisney’s Principled BRDF\nMotivation\nNo physically-based materials are good at rep. all real materials 微表面模型并不能表示所有的材质\nPhysically-based materials are not artist friendly 对“艺术家”来说非常不友好\ne.g. “the complex index of refraction ”\n\n\n\n\n\n\n    \n\n\n\nA table showing the effects of individual parameters\nsubsurface 次表面散射 比 Diffuse 还要平的效果\nmetallic 金属性\nspecular 相当于 Blinn-Phong 模型中的，控制镜面反射区域的大小\nspecular Tint 可以表示镜面反射的颜色\nroughness 粗糙程度\nanisotropy 各项异性\nsheen 雾化效果\nsheen Tint 雾化效果（颜色）\nclearcoat 清漆\nclearcoat Gloss 清漆（光滑程度）\n\n\n\nNon-Photorealistic Rendering (NPR 非真实感渲染）\nCharacteristics of NPR\n\nStarts from photorealistic rendering\nExploits abstraction\nStrengthens important parts\n\n\nApplications of NPR\n\nArt 艺术\nVisualization 可视化\nInstruciton 说明书\nEducation\nEntertainment 娱乐\n…\n\n\n\nOutline Rendering\nOutlines are not just contours 不仅仅是轮廓\n[B]oundary / border edge 边界；边缘\n[C]rease 折痕\n[M]aterial edge 材质的边界\n[S]ilhouette edge 剪影；有多个面共享的边界\n必须是物体的外轮廓边界\n有多个面共享的边界\n\n\n\n\n\n\n    \n\n\nOutline Rendering – Shading [Silhouette]Darken the surface where the shading normal is perpendicular to viewing direciton 观察的方向和物体上某一点的法线方向几乎垂直的边就是 [Silhouette] 边，但会造成描边粗细不一样\nOutline Rendering – GeometryBackface fattening\n\nRender frontface normally\n“Fatten” backfaces, then render again 背向观察者的面上的三角面片都扩大，然后进行渲染\nExtension: fatten along vertex normals\n\nOutline Rendering – ImageEdge detection in images\n\nUsually use a Sobel detector\n\nColor blocks 大量的色块\nHard shading: thresholding on shading 在 shading 的过程中阈值化\nPosterization: thresholding on the final image color 在最后的图像上阈值化\nMay not be binary 阈值化不一定只是二值化\n\nSome Note\nNPR is art driven\nBut you need the ability to “translate” artists’ needs into rendering insights\nCommunicaiton is important\nSometimes, per character, even per part\n\nReal-Time Ray Tracing (RTRT)In 2018, NVIDA announced GeForce RTX series (Turing architecture) 有了 RTX 之后，允许我们每秒追踪更多的光线 （tensor core 加速神经网络感知；RT core 加速光线追踪），每秒钟能够追踪 10G 的光线，然而实际应用中：只能一个像素用一个样本采样，得到光线追踪的结果\n1 SPP(sample per pixel) path tracing = 1 rasterization (primary) + 1 ray (primary visibility) + 1 ray (secondary bounce) + (secondary visibility)\n\nrasterization 光栅化和 primary ray 的结果是等价的，但是光栅化可以更快\n1 SPP 噪声是一个夸张的结果\n所以 RTX 关键的技术是 Denosing 降噪\n\nGoals with 1 SPP\n\nQuality (no overblur, no artifacts, keep all details …)\nSpeed (less than 2ms to denoise one frame)\n\nIndustrial Solution Temporal\n\nSuppose the previous frame is denoised and reuse it 认为当前帧的前一帧是已经滤波好了的\nUse motion vectors to find previous locations\nEnssentially increased SPP\n\nG-Buffers\n\nThe auxiliary infomation acquired FOR FREE during rendering 在渲染场景的过程中“免费”得到的一些信息，但 FOR FREE* 并不是 100% 的“免费”\nUsually, per pixel depth, normal, world coordinate, etc.\nTherefore, only screen space info\n\nBack Projection\nPixel  in the current frame \n\nWhere was it in the last frame i - 1 ? 要找到上一帧像素  在哪，但是可以换一种描述\nWhat pixel in fram  contains the same place/point that you see through pixel  in frame ? 在上一帧哪一个像素是在当前帧所观察到的点\n\n\nBack projection\n\nif world coord  is available as a G-buffer, just take it 第一种方法\nOtherwise, (still require  value) 第二种方法\nMotion is known: , thus  物体如果存在运动\nProject world coord in frame  to its screen: \n\n\n\nTemporal Accum./Denoising\n\n: unfiltered\n: filtered\n\n\nThis frame (-th frame)\\bar{C}^{(i)} = \\alpha\\bar{C}^{(i)} + (1 - \\alpha)\\tilde{C}^{(i - 1)}, \\alpha \\in [0.1, 0.2]$$\n\n80% - 90% cobtributions from last frame(s)\n\nTemporal Failure\nTemporal info is not always available\n\nFailure case 1: switching scenes (burn-in period) 切换场景或者第一帧\nFailure case 2: walking backwards in a hallway (screen space issue) 在走廊中倒退镜头，越来越多的信息会出现在视野范围内\nFailure case 3: suddenly appearing background (disocclusion)\n\nAdjustments to Temporal Failure\n\nClamping: Clamp previous toward current 把上一帧的结果“拉”到当前帧\nDetection 检测到底要不要用以前的信息\nUse e.g. object ID to detect temporal failure 每个物体都给定一个渲染 ID\nTune , binary or continuously 微调\nPossibly strengthen / enlarge spatial filtering\n会重新引入一些噪声\n\n\n\n\n\nSome Side Notes\n\nThe temporal accumulation is inspired by Temporal Anti-Aliasing(TAA) 这两个概念几乎等同\nThey are very similar\nTemporal reuse essentially increses the sampling rate\n\n\n\nImplementation of filteringSuppose we want to (low-pass) filter an image 希望保留低频信息\n\nTo remove (usually high-frequency) noise\nNow only focus on the spatial domain spatial domain 空间域区别于频域\n\nInputs\n\nA noisy image \nA filter kernel , could vary per pixel\n\nOutput - A filterd image \nLet’s assume a Gaussian filter centered at pixel  (2D)\n\nAny peixl  in the neighborhood of  would contribute 从高斯的  范围内取，包括本身\nBased on the distance between  and \n\n  \n\n目的是做归一化 Test whether  is zero (for other kernels) 对于其他的滤波核需要判断 不为 0，高斯滤波核必定不为 0Color can be multi-channel\n\n\n\nBilateral filtering 双边滤波Observation The boundary &lt;-&gt; drastically changing colors 边界就是颜色变换非常剧烈的地方\nIdea\n\nHow to keep the boundary?\nLet pixel  contribute less if its color is too different to  如果  和颜色差距很大，就让  的贡献变小\n\n\n是一个点，是另一个点\nJoint Bilateral filtering 联合双边滤波\nGaussian filtering: 1 metric (distance) 高斯滤波提出了一个标准——距离\nBilateral filtering: 2 metric (position distance &amp; color distance) 双边滤波提出了两个标准\n\n\n    \n\n\nSuppose we consider 假设考虑 G-Buffer 生成的两种种额外的信息\n\nDepth\nNormal\nColor 颜色不属于 G-Buffer 生成出来的\n\nWhy we do not blur the boundary between\n\nA and B: depth\nB and C: normal\nD and E: color\n\nImplementing Large Filters\nFor samll filters, this is fine (e.g. )\nFor large filters, this can be prohibitively heavy (e.g. )\n\nSolution 1: Separate Passes\nConsider a 2D Gaussian filter\n\nSeprate it inro a horizontal pass () and a vertical pass () 对于任何一个像素来说，都取它周围  或的范围进行高斯滤波\n#queries:  查询次数从  到\n\n\n为什么能够从  到\nA 2D Guassian filter kernel is separable 二维的高斯函数的定义就是可以拆分的\n\nfiltering == convolution 滤波就是卷积\n\n\nSolution 2: Progressively Growing Sizes\nA-trous wavelet\n\nMultiple passes, each is a  filter\nTher interval between samples is growing () (save e.g. ) 样本和样本之间的间隔都是\n  \n\n\n\n\nWhy growing sizes？为什么要用逐渐增大的 filter，而不是直接使用一个大的 filter\nApplying larger filter == removing lower frequencies 用更大的 filter 意味着去除更低的频率，用越小的 filter 意味着去掉更高的频率，不断的去除不同的频率\n\nWhy is it safe to skip samples? 为什么能够跳着采样\nSampling == repeating the spectrum 采样在频域就是搬移频谱，将有规则的频谱段搬移到无规则的频谱段\n\n\n\n   \n\n\n如图所示，通过第一个 pass，高频率部分被干掉，所有的频率都集中在蓝色区域内，第二个 pass 相当于做了一个采样，也就是把第一个 pass 留下来的频谱向左或向右搬移一次\n\nOutlier RemovalFiltering is not aimighty\n\nSometimes the filtered result still noisy, even blocky\nMostly due to extremely bright pixels (outliers)\n\nOutlier Detection and Clamping\nFor each pixel, take a look at its e.g.  neighborhood\nCompute mean and variance 计算均值和方差\nValue outside   outlier 在范围之外的就是 outlier\nClamp any value outside  to this range\nNote: this is NOT throwing away (zero out) the outlier 并不是丢弃掉 outlier，而是把 outlier 限制到一个范围内\n\nSpatiotemporal Variance-Guided Filtring (SVGF)3 factors to guide filtering\n\n    \n\n\n\nDepth\n\n\nA and B are on the same plane, of similar color, so they should be contribute to each other. But the depth between A and B are very different\n只是有衰减的形状但并不是高斯的形式，是为了防止出现除 0 的情况，控制衰减快慢的参数，A 和 B 其实是在同一平面上，但是如果用正常的深度比较 A 和 B 的深度差距会很大，所以使用他们所在的切平面上的深度差异。任一点的深度的梯度，那么  可以表示为深度的变化量\n\nNormal\n\n\n点积可以确定两个向量的差异，变化系数\nNote: in case normal maps exist, use macro normal 有法线贴图的情况\n\nColorB 点可能刚好取到噪声上，需要用 B 点标准差，所以要用到 SVGF 中的 Variance\nCaculate spatially in \nAlso averaged over time using motion vectors\nTake another  spatial filter before use 就是在使用前计算出来的\n\n\n\nLuminance (grayscale color value)\n\nRecurrent AutoEncoder (RAE)Interactive Reconstruction of Monte Carlo Image Sequence using a Recurrent denoising AutoEncoder\n\nA post-processing network that does denosing\nWith help of G-buffers\nThe network automatically performs temporal accumulation\n\nKey architecture design\n\nAutoEncoder (or U-Net) structure\nRecurrent convolutional block\n\n\n    \n\n\nA Glimpse of Instustrail SolutionTemporal Anti-Aliasing (TAA)Why aliasing?\n\nNot enough samples per pixel during rasterization\nTherefor, the ultimate solution is to be use more samples\n\n\n    \n\n\n\n    \n\n\n\nMSAA (Multisample) vs SSAA (Supersampling)\nSSAA is straightforward\nRenderring at a larger resolutiont, then downsample 把场景按照原来几倍的分辨率渲染，渲染完成后再进行降采样\nThe ultimate solution, but costly 基本上 100% 正确\n\n\nMSAA: an improvement on performance 在 SSAA 基础上做了近似是的效率能够提上去\nThe same primitive is shaded only once 每个三角形只采样一次，通过维护一个表来实现\nReuse samples across pixels\n\n\n\n\nState of the art image based anti-aliasing solution\nSMAA (Enhanced subpixel morphological AA)\nHistory: FXAA → MLAA (Morphological AA) → SMAA\n\n\nG-buffers should never be anti-aliased\n\nTemporal Super ResolutionSuper resolution (or super sampling)\n\nliteral understanding: increasing resolution 给一张低分辨率的图变成高分辨率的图\nSource 1 (DLSS 1.0): out of nowhere / completely guessed 信息来源什么都没有，全靠猜\nSource 2 (DLSS 2.0): from temporal information\nMain Problem\nUpon temporal failure, clamping is no longer an option\nBecause we need a clear value for each smaller pixel\nTherefore, key is how to use temporal info samrter than clamping\n\n\nAn important practical issue\nIf DLSS itself runs at 30ms per frame, it’s dead already\nNetwork inference performance optimization (classified)\n\n\n\n\n\nDeferred ShadingOriginally invented to save shading time 节省 shading 的时间\nConsider the rasterization process\n\nTriangles → fragments → depth test → shade → pixel\nEach fragment needs to be shaded (in what scenario?) 在什么情况下每一个 fragment 都需要 shading，从远到近渲染可能会出现\nComplexity: \n\nKey Observation\n\nMost fragment will not be seen in the final image 很多 fragment 最后不会被看到，但是中间某个阶段对其进行了着色\nDue to depth test / occlusion\nCane we only shade those visible fragments?\n\nModifying the rasterizaiton process\n\nJust rasterize the scene twice 光栅化两次\nPass 1: no shading, just update the depth buffer 第一次不做着色，只对深度缓存进行更新\nPass 2 is the same (why does this guarantee shading visible fragment only?) 第二次光栅化开始做着色\nImplicitly, this is assuming rasterzing the scene is way faster then shading all unseen fragments (usually trye) 跑一边光栅化的时间要比渲染全部 fragments 的时间要快\n\nIssue\n\nDifficult to do anti-aliasing 不能用 AA\nBut almost completely solved by TAA 但是 TAA 是可以用的 为什么？\n\nTiled ShadingSubdivide the screen into tiles of e.g.  then shade each 建立在 deferred shading 的基础上，把屏幕分成小块，每个小块单独做 shading\nNot all lights can illuminate a specific tile 光源覆盖的范围是随着距离衰减的，可以把覆盖范围想象成球形\n\n    \n\n\nClustered Shading\nFurther subdivide each tile into different depth segments\nEssentially subdividing the view frustum into a 3D grid\n\n复杂度更加减少，但是实现越来越复杂\nLevel of Detail (LoD) Solutions\n    \n    \n\n\nExample\n\nCascaded shadow maps 距离 Camera 越远的地方就可以用越粗糙的 Shadow Map\n范围有一定的重叠，保证切换不同大小的 Shadow Map 有平滑的过度\n\n\nCascaded LPV\nGeometric LoD\nBased on the distance to the camera, choose the right object ot show\nPopping artifacts? Leave it to TAA\nThis is Nanite in UE5 动态的选取 LoD 的实现\n\n\n\nKey Challenge\n\nTransition between different levels 不同层级之间的转换\nUsually need some overlapping and blending near boundaries\n\nGlobal Illumination SolutionsA possible solution to GI may include\n\nSSR for a rough GI approximation\nUpon SSR failure, switching to more complex ray tracing.\nEither hardware(RTRT) or software 或者用硬件做 tracing，或者用软件做 tracing\nSoftware ray tracing\nHQ SDF for individual objects that are closed-by 近处的用高质量的 SDF，SDF 可以让我们快速的在 shader 里面做 tracing\nLQ SDF for the entire scene 远处的用低质量的 SDF\nRSM if there are strong directional / point light 非常强的方向光源或点光源用 RSM\nProbes that stores irradiance in a 3D grid (Dynamic Diffuse GI, DDGI)\n\n\nHardware ray tracing\nDoesn’t have to use the original geometry, but low-poly proxies 用简化了的模型代替原始模型\nProbes (RTXGI)\n\n\n\n\n\nThe hightlighted solutions are mixed to get Lumen in UE5\nA lot of uncovered topics\nTexturing an SDF SDF 贴纹理\nTransparent material and order-independent transparency 透明物体渲染顺序\nParticle rendering\nPost processing (depth of field, motion blur, etc.)\nRandom seed and blue noise 实时渲染中怎么利用随机数种子 蓝噪声\nFoveated rendering\nProbe based global illumination 基于探针的 GI\nReSTIR, Neural Radiance Caching, etc. 更先进的实时渲染技术\nMany-light theory and light cuts\nParticipating media, SSSSS 云烟雾，次表面散射\nHair appearance\n…\n\n\n[1]  类似花瓣的“瓣”，BRDF 是四维的，但是给定观察方向，会反射出来一个类似于“花瓣”的分布 lobe: n. （脑、肺等的）叶；裂片；耳垂；波瓣\n","categories":["图形学"],"tags":["Graphics","GAMES","实时渲染"]},{"title":"现代 C++ 核心特性解析","url":"/2024/07/18/ba744a9761cc/","content":"本书是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++ 11 到 C++ 20 引入的核心特性。书中不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理\n\n\n01 新基础类型  整数类型long long\nlong long至少  表示 64 位的整数\nlong不能比 int 短，所以可以相等\nlong就是 long int，同理long long 就是long long int\n初始化可以添加 l 或L后缀，long long x = 65536LL;\n可以用于枚举类型或位域enum longlong_enum : long long &#123;    x1,    x2&#125;;struct longlong_struct &#123; // 位域可以用来解析协议    long long x1 : 8,    long long x2 : 24,    long long x3 : 32&#125;\n\n\n            long long格式化输出可以使用 %lld、%llu，int 格式化输出可以使用 %d，short 格式化输出可以使用%h，应该是 half 的意思\n          \n\n新字符串类型 char16_t 和char32_t\n分别对应 Unicode 的 UTF-16 和 UTF-32\nUTF-32 编码简单但是占用内存多\n所有字符都映射\n\n\nUTF-16 占用内存少但是不够用\n常用字符做唯一映射\n其余字符采用了一种特殊的方法表示 Unicode 字符\n\n\nUTF-8 一般序列化到磁盘中，不存在内存中\n变长编码\n查找和获取大小比较麻烦\n\n\nwchar_t存在的问题\n在 Windows 上 wchat_t 是 16 位，而在 Linux 和 macOS 上 wchat_t 是 32 位的\n无法保证相同的代码在不同平台上有相同的行为\nchar16_t和 char32_t 解决了这个问题\n\n\nchar8_t字符类型 C++ 20\n使用 char 类型来处理 UTF-8 字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称，以区分普通字符和 UTF-8 字符\nchar8_t可以代替 char 作为 UTF-8 的字符类型\n\n\n\n02 内联和嵌套命名空间C++11 标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了\n#include &lt;iostream&gt;namespace Parent &#123;    namespace Child1 &#123;        void foo() &#123; std::cout &lt;&lt; &quot;Child1: foo()&quot; &lt;&lt; std::endl; &#125;    &#125;    inline namespace Child2 &#123;        void foo() &#123; std::cout &lt; &quot;Child2: foo()&quot;&lt;&lt; std::endl; &#125;    &#125;&#125;int main() &#123;    Parent::Child1::foo();    Parent::foo(); // 兼容老代码，删掉 Child2 命名空间效果是一样的&#125; \n\n\n嵌套命名空间的简化语法 C++ 17\nnamespace A::B::C &#123;    int foo () &#123; return 5; &#125;&#125;\n内联命名空间 C++ 20\nnamespace A::B::inline C &#123;    int foo () &#123; return 5; &#125;&#125;// 或者namespace A::inline B::C &#123;    int foo () &#123; return 5; &#125;&#125;\n\n03 auto占位符\nC++ 98 开始就有了，平常定义的变量都是 auto 的，也可以不写\n\nC++ 11 开始赋予了新的含义\n\n声明多个变量时，从左往右推导，必须一致\n\n条件表达式推导出更强的类型 e.g. auto i = true ? 5 : 8.8 i的类型为double\n\n初始化静态成员变量必须加const C++ 11\nstruct sometype &#123;    static const auto i = 5;&#125;\n\n\nC++ 17 标准中，auto可以在没有 const 的情况下使用 C++ 17\nstruct sometype &#123;    static inline auto i = 5;&#125;\n\n\nC++ 20 之前，无法在函数形参列表中使用 auto 声明形参 e.g. void echo(auto str) &#123; ... &#125;\n\nauto可以为 lambda 表达式声明形参 C++ 14\n\n\n如果 auto 声明的变量时按值初始化，则推导出的类型会忽略 cv 限定符\nconst int i = 5;auto j = i;       // auto 推导类型为 int，而非 const intauto &amp;m = i;      // auto 推导类型为 const int，m 推导类型为 const int&amp;auto *k = &amp;i;     // auto 推导类型为 const int，k 推导类型为 const int*const auto n = j; // auto 推导类型为 int，n 的类型为 const int\n\n\n对于值类型的推导只是值上的关系，没有内存的关联\n但是对于引用或指针涉及到了内存的关联，需要保留 cv 限定符\n\n\n使用 auto 声明变量初始化时，目标对象如果是引用，则引用属性会被忽略\nint i = 5;int &amp;j = i;auto m = j; // auto 推导类型为 int，而非 int&amp;\n使用 auto 和万能引用声明变量时，对于左值会将 auto 推导为应用类型\nint i = 5;auto&amp;&amp; m = i; // auto 推导类型为 int&amp;，这里涉及引用折叠的概念（遇左则左）auto&amp;&amp; j = 5; // auto 推导类型为 int\n使用 auto 声明变量，如果对象目标是一个数组或者函数，则 auto 会被推导为对应的指针类型\n\n当 auto 关键字与列表初始化组合时  C++ 17\n\n直接使用列表初始化，列表中必须为单元素，否则无法编译，auto类型被推导为单元素的类型\n用等号加初始化列表，列表中可以包含单个或多个元素，auto类型别推导为 std::initializer_list&lt;T&gt;，其中T 是元素类型\n\nauto x1 = &#123; 1, 2 &#125;;   // x1 类型为 std::initializer_list&lt;int&gt;auto x2 = &#123; 1, 2.0 &#125;; // 编译失败，花括号中元素类型不同auto x3&#123; 1, 2 &#125;;      // 编译失败，不是单个元素auto x4 = &#123; 3 &#125;;      // x4 类型为 std::initializer_list&lt;int&gt;auto x5&#123; 3 &#125;;         // x5 类型为 int\n\n\n            class Base &#123;public:    virtual void f() &#123;        std::cout &lt;&lt; &quot;Base::f()&quot; &lt;&lt; std::endl;    &#125;&#125;;class Derived : public Base &#123;public:    virtual void f() &#123;        std::cout &lt;&lt; &quot;Derived::f()&quot; &lt;&lt; std::endl;    &#125;&#125;Base* d = new Derived();auto b = *d;b.f();由于 auto b = *d; 是按值赋值的，因此 auto 会直接推导为 Base。代码自然会调用Base 的复制构造函数，也就是说 Derived 被切割（Sliced）成了 Base，如果是auto &amp;b1 = *d 或者 auto *b2 = d 则会触发多态的性质\n          \n\n\n返回类型声明为 auto 的推导 e.g. auto sum(int a, int b) &#123; return a + b; &#125; C++ 14\n\n如果有多重返回值，那么需要保证返回值类型是相同的，否则会编译失败\nauto sum(long a, long b) &#123;    if (a &lt; 0) &#123;        return 0; // 返回 int 类型    &#125;    else &#123;        return a + b; // 返回 long 类型    &#125;&#125;\n\n\n可以把 auto 写到 lambda 表达式的形参中，这样就得到了一个泛型的 lambda 表达式 C++ 14\n\n非类型模板形参占位符 C++ 17\n #include &lt;iostream&gt;template&lt;auto N&gt;void f() &#123;   std::cout &lt;&lt; N &lt;&lt; std::endl;&#125;int main() &#123;   f&lt;5&gt;();   // N 为 int 类型   f&lt;&#x27;c&#x27;&gt;(); // N 为 char 类型   f&lt;5.0&gt;(); // 编译失败，模板参数不能为 double&#125;\n\n04 decltype说明符\n使用 decltype 说明符可以获取对象或者表达式的类型，其语法与 typeof 类似 C++ 11\n\nauto sum(int a1, int a2) -&gt; int &#123;    return a1 + a2;&#125;\n\nC++ 11 标准中，auto作为占位符不能是编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型，如果想泛化这个函数，需要使用到函数模板\ntemplate&lt;class T&gt;T sum(T a1, T a2) &#123;    return a1 + a2;&#125;auto x1 = sum(5, 10);\n\n但是如果传递不同类型的实参，则无法编译通过 e.g. auto x2 = sum(5, 10.5);，只能增加模板类型来解决了\ntemplate&lt;class R, class T1, class T2&gt;R sum(T1 a1, T2 a2) &#123;    return a1 + a2;&#125;auto x3 = sum&lt;double&gt;(5, 10.5);\n\n这时可以使用 decltype 进行优化 C++ 11\ntemplate&lt;class T1, class T2&gt;auto sum(T1 a1, T2 a2) -&gt; decltype(a1 + a2) &#123;    return a1 + a2;&#125;\n\n\n            decltype(a1 + a2)的作用域是这个函数，也就是说表达式里面的变量必须是在函数中的形参  编译阶段进行推导\n          \n\nC++ 14 标准已经支持对 auto 声明的返回类型进行推导了 C++ 14\ntemplate&lt;class T1, class T2&gt;auto sum(T1 a1, T2 a2) &#123; // 直接去掉 decltype 说明符即可    return a1 + a2;&#125;\n\nauto作为返回类型的占位符还存在一些问题\ntemplate&lt;class T&gt;auto return_ref(T&amp; t) &#123;    return t;&#125;int x1 = 0;static_assert(std::is_reference_v&lt;decltype(return_ref(x1))&gt;); // 编译错误，返回值不为引用类型\n\n这里 auto 被推导为值类型，参考 auto 占位符规则，如果想正确地返回引用类型，则需要使用 decltype 说明符\ntemplate&lt;class T&gt;auto return_ref(T&amp; t) -&gt; decltype(t) &#123;    return t;&#125;int x1 = 0;static_assert(std::is_reference_v&lt;decltype(return_ref(x1))&gt;); // 编译成功\n\n\n推导规则 decltype(e)，e的类型为T\n\n如果 e 是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则 decltype(e) 推断出的类型是 e 的类型 T。如果并不存在这样的类型，或者e 是一组重载函数，则无法进行推导 没有候选或者候选太多\n如果加上括号则推断出的是引用类型\n\n\n如果 e 是一个函数调用或者仿函数调用，那么 decltype(e) 推断出的类型是其返回值的类型\n如果 e 是一个类型为 T 的左值，则 decltype(e) 是T&amp;\n如果 e 是一个类型为 T 的将亡值，则 decltype(e) 是T&amp;&amp;\n除去以上情况，则 decltype(e) 是T\n\n\ncv 限定符的推导\n\n通常情况下，decltype(e)所推导的类型会同步 e 的 cv 限定符\n\n当 e 是未加括号的成员变量时，父对象表达式的 cv 限定符会被忽略，不能同步推导结果，只有加括号时 cv 限定符会同步到推断结果\nstruct A &#123;    double x;&#125;const A* a = new A();decltype(a-&gt;x); //  decltype(a-&gt;x) 推导类型为 double，const 属性被忽略\n\n\ndecltype(auto) C++ 14\n\n告诉编译器用 decltype 推导表达式规则来推导auto\ndecltype(auto)必须单独声明，不能结合指针、引用以及 cv 限定符\n\nint i;int&amp;&amp; f();auto x1a = i;                     // x1a 推导类型为 intdecltype(auto) x1d = i;           // x1d 推导类型为 intauto x2a = (i);                   // x2a 推导类型为 intdecltype(auto) x2d = (i);         // x2d 推导类型为 int&amp;auto x3a = f();                   // x3a 推导类型为 intdecltype(auto) x3d = f();         // x3d 推导类型为 int&amp;&amp;auto x4a = &#123; 1, 2 &#125;;              // x 推导类型为 std::initializer_list&lt;int&gt;decltype(auto) x4d = &#123; 1, 2 &#125;;    // 编译失败，&#123; 1, 2 &#125; 不是表达式auto *x5a = &amp;i;                   // x5a 推导类型为 int*decltype(auto) *x5d = &amp;i;         // x 编译失败，decltype(auto) 必须单独声明\n\n\nauto和 decltype(auto) 的用法几乎相同，只是在推导规则上遵循 decltype 而已\n\n之前代码 return_ref 想返回一个引用类型，但是如果直接使用 auto，则一定会返回一个值类型，解决方案是采用后置的方式声明返回类型，现在可以通过decltype(auto) 也可以解决\ntemplate&lt;class T&gt;decltype(auto) return_ref(T&amp; t) &#123;    return t;&#125;int x1 = 0;static_assert(std::is_reference_v&lt;decltype(return_ref(x1))&gt;); // 编译成功\ndecltype(auto)作为非理性模板形参占位符\n\n\n#include &lt;iostream&gt; template&lt;decltype(auto) N&gt; void f() &#123;    std::cout &lt;&lt; N &lt;&lt; std::endl; &#125; static const int x = 11; static int y = 7; int main() &#123;    f&lt;x&gt;();   // N 为 const int 类型    f&lt;(x)&gt;(); // N 为 const int&amp; 类型    f&lt;y&gt;();   // 编译失败，因为 y 不是一个常量，编译器无法对函数模板进行实例化    f&lt;(y)&gt;(); // N 为 int&amp; 类型，恰好对于静态对象而言内存地址时固定的，所以可以通过编译 &#125;\n\n05 函数返回类型后置 C++ 11\n返回类型比较复杂的是时候，比如返回一个函数指针类型，使用返回类型后置\nint bar_impl(int x) &#123;    return x;&#125;typedef int(*bar)(int);bar foo1() &#123;    return bar_impl;&#125;auto foo2() -&gt; int (*)(int) &#123;    return bar_impl;&#125;\n\n有了返回类型后置，返回类型就可以用 auto 占位符，再后置函数指针类型，不需要写typedef\n\n推导函数模板返回类型\n\n\n06 右值引用  左值和右值\ni++：先把 i 的值取出来存到临时变量中，再把 i 加一，最后返回的是临时变量的值，属于右值（将亡值）\n++i：自增后将自己返回，属于左值\n但凡能取地址&amp;，就是左值\n通常字面量都是一个右值，除了字符串字面量以外\n字符串是一块连续的内存，通常存在静态数据去里面\n\n\n\n左值引用\n            指针最危险的地方在于可以运算C++ 是弱类型语言，类型之前可以随意转换\n          \n\nint &amp;x1 = 7; // 编译错误const int &amp;x2 = 11; // 编译成功\n\n\n非常量左值的引用对象必须是一个左值\n引用一块内存首先要有一块内存，如果引用右值，内存都不知道在哪，肯定就有问题了\n\n\n常量左值引用的对象可以是左值，也可以是右值\n在函数形参列表中有着很大的作用\n\nclass X &#123;public:    X() &#123;&#125;    X(const X&amp;) &#123;&#125;    X&amp; operator = (const X&amp;) &#123; return *this; &#125;&#125;;X make_X() &#123;    return X();&#125;int main() &#123;    X x1;    X x2;    X x3(make_X());    x3 = make_X();&#125;\n\n\n如果将类 X 的复制构造函数和复制赋值构造函数形参类型的常量性删除，则 X x3(make_X()); 和x3 = make_X();会报错，因为非常量左值引用无法绑定到右值上\n缺点是一旦使用了常量左值应用，就无法在函数内部修改该对象的内容\n\n\n            X make_X() &#123;    return X(); &#125;C++ 17 之后编译器有做拷贝优化，虽然返回值是右值，函数返回类型是左值，因为做了拷贝优化所以不会报错\n          \n\n右值引用\n右值引用可以延长右值的声明周期\n右值引用可以减少对象复制，提升程序性能\n\n#include &lt;iostream&gt;class BigMemoryPool &#123;public:    static const int PoolSize = 4096;    BigMemoryPool() : pool_(new char[PoolSize]) &#123;&#125;    ~BigMemoryPool()    &#123;        if (pool_ != nullptr) &#123;            delete[] pool_;        &#125;    &#125;    // 移动构造器    BigMemoryPool(BigMemoryPool&amp;&amp; other)    &#123;        std::cout &lt;&lt; &quot;move big memory pool.&quot; &lt;&lt; std::endl;        pool_ = other.pool_;        other.pool_ = nullptr;    &#125;    // 复制构造器    BigMemoryPool(const BigMemoryPool&amp; other) : pool_(new char[PoolSize])    &#123;        std::cout &lt;&lt; &quot;copy big memory pool.&quot; &lt;&lt; std::endl;        memcpy(pool_, other.pool_, PoolSize);    &#125;private:    char *pool_;&#125;;BigMemoryPool get_pool(const BigMemoryPool&amp; pool)&#123;    return pool;&#125;BigMemoryPool make_pool()&#123;    BigMemoryPool pool;    return get_pool(pool);&#125;int main()&#123;    BigMemoryPool my_pool = make_pool();&#125;\n\n\n调用复制构造函数会严重影响运行性能\n对于复制构造函数而言形参是一个左值引用，函数的实参必须是一个具名的左值，不能破坏实参对象的前提下复制目标对象\n移动构造函数接受的是一个右值，通过转移实参对象的数据以达成构造目标对象的目的，也就是说实参对象是会被修改的\n传过来的参数用过之后就没有用了\n\n\n编译器生成的移动构造函数和复制构造函数并没有什么区别\n编写移动语义的函数时建议确保函数不会抛出异常\n如果无法保证移动构造函数不会抛出异常，可以使用 noexcept 说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用 std::terminate 中止执行\n\n值类别\n\n\n左值和右值实际上指的是表达式，表达式的结果就是值\n\n将亡值产生\n\n使用类型转换将泛左值转换为该类型的右值引用\n\n临时量实质化 C++ 17\nstruct X &#123;    int a;&#125;;int main() &#123;    int b = X().a;&#125;\n\n\n纯右值转换到临时对象的过程\n每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生——创建一个临时对象并且使用纯右值对其进行初始化\n只要返回的是纯右值就不会调用类的构造函数了\n\n\n\n\n在 C++11 标准中可以在不创建临时值的情况下显式地将左值通过 static_cast 转换为将亡值\nint i = 0;int &amp;&amp;k = static_cast&lt;int&amp;&amp;&gt;(i);\n这个转换既不改变生命周期也不改变内存地址，最大作用是让左值使用移动语义\n\n正确的使用场景是在一个右值被转换为左值后需要再次转换为右值\n\n\nvoid move_pool(BigMemoryPool &amp;&amp;pool)&#123;    std::cout &lt;&lt; &quot;call move_pool&quot; &lt;&lt; std::endl;    BigMemoryPool my_pool(pool);&#125;int main()&#123;    move_pool(make_pool());&#125;\n\n\n无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用\nBigMemoryPool my_pool(pool); 还是会调用复制构造函数而非移动构造函数\nBigMemoryPool my_pool(static_cast&lt;BigMemoryPool&amp;&amp;&gt;(pool));则会调用移动构造函数进行构造\n在 C++ 11 的标准库中还提供了一个函数模板 std::move 将左值转换为右值 e.g. BigMemoryPool my_pool(std::move(pool));\n\n万能引用和引用折叠void foo(int &amp;&amp;i) &#123;&#125; // i 为右值引用template&lt;class T&gt;void bar(T &amp;&amp;t) &#123;&#125; // t 为万能引用\n\n\n&amp;&amp;i就是定义出来具体的参数，字面意思\n而模板有实例化的过程，所以就是万能引用\n所谓的万能引用就是发生类型推导\n\n\n\n\n模板类型\nT实际类型\n最终类型\n\n\n\nT&amp;\nR\nR&amp;\n\n\nT&amp;\nR&amp;\nR&amp;\n\n\nT&amp;\nR&amp;&amp;\nR&amp;\n\n\nT&amp;&amp;\nR\nR&amp;&amp;\n\n\nT&amp;&amp;\nR&amp;\nR&amp;\n\n\n\n            “遇左则左”只要有左值引用参与进来，最后推导的结果就是一个左值引用  只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用\n          \n\n#include &lt;iostream&gt;#include &lt;string&gt;template&lt;class T&gt;void show_type(T t)&#123;    std::cout &lt;&lt; typeid(t).name() &lt;&lt; std::endl;&#125;template&lt;class T&gt;void normal_forwarding(T t)&#123;    show_type(t);&#125;std::string get_string()&#123;    return &quot;hi world&quot;;&#125;int main()&#123;    std::string s = &quot;hello world&quot;;    normal_forwarding(s);    normal_forwarding(get_string()); // 编译失败&#125;\n\n\nnormal_forwarding(get_string());因为 normal_forwarding 接受的是左值，而传入的是右值\n\n可以将 void normal_forwarding(T &amp;t) 替换为 void normal_forwarding (const T &amp;t) 来解决这个问题\n\n常量左值引用是可以引用右值的\n但是不能修改传入进来的数据了\n\n\n可以用引用折叠规则来处理\ntemplate&lt;class T&gt;void perfect_forwarding(T &amp;&amp;t)&#123;    show_type(static_cast&lt;T&amp;&amp;&gt;(t));&#125;\n在 C++ 11 的标准库中提供了一个 std::forward 函数模板，在函数内部也是使用 static_cast 进行类型转换\n\n\nremove_reference移除引用，根据不同的类型去匹配\ntemplate &lt;class _Ty&gt;struct remove_reference &#123;    using type                 = _Ty;    using _Const_thru_ref_type = const _Ty;&#125;;template &lt;class _Ty&gt;struct remove_reference&lt;_Ty&amp;&gt; &#123;    using type                 = _Ty;    using _Const_thru_ref_type = const _Ty&amp;;&#125;;template &lt;class _Ty&gt;struct remove_reference&lt;_Ty&amp;&amp;&gt; &#123;    using type                 = _Ty;    using _Const_thru_ref_type = const _Ty&amp;&amp;;&#125;;\n\nstd::forward\ntemplate &lt;class _Ty&gt;constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept &#123;    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);&#125;\n\nstd::move\ntemplate &lt;class _Ty&gt;constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept &#123;    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);&#125;\n\n针对局部变量和右值引用的隐式移动操作#include &lt;iostream&gt;struct X &#123;    X() = default;    X(const X&amp;) &#123;        std::cout &lt;&lt; &quot;copy ctor&quot; &lt;&lt; std::endl;    &#125;    X(X&amp;&amp;) &#123;        std::cout &lt;&lt; &quot;move ctor&quot; &lt;&lt; std::endl;    &#125;&#125;;X get(X x) &#123;    return x;&#125;int main() &#123;    X x = get(X&#123;&#125;);&#125;\n\n\n            -fno-elide-constructors选项用于关闭返回值优化，才会出现三次输出\n          \n\n\n如果没有移动构造函数，则会调用三次复制构造函数\n如果定义了移动构造函数，会隐式地采用移动构造函数，调用三次移动构造函数\n隐式移动操作针对右值引用和 throw 的情况进行了扩展 C++ 20\n可隐式移动的对象必须是一个非易失或一个右值引用的非易失自动存储对象，在以下情况下可以使用移动代替复制\nreturn或者 co_return 语句中的返回对象是函数或者 lambda 表达式中的对象或形参\nthrow 语  句中抛出的对象是函数或 try 代码块中的对象\n\n\n\n小结  对于这些优化空间，C++ 委员会已经对标准库进行了优化，比如常用的容器 vector、list 和map等均已支持移动构造函数和移动赋值运算符函数。另外，如 make_pair、make_tuple 以及 make_shared 等也都使用完美转发以提高程序的性能\n07 lambda 表达式\n语法定义：[captures](params) specifiers exception -&gt; ret {body}\n\n[captures]在大部分其他语言是不存在的，因为诸如 Java、C# 等语言是有 GC 机制的，不需要担心捕获对象的声明周期的问题\n[captures] —— 捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。捕获列表的捕获方式有两种：按值捕获和引用捕获\n(params) —— 可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表\nspecifiers —— 可选限定符，C++11 中可以用 mutable，它允许在 lambda 表达式函数体内改变按值捕获的变量，或者调用非const 的成员函数\nexception —— 可选异常说明符，可以使用 noexcept 来指明 lambda 是否会抛出异常\n-&gt; ret —— 可选返回值类型，不同于普通函数，lambda 表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（void类型），可以忽略包括 -&gt; 在内的整个部分\n&#123; body &#125; —— lambda 表达式的函数体，这个部分和普通函数的函数体一样\n\n\n不允许捕获全局变量和静态变量，因为可以直接使用\n\nlambda 表达式按值捕获每次调用都会保留上一次修改的值，具体参考 lambda 表达式实现原理\n\n特殊的捕获方法\n\n[this] —— 捕获 this 指针，捕获 this 指针可以使用 this 类型的成员变量和函数\n[=] —— 捕获 lambda 表达式定义作用域的全部变量的值，包括this\n[&amp;] —— 捕获 lambda 表达式定义作用域的全部变量的引用，包括this\n\n\nlambda 表达式的优势在于书写简单方便且易于维护\n\n函数对象的优势在于使用更加灵活不受限制\n\nlambda 表达式实现原理\n#include &lt;iostream&gt;int main()&#123;    int x = 5, y = 8;    auto foo = [=] &#123; return x * y; &#125;;    int z = foo();&#125;\n\n用 CppInsights 输出其 GIMPLE 的中间代码\n#include &lt;iostream&gt;int main()&#123;    int x = 5;    int y = 8;        class __lambda_5_16    &#123;    public:         inline /*constexpr */ int operator()() const        &#123;            return x * y;        &#125;            private:         int x;        int y;            public:        __lambda_5_16(int &amp; _x, int &amp; _y): x&#123;_x&#125;, y&#123;_y&#125; &#123;&#125;    &#125;;    __lambda_5_16 foo = __lambda_5_16&#123;x, y&#125;;    int z = foo.operator()();    return 0;&#125;\n\n\nlambda 表达式在编译期会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，称为闭包。在 C++ 中，所谓的闭包可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象\nlambda 表达式是 C++11 提供的一块语法糖而已，lambda 表达式的功能完全能够手动实现，而且如果实现合理，代码在运行效率上也不会有差距，只不过实用 lambda 表达式让代码编写更加轻松了\n\n\n无状态的 lambda 表达式\n\n有状态会在匿名类中定义按值捕获的变量，从而在每次调用的时候都会保持变量上一次的状态\n\n如果是无状态的 lambda 表达式，可以隐式转换为函数指针\nvoid f(void(*)()) &#123;&#125;void g() &#123; f([] &#123;&#125;); &#125; // 编译成功\n尽量让 lambda 表达式“纯粹”一些，不捕获外部变量\n\n\n\n在 STL 中使用 lambda 表达式\n\nstd::sort、std::find_if\n\n\n广义捕获 C++ 14\n\n简单捕获\n\n初始化捕获\n\n捕获表达式结果\n自定义捕获变量名\n\nint main() &#123;    int x = 5;    auto foo1 = [x = x + 1] &#123; return x; &#125;; // 两个 x 的作用域不一样    auto foo2 = [r = x + 1] &#123; return r; &#125;; // 推荐的写法&#125;\n\n#include &lt;string&gt;int main()&#123;    std::string x = &quot;hello c++ &quot;;    auto foo = [x = std::move(x)]&#123; return x + &quot;world&quot;; &#125;;&#125;\n\n\n使用 std::move 对捕获列表变量 x 进行初始化，这样避免了简单捕获的复制对象操作\n\n\n异步调用时复制 this 对象，防止 lambda 表达式被调用时因原始 this 对象被析构造成未定义的行为\n#include &lt;iostream&gt;#include &lt;future&gt;class Work &#123;private:    int value;public:    Work() : value(42) &#123;&#125;    std::future&lt;int&gt; spawn() &#123;        return std::async([=]() -&gt; int &#123; return value; &#125;);    &#125;&#125;;std::future&lt;int&gt; foo() &#123;    Work tmp;    return tmp.spawn();&#125;int main() &#123;    std::future&lt;int&gt; f = foo();    f.wait();    std::cout &lt;&lt; &quot;f.get() = &quot; &lt;&lt; f.get() &lt;&lt; std::endl;&#125;\n\n\n            输出结果 f.get() = 32766f.wait() 调用之后，访问 value 这块内存的时候已经是未知的状态\n          \n\n解决方法就是可以将对象复制到 lambda 表达式内\nclass Work &#123;private:    int value;public:    Work() : value(42) &#123;&#125;    std::future&lt;int&gt; spawn() &#123;        return std::async([=, tmp = *this]() -&gt; int &#123; return tmp.value; &#125;);    &#125;&#125;;\n\n\n            这种方式也不能解决所有问题，一个技术手段是不能解决所有问题的，需要在合适的场景下提出不同的解决方案\n          \n\n\n泛型 lambda 表达式 C++ 14\n\n定义方式不用 template 关键字，只需要使用 auto 占位符即可\n\nint main()&#123;    auto foo = [](auto a) &#123; return a; &#125;;    int three = foo(3);    char const* hello = foo(&quot;hello&quot;);&#125;\n常量 lambda 表达式 C++ 17\n\n捕获 *this 增强 C++ 17\n\n不需要额外定义变量初始化捕获列表，直接使用 *this 就是一份拷贝\n\n\n捕获[=, this] C++ 20\n\n表达的意思和 [=] 相同，目的区分它与 [=,*this] 的不同\nC++ 20 标准中还特别强调了要用 [=, this] 代替[=]\n希望捕获 this 时，把 this 写出来\n\n\n\ntemplate &lt;typename T&gt;struct is_std_vector : std::false_type &#123; &#125;;template &lt;typename T&gt;struct is_std_vector&lt;std::vector&lt;T&gt;&gt; : std::true_type &#123; &#125;;auto f = [](auto vector) &#123;    static_assert(is_std_vector&lt;decltype(vector)&gt;::value, &quot;&quot;);&#125;;f(1); // 静态断言失败，需要传入 vector&lt;T&gt; 类型auto v = std::vector&lt;int&gt;();f(v); // 正确\n\n\n普通的函数模板可以轻松地通过形参模式匹配一个实参为 vector 的容器对象，但是对于 lambda 表达式，auto不具备这种表达能力，所以不得不实现 is_std_vector，并且通过static_assert 来辅助判断实参的真实类型是否为vector\n\n如果用 lambda 表达式想获取 vector 里面的 T 的类型就会更复杂\nauto f = [] (auto vector) &#123;    using T = typename decltype(vector)::value_type;    // ...&#125;\n\n\nvector容器类型会使用内嵌类型 value_type 表示存储对象的类型\n不能保证面对的所有容器都会实现这一规则，所以依赖内嵌类型是不可靠的\n\n\n还有一个问题是 decltype(obj) 有时候并不能直接获取想要的类型\nauto f = [](const auto&amp; x) &#123;    using T = decltype(x);    T copy = x; // 可以编译，但是语义错误    using Iterator = typename T::iterator; // 编译错误&#125;;\n\n\ndecltype(x)推导出来的类型并不是 std::vector，而是const std::vector &amp;，所以T copy = x; 不是一个复制而是引用\n\n对于一个引用类型来说，T::iterator也是不符合语法的，所以编译出错\n\n可以将类型的 cv 以及引用属性删除\nauto f = [](const auto&amp; x) &#123;    using T = std::decay_t&lt;decltype(x)&gt;;    T copy = x;    using Iterator = typename T::iterator;&#125;;\n\n\n模板语法的泛型 lambda 表达式 C++ 20\n\n[]&lt;template T&gt;(T t) &#123;&#125;\n\n\n可构造和可赋值的无状态 lambda 表达式 C++ 20\n\nstd::sort和 std::find_if 这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况可以使用 lambda 表达式完成任务\n\nstd::map的比较函数对象是通过模板参数确定的，这个时候需要的是一个类型\nauto greater = [](auto x, auto y) &#123; return x &gt; y; &#125;;std::map&lt;std::string, int, decltype(greater)&gt; mymap; // 需要的是类型所以用 `decltype`\n\n\n            但是在 C++ 17 标准中是不可行的，因为 lambda 表达式类型无法构造，lambda 表达式的默认构造函数已经被删除了  无状态的 lambda 表达式也没办法赋值，原因是复制赋值函数被删除了  使用 C++ 20 标准的编译环境来编译上面的代码是可行的\n          \n\n\n\n08 非静态数据成员默认初始化\n声明非静态数据成员的同时直接对其使用 = 或者 &#123;&#125; 初始化 C++ 11\n\n在此之前只有类型为整型或者枚举类型的常量静态数据成员才可以这样初始化\n\n初始化列表对数据成员的初始化总是优先于声明时默认初始化\n\n不要使用括号 () 对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误\n\n不要用 auto 来声明和初始化非静态数据成员\n\n位域的默认初始化 C++ 20\nstruct S &#123;    int y : 8 = 11;    int z : 4 = &#123; 7 &#125;;&#125;\n\nint数据的低 8 位被初始化为 11，紧跟它的高 4 位被初始化为 7\n\n\n09 列表初始化\n列表初始化，使用大括号 &#123;&#125; 对变量进行初始化 C++ 11\n传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化\n\n#include &lt;string&gt;struct C &#123;    C(std::string a, int b) &#123;&#125;    C(int a) &#123;&#125;&#125;;void foo(C) &#123;&#125;C bar() &#123;    return &#123;&quot;world&quot;, 5&#125;;&#125;int main() &#123;    int x = &#123;5&#125;;                // 拷贝初始化    int x1&#123;8&#125;;                  // 直接初始化    C x2 = &#123;4&#125;;                 // 拷贝初始化    C x3&#123;2&#125;;                    // 直接初始化    foo(&#123;8&#125;);                   // 拷贝初始化    foo(&#123;&quot;hello&quot;, 8&#125;);          // 拷贝初始化    C x4 = bar();               // 拷贝初始化    C *x5 = new C&#123; &quot;hi&quot;, 42 &#125;;  // 直接初始化&#125;\n\n\nstd::initializer_list简单地说就是一个支持 begin、end 以及 size 成员函数的类模板\n\n实际上是一块连续的内存，也就是数组\n\n\n隐式缩窄转换问题\nint x = 12345;char y = x; // 将超过 char 大小的数据赋值给 char，明显是一个隐式缩窄转换\n\n\n传统变量初始化中是没有问题的，代码能顺利通过编译\n如果采用列表初始化，根据标准编译器通常会给出一个错误\n隐式缩窄转换发生的情况 表示范围大的类型向表示范围小的类型转换就发生了缩窄\n从浮点类型转换整数类型\n从 long double 转换到 double 或float，或从 double 转换到float，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内\n从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值\n从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型\n\n\n\nint x = 999;const int y = 999;const int z = 99;const double cdb = 99.9;double db = 99.9;char c1 = x; // 编译成功，传统变量初始化支持隐式缩窄转换char c2&#123; x &#125;; // 编译失败，可能是隐式缩窄转换，对应规则 4char c3&#123; y &#125;; // 编译失败，确定是隐式缩窄转换，999 超出 char 能够适应的范围，对应规则 4char c4&#123; z &#125;; // 编译成功，99 在 char 能够适应的范围内，对应规则 4unsigned char uc1 = &#123; 5 &#125;; // 编译成功，5 在 unsigned char 能够适应的范围内，// 对应规则 4unsigned char uc2 = &#123; -1 &#125;; // 编译失败，unsigned char 不能够适应负数，对应规则 4unsigned int ui1 = &#123; -1 &#125;; // 编译失败，unsigned int 不能够适应负数，对应规则 4signed int si1 = &#123; (unsigned int)-1 &#125;; // 编译失败，signed int 不能够适应 -1 所对应的//unsigned int，通常是 4294967295，对应规则 4int ii = &#123; 2.0 &#125;; // 编译失败，int 不能适应浮点范围，对应规则 1float f1&#123; x &#125;; // 编译失败，float 可能无法适应整数或者互相转换，对应规则 3float f2&#123; 7 &#125;; // 编译成功，7 能够适应 float，且 float 也能转换回整数 7，对应规则 3float f3&#123; cdb &#125;; // 编译成功，99.9 能适应 float，对应规则 2float f4&#123; db &#125;; // 编译失败，可能是隐式缩窄转无法表达 double，对应规则 2\n如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以 std::initializer_list 为参数，那么编译器将优先以 std::initializer_list 为参数构造函数\n\n指定初始化 C++ 20\nstruct Point &#123;    int x;    int y;    int z;&#125;;Point p&#123; .x = 4, .y = 2 &#125;; // z = 0\n\n\n并不是什么对象都能够指定初始化\n\n对象必须是一个聚合类型\n\n指定的数据成员必须是非静态数据成员 静态数据成员不属于某个对象\n\n每个非静态数据成员最多只能初始化一次\nPoint p&#123; .y = 4, .y = 2 &#125;; // 编译失败，y 不能初始化多次\n非静态数据成员的初始化必须按照声明的顺序进行\n\n在 C 语言中，乱序的指定初始化是合法的，但 C++ 不行\nC++ 中的数据成员会按照声明的顺序构造，按照顺序指定初始化会让代码更容易阅读\n\nPoint p&#123; .y = 4, .x = 2 &#125;; // C++ 编译失败，C 编译正常\n针对联合体中的数据成员只能初始化一次，不能同时指定\nunion u &#123;    int a;    const char* b;&#125;;u f = &#123; .a = 1 &#125;; // 编译成功u g = &#123; .b = &quot;a&quot; &#125;; // 编译成功u h = &#123; .a = 1, .b = &quot;a&quot; &#125;; // 编译失败，同时指定初始化联合体中的多个数据成员\n不能嵌套指定初始化数据成员\n\nC 语言中也是允许的\nC++ 标准认为这个特性很少有用，所以直接禁止了\n\nstruct Line &#123;    Point a;    Point b;&#125;;Line l&#123; .a.y = 5 &#125;; // 编译失败，.a.y = 5 访问了嵌套成员，不符合 C++ 标准\n\n\n如果确实想嵌套指定初始化，可以换一种形式来达到目的\nLine l&#123; .a &#123; .y = 5 &#125; &#125;;\n\n\n一旦使用指定初始化，就不能混用其他方法对数据成员初始化了\nPoint p&#123; .x = 2, 3 &#125;; // 编译失败，混用数据成员的初始化\n指定初始化不能初始化数组的某一位置 C++ 标准中给出的禁止理由非常简单，它的语法和 lambda 表达式冲突了\nint arr[3] = &#123; [1] = 5 &#125;; // 编译失败\n\n\n\n\n\n10 默认和删除函数\n在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数\n默认构造函数\n析构函数\n复制构造函数\n复制赋值运算符函数\n移动构造函数 C++ 11\n移动赋值运算符函数 C++ 11\n\n\n添加默认特殊成员函数也会带来一些问题\n声明任何构造函数都会抑制默认构造函数的添加 显示的定义了非默认构造函数，编译器不再为类提供默认构造函数\n一旦用自定义构造函数代替默认构造函数，类就将转变为  非平凡类型\n如果自定义了构造函数（即使是默认构造函数），有可能编译器只能看到声明，看不到实现，就没办法做一些优化处理了\n平凡类型可以想象为 C 的结构体\n\n\n没有明确的办法彻底禁止特殊成员函数的生成  C++ 11 之前\n\n\n\n禁止重载函数的某些版本\nclass Base &#123;    void foo(long &amp;); // 访问属性设置为 private，目的不想让其被重载public:    void foo(int) &#123;&#125;&#125;;class Derived : public Base &#123;public:    using Base::foo; // 将父类中所有 `foo` 函数全部导入    void foo(const char *) &#123;&#125;&#125;;int main()&#123;    Derived d;    d.foo(&quot;hello&quot;);    d.foo(5);&#125;\n\n\n无法通过编译。因为 using 说明符无法将基类的私有成员函数引入子类当中\nC++ 11 标准提供了一种方法能够简单有效又精确地控制默认特殊成员函数的添加和删除\n在声明函数的尾部添加 = default 和= delete\n相对于使用 private 限制函数访问，使用 = delete 更加彻底，它从编译层面上抑制了函数的生成，所以无论调用者是什么身份（包括类的成员函数），都无法调用被删除的函数\n显式删除不仅适用于类的成员函数，对于普通函数同样有效 应用于普通函数的意义就不大了\n显式删除还可以用于类的 new 运算符和类析构函数\n作用于 new 运算符可以阻止该类在堆上动态创建对象\n\n\n在类的构造函数上同时使用 explicit 和= delete是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做\n\n11 非受限联合类型\nC++ 中的联合类型（union）可以说是节约内存的一个典型代表\n在联合类型中多个对象可以共享一片内存，相应的这片内存也只能由一个对象使用\n过去的 C++ 标准规定，联合类型的成员变量的类型不能是一个非平凡类型，也就是说它的成员类型不能有自定义构造函数\n在 C++11 中如果有联合类型中存在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说必须至少提供联合类型的构造和析构函数\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;union U &#123;    U() &#123;&#125; // 存在非平凡类型成员，必须提供构造函数    ~U() &#123;&#125; // 存在非平凡类型成员，必须提供析构函数    int x1;    float x2;    std::string x3;    std::vector&lt;int&gt; x4;&#125;;int main() &#123;    U u;    u.x3 = &quot;hello world&quot;; // 因为非平凡类型 x3 并没有被构造，所以在赋值操作的时候必然会出错    std::cout &lt;&lt; u.x3;&#125;\n\n修改后\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;union U &#123;    U() : x3() &#123;&#125;    ~U() &#123; x3.~basic_string(); &#125;    int x1;    float x2;    std::string x3;    std::vector&lt;int&gt; x4;&#125;;int main() &#123;    U u;    u.x3 = &quot;hello world&quot;;    std::cout &lt;&lt; u.x3;&#125;\n\n\n在构造函数中添加了初始化列表来构造 x3，在析构函数中手动调用了x3 的析构函数\n联合类型在析构的时候编译器并不知道当前激活的是哪个成员，所以无法自动调用成员的析构函数\n但是如果初始化 x4 又会出现问题，所以继续修改代码\n\n#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;union U &#123;    U() &#123;&#125;    ~U() &#123;&#125;    int x1;    float x2;    std::string x3;    std::vector&lt;int&gt; x4;&#125;;int main() &#123;    U u;    new(&amp;u.x3) std::string(&quot;hello world&quot;);    std::cout &lt;&lt; u.x3 &lt;&lt; std::endl;    u.x3.~basic_string();    new(&amp;u.x4) std::vector&lt;int&gt;;    u.x4.push_back(58);    std::cout &lt;&lt; u.x4[0] &lt;&lt; std::endl;    u.x4.~vector();&#125;\n\n\n上面的代码用了 placement new 的技巧来初始化构造 x3 和x4对象\n\n在使用完对象后手动调用对象的析构函数\n\n通过这样的方法保证了联合类型使用的灵活性和正确性\n\n联合类型其实就是 C 语言的遗产\n\n可以使用 std::variant 来代替联合类型 C++ 17\n\n是  类型安全  的联合类型\n\n#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;variant&gt; int main()&#123;    std::variant&lt;int, float&gt; v, w;    v = 42; // v contains int    int i = std::get&lt;int&gt;(v);    assert(42 == i); // succeeds    w = std::get&lt;int&gt;(v);    w = std::get&lt;0&gt;(v); // same effect as the previous line    w = v; // same effect as the previous line     // std::get&lt;double&gt;(v); // error: no double in [int, float]    // std::get&lt;3&gt;(v);      // error: valid index values are 0 and 1     // 类型安全就是可以抛出异常并且捕获    try    &#123;        std::get&lt;float&gt;(w); // w contains int, not float: will throw    &#125;    catch (const std::bad_variant_access&amp; ex)    &#123;        std::cout &lt;&lt; ex.what() &lt;&lt; &#x27;\\n&#x27;;    &#125;     using namespace std::literals;     std::variant&lt;std::string&gt; x(&quot;abc&quot;);    // converting constructors work when unambiguous    x = &quot;def&quot;; // converting assignment also works when unambiguous     std::variant&lt;std::string, void const*&gt; y(&quot;abc&quot;);    // casts to void const* when passed a char const*    assert(std::holds_alternative&lt;void const*&gt;(y)); // succeeds    y = &quot;xyz&quot;s;    assert(std::holds_alternative&lt;std::string&gt;(y)); // succeeds&#125;\n\n12 委托构造函数class X &#123;public:    X() : a_(0), b_(0.) &#123; CommonInit(); &#125;    X(int a) : a_(a), b_(0.) &#123; CommonInit(); &#125;    X(double b) : a_(0), b_(b) &#123; CommonInit(); &#125;    X(int a, double b) : a_(a), b_(b) &#123; CommonInit(); &#125;private:    void CommonInit() &#123;&#125;    int a_;    double b_;&#125;;\n\n\n构造函数构造对象时，确保构造路径只有一条，否则如果漏改了某些构造函数会出现问题\n大量重复代码\n所有的构造函数都依赖同一个初始函数\n\n如果成员初始化都在 CommonInit 里面也会有其他问题\nclass Y &#123;    Y operator= (Y) = delete;&#125;class X &#123;public:    X() &#123; CommonInit(0, 0); &#125;    X(int a) &#123; CommonInit(a, 0); &#125;    X(double b) &#123; CommonInit(0, b); &#125;    X(int a, double b) &#123; CommonInit(a, b); &#125;private:    void CommonInit(int a, double b) &#123;        a_ = a;        b_ = b;        c_ = &quot;hello world&quot;;        y_ = Y(); // 赋值构造函数被 delete 了，编译报错    &#125;    int a_;    double b_;    std::string c_;    Y y_;&#125;;\n\n\nc_并不是初始化，而是赋值操作\n\n对象的初始化在构造函数主题执行之前，也就是初始化列表阶段就已经执行了\n用 CommonInit“初始化”c_ 其实对其进行了两次操作：一次初始化，另一次的赋值\n\n\n有些情况时不能使用函数主体对成员对象进行赋值的\n\n禁用了赋值运算符的数据成员 e.g. class Y\n\n\n委托构造函数 C++ 11\n\n某个类型的一个构造函数可以委托同类型的另一个构造函数对对象惊醒初始化\n前者为委托构造函数\n后者为代理构造函数\n委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完成之后，再执行委托构造函数的主体\n路径是唯一了\n\n\n\nclass X&#123;public:    X() : X(0, 0.) &#123;&#125;    X(int a) : X(a, 0.) &#123;&#125;    X(double b) : X(0, b) &#123;&#125;    X(int a, double b) : a_(a), b_(b) &#123; CommonInit(); &#125;private:    void CommonInit() &#123;&#125;    int a_;    double b_;&#125;;\n\n\nNote\n\n每个构造函数都可以委托另一个构造函数为代理\n\n不要递归循环委托\n\n最好的习惯就是指定一个  主构造函数，其他构造函数都委托到这个主构造函数\n就一个负重前行就可以了，不用折腾别的构造函数了\n\n\n如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化\nclass X&#123;public:    X() : a_(0), b_(0) &#123; CommonInit(); &#125;    X(int a) : X(), a_(a) &#123;&#125; // 编译错误，委托构造函数不能在初始化列表初始化成员变量    X(double b) : X(), b_(b) &#123;&#125;// 编译错误，委托构造函数不能在初始化列表初始化成员变量private:    void CommonInit() &#123;&#125;    int a_;    double b_;&#125;;\n\n\n根据 C++ 标准规定，一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成\n代理构造函数执行完成以后，编译器认为对象已经构造成功，再次执行初始化列表必然会导致不可预知的问题，所以 C++ 标准禁止了这样的语法\n\n\n委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体\n\n如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数\n\n\n\n委托模板构造函数  是指一个构造函数将控制权委托到同类型的一个模板构造函数，就是代理构造函数是一个函数模板\n\n\n#include &lt;vector&gt;#include &lt;list&gt;#include &lt;deque&gt;class X &#123;    template&lt;class T&gt; X(T first, T last) : l_(first, last) &#123; &#125;    std::list&lt;int&gt; l_;public:    X(std::vector&lt;short&gt;&amp;);    X(std::deque&lt;int&gt;&amp;);&#125;;X::X(std::vector&lt;short&gt;&amp; v) : X(v.begin(), v.end()) &#123; &#125;X::X(std::deque&lt;int&gt;&amp; v) : X(v.begin(), v.end()) &#123; &#125;int main() &#123;    std::vector&lt;short&gt; a&#123; 1,2,3,4,5 &#125;;    std::deque&lt;int&gt; b&#123; 1,2,3,4,5 &#125;;    X x1(a);    X x2(b);&#125;\n\n\n捕获委托构造函数的异常\n\n#include &lt;iostream&gt;class X &#123;public:    X() try : X(0) &#123;&#125;    catch (int e) &#123;        std::cout &lt;&lt; &quot;catch: &quot; &lt;&lt; e &lt;&lt; std::endl;        throw 3;    &#125;    X(int a) try : X(a, 0.) &#123;&#125;    catch (int e)    &#123;        std::cout &lt;&lt; &quot;catch: &quot; &lt;&lt; e &lt;&lt; std::endl;        throw 2;    &#125;    X(double b) : X(0, b) &#123;&#125;    X(int a, double b) : a_(a), b_(b) &#123; throw 1; &#125;private:    int a_;    double b_;&#125;;int main() &#123;    try &#123;        X x;    &#125;    catch (int e) &#123;    std::cout &lt;&lt; &quot;catch: &quot; &lt;&lt; e &lt;&lt; std::endl;    &#125;&#125;\n\n\n            使用 Function-try-block 的代码格式，也可以应用到普通函数上\n          \n\n\n委托参数较少的构造函数\n通常情况下将参数较少的构造函数委托给参数较多的构造函数\n也可以从参数较多的构造函数委托参数较少的构造函数，例如完成一些最基础的初始化工作\n\n\n\n13 继承构造函数class Base &#123;public:    Base() : x_(0), y_(0.) &#123;&#125;;    Base(int x, double y) : x_(x), y_(y) &#123;&#125;    Base(int x) : x_(x), y_(0.) &#123;&#125;    Base(double y) : x_(0), y_(y) &#123;&#125;    void SomeFunc() &#123;&#125;private:    int x_;    double y_;&#125;;class Derived : public Base &#123;public:    Derived() &#123;&#125;;    Derived(int x, double y) : Base(x, y) &#123;&#125;    Derived(int x) : Base(x) &#123;&#125;    Derived(double y) : Base(y) &#123;&#125;    void SomeFunc() &#123;&#125;&#125;;\n\n\n一个类有很多构造入口就不是一个很好的设计\n\nDerived并不会自动继承 Base 里面所有的构造函数，所以要把基类所有的构造函数都要重新写一遍\n\nC++ 中可以使用 using 关键字将基类的函数引入派生类\n\nC++ 11 将 using 关键字的能力进行了扩展，使其能够引入基类的构造函数\n\n派生类 Derived 使用 using Base::Base 让编译器为自己生成转发到基类的构造函数\nclass Derived : public Base &#123;public:    using Base::Base;    void SomeFunc() &#123;&#125;&#125;;\nNote\n\n派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码\n\n派生类不会继承基类的默认构造函数和复制构造函数\n\n继承基类的默认构造函数和默认复制构造函数的做法是多余的\n\n\n继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码\n\n在派生类中声明签名相同的构造函数会禁止继承相应的构造函数\n\n派生类继承多个签名相同的构造函数会导致编译失败\nclass Base1 &#123;public:    Base1(int) &#123; std::cout &lt;&lt; &quot;Base1(int x)&quot; &lt;&lt; std::endl; &#125;;&#125;;class Base2 &#123;public:    Base2(int) &#123; std::cout &lt;&lt; &quot;Base2(int x)&quot; &lt;&lt; std::endl; &#125;;&#125;;class Derived : public Base1, Base2 &#123;public:    using Base1::Base1;    using Base2::Base2;&#125;;int main() &#123;    Derived d(5);&#125;\n\n\n编译器不知道用哪个\n最好的解决办法就是不要搞多继承\n\n\n继承构造函数的基类构造函数不能为私有\n\nprotected是可以的\n\n\n继承基类构造函数时，不会继承默认参数\n\n\n\n\n14 强枚举类型\n枚举类型的弊端\n\n一个枚举类型不允许分配到另外一种枚举类型\n\n整型也无法隐式转换成枚举类型，枚举类型却可以隐式转换为整型\n\n枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域，这样重复定义的概率就变大了\nenum HighSchool &#123;    student,    teacher,    principal&#125;;enum University &#123;    student,    professor,    principal&#125;;\n\nprincipal重定义了\n\n无法指定枚举类型的底层类型\n\n不同的编译器对于相同枚举类型可能会有不同的底层类型\n\n\n\n\n强枚举类型 C++ 11\n\n枚举标识符属于强枚举类型的作用域\n枚举标识符不会隐式转换为整型\n能指定强枚举类型的底层类型，底层类型默认为 int 类型\n在枚举定义的 enum 关键字之后加上 class 关键字\n相同类型可以比较，不同类型比较没有意义\n可以通过 static_cast 对其进行强制类型转换\n\n\n列表初始化有底层类型枚举对象 C++ 17\n\n从 C++ 17 标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化\nenum class Color &#123;    Red,    Green,    Blue&#125;;int main() &#123;    Color c&#123; 5 &#125;; // 编译成功    Color c1 = 5; // 编译失败    Color c2 = &#123; 5 &#125;; // 编译失败    Color c3(5); // 编译失败&#125;\n没有指定底层类型的枚举类型是无法使用列表初始化的\n\n同所有的列表初始化一样，它禁止缩窄转换\nenum class Color : char &#123;&#125;int main() &#123;    Color c&#123; 7.11 &#125;;&#125;\n\n\n使用 using 打开强枚举类型 C++ 20\nenum class Color &#123;    Red,    Green,    Blue&#125;;const char* ColorToString(Color c)&#123;    switch (c)    &#123;        using enum Color;        case Red: return &quot;Red&quot;;        case Green: return &quot;Green&quot;;        case Blue: return &quot;Blue&quot;;        default:            return &quot;none&quot;;    &#125;&#125;\n\n15 扩展的聚合类型  聚合类型\n没有用户提供的构造函数\n没有私有和受保护的非静态数据成员\n可以类比于 C 结构体中的数据成员，因为都是public\n\n\n没有虚函数\n必须是公开的基类，不能是私有或者受保护的基类\n必须是非虚继承\n\n\n            基类是否是聚合类型与派生类是否为聚合类型没有关系  在标准库 &lt;type_traits&gt; 中提供了一个聚合类型的甄别办法is_aggregate，判断目标类型是否为聚合类型\n          \n\n聚合类型的初始化#include &lt;iostream&gt;#include &lt;string&gt;class MyStringWithIndex : public std::string &#123;public:    int index_ = 0;&#125;;std::ostream&amp; operator &lt;&lt; (std::ostream &amp;o, const MyStringWithIndex&amp; s) &#123;    o &lt;&lt; s.index_ &lt;&lt; &quot;:&quot; &lt;&lt; s.c_str();    return o;&#125;int main() &#123;    MyStringWithIndex s&#123; &#123;&quot;hello world&quot;&#125;, 11 &#125;;    std::cout &lt;&lt; s &lt;&lt; std::endl;&#125;\n\n\nMyStringWithIndex是聚合类型，&#123;&quot;hello world&quot;&#125;是基类初始化方式，11是派生类的初始化方式\n\n&#123;&quot;hello world&quot;&#125;的大括号也可以省略，即MyStringWithIndex s&#123; &quot;hello world&quot;, 11 &#125;\n\n如果派生类存在多个基类，那么其初始化的顺序与继承的顺序相同\n\n基类中的构造函数如果是受保护的关系，它不允许在聚合类型初始化中被调用\n\n需要为派生类提供一个默认构造函数，就不是聚合类型了\n\n\n用户  提供  的构造函数和用户  声明  的构造函数是有区别的\n#include &lt;iostream&gt;struct X &#123;    X() = default;&#125;;struct Y &#123;    Y() = delete;&#125;;int main() &#123;    std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;std::is_aggregate_v&lt;X&gt; : &quot; &lt;&lt; std::is_aggregate_v&lt;X&gt; &lt;&lt; std::endl;    std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;std::is_aggregate_v&lt;Y&gt; : &quot; &lt;&lt; std::is_aggregate_v&lt;Y&gt; &lt;&lt; std::endl;&#125;\n\n\nC++ 17 认为类中存在用户声明的构造函数是聚合类型，所以 X 和Y都是聚合类型\n\nY y1; // 编译失败，使用了删除函数Y y2&#123;&#125;; // 编译成功，聚合类型初始化\n\n\n这个问题很容易在真实的开发过程中被忽略，从而导致意想不到的结果\n所以在 C++ 20 标准中禁止聚合类型使用用户声明的构造函数 C++ 20\n用 C++20 环境编译后 X 和Y都不是聚合类型了\n\n\n\n\n使用带小括号的列表初始化聚合类型对象 C++ 20\nstruct X &#123;    int i;    float f;&#125;;X x(11, 7.0f);\n\n\n带大括号的列表初始化是不支持缩窄转换，但是带小括号的列表初始化却是支持缩窄转换的\n\n\n\n\n    \n\n\n16 override和 final 重写、重载和隐藏\n重写（override）：在 C++ 中是指派生类覆盖了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型，也就是说有相同的函数名、形参列表以及返回类型\n重载（overload）：它通常是指在同一个类中有两个或者两个以上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形参\n隐藏（overwrite）：隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏\n如果还想使用基类函数，可以使用 using 关键字将其引入派生类\n\n\n\noverride说明符class Base &#123;public:    virtual void some_func() &#123;&#125;    virtual void foo(int x) &#123;&#125;    virtual void bar() const &#123;&#125;    void baz() &#123;&#125;&#125;;class Derived : public Base &#123;public:    virtual void sone_func() &#123;&#125; // 拼写错误    virtual void foo(int &amp;x) &#123;&#125; // 函数签名不一样    virtual void bar() &#123;&#125; // 函数签名不一样    virtual void baz() &#123;&#125; // 基类成员函数不是虚函数&#125;;\n\n\n            派生类 Derived 的 4 个函数都没有触发重写操作  稍不注意就会无法重写基类虚函数  即使写错了代码，编译器也可能不会提示任何错误信息，直到程序编译成功后，运行测试才会发现其中的逻辑问题\n          \n\n\nC++ 11 标准提供了 override 说明符 C++ 11\noverride说明符必须放到虚函数的尾部\n告诉诉编译器这个虚函数需要覆盖基类的虚函数\n编译器发现该虚函数不符合重写规则，会给出错误提示\n基类如果改了成员函数，派生类却不知道，这个时候加上 override 编译器就能检查出来了\n\n\n\nclass Derived : public Base &#123;public:    virtual void sone_func() override &#123;&#125;    virtual void foo(int override &amp;x    virtual void bar() override &#123;&#125;    virtual void baz() override &#123;&#125;&#125;;\n\nfinal说明符\n可以为基类声明纯虚函数来迫使派生类继承并且重写这个纯虚函数\nC++ 11 标准引入 final 说明符来阻止派生类去继承基类的虚函数 C++ 11\noverride和 final 可以同时出现\n类定义的时候声明了final，那么这个类将不能作为基类被其他类继承\n\nclass Base &#123;public:    virtual void foo(int x) &#123;&#125;&#125;;class Derived : public Base &#123;public:    void foo(int x) final &#123;&#125;;&#125;;class Derived2 : public Derived &#123;public:    void foo(int x) &#123;&#125;; // 编译报错&#125;;\n\n\n            C++ 11 标准中，override和 final 并没有被作为保留的关键字，其中 override 只有在虚函数尾部才有意义，而 final 只有在虚函数尾部以及类声明的时候才有意义 class X &#123;public:    void override() &#123;&#125;    void final() &#123;&#125;    int override = 1;    int final = 2;&#125; 这样的代码都是可以的，为了兼容老代码\n          \n\n17 基于范围的 for 循环\nC++ 11 标准引入了基于范围的 for 循环特性，该特性隐藏了迭代器的初始化和更新过程 C++ 11\n\nfor (range_declaration : range_expression) loop_statement，必须满足下面 2 个条件之一\n\n对象类型定义了 begin 和end成员函数\n定义了以对象类型为参数的 begin 和end普通函数\n\n\n对于复杂的对象使用引用，而对于基础类型使用值，因为这样能够减少内存的复制\n\n如果不会在循环过程中修改引用对象，那么推荐在范围声明中加上 const 限定符，免得犯错误\n\nC++ 11 标准中基于范围的 for 循环相当于以下伪代码 C++ 11\n&#123;    auto &amp;&amp; __range = range_expression;    for (auto __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) &#123;        range_declaration = *__begin;        loop_statement    &#125;&#125;\n\nauto __begin = begin_expr, __end = end_expr;表明了 begin 和end必须类型相同，但是没有必要\n\nC++ 17 标准对基于范围的 for 循环的实现进行了改进 C++ 17\n&#123;    auto &amp;&amp; __range = range_expression;    auto __begin = begin_expr;    auto __end = end_expr;    for (; __begin != __end; ++__begin) &#123;        range_declaration = *__begin;        loop_statement    &#125;&#125;\n\n对于 auto &amp;&amp; __range = range_expression;，如果range_expression 是一个纯右值，那么右值引用会扩展其生命周期，保证其整个 for 循环过程中访问的安全性。但如果 range_ expression 是一个泛左值，那结果可就不确定了\nclass T &#123;    std::vector&lt;int&gt; data_;public:    std::vector&lt;int&gt;&amp; items() &#123; return data_; &#125;    // ...&#125;;T foo() &#123;    T t;    return t;&#125;for (auto&amp; x : foo().items()) &#123;&#125; // 未定义行为\n\n\n            因为 foo().items() 返回的是一个泛左值类型 std::vector&lt;int&gt;&amp;，也就是在foo().items() 表达式的一瞬间是有用的，之后就找不到了，所以出现了 UB\n          \n\n对于这种情况将数据复制出来是一种解决方法\nT thing = foo();for (auto&amp; x : foo().items()) &#123;&#125;\n\n在 C++ 20 标准中，基于范围的 for 循环增加了对初始化语句的支持 C++ 20\nfor (T thing = foo(); auto&amp; x : foo().items()) &#123;&#125;\n\n18 支持初始化语句的 if 和switch\n支持初始化语句的 if 和switch C++ 17\nif控制结构可以在执行条件语句之前先执行一个初始化语句 if (init; condition) &#123;&#125;\n其中 init 是初始化语句，condition 是条件语句，它们之间使用分号分隔\n变量的作用于不会泄露到外面\nswitch在通过条件判断确定执行的代码分支之前也可以接受一个初始化语句\n\n\n\n19 static_assert声明\n运行时断言\n\n静态断言出现之前\n只有在程序运行时才会起作用\n直接终止程序，没有必要直接终止程序\nRelease 断言都要关掉的\n性能上也会有问题\n\n\n静态断言static_assert C++ 11\n\n所有处理必须在编译期间执行，不允许有空间或时间上的运行时成本\n它必须具有简单的语法\n断言失败可以显示丰富的错误诊断信息\n它可以在命名空间、类或代码块内使用\n失败的断言会在编译阶段报错\n第一个实参必须是常量表达式，因为编译器无法计算运行时才能确定结果的表达式\n\n#include &lt;type_traits&gt;class A &#123;&#125;;class B : public A &#123;&#125;;class C &#123;&#125;;template&lt;class T&gt;class E &#123;    static_assert(std::is_base_of&lt;A, T&gt;::value, &quot;T is not base of A&quot;);&#125;;int main(int argc, char *argv[]) &#123;    static_assert(argc &gt; 0, &quot;argc &gt; 0&quot;); // 使用错误，argc&gt;0 不是常量表达式    E&lt;C&gt; x; // 使用正确，但由于 A 不是 C 的基类，所以触发断言    static_assert(sizeof(int) &gt;= 4, &quot;sizeof(int) &gt;= 4&quot;); // 使用正确，表达式返回真，不会触发失败断言    E&lt;B&gt; y; // 使用正确，A 是 B 的基类，不会触发失败断言&#125;\n\n\n要使用单参数的static_assert C++ 17\n\n\n\n20 结构化绑定\nC++ 11 标准中同样引入了元组的概念，通过元组 C++ 也能返回多个值\n\n#include &lt;iostream&gt;#include &lt;tuple&gt;std::tuple&lt;int, int&gt; return_multiple_values() &#123;    return std::make_tuple(11, 7);&#125;int main() &#123;    int x = 0, y = 0;    std::tie(x, y) = return_multiple_values();    std::cout &lt;&lt; &quot;x=&quot; &lt;&lt; x &lt;&lt; &quot; y=&quot; &lt;&lt; y &lt;&lt; std::endl;&#125;\n\n如果不使用 std::tie(x, y) 而是直接使用 std::tuple(x, y) 来接受返回值，即\nstd::tuple(x, y) = return_multiple_values();\n\n因为 std::tuple 构造函数参数不是引用，无法修改实参的值，而且返回的是一个临时对象，这一行语句结束后临时对象就失效，所以可以使用引用的形式接受返回值，即\nstd::tuple&lt;int&amp;, int&gt;(x, y) = return_multiple_values();\n\n这样对比下来发现 x 的值改变了，y的值没有改变\n\nC++ 11 必须指定 return_multiple_values 函数的返回值类型，提前声明变量\n可以使用 auto 的新特性来简化返回类型的声明 C++ 14\n结构化绑定是指将一个或者多个名称绑定到初始化对象中的一个或者多个子对象（或者元素）上，相当于给初始化对象的子对象（或者元素）起了别名 C++ 17\n\n深入理解结构化绑定#include &lt;iostream&gt;#include &lt;string&gt;struct BindTest &#123;    int a = 42;    std::string b = &quot;hello structured binding&quot;;&#125;;int main()&#123;    BindTest bt;    const auto[x, y] = bt;    auto&amp; [x1, y1] = bt;    auto [x2, y2] = bt;&#125;\n\n经过解语法糖后\n#include &lt;iostream&gt;#include &lt;string&gt;struct BindTest &#123;  int a = 42;  std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; b = std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;(&quot;hello structured binding&quot;, std::allocator&lt;char&gt;());  // inline constexpr BindTest(const BindTest &amp;) noexcept(false) = default;  // inline constexpr ~BindTest() noexcept = default;  // inline constexpr BindTest() noexcept(false) = default;&#125;;int main() &#123;    BindTest bt = BindTest();    // const auto[x, y] = bt;    const BindTest __bt11 = BindTest(bt);    const int &amp; x = __bt11.a;    const std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &amp; y = __bt11.b;    // auto&amp; [x1, y1] = bt;    BindTest &amp; __bt13 = bt;    int &amp; x1 = __bt13.a;    std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &amp; y1 = __bt13.b;    // auto [x2, y2] = bt;    BindTest __bt15 = BindTest(bt);    int &amp; x2 = __bt15.a;    std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt; &amp; y2 = __bt15.b;    return 0;&#125;\n\n\n绑定后的变量和原来的结构体中的数据不是同一块内存，是匿名构造了一个新的对象，然后引用原来对象中的数据成员，可以理解为原来对象成员变量的别名\n\n只有匿名对象是原来对象的引用，才能够修改原来对象的数据\n\n使用结构化绑定无法忽略对象的子对象或者元素\nauto t = std::make_tuple(42, &quot;hello world&quot;);auto [x] = t; // 编译报错\n\n\n在 C++ 11 标准下可以使用 std::tie 加std::ignore解决\nauto t = std::make_tuple(42, &quot;hello world&quot;);int x = 0, y = 0;std::tie(x, std::ignore) = t;std::tie(y, std::ignore) = t;\n但是结构化绑定的别名无法在同一个作用域中重复使用\nauto t = std::make_tuple(42, &quot;hello world&quot;);auto[x, std::ignore] = t;auto[y, std::ignore] = t; // 编译错误，std::ignore 无法重复声明\n\n\n\n结构化绑定的 3 中类型\n绑定到原生数组\n\n#include &lt;iostream&gt;int main()&#123;    int a[3]&#123; 1, 3, 5 &#125;;    auto[x, y, z] = a;    std::cout &lt;&lt; &quot;[x, y, z]=[&quot;        &lt;&lt; x &lt;&lt; &quot;, &quot;        &lt;&lt; y &lt;&lt; &quot;, &quot;        &lt;&lt; z &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;&#125;\n\n\n绑定到结构体和类对象\n\n类或者结构体中的非静态数据成员个数必须和标识符列表中的别名的个数相同\n\n这些数据成员必须是公有的\n\nC++ 20 标准规定结构化绑定的限制不再强调必须为公开数据成员 C++ 20\n\n\n这些数据成员必须是在同一个类或者基类中\nclass BindBase1 &#123;public:    int a = 42;    double b = 11.7;&#125;;class BindTest1 : public BindBase1 &#123;&#125;;class BindBase2 &#123;&#125;;class BindTest2 : public BindBase2 &#123;public:    int a = 42;    double b = 11.7;&#125;;class BindBase3 &#123;public:    int a = 42;&#125;;class BindTest3 : public BindBase3 &#123;public:    double b = 11.7;&#125;;int main() &#123;    BindTest1 bt1;    BindTest2 bt2;    BindTest3 bt3;    auto[x1, y1] = bt1; // 编译成功    auto[x2, y2] = bt2; // 编译成功    auto[x3, y3] = bt3; // 编译错误&#125;\n定的类和结构体中不能存在匿名联合体\n\n\n\n绑定到元组和类元组的对象\n\n类元组就是像元组一样的东西 ，满足元组抽象的几种条件；对于元组或者类元组类型T  就跟 C++ 20 中的协程一样，只要按照某种模式写就行了\n需要满足 std::tuple_size&lt;T&gt;::value 是一个符合语法的表达式，并且该表达式获得的整数值与标识符列表中的别名个数相同 能取到大小\n类型 T 还需要保证 std::tuple_element&lt;i, T&gt;::type 也是一个符合语法的表达式，其中 i 是小于 std::tuple_size&lt;T&gt;::value 的整数，表达式代表了类型 T 中第 i 个元素的类型 能取到类型\n类型 T 必须存在合法的成员函数模板 get&lt;i&gt;() 或者函数模板 get&lt;i&gt;(t)，其中i 是小于 std::tuple_size&lt;T&gt;::value 的整数，t是类型 T 的实例，get&lt;i&gt;()和 get&lt;i&gt;(t) 返回的是实例 t 中第 i 个元素的值 能取到值\n\n\n\n\n\n21 noexcept关键字\n异常不仅是语法层的概念\n\n很多语言都把异常作为逻辑的一部分\n\n返回一个optional，而不是抛异常，这样在发生异常的时候可以有选择的处理：是继续取里面的值还是向上传递\n\noptional是一个返回值，需要调用者去关心，去处理，但是异常就可能不受到关心\n\n移动构造函数中包含着一个严重的异常陷阱\n\n在 C++ 11 之前，由于没有移动语义，只能将原始容器的数据复制到新容器中。如果在数据复制的过程中复制构造函数发生了异常，那么可以丢弃新的容器，保留原始的容器\n但是有了移动语义，原始容器的数据会逐一地移动到新容器中，如果数据移动的途中发生异常，那么原始容器也将无法继续使用，因为已经有一部分数据移动到新的容器中\n\n\nC++ 标准委员会提出了 noexcept 说明符 C++ 11\n\n它既是一个说明符，也是一个运算符\n\n作为说明符，它能够用来说明函数是否会抛出异常\n\nnoexcept只是告诉编译器不会抛出异常，但函数不一定真的不会抛出异常\n在声明了 noexcept 的函数中抛出异常时，程序会调用 std::terminate 去结束程序的生命周期\n\n\n作为运算符，noexcept还能接受一个返回布尔的常量表达式\n\n当表达式  评估  为true的时候，其行为和不带参数一样，表示函数不会抛出异常\n当表达式  评估  为false的时候，则表示该函数有可能会抛出异常\n由于 noexcept 对表达式的评估是在编译阶段执行的，因此表达式必须是一个常量表达式\n广泛应用于模板当中，看到编译阶段执行，大概率给模板使用\n\ntemplate &lt;class T&gt;T copy(const T &amp;o) noexcept(std::is_fundamental&lt;T&gt;::value) &#123;    ...&#125;\n\n\n只有在 T 是一个基础类型时复制函数才会被声明为noexcept，因为基础类型的复制是不会发生异常的，\n如果 T 是复杂类型么调用其复制构造函数是有可能发生异常的，直接声明 noexcept 会导致当函数遇到异常的时候程序被终止\nnoexcept运算符能够准确地判断函数是否有声明不会抛出异常\n还希望在类型 T 的复制构造函数保证不抛出异常的情况下都使用 noexcept 声明\n\ntemplate &lt;class T&gt;T copy(const T &amp;o) noexcept(noexcept(T(o))) &#123;    ...&#125;\n\n\n只不过两个 noexcept 关键字发挥了不同的作用\n第二个关键字是运算符，它判断 T(o) 是否有可能抛出异常\n第一个 noexcept 关键字则是说明符，它接受第二个运算符的返回值，以此决定 T 类型的复制函数是否声明为不抛出异常\n\n\n\n\n\n\n\n用 noexcept 来解决移动构造问题  现在 noexcept 运算符可以判断目标类型的移动构造函数是否有可能抛出异常。如果没有抛出异常的可能，那么函数可以选择进行移动操作；否则将使用传统的复制操作\ntemplate&lt;class T&gt;void swap(T&amp; a, T&amp; b) noexcept(    noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b)))) &#123;    T tmp(std::move(a));    a = std::move(b);    b = std::move(tmp);&#125;\n\n\n检查类型 T 的移动构造函数和移动赋值函数是否都不会抛出异常\n通过移动构造函数和移动赋值函数移动对象 a 和b\n但是只进行了移动交换，当交换的两个对象在移动时可能抛出异常情况下，需要使用拷贝交换而不是移动交换\n\ntemplate&lt;class T&gt;void swap(T&amp; a, T&amp; b) noexcept(    noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b)))) &#123;    static_assert(noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b))));    T tmp(std::move(a));    a = std::move(b);    b = std::move(tmp);&#125;\n\n只是不能让用，但是还是没有解决问题，最终的交换函数\n#include &lt;iostream&gt;#include &lt;type_traits&gt;struct X &#123;    X() &#123;&#125;    X(X&amp;&amp;) noexcept &#123;&#125;    X(const X&amp;) &#123;&#125;    X operator= (X&amp;&amp;) noexcept &#123; return *this; &#125;    X operator= (const X&amp;) &#123; return *this; &#125;&#125;;struct X1 &#123;    X1() &#123;&#125;    X1(X1&amp;&amp;) &#123;&#125;    X1(const X1&amp;) &#123;&#125;    X1 operator= (X1&amp;&amp;) &#123; return *this; &#125;    X1 operator= (const X1&amp;) &#123; return *this; &#125;&#125;;template&lt;typename T&gt;void swap_impl(T&amp; a, T&amp; b, std::integral_constant&lt;bool, true&gt;) noexcept &#123;    T tmp(std::move(a));    a = std::move(b);    b = std::move(tmp);&#125;template&lt;typename T&gt;void swap_impl(T&amp; a, T&amp; b, std::integral_constant&lt;bool, false&gt;) &#123;    T tmp(a);    a = b;    b = tmp;&#125;template&lt;typename T&gt;void swap(T&amp; a, T&amp; b) noexcept(    noexcept(swap_impl(a, b, std::integral_constant&lt;bool, noexcept(T(std::move(a))) &amp;&amp;    noexcept(a.operator=(std::move(b)))&gt;()))) &#123;    swap_impl(a, b, std::integral_constant&lt;bool, noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std::move(b)))&gt;());&#125;int main() &#123;    X x1, x2;    swap(x1, x2);    X1 x3, x4;    swap(x3, x4);&#125;\n\nnoexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std:: move(b)))这段代码完全可以使用 std::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; std::is_nothrow_move_ assignable&lt;T&gt;::value 来代替\nnoexcept和throw()\n            throw()什么都不抛，就是没有异常\n          \n\n\nthrow()能用的地方 noexcept 也可以用，反过来不行\n如果一个函数在声明了 noexcept 的基础上抛出了异常，那么程序将不需要展开堆栈，它不会调用 std::unexpected，而是调用std::terminate 结束程序\nthrow()则需要展开堆栈，并调用std::unexpected\n在 C++ 17 标准中，throw()成为 noexcept 的一个别名，throw()和 noexcept 拥有了同样的行为和实现 C++ 17\n在 C++ 20 中 throw() 被标准移除 C++ 20\n\n默认使用 noexcept 的函数\n默认构造函数、默认复制构造函数、默认赋值函数、默认移动构造函数和默认移动赋值函数会默认带有 noexcept 声明\n对应的函数在类型的基类和成员中也具有 noexcept 声明，否则其对应函数将不再默认带有 noexcept 声明\n自定义实现的函数默认也不会带有 noexcept 声明\n\n\n类型的析构函数以及 delete 运算符默认带有 noexcept 声明\n即使自定义实现的析构函数也会默认带有 noexcept 声明\n\n\n\n使用 noexcept 的时机\n一定不会出现异常的函数。通常情况下，这种函数非常简短，例如求一个整数的绝对值、对基本类型的初始化等\n目标是提供不会失败或者不会抛出异常的函数时可以使用 noexcept 声明\n对于保证不会抛出异常的函数而言，即使有错误发生，函数也更倾向用返回错误码的方式而不是抛出异常 是  异常太粗暴了\n\n\n\n22 类型别名和别名模板\n往往会使用 typedef 为较长的类型名定义一个别名\n\n实际上 C 语言中是比较常用的如struct xxx、union xxx\nC++ 中 struct xxx、union xxx 定义后 xxx 就是类名，不需要 typedef 了\n\n\n新的定义类型别名的方法，使用 using 关键字 C++ 11\ntypedef void(*func1)(int, int);using func2 = void(*)(int, int);\n\n对比 typedef 更加清晰\n\n\n\n  \n    \n      \n        typedef模板别名\n        #include &lt;map&gt;#include &lt;string&gt;template&lt;class T&gt;struct int_map &#123;    typedef std::map&lt;int, T&gt; type;&#125;;template&lt;class T&gt;struct X &#123;    typename int_map&lt;T&gt;::type int2other; // 必须带有 typename 关键字，否则编译错误&#125;;int main() &#123;    int_map&lt;std::string&gt;::type int2string;    int2string[11] = \"7\";&#125;C++\n        在上面这段代码中，类模板 X 没有确定模板形参 T 的类型，所以 int_map::type 是一个未决类型，也就是说 int_map::type 既有可能是一个类型，也有可能是一个静态成员变量，编译器是无法处理这种情况的。这里的 typename 关键字告诉编译器应该将 int_map::type 作为类型来处理\n      \n    \n  \n  \n    \n      \n        using模板别名\n        #include &lt;map&gt;#include &lt;string&gt;template&lt;class T&gt;using int_map = std::map&lt;int, T&gt;;template&lt;class T&gt;struct X &#123;    typename int_map&lt;T&gt;::type int2other; // 编译成功，别名模板不会有任何问题&#125;;int main() &#123;    int_map&lt;std::string&gt;::type int2string;    int2string[11] = \"7\";&#125;C++\n        别名模板不会有 ::type 的困扰，当然也不会有这样的问题了。当然，为了保证与老代码的兼容性，typedef的方案依然存在。别名模板的模板元编程函数使用 _t 作为其名称的后缀以示区分\n      \n    \n  \n\n\n23 指针字面量nullptr\nNULL是一个宏，在 C++ 11 标准之前其本质就是 0\n#ifndef NULL    #ifdef __cplusplus        #define NULL 0    #else        #define NULL ((void *)0)    #endif#endif\n使用 0 代表不同类型的特殊规则给 C++ 带来了二义性\nvoid f(int) &#123;    std::cout &lt;&lt; &quot;int&quot; &lt;&lt; std::endl;&#125;void f(char *) &#123;    std::cout &lt;&lt; &quot;char *&quot; &lt;&lt; std::endl;&#125;f(NULL);f(reinterpret_cast&lt;char *&gt;(NULL));\n\n\nf(NULL)会造成 UB\n\nstd::string s1(false);std::string s2(true);\n\n\nfalse被隐式转换为 0，true不能隐式转换成 1，所以 std::string s2(true) 在 MSVC 中编译报错\n\n\nnullptr表示空指针的字面量 C++ 11\n\n它是一个 std::nullptr_t 类型的纯右值\n\n不允许运用在算术表达式中或者与非指针类型进行比较（除了空指针常量 0）\n\n可以隐式转换为各种指针类型，但是无法隐式转换到非指针类型\n\n可以为函数模板或者类设计一些空指针类型的特化版本\n#include &lt;iostream&gt;template&lt;class T&gt;struct widget &#123;    widget() &#123;        std::cout &lt;&lt; &quot;template&quot; &lt;&lt; std::endl;    &#125;&#125;;template&lt;&gt;struct widget&lt;std::nullptr_t&gt; &#123;    widget() &#123;        std::cout &lt;&lt; &quot;nullptr&quot; &lt;&lt; std::endl;    &#125;&#125;;template&lt;class T&gt;widget&lt;T&gt;* make_widget(T) &#123;    return new widget&lt;T&gt;();&#125;int main() &#123;    auto w1 = make_widget(0);    auto w2 = make_widget(nullptr);&#125;\n\n\n\n24 三向比较\nC++ 20 标准新引入了一个名为“太空飞船”（spaceship）的运算符&lt;=&gt; C++ 20\n\n运算符 &lt;=&gt; 的返回值只能与 0 和自身类型来比较，如果同其他数值比较，编译器会报错\n\n三向比较的返回类型：std::strong_ordering、std::weak_ordering以及std::partial_ordering\n\nstd::strong_ordering 表达的是一种可替换性\n对于基本类型中的 int 类型，三向比较返回的是std::strong_ordering\n默认情况下自定义类型是不存在三向比较运算符函数的，需要用户显式默认声明\n\n\nstd::weak_ordering 表达的是不可替换性\n基础类型中并没有，但是它常常发生在用户自定义类中，比如一个大小写不敏感的字符串类\n\n\nstd::partial_ordering 表示进行比较的两个操作数没有关系\n基础类型中的浮点数\n浮点的集合中存在一个特殊的 NaN（not a number），它和其他浮点数值是没关系的\n\n\n\n\n对基础类型的支持\n\n对两个算术类型的操作数进行一般算术转换，然后进行比较\n\n整型的比较结果为std::strong_ordering\n浮点型的比较结果为std::partial_ordering\n\n\n对于无作用域枚举类型和整型操作数，枚举类型会转换为整型再进行比较，无作用域枚举类型无法与浮点类型比较\n\n对两个相同枚举类型的操作数比较结果，如果枚举类型不同，则无法编译\n\n对于其中一个操作数为 bool 类型的情况，另一个操作数必须也是 bool 类型，否则无法编译\n\n不支持作比较的两个操作数为数组的情况，会导致编译出错\n\n对于其中一个操作数为指针类型的情况，需要另一个操作数是同样类型的指针，或者是可以转换为相同类型的指针，比如数组到指针的转换、派生类指针到基类指针的转换等\nchar arr1[5];char arr2[5];char* ptr = arr2;auto r = ptr &lt;=&gt; arr1;\n\n\nC++20 标准规定，如果用户为自定义类型声明了三向比较运算符，那么编译器会为其自动生成 &lt;、&gt;、&lt;= 和&gt;=这 4 种运算符函数\n\n现在 C++ 20 标准已经推荐使用 &lt;=&gt; 和==运算符自动生成其他比较运算符函数\n\n有了 &lt;=&gt; 可以生成 &lt;、&gt;、&lt;= 和&gt;=\n有了 == 可以生成!=\n\n\n在用户自定义类型中，实现了 &lt;、== 运算符函数的数据成员类型，在该类型的三向比较中将自动生成合适的比较代码\nstruct Legacy &#123;    int n;    bool operator==(const Legacy&amp; rhs) const &#123;        return n == rhs.n;    &#125;    bool operator&lt;(const Legacy&amp; rhs) const &#123;        return n &lt; rhs.n;    &#125;&#125;;struct TreeWay &#123;    Legacy m;    std::strong_ordering operator&lt;=&gt;(const TreeWay &amp;) const = default;&#125;;TreeWay t1, t2;bool r = t1 &lt; t2;\n\n结构体 TreeWay 的三向比较操作会调用结构体 Legacy 中的 &lt; 和==运算符来完成\n\n\n25 线程局部存储\n线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例\n\nthread_local说明符可以用来声明线程生命周期的对象\n\n能与 static 或extern结合，分别指定内部或外部链接\n和 static 类似，但是在多线程访问时 thread_local 修饰的变量在每个线程中是独立的，static修饰的变量在线程之间是一份内存\n\n\n使用取地址运算符 &amp; 取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和 constexpr 结合\nthread_local int tv;static int sv;int main()&#123;    constexpr int *sp = &amp;sv; // 编译成功，sv 的地址在编译时确定    constexpr int *tp = &amp;tv; // 编译失败，tv 的地址在运行时确定&#125;\n线程局部存储对象的初始化和销毁。在同一个线程中，一个线程局部存储对象只会初始化一次\n\n对象的销毁也只会发生一次，通常发生在线程退出的时刻\n\n\n26 扩展的 inline 说明符\n在 C++ 17 标准之前，非常量静态成员变量的声明和定义必须分开进行\ninclude是单纯的宏替换 以小博大，谓之“宏”\n\n\nC++ 17 增强了 inline 说明符的能力，它允许我们内联定义静态变量 C++ 17\n\n#include &lt;iostream&gt;#include &lt;string&gt;class X &#123;public:    inline static std::string text&#123;&quot;hello&quot;&#125;;&#125;;int main() &#123;    X::text += &quot; world&quot;;    std::cout &lt;&lt; X::text &lt;&lt; std::endl;&#125;\n\n\n            针对于 inline 函数，有时候并不一定需要用户手动去指定，编译器会做优化；也就是说编译器也会决定哪些函数是可以内联的，很多时候能覆盖绝大多数的场景\n          \n\n27 常量表达式\n  \n    \n      \n        宏定义或这常量定义\n        const int index0 = 0;#define index1 1// case 语句switch (argc) &#123;    case index0:        std::cout &lt;&lt; \"index0\" &lt;&lt; std::endl;        break;    case index1:        std::cout &lt;&lt; \"index1\" &lt;&lt; std::endl;        break;    default:        std::cout &lt;&lt; \"none\" &lt;&lt; std::endl;&#125;const int x_size = 5 + 8;#define y_size 6 + 7// 数组长度char buffer[x_size][y_size] = &#123; 0 &#125;;// 枚举成员enum &#123;    enum_index0 = index0,    enum_index1 = index1,&#125;;std::tuple&lt;int, char&gt; tp = std::make_tuple(4, '3');// 非类型的模板参数int x1 = std::get&lt;index0&gt;(tp);char x2 = std::get&lt;index1&gt;(tp);C++\n        \n          C++ 程序员应该尽量少使用宏，因为预处理器对于宏只是简单的字符替换，完全没有类型检查，而且宏使用不当出现的错误难以排查\n          可以用模板代替\n        \n      \n    \n  \n  \n    \n      \n        将宏或常量改为函数调用\n        int get_index0() &#123;    return 0;&#125;int get_index1() &#123;    return 1;&#125;int get_x_size() &#123;    return 5 + 8;&#125;int get_y_size() &#123;    return 6 + 7;&#125;const int index0 = get_index0();#define index1 get_index1()// case 语句switch (argc) &#123;    case index0:        std::cout &lt;&lt; \"index0\" &lt;&lt; std::endl;        break;    case index1:        std::cout &lt;&lt; \"index1\" &lt;&lt; std::endl;        break;    default:        std::cout &lt;&lt; \"none\" &lt;&lt; std::endl;&#125;const int x_size = get_x_size();#define y_size get_y_size()// 数组长度char buffer[x_size][y_size] = &#123; 0 &#125;;// 枚举成员enum &#123;    enum_index0 = index0,    enum_index1 = index1,&#125;;std::tuple&lt;int, char&gt; tp = std::make_tuple(4, '3');// 非类型的模板参数int x1 = std::get&lt;index0&gt;(tp);char x2 = std::get&lt;index1&gt;(tp);C++\n        无法通过编译，无论是宏定义的函数调用，还是通过函数返回值初始化 const 变量都是在运行时确定的\n      \n    \n  \n\n\n\n            C 语言中可支持在栈上开辟变长数组（VLA），C++ 没有必要\n          \n\n\nC 语言 &lt;limit.h&gt; 中定义了各种整型类型的最大值和最小值，是通过宏定义的\nC++ 为了避免宏的使用，在 &lt;limit&gt; 中采用模板特化的方式来定义最值，返回的是函数计算后的值，但是必须在运行时计算，仍然会导致常量无法确定的问题\nchar buffer[std::numeric_limits&lt;unsigned char&gt;::max()] = &#123;0&#125;; 编译报错\n\n\nC++ 11 标准中定义一个新的关键字constexpr，它能够有效地定义常量表达式 C++ 11\n\nconstexpr值和函数 constexpr 值即常量表达式值，是一个用 constexpr 说明符声明的变量或者数据成员，它要求该值必须在编译期计算 常量表达式值必须由常量表达式初始化\n// 正常使用constexpr int x1 = 42;char buffer1[x1] = &#123; 0 &#125;;// 将 constexpr 替换为 const 也可以正常使用const int x2 = 42;char buffer2[x2] = &#123; 0 &#125;;int x3 = 42;const int x4 = x3; // 定义和初始化成功，但是编译器并不一定把它作为一个编译期需要确定的值char buffer[x4] = &#123; 0 &#125;; // 编译失败，x4 无法作为数组长度int x5 = 42;constexpr int x6 = x5; // 编译失败，x6 无法用 x5 初始化char buffer[x6] = &#123; 0 &#125;;\n\n\nconstexpr是一个加强版的const，它不仅要求常量表达式是常量，并且要求是一个编译阶段就能够确定其值的常量\n\n常量和常量是不一样的\n\n编译器 / 编译时常量\n数值类型，bool类型，字符串类型\n\n\n运行期 / 运行时常量\n\n\nconstexpr函数，常量表达式函数的返回值可以在编译阶段就计算出来\n\n函数必须返回一个值，所以它的返回值类型不能是void\n函数体必须只有一条语句：return expr，其中 expr 必须也是一个常量表达式。如果函数有形参，则将形参替换到 expr 中后，expr仍然必须是一个常量表达式\n函数使用之前必须有定义\n函数必须用 constexpr 声明\n\n\n虽然常量表达式函数的返回值可以在编译期计算出来，但是这个行为并不是确定的\n\n当带形参的常量表达式函数接受了一个非常量实参时，常量表达式函数可能会退化为普通函数\n\n\nconstexpr构造函数\n\n构造函数必须用 constexpr 声明\n\n构造函数初始化列表中必须是常量表达式\n\n构造函数的函数体必须为空（这一点基于构造函数没有返回值，所以不存在return expr）\nclass X &#123;public:    constexpr X() : x1(5) &#123;&#125;    constexpr X(int i) : x1(i) &#123;&#125;    constexpr int get() const &#123;        return x1;    &#125;private:    int x1;&#125;;constexpr X x;char buffer[x.get()] = &#123; 0 &#125;;\n\n\n称这样的类为字面量类类型（literal class type）\nconstexpr会自动给函数带上 const 属性\n常量表达式构造函数拥有和常量表达式函数相同的退化特性，当它的实参不是常量表达式的时候，构造函数可以退化为普通构造函数\n\n\n使用 constexpr 声明自定义类型的变量，必须确保这个自定义类型的析构函数是平凡的，否则也是无法通过编译的\n\n自定义类型中不能有用户自定义的析构函数\n析构函数不能是虚函数\n基类和成员的析构函数必须都是平凡的\n\n\nconstexpr说明符则支持声明浮点类型的常量表达式值，而且标准还规定其精度必须至少和运行时的精度相同\nconstexpr double sum(double x) &#123;    return x &gt; 0 ? x + sum(x - 1) : 0;&#125;constexpr double x = sum(5);\n\n\n\n常量表达式函数的增强 C++ 14\n函数体允许声明变量，除了没有初始化、static和 thread_local 变量\n\n函数允许出现 if 和switch语句，不能使用 goto 语句\n\n函数允许所有的循环语句，包括for、while、do-while\n\n函数可以修改生命周期和常量表达式相同的对象\nconstexpr int next(int x) &#123;    return ++x;&#125;char buffer[next(5)] = &#123; 0 &#125;;\n\nx的声明周期和常量的生命周期一致\n\n函数的返回值可以声明为void\n\nconstexpr声明的成员函数不再具有 const 属性\n\n除了在常量表达式函数特性方面做了增强，也在标准库方面做了增强，包括 &lt;complex&gt;、&lt;chrono&gt;、&lt;array&gt;、&lt;initializer_list&gt;、&lt;utility&gt; 和&lt;tuple&gt;\n\n\nconstexprlambda 表达式和内联属性\nlambda 表达式在条件允许的情况下都会隐式声明为constexpr C++ 17\n\n当 lambda 表达式不满足 constexpr 的条件时也没有关系，变成运行时的 lambda 表达式，只要用在合适的地方就可以了\n\n可以强制要求 lambda 表达式是一个常量表达式，用 constexpr 去声明它即可\n\n可以检查 lambda 表达式是否有可能是一个常量表达式，如果不能则会编译报错\n\n\nconstexpr声明静态成员变量时，也被赋予了该变量的内联属性 C++ 17\nclass X &#123;public:    static constexpr int num&#123; 5 &#125;;&#125;;\n\n\nC++ 11 中 num 只有声明没有定义，实际上是编译器直接将 X::num 替换为 5，如果对num 取地址，即 &amp;X::num 连接器会提示 X::num 缺少定义\nC++ 17 中 num&#123; 5 &#125; 既是声明也是定义\n\n\n\nif constexpr\n            该特性只有在使用模板的时候才具有实际意义，如果是普通函数，那直接可以写出分支中的语句即可；模板的类型只有实例化的时候才会出现不同的分支情况，使用 if constexpr 才有意义\n          \n\n\nif constexpr的条件必须是编译期能确定结果的常量表达式\n条件结果一旦确定，编译器将只编译符合条件的代码块\nif constexpr不支持短路规则\n\n#include &lt;iostream&gt;template&lt;class T&gt; bool is_same_value(T a, T b) &#123;    return a == b;&#125;template&lt;&gt; bool is_same_value&lt;double&gt;(double a, double b) &#123;    if (std::abs(a - b) &lt; 0.0001) &#123;        return true;    &#125; else &#123;        return false;    &#125;&#125;int main() &#123;    double x = 0.1 + 0.1 + 0.1 - 0.3;    std::cout &lt;&lt; std::boolalpha;    std::cout &lt;&lt; &quot;is_same_value(5, 5) : &quot; &lt;&lt; is_same_value(5, 5) &lt;&lt;    std::endl;    std::cout &lt;&lt; &quot;x == 0.0 : &quot; &lt;&lt; (x == 0.) &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;is_same_value(x, 0.) : &quot; &lt;&lt; is_same_value(x, 0.) &lt;&lt;    std::endl;&#125;\n\nis_same_value(5, 5) : truex == 0.0 : falseis_same_value(x, 0.) : true\n\n\n            float有效位数是 7 位，一般用 0.0000001 比较；double有效位数是 15 位，所以要多写几位，如 0.000000000000001 比较\n          \n\n使用 if constexpr 表达式，代码会简化很多而且更加容易理解\n#include &lt;type_traits&gt;template&lt;class T&gt; bool is_same_value(T a, T b) &#123;    if constexpr (std::is_same&lt;T, double&gt;::value) &#123;        if (std::abs(a - b) &lt; 0.0001) &#123;            return true;        &#125;        else &#123;            return false;        &#125;    &#125; else &#123;        return a == b;    &#125;&#125;\n\n需要注意这样一种陷阱\n\n  \n    \n      \n        正常情况\n        #include &lt;iostream&gt;#include &lt;type_traits&gt;template&lt;class T&gt; auto minus(T a, T b) &#123;    if constexpr (std::is_same&lt;T, double&gt;::value) &#123;        if (std::abs(a - b) &lt; 0.0001) &#123;            return 0.;        &#125;        else &#123;            return a - b;        &#125;    &#125;    else &#123;        return static_cast&lt;int&gt;(a - b);    &#125;&#125;int main()&#123;    std::cout &lt;&lt; minus(5.6, 5.11) &lt;&lt; std::endl;    std::cout &lt;&lt; minus(5.60002, 5.600011) &lt;&lt; std::endl;    std::cout &lt;&lt; minus(6, 5) &lt;&lt; std::endl;&#125;C++\n      \n    \n  \n  \n    \n      \n        缺少 else 分支\n        #include &lt;iostream&gt;#include &lt;type_traits&gt;template&lt;class T&gt; auto minus(T a, T b) &#123;    if constexpr (std::is_same&lt;T, double&gt;::value) &#123;        if (std::abs(a - b) &lt; 0.0001) &#123;            return 0.;        &#125;        else &#123;            return a - b;        &#125;    &#125;    else &#123;        return static_cast&lt;int&gt;(a - b);    &#125;&#125;C++\n        可能会导致函数有多个不同的返回类型；当实参类型为 double 的时，if的代码块会被正常地编译，代码块内部的返回结果类型为double，而代码块外部返回类型为int。编译器遇到了两个不同的返回类型，只能报错\n      \n    \n  \n\n\nconstexpr其他特性 C++ 20\n允许 constexpr 虚函数\n\nconstexpr的虚函数可以覆盖重写普通虚函数\n普通虚函数也可以覆盖重写 constexpr 的虚函数\n大不了就退化\n\n\n允许在 constexpr 函数中出现try-catch\nconstexpr int f(int x)&#123;    try &#123; return x + 1; &#125;    catch (...) &#123; return 0; &#125;&#125;\n\ntry-catch和 if-else 是一个意思\n\n允许在 constexpr 中进行平凡的默认初始化\n\n应该养成声明对象时随手初始化的习惯，避免让代码出现未定义的行为\n\n\n允许在 constexpr 中更改联合类型的有效成员\nunion Foo &#123;    int i;    float f;&#125;;constexpr int use() &#123;    Foo foo&#123;&#125;;    foo.i = 3;    foo.f = 1.2f; // C++20 之前编译失败    return 1;&#125;\n使用 consteval 声明立即函数，对于无法在编译期执行计算的情况则让编译器直接报错\nconsteval int sqr(int n) &#123;    return n * n;&#125;constexpr int r = sqr(100); // 编译成功int x = 100;int r2 = sqr(x); // 编译失败\n\n\nlambda 表达式也可以使用 consteval 说明符\n\n\n使用 constinit 检查常量初始化，要用于具有静态存储持续时间的变量声明上，它要求变量具有常量初始化程序\n\nconstinit说明符作用的对象是必须具有静态存储持续时间的\nconstinit int x = 11; // 编译成功，全局变量具有静态存储持续int main() &#123;    constinit static int y = 42; // 编译成功，静态变量具有静态存储持续    constinit int z = 7; // 编译失败，局部变量是动态分配的&#125;\nconstinit要求变量具有常量初始化程序\nconst char* f() &#123; return &quot;hello&quot;; &#125;constexpr const char* g() &#123; return &quot;cpp&quot;; &#125;constinit const char* str1 = f(); // 编译错误，f() 不是一个常量初始化程序，编译的时候不能确定其值constinit const char* str2 = g(); // 编译成功，编译的时候可以确定其值\n虽然 constinit 说明符一直在强调常量初始化，但是初始化的对象并不要求具有常量属性\n\n\n\nstd::is_constant_evaluated是 C++ 20 新加入标准库的函数，它用于检查当前表达式是否是一个常量求值环境\n#include &lt;cmath&gt;#include &lt;type_traits&gt;constexpr double power(double b, int x) &#123;    if (std::is_constant_evaluated() &amp;&amp; x &gt;= 0) &#123;        double r = 1.0, p = b;        unsigned u = (unsigned)x;        while (u != 0) &#123;            if (u &amp; 1) r *= p;            u /= 2;            p *= p;        &#125;        return r;    &#125; else &#123;        return std::pow(b, (double)x);    &#125;&#125;int main() &#123;    constexpr double kilo = power(10.0, 3); // 常量求值    int n = 3;    double mucho = power(10.0, n); // 非常量求值    return 0;&#125;\n\n\n明显常量求值\n\n常量表达式，这个类别包括很多种情况，比如数组长度、case表达式、非类型模板实参等\nif constexpr语句中的条件\nconstexpr变量的初始化程序\n立即函数调用\n约束概念表达式\n可在常量表达式中使用或具有常量初始化的变量初始化程序\n\ntemplate&lt;bool&gt; struct X &#123;&#125;;X&lt;std::is_constant_evaluated()&gt; x; // 非类型模板实参，函数返回 true，最终类型为 X&lt;true&gt;int y;constexpr int f() &#123;    const int n = std::is_constant_evaluated() ? 13 : 17; // n 是 13    int m = std::is_constant_evaluated() ? 13 : 17; // m 可能是 13 或者 17，取决于函数环境    char arr[n] = &#123;&#125;; // char[13]    return m + sizeof(arr);&#125;int p = f(); // m 是 13；p 结果如下 26int q = p + f(); // m 是 17；q 结果如下 56\n\n\n\n28 确定的表达式求值顺序\n在 C++ 17 之前是没有具体说明的，所以编译器可以以任何顺序对子表达式进行求值\n\nfoo(a, b, c)，这里的 foo、a、b 和c的求值顺序是没有确定的\n\n\n函数表达式一定会在函数的参数之前求值 C++ 17\n\nfoo(a, b, c)，foo一定会在 a、b 和c之前求值\n但是参数之间的求值顺序依然没有确定\n\n\n对于后缀表达式和移位操作符而言，表达式求值总是从左往右\nE1[E2]E1.E2E1.*E2E1-&gt;*E2E1&lt;&lt;E2E1&gt;&gt;E2\n\n在上面的表达式中，子表达式求值 E1 总是优先于E2\n\n对于赋值表达式，这个顺序又正好相反，它的表达式求值总是从右往左\nE1=E2E1+=E2E1-=E2E1*=E2E1/=E2...\n\n在上面的表达式中，子表达式求值 E2 总是优先于E1\n\n对于 new 表达式，C++ 17 也做了规定 C++ 17\nnew T(E)\n\n\n这里 new 表达式的内存分配总是优先于 T 构造函数中参数 E 的求值\n涉及重载运算符的表达式的求值顺序应由与之相应的内置运算符的求值顺序确定，而不是函数调用的顺序规则\n\n\n\n\n            尽量不要使函数调用产生副作用，否则会很难确认实参的真实值  通过变成规范避免产生这种问题  在函数中不要既要修改又要访问\n          \n\n29 字面量优化\n标准库中引入了 std::hexfloat 和std::defaultfloat来修改浮点输入和输出的默认格式化 C++ 11\n\nstd::hexfloat可以将浮点数格式化为十六进制的字符串\nstd::defaultfloat可以将格式还原到十进制\n\n\n二进制整数字面量也有前缀 0b 和0B C++ 14\n\n十六进制 0x，0X 和八进制0\n\n\n一个用单引号作为整数分隔符的特性 C++ 14\nconstexpr int x = 123&#x27;456;static_assert(x == 0x1e&#x27;240);static_assert(x == 036&#x27;11&#x27;00);static_assert(x == 0b11&#x27;110&#x27;001&#x27;001&#x27;000&#x27;000);\n\n\n单引号整数分隔符对于十进制、八进制、十六进制、二进制整数都是有效的\n&#39;加哪都可以\n\n\n原生字符串字面量 raw string C++ 11\n\n原生字符串字面量声明是R&quot;(raw_characters)&quot;，特殊字符不需要转义了\n\n\n用户自定义字面量 C++ 11\n\n可以通过自定义后缀将整数、浮点数、字符和字符串转化为特定的对象\n字面量运算符函数的语法规则\n由返回类型、operator关键字、标识符以及函数形参组成的\nretrun_type operator &quot;&quot; identifier (params)\n在 C++ 11 的标准中，双引号和紧跟的标识符中间必须有空格\n标识符可以紧跟在双引号后 C++ 14\n还能使用 C++ 的保留字作为标识符 C++ 14\n建议用户定义的字面量运算符函数的标识符应该以下画线开始\n\n\n整数字面量运算符函数有 3 种不同的形参类型\nunsigned long long\nconst char *\n形参为空\n使用模板参数实现：operator &quot;&quot;identifier&lt;char…c&gt;()\n\n\n编译器会将整数字面量转换为对应的无符号 long long 类型或者常量字符串类型，然后将其作为参数传递给运算符函数\n\n\n浮点数字面量运算符函数有 3 种形参类型\nlong double\nconst char *\n形参为空\n\n\n字符串字面量运算符函数\n形参类型列表为const char * str, size_t len\nstr为字符串字面量的具体内容\nlen是字符串字面量的长度\n\n\n字符字面量运算符函数也只有一种形参类型char\n\n\n\n#include &lt;string&gt;unsigned long long operator &quot;&quot; _w1(unsigned long long n) &#123;    return n;&#125;const char * operator &quot;&quot; _w2(const char *str) &#123;    return str;&#125;unsigned long long operator &quot;&quot; _w3(long double n) &#123;    return n;&#125;std::string operator &quot;&quot; _w4(const char* str, size_t len) &#123;    return str;&#125;char operator &quot;&quot; _w5(char n) &#123;    return n;&#125;unsigned long long operator &quot;&quot;if(unsigned long long n) &#123;    return n;&#125;int main() &#123;    auto x1 = 123_w1;    auto x2_1 = 123_w2;    auto x2_2 = 12.3_w2;    auto x3 = 12.3_w3;    auto x4 = &quot;hello world&quot;_w4;auto x5 = &#x27;a&#x27;_w5;auto x6 = 123if;&#125;\n\n\n字面量运算符函数使用模板参数的情况\n#include &lt;string&gt;template &lt;char…c&gt; std::string operator &quot;&quot; _w() &#123;    std::string str;    //(str.push_back(c), …); // C++17 的折叠表达式    using unused = int[]; // 为了避免歧义，导致编译器报错，如果使用    unused&#123; (str.push_back(c), 0) … &#125;;    // int[]&#123; (str.push_back(c), 0) …  &#125;; 类似结构化绑定，会导致编译器报错    return str;&#125;int main() &#123;    auto x = 123_w;    auto y = 12.3_w;&#125;\n\nunused&#123; (str.push_back(c), 0) … &#125;;如果使用的是 123_w 实际上可以展开为 unused&#123; (str.push_back(1), 0), (str.push_back(2), 0), (str.push_back(3), 0)，每个表达式的结果都是0，因为使用了逗号表达式，所以unused 最终没有用到，目的是驱动这个表达式的计算\n\n\n\n\n30 alignas和alignof\nalignof运算符可以用于获取类型的对齐字节长度\n\nalignas说明符可以用来改变类型的默认对齐字节长度\n\n在 alignof 运算符被引入之前，常用 offsetof 来间接实现 alignof 的功能\n#define ALIGNOF(type, result) \\  struct type##_alignof_trick&#123; char c; type member; &#125;; \\  result = offsetof(type##_alignof_trick, member)int x1 = 0;ALIGNOF(int, x1);\n\n其中 offsetof 在 mscv 中实现也是一个宏 0\n#define offsetof(s, m) ((::size_t)&amp;reinterpret_cast&lt;char const volatile&amp;&gt;((((s*)0)-&gt;m)))\n\nreinterpret_cast&lt;char const volatile&amp;&gt;是编译器优化所用，理解时可以去掉，就是相对于地址 0 的偏移\n\n使用 alignof 运算符\nauto x1 = alignof(int);auto x2 = alignof(void(*)());int a = 0;auto x3 = alignof(a); // *C++ 标准不支持这种用法\n\n\nC++ 标准规定 alignof 必须是针对类型的\nGCC 扩展了这条规则，alignof除了能接受一个类型外还能接受一个变量\n使用 MSVC 如果想获得变量的对齐，可以使用编译器的扩展关键字__alignof\n可以通过 alignof 获得类型 std::max_align_t 的对齐字节长度\nC++ 11 定义了std::max_align_t，它是一个平凡的标准布局类型，其对齐字节长度要求至少与每个标量类型一样严格\n所有的标量类型都适应 std::max_align_t 的对齐字节长度\nnew和 malloc之类的分配函数返回的指针需要适合于任何对象，也就是说内存地址至少与 std::max_align_t 严格对齐\n\n\n使用 alignas 说明符\n\n该说明符可以接受类型或者常量表达式 该常量表达式计算的结果必须是一个 2 的幂值，否则是无法通过编译的\n\n#include &lt;iostream&gt;struct X &#123;    char a1;    int a2;    double a3;&#125;;struct X1 &#123;    alignas(16) char a1;    alignas(double) int a2;    double a3;&#125;;struct alignas(16) X2 &#123;    char a1;    int a2;    double a3;&#125;;struct alignas(16) X3 &#123;    alignas(8) char a1;    alignas(double) int a2;double a3;&#125;;struct alignas(4) X4 &#123;    alignas(8) char a1;    alignas(double) int a2;double a3;&#125;;#define COUT_ALIGN(s) std::cout &lt;&lt; &quot;alignof(&quot; #s &quot;) = &quot; &lt;&lt; alignof(s) &lt;&lt;std::endlint main() &#123;    X x;    X1 x1;    X2 x2;    X3 x3;    X4 x4;    alignas(4) X3 x5;    alignas(16) X4 x6;    COUT_ALIGN(x);    COUT_ALIGN(x1);    COUT_ALIGN(x2);    COUT_ALIGN(x3);    COUT_ALIGN(x4);    COUT_ALIGN(x5);    COUT_ALIGN(x6);    COUT_ALIGN(x5.a1);    COUT_ALIGN(x6.a1);&#125;\n\n\n既可以用于结构体，也可以用于结构体的成员变量\n如果将 alignas 用于结构体类型，那么该结构体整体就会以 alignas 声明的对齐字节长度进行对齐\n结构体类型的对齐字节长度总是需要大于或者等于其成员变量类型的对齐字节长度\n结构体类型的对齐字节长度，并不能影响声明变量时变量的对齐字节长度\n\n\n提供了 std::alignment_of、std::aligned_storage 和std::aligned_union类模板型以及 std::align 函数模板来支持对于对齐字节长度的控制\nstd::cout &lt;&lt; std::alignment_of&lt;int&gt;::value &lt;&lt; std::endl; // 输出 4std::cout &lt;&lt; std::alignment_of&lt;int&gt;() &lt;&lt; std::endl; // 输出 4std::cout &lt;&lt; std::alignment_of&lt;double&gt;::value &lt;&lt; std::endl; // 输出 8std::cout &lt;&lt; std::alignment_of&lt;double&gt;() &lt;&lt; std::endl; // 输出 8std::aligned_storage&lt;128, 16&gt;::type buffer;std::cout &lt;&lt; sizeof(buffer) &lt;&lt; std::endl; // 内存大小指定为 128 字节std::cout &lt;&lt; alignof(buffer) &lt;&lt; std::endl; // 对齐字节长度指定为 16 字节std::aligned_union&lt;64, double, int, char&gt;::type buffer;std::cout &lt;&lt; sizeof(buffer) &lt;&lt; std::endl; // 内存大小指定为 64 字节std::cout &lt;&lt; alignof(buffer) &lt;&lt;  std::endl; // 对齐字节长度自动选择为 double，8 字节对齐\n使用 new 分配指定对齐字节长度的对象 C++ 17\n\n通过让 new 运算符接受一个 std::align_val_t 类型的参数来获得分配对象需要的对齐字节长度\n编译器会自动从类型对齐字节长度的属性中获取这个参数并且传参，不需要额外的代码介入\n\n\n\n31 属性说明符和标准属性\n标准属性说明符语法 C++ 11\n\n[[attr]] [[attr1, attr2, attr3(args)]] [[namespace::attr(args)]]\n可以有一个属性，也可以有多个属性，也可以带参数，还可以存在namespace\nC++ 11 标准的属性说明符可用在 C++ 程序中的几乎所有位置\n属性说明符总是声明位于其之前的对象，而在整个声明之前的属性则会声明语句中所有声明的对象\n[[attr1]] class [[attr2]] X &#123; int i; &#125; a, b[[attr3]];\n到 C++ 20 为止，绝大部分标准属性在声明中使用\n\n\n使用 using 打开属性的命名空间，可直接使用命名空间的属性从而减少代码冗余 C++ 17\n\n[[using attribute-namespace : attribute-list]]\n编译器应该忽略任何无法识别的属性\n\n\n标准属性\n\nnoreturn C++ 11\n\n回类型为 void 说明函数还是会返回到调用者，只不过没有返回值\n用 noreturn 属性声明的函数编译器会认为在这个函数中执行流会被中断，函数不会返回到其调用者\n\n[[noreturn]] void foo() &#123;&#125;void bar() &#123;&#125;int main()&#123;    foo();    bar();&#125;\n\n\n            在对 foo 添加 noreturn 属性以后，main函数中编译器不再为调用 foo 后面的过程生成代码了，它不仅忽略了对 bar 函数的调用，甚至干脆连 main 函数里的栈平衡以及返回代码都忽略了。因为编译器被告知，调用 foo 函数之后程序的执行流会被中断，所以生成的代码一定不会被执行，索性也不需要生成这些代码了\n          \ncarries_dependency C++ 11\n\ndeprecaetd C++ 14\n\n带有此属性的实体被声明为弃用\n不仅能用在类、结构体和函数上，在普通变量、别名、联合体、枚举类型甚至命名空间上都可以使用\n\n\nfallthrough C++ 17\n\n该属性可以在 switch 语句的上下文中提示编译器直落行为是有意的，并不需要给出警告\n\n\nnodiscard C++ 17\n\n该属性声明函数的返回值不应该被舍弃\n\nnodiscard属性也可以声明在类或者枚举类型上\n\n对类或者枚举类型本身并不起作用，只有当被声明为 nodiscard 属性的类或者枚举类型被当作函数返回值的时候才发挥作用\nnodiscard属性只适用于返回值类型的函数，对于返回引用的函数使用 nodiscard 属性是没有作用的\n\nclass[[nodiscard]] X&#123;&#125;;[[nodiscard]] int foo() &#123; return 1; &#125;X bar1() &#123; return X(); &#125;;X&amp; bar2(X &amp;x) &#123; return x; &#125;;int main() &#123;    X x;    foo(); // 编译器发出警告    bar1(); // 编译器发出警告    bar2(x); // bar 返回引用，nodiscard 不起作用，不会引发警告&#125;\nnodiscard属性支持将一个字符串字面量作为属性的参数 C++ 20\n\nnodiscard属性还能用于构造函数，它会在类型构建临时对象的时候让编译器发出警告 C++ 20\nclass X &#123;public:    [[nodiscard]] X() &#123;&#125;    X(int a) &#123;&#125;&#125;;int main() &#123;    X x;    X&#123;&#125;; // `X&#123;&#125;` 构造了临时对象，于是编译器给出忽略 `X::X()` 返回值的警告    X&#123; 42 &#125;;&#125;\n\n\nmaybe_unused C++ 17\n\n该属性声明实体可能不会被应用以消除编译器警告\n还可以用在如类、结构体、联合类型、枚举类型、函数、变量等地方\n\n\nlikely和unlikely C++ 20\n\nlikely属性允许编译器对该属性所在的执行路径相对于其他执行路径进行优化\nunlikely属性恰恰相反\n\nint f(int i) &#123;    switch(i) &#123;    case 1: return 1;    [[unlikely]] case 2: return 2;&#125;return 3;&#125;\n\n编译在分支语句面前会做预判，对概率大的优先执行，如果执行的分支不是预测的，就直接将执行结果丢掉即可，再重新进行执行判断正确的语句\n\nno_unique_address C++ 20\n\n该属性指示编译器该数据成员不需要唯一的地址，也就是说它不需要与其他非静态数据成员使用不同的地址\n是不是可与理解为不占用其他非静态数据成员的地址\n\n\n\n\n\n32 新增预处理器和宏\n预处理器__has_include C++ 17\n\n用于判断某个头文件是否能够被包含进来\n可以替换实验性的头文件\n\n\n特性测试宏 C++ 20 测试当前的编译环境对各种功能特性的支持程度\n\n属性特性测试宏__has_cpp_attribute\n指示编译环境是否支持某种属性\nstd::cout &lt;&lt; __has_cpp_attribute(deprecated); // 输出结果如下：201309\n\n\n语言功能特性测试宏\n编译环境所支持的语言功能特性\n__cpp_concepts，__cpp_constexpr等等\n\n\n标准库功能特性测试宏\n编译环境所支持的标准库功能特性\n判断起来很麻烦，直接查表更方便\n\n\n\n\n新增宏VA_OPT\n\n__VA_ARGS__常见的用法集中于打印日志上\n#define LOG(msg, …) printf(&quot;[&quot; __FILE__ &quot;:%d] &quot; msg, __LINE__, __VA_ARGS__)LOG(&quot;Hello %d&quot;, 2020);\n\n对于 LOG 宏来说，这种写法是非法的\nLOG(&quot;Hello 2020&quot;);\n\n上面这句代码展开后应该是\nprintf(&quot;[&quot; __FILE__ &quot;:%d] &quot; &quot;Hello 2020&quot;, __LINE__, );\n\n可以使用 ## 连接逗号和__VA_ARGS__\n#define LOG(msg, …) printf(&quot;[&quot; __FILE__ &quot;:%d] &quot; msg, __LINE__, ##__VA_ARGS__)LOG(&quot;Hello 2020&quot;);\n引入了一个新的宏__VA_OPT__令可变参数宏更易于在可变参数为空的情况下使用\n#define LOG(msg, …) printf(&quot;[&quot; __FILE__ &quot;:%d] &quot; msg, __LINE__ __VA_OPT__(,) __VA_ARGS__)\n\n观察上面的代码可以发现，__LINE__后面的逗号被修改为__VA_OPT__(,)，这是告诉编译器这个逗号是可选的\n\n\n\n\n33 协程\n协程是一种可以被挂起和恢复的函数，它提供了一种创建  异步  代码的方法\n\n协程的使用方法#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;future&gt;using namespace std::chrono_literals;std::future&lt;int&gt; foo() &#123;    std::cout &lt;&lt; &quot;call foo\\n&quot;;    std::this_thread::sleep_for(3s);    co_return 5;&#125;std::future&lt;std::future&lt;int&gt;&gt; bar() &#123;    std::cout &lt;&lt; &quot;call bar\\n&quot;;    std::cout &lt;&lt; &quot;before foo\\n&quot;;    auto n = co_await std::async(foo); // 挂起点    std::cout &lt;&lt; &quot;after foo\\n&quot;;    co_return n;&#125;int main() &#123;    std::cout &lt;&lt; &quot;before bar\\n&quot;;    auto i = bar();    std::cout &lt;&lt; &quot;after bar\\n&quot;;    i.wait();    std::cout &lt;&lt; &quot;result = &quot; &lt;&lt; i.get().get();&#125;\n\n\nco_await、co_return和 co_yield，具有以上 3 个关键字中任意一个的函数就是协程 C++ 20\n建议将协程和标准库中的 future、generator 一起使用\n协程虽然提供了一种异步代码的编写方法，但是并不会自动执行异步操作\n\n协程的实现原理#include &lt;chrono&gt;#include &lt;coroutine&gt;#include &lt;exception&gt;#include &lt;future&gt;#include &lt;iostream&gt;#include &lt;thread&gt;#include &lt;type_traits&gt; // A program-defined type on which the coroutine_traits specializations below dependstruct as_coroutine &#123;&#125;; // Enable the use of std::future&lt;T&gt; as a coroutine type// by using a std::promise&lt;T&gt; as the promise type.template&lt;typename T, typename... Args&gt;    requires(!std::is_void_v&lt;T&gt; &amp;&amp; !std::is_reference_v&lt;T&gt;)struct std::coroutine_traits&lt;std::future&lt;T&gt;, as_coroutine, Args...&gt;&#123;    struct promise_type : std::promise&lt;T&gt;    &#123;        std::future&lt;T&gt; get_return_object() noexcept        &#123;            return this-&gt;get_future();        &#125;         std::suspend_never initial_suspend() const noexcept &#123; return &#123;&#125;; &#125;        std::suspend_never final_suspend() const noexcept &#123; return &#123;&#125;; &#125;         void return_value(const T&amp; value)            noexcept(std::is_nothrow_copy_constructible_v&lt;T&gt;)        &#123;            this-&gt;set_value(value);        &#125;         void return_value(T&amp;&amp; value) noexcept(std::is_nothrow_move_constructible_v&lt;T&gt;)        &#123;            this-&gt;set_value(std::move(value));        &#125;         void unhandled_exception() noexcept        &#123;            this-&gt;set_exception(std::current_exception());        &#125;    &#125;;&#125;; // Same for std::future&lt;void&gt;.template&lt;typename... Args&gt;struct std::coroutine_traits&lt;std::future&lt;void&gt;, as_coroutine, Args...&gt;&#123;    struct promise_type : std::promise&lt;void&gt;    &#123;        std::future&lt;void&gt; get_return_object() noexcept        &#123;            return this-&gt;get_future();        &#125;         std::suspend_never initial_suspend() const noexcept &#123; return &#123;&#125;; &#125;        std::suspend_never final_suspend() const noexcept &#123; return &#123;&#125;; &#125;         void return_void() noexcept        &#123;            this-&gt;set_value();        &#125;         void unhandled_exception() noexcept        &#123;            this-&gt;set_exception(std::current_exception());        &#125;    &#125;;&#125;; // Allow co_await&#x27;ing std::future&lt;T&gt; and std::future&lt;void&gt;// by naively spawning a new thread for each co_await.template&lt;typename T&gt;auto operator co_await(std::future&lt;T&gt; future) noexcept    requires(!std::is_reference_v&lt;T&gt;)&#123;    struct awaiter : std::future&lt;T&gt;    &#123;        bool await_ready() const noexcept        &#123;            using namespace std::chrono_literals;            return this-&gt;wait_for(0s) != std::future_status::timeout;        &#125;         void await_suspend(std::coroutine_handle&lt;&gt; cont) const        &#123;            std::thread([this, cont]            &#123;                this-&gt;wait();                cont();            &#125;).detach();        &#125;         T await_resume() &#123; return this-&gt;get(); &#125;    &#125;;     return awaiter &#123; std::move(future) &#125;;&#125;\n\nco_await运算符原理  目标对象可被等待需要实现 await_resume、await_ready和 await_suspen 这 3 个成员函数\n\nawait_ready函数叫作 is_ready 或许更加容易理解，该函数用于判定可等待体是否已经准备好，也就是说可等待体是否已经完成了目标任务，如果已经完成，则返回true；否则返回false\nawait_suspend这个函数名则更加令人难以理解，命名为 schedule_continuation 应该会更加清晰，它的作用就是调度协程的执行流程，比如异步等待可等待体的结果、恢复协程以及将执行的控制权返回调用者\n形参coroutine_handle&lt;&gt;，正如它的类型名所示，它是协程的句柄，可以用于控制协程的运行流程\n有 operator() 和resume()函数，它们可以执行挂起点之后的代码\nawait_suspend不一定返回 void 类型，还可以返回 bool 和coroutine_handle类型\n返回 void 类型表示协程需要将执行流的控制权交给调用者，协程保持挂起状态\n返回 bool 类型则又会出现两种情况，当返回值为 true 时，效果和返回类型与 void 相同；当返回 false 的时候，则恢复当前协程运行\n返回 coroutine_handle 类型的时候，则会恢复该句柄对应的协程\n如果在 await_suspend 中捕获到了异常，那么协程也会恢复并且在协程中抛出该异常\n\n\n\n\nawait_resume实际上用于接收异步执行结果，可以叫作retrieve_value\n可以重载 co_await 运算符，让它从可等待体转换为等待器\n\nco_yield运算符原理\npromise_type可以用于自定义协程自身行为，代码的编写者可以自定义协程的多种状态以及自定义协程中任何 co_await、co_return 或co_yield表达式的行为，比如挂起前和恢复后的处理、如何返回最终结果等\n通常情况下 promise_type 会作为函数的嵌套类型存在\n协程需要 promise_type 帮助它返回一个对象，这个辅助函数就是get_return_object\n等待器 suspend_always 和suspend_never，分别表示必然挂起和从不挂起\nyield_value的意思很简单，保存 co_yield 操作数的值并且返回等待器\ngenerator通常返回suspend_always\n事实上，co_yield i;可以等价于代码co_await promise.yield_value(i);\n\n\nreturn_void用于实现没有 co_return 的情况。promise_type中必须存在 return_void 或者return_value\n\nco_return运算符原理\nco_return也需要 promise_type 的支持\n如果 co_return 没有任何返回值，则需要用成员函数 void return_void() 代替void return_value(int value)\n\npromise_type的其他功能\npromise_type还有一个额外的功能，即可对 co_await 的操作数进行转换处理\nstruct promise_type &#123;    …    awaitable await_transform(expr e) &#123; return awaitable(e); &#125;&#125;;\n\n这样做的结果是代码 co_await expr; 最终会转换为：co_await promise.await_transform(expr);\n\npromise_type还可以对异常进行处理\nstruct promise_type &#123;    …    void unhandled_exception() &#123;        eptr_ = std::current_exception();    &#125;&#125;;\n\n","categories":["C++"],"tags":["C++","Modern C++","笔记"]},{"title":"Triangles and Z-Buffer","url":"/2021/11/09/f90648db822c/","content":"投影矩阵  透视投影矩阵推导\n    \n\n\n对于正交投影（Orthographic Projection）需要把长方体  进行标准化成正方体，相应的变换矩阵是先进行平移变换（将长方体的中心与原点重合），再进行缩放变换（由于标准化的正方体的边长是 2，长宽高要归一化到 2），即：\n\n    \n\n\n对于透视投影（Perspective Projection），思路是把视锥体“挤压”成长方体，再对长方体进行归一化。于是视锥体内的所有点“挤压”到近平面上（可以想象视角在远平面外侧，方向垂直于远平面），可以根据相似三角形原理计算出“挤压”后的  和坐标\n\n    \n\n\n那么“挤压”后的点在齐次坐标系（Homogeneous Coordinates）下可以表示为：\n所以从视锥体到长方体的矩阵变换  满足下面的等式：\n\n即\n第三行的未知值可以根据两个设定计算出来：\n\n近平面上的任意一点经过“挤压”后的  坐标不发生变化，近平面上的点为 ，挤压后还是，也可以写成，所以第三行一定满足以下等式： 可以得出：\n\n远平面上的任意一点经过“挤压”后的  坐标也不会发生变化，同上可得：\n\n\n联立可得：所以透视投影矩阵可以表示为：\n对于函数 get_projection_matrix 中的参数可由下图计算出：\n\n    \n\n\n长方体的中心位于原点，则，根据对称性，根据纵横比和对称性可得，，代入公式即可\n旋转与投影代码Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar){    // TODO: Copy-paste your implementation from the previous assignment.    Eigen::Matrix4f projection;        float fov = eye_fov * M_PI / 180.0;    float t = std::abs(zNear) * std::tan(fov / 2.0);    float b = -t;    float r = t * aspect_ratio;    float l = -r;    float n = zNear;    float f = zFar;        Eigen::Matrix4f scale;    scale &lt;&lt; 1 / r - l, 0, 0, 0,        0, 1 / t - b, 0, 0,        0, 0, 1 / n - f, 0,        0, 0, 0, 1;        Eigen::Matrix4f translate;    translate &lt;&lt; 1, 0, 0, 0,        0, 1, 0, 0,        0, 0, 1, (n + f) / -2,        0, 0, 0, 1;        auto orthographic = scale * translate;    Eigen::Matrix4f orthographicToProjection;    orthographicToProjection &lt;&lt; n, 0, 0, 0,        0, n, 0, 0,        0, 0, n + f, -n * f,        0, 0, 1, 0;    projection = orthographic * orthographicToProjection;        return projection;}\n\n三维空间中判断一个点是否在三角形内\n求出向量，，\n计算，，\n如果叉乘后三个向量方向同向则说明  点在三角形内部，否则在外部\n\nstatic bool insideTriangle(int x, int y, const Vector3f* _v){    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]    Eigen::Vector2f side1;    side1 &lt;&lt; _v[1].x() - _v[0].x(), _v[1].y() - _v[0].y();    Eigen::Vector2f side2;    side2 &lt;&lt; _v[2].x() - _v[1].x(), _v[2].y() - _v[1].y();    Eigen::Vector2f side3;    side3 &lt;&lt; _v[0].x() - _v[2].x(), _v[0].y() - _v[2].y();        Eigen::Vector2f v1;    v1 &lt;&lt; x - _v[0].x(), y - _v[0].y();    Eigen::Vector2f v2;    v2 &lt;&lt; x - _v[1].x(), y - _v[1].y();    Eigen::Vector2f v3;    v3 &lt;&lt; x - _v[2].x(), y - _v[2].y();        float z1 = side1.x() * v1.y() - side1.y() * v1.x();    float z2 = side2.x() * v2.y() - side2.y() * v2.x();    float z3 = side3.x() * v3.y() - side3.y() * v3.x();        if ((z1 &gt; 0 &amp;&amp; z2 &gt; 0 &amp;&amp; z3 &gt; 0) || (z1 &lt; 0 &amp;&amp; z2 &lt; 0 &amp;&amp; z3 &lt; 0))    {        return true;    }    else    {        return false;    }}\n\n光栅化  计算重心坐标  考虑三角形三个顶点 ，， 以及内部坐标点 ，假设又三个值，， 满足：解方程组可得\nstatic std::tuple&lt;float, float, float&gt; computeBarycentric2D(float x, float y, const Vector3f* v){    float xp = x, yp = y;    float xa = v[0].x(), ya = v[0].y();    float xb = v[1].x(), yb = v[1].y();    float xc = v[2].x(), yc = v[2].y();    float gamma = ((xb - xa) * (yp - ya) - (xp - xa) * (yb - ya)) /                   ((xb - xa) * (yc - ya) - (xc - xa) * (yb - ya));    float beta = (xp - xa - gamma * (xc - xa)) / (xb - xa);    float alpha = 1.0f - beta - gamma;    return {alpha, beta, gamma};}\n\n\n    \n\n\n光栅化一个三角形需要扫描三角形所在的包围盒，判断点是否在三角形内部然后通过中心坐标插值\n\n    \n\n\n所以判断是否在三角形内部需要加\nif (insideTriangle(i + 0.5f, j + 0.5f, t.v)) {    ...}\n\n已知重心坐标 ，， 的值求深度值  的公式如下（需要做重心坐标 - 插值校正 [1][2]）： 其中，，\n重心坐标是在 2D 空间里做的，不能用作插值 3D 空间的坐标，需要经过插值矫正才可以\n//Screen space rasterizationvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t) {    auto v = t.toVector4();        // TODO : Find out the bounding box of current triangle.    // iterate through the pixel and find if the current pixel is inside the triangle    auto minX = std::min(v[0].x(), std::min(v[1].x(), v[2].x()));    auto minY = std::min(v[0].y(), std::min(v[1].y(), v[2].y()));    auto maxX = std::max(v[0].x(), std::max(v[1].x(), v[2].x()));    auto maxY = std::max(v[0].y(), std::max(v[1].y(), v[2].y()));    // If so, use the following code to get the interpolated z value.    // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.    for (int i = minX; i &lt;= maxX; i++) {        for (int j = minY; j &lt;= maxY; j++) {            if (insideTriangle(i + 0.5f, j + 0.5f, t.v)) {                float minDepth = FLT_MAX;                auto tup = computeBarycentric2D(i, j, t.v);                                float alpha, beta, gamma;                std::tie(alpha, beta, gamma) = tup;                float wReciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());                float zInterpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();                zInterpolated *= wReciprocal;                minDepth = std::min(minDepth, zInterpolated);                auto index = get_index(i, j);                if (depth_buf[index] &gt; minDepth) {                    Eigen::Vector3f color = t.getColor();                    Vector3f point;                    point &lt;&lt; i, j, minDepth;                    depth_buf[index] = minDepth;                    set_pixel(point, color);                }            }        }    }}\n\n\n[1]  透视投影 - 重心坐标 - 插值校正[2]  Perspective-Correct Interpolation\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }；\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["图形学"],"tags":["Graphics","GAMES"]},{"title":"Linux 内核 --offsetof 和 container_of","url":"/2021/11/12/f47f5e2db501/","content":"#define offsetof(type, member)  ((size_t)&amp;((type *)0)-&gt;member)\n\n offsetof：获取结构体中成员的偏移位置，将地址 0 强制转换为 type 类型的指针（编译器认为 0 是一个有效地址，即 0 是type指针的起始地址），然后再引用 member 成员（对应的就是 ((type *)0)-&gt;member，即偏移到member 成员的起始地址），最后将 member 成员的起始地址强制转换为 size_t 类型\n\nConsider this example:\nstruct Test &#123; char text[32]; int count;&#125;\n\nIf struct Test is allocated at the address 0xC000, then the address of text would be 0xC000, and the address of count would be 0xC020. However, if the base address is zero (which is not allowed by the standard), then the address of text would be zero, and the address of the count would be 0x20. Casting these addresses to size_t gives you the offset of the corresponding members.\n\n/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */#define container_of(ptr, type, member) (&#123;                   \\     const typeof(((type *)0)-&gt;member ) *__mptr = (ptr);    \\     (type *)((char *)__mptr - offsetof(type,member) );&#125;)\n\ncontainer_of：const typeof(((type *)0)-&gt;member ) *__mptr = (ptr);通过 typeof 定义一个 member 指针类型的指针变量 __mptr（即__mptr 是指向 member 类型的指针），并将 __mptr 赋值为 ptr；(type *)((char *)__mptr - offsetof(type,member)); 通过 offsetof 宏计算出 member 在type中的偏移，然后用 member 的实际地址 __mptr 减去偏移，得到 type 的起始地址，即指向 type 类型的指针\n","categories":["Linux"],"tags":["macro","linux"]}]