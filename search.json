[{"title":"Pipeline and Shading","url":"/2021/11/12/10/","content":"å…‰æ …åŒ–  ä¸ Triangles and Z-Buffer ä¸€æ ·çš„æµç¨‹\n\nè®¡ç®—ä¸‰è§’å½¢çš„åŒ…å›´ç›’ï¼ˆbounding boxï¼‰\néå†åŒ…å›´ç›’åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…\næ±‚è§£é‡å¿ƒåæ ‡å¹¶è¿›è¡Œæ’å€¼æ ¡æ­£\næ›´æ–°æ·±åº¦å€¼\n\nè¿™é‡Œéœ€è¦è®¡ç®—é¢œè‰²æ’å€¼ï¼ˆcolorï¼‰ã€å‘é‡æ’å€¼ï¼ˆnormalï¼‰ã€çº¹ç†åæ ‡æ’å€¼ï¼ˆtexcoordsï¼‰å’Œç€è‰²ç‚¹åæ ‡æ’å€¼ï¼ˆshadingcoordsï¼‰\nshadingcoordsGPU å…ˆè¿›è¡Œè§‚æµ‹å˜æ¢ï¼ˆViewing Transformationï¼‰ï¼Œå†è¿›è¡Œå…‰æ …åŒ–ã€‚ç”±äºå¢åŠ äº†å…‰ç…§ï¼ŒåŒä¸€ç‰©ä½“çš„ä¸åŒä½ç½®çš„é¢œè‰²ä¸ä¸€æ ·ï¼Œéœ€è¦ç»“åˆæ³•çº¿ç­‰å› ç´ å»è®¡ç®—ï¼Œæ‰€ä»¥éœ€è¦è€ƒè™‘ç‰©ä½“åœ¨åŸæœ¬ç©ºé—´çš„ä½ç½®ã€‚\nåœ¨è¿›è¡Œå…‰æ …åŒ–æ—¶åªæœ‰åƒç´ çš„  åæ ‡æ˜¯å·²çŸ¥çš„ï¼Œç»è¿‡æ·±åº¦æ’å€¼ï¼Œæ‰å¾—åˆ°äº†  å±å¹•ç©ºé—´  ä¸­å¯¹åº”çš„æŸç‚¹çš„åæ ‡ ã€‚è€Œè¿™ä¸ªåæ ‡ä¹Ÿä¸æ˜¯ è§‚å¯Ÿç©ºé—´ ï¼ˆView Space æˆ–è€… Camera Spaceï¼‰é‡Œé¢çš„ç‚¹ï¼Œå› ä¸ºæŠ•å½±çŸ©é˜µæœ¬è´¨ä¸Šæ˜¯æŠŠè§†é”¥å‹ç¼©æˆäº†é•¿æ–¹ä½“ï¼Œè¿™ä¸ªåæ ‡æ˜¯ç»å†äº†å‹ç¼©ä¹‹åçš„ã€‚åªæœ‰åˆ©ç”¨ï¼Œï¼Œ ç»“åˆ rasterize_triangle ä¼ è¿›æ¥çš„å‚æ•° viewspace_pos æ’å€¼æ‰èƒ½ç®—å‡ºå¯¹åº”  è§‚å¯Ÿç©ºé—´  ä¸­çš„åƒç´ ç‚¹ã€‚å¾—åˆ°äº†è¿™ä¸ªæ‰€è°“çš„ interpolated_shadingcoordsï¼Œå…¶å®å°±æ˜¯ è§‚å¯Ÿç©ºé—´  ä¸­ä½ çœŸæ­£åœ¨ç€è‰²çš„é‚£ä¸ªç‚¹ã€‚\nå…‰çº¿ä½œç”¨æ˜¯  è§‚å¯Ÿç©ºé—´ ï¼ˆView Space æˆ–è€… Camera Spaceï¼‰ä¸­è¿›è¡Œçš„ï¼Œç»è¿‡äº† MV å˜æ¢ï¼ˆModel å’Œ Viewpointï¼‰çš„ç©ºé—´å°±æ˜¯ è§‚å¯Ÿç©ºé—´ ï¼Œè¿™æ—¶æ‰€æœ‰ç©ºé—´ç‚¹ä¹‹é—´çš„ç›¸å¯¹ä½ç½®éƒ½è¿˜æ˜¯æ­£å¸¸çš„ï¼Œæ‰€ä»¥è¦åœ¨è¿™ä¸ª è§‚å¯Ÿç©ºé—´  æ¥åšç€è‰²ï¼Œè®¡ç®—å…‰çš„å…¥å°„å’Œç©ºé—´ç‚¹çš„ä½œç”¨ã€‚ç»è¿‡äº† MVP å˜æ¢çš„ç©ºé—´è¿˜æ˜¯ä¸‰ç»´ç©ºé—´ï¼Œä½†å·²ç»æ˜¯è¢«é€è§†å˜æ¢å‹ç¼©çš„ä¸‰ç»´ç©ºé—´ï¼Œå› ä¸º  è¢«å‹ç¼©äº†ï¼Œæ‰€ä»¥ä¸èƒ½ç”¨è¿™ä¸ªç©ºé—´æ¥åšå…‰çº¿ä½œç”¨ã€‚ç»è¿‡äº† MVP å˜æ¢å’Œ Viewport å˜æ¢çš„ç©ºé—´å«åš  å±å¹•ç©ºé—´ï¼ˆScreen Spaceï¼‰ï¼Œå·²ç»æ˜¯äºŒç»´ç©ºé—´ç‚¹äº†ï¼Œå‡†å¤‡å¥½æˆä¸ºåƒç´ äº†ã€‚\n//Screen space rasterizationvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t, const std::array&lt;Eigen::Vector3f, 3&gt;&amp; view_pos) {    // TODO: From your HW3, get the triangle rasterization code.    // TODO: Inside your rasterization loop:    //    * v[i].w() is the vertex view space depth value z.    //    * Z is interpolated view space depth for the current pixel    //    * zp is depth between zNear and zFar, used for z-buffer    // float Z = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());    // float zp = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();    // zp *= Z;    // TODO: Interpolate the attributes:    // auto interpolated_color    // auto interpolated_normal    // auto interpolated_texcoords    // auto interpolated_shadingcoords    // Use: fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);    // Use: payload.view_pos = interpolated_shadingcoords;    // Use: Instead of passing the triangle's color directly to the frame buffer, pass the color to the shaders first to get the final color;    // Use: auto pixel_color = fragment_shader(payload);    auto v = t.toVector4();    auto minX = std::min(v[0].x(), std::min(v[1].x(), v[2].x()));    auto minY = std::min(v[0].y(), std::min(v[1].y(), v[2].y()));    auto maxX = std::max(v[0].x(), std::max(v[1].x(), v[2].x()));    auto maxY = std::max(v[0].y(), std::max(v[1].y(), v[2].y()));        for (int i = minX; i &lt;= maxX; i++) {        for (int j = minY; j &lt;= maxY; j++) {            if (insideTriangle(i + 0.5, j + 0.5, t.v)) {                auto tup = computeBarycentric2D(i, j, t.v);                float alpha, beta, gamma;                std::tie(alpha, beta, gamma) = tup;                float wReciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());                float zInterpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();                zInterpolated *= wReciprocal;                auto index = get_index(i, j);                                if (depth_buf[index] &gt; zInterpolated) {                    auto interpolated_color = interpolate(alpha, beta, gamma, t.color[0], t.color[1], t.color[2], 1);                    auto interpolated_normal = interpolate(alpha, beta, gamma, t.normal[0], t.normal[1], t.normal[2], 1);                    auto interpolated_texcoords = interpolate(alpha, beta, gamma, t.tex_coords[0], t.tex_coords[1], t.tex_coords[2], 1);                    auto interpolated_shadingcoords = interpolate(alpha, beta, gamma, view_pos[0], view_pos[1], view_pos[2], 1);                    fragment_shader_payload payload(interpolated_color, interpolated_normal.normalized(), interpolated_texcoords, texture ? &amp;*texture : nullptr);                    payload.view_pos = interpolated_shadingcoords;                    auto pixel_color = fragment_shader(payload);                    set_pixel(Eigen::Vector2i(i, j), pixel_color);                    depth_buf[index] = zInterpolated;                }            }        }    }}\n\nNormalæ³•å‘è´´å›¾ä¸è€ƒè™‘å…‰ç…§ç›´æ¥å°†ç€è‰²ç‚¹çš„æ³•å‘é‡çš„å€¼æ˜ å°„ä¸ºé¢œè‰²å€¼å³å¯\nEigen::Vector3f normal_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f return_color = (payload.normal.head&lt;3&gt;().normalized() + Eigen::Vector3f(1.0f, 1.0f, 1.0f)) / 2.f;    Eigen::Vector3f result;    result &lt;&lt; return_color.x() * 255, return_color.y() * 255, return_color.z() * 255;    return result;}\n\n\n    \n\n\nBlinn-Phongæ¼«åå°„ï¼ˆDiffuse Termï¼‰\né«˜å…‰ï¼ˆSpecular Termï¼‰\n    \n\n\n\nå…¶ä¸­  æ˜¯åŠç¨‹å‘é‡\nç¯å¢ƒå…‰ï¼ˆAmbient Termï¼‰\nBlinn-Phong Refection Model\n    \n\n\n\nEigen::Vector3f phong_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color / 255.f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;    Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);        //std::cout &lt;&lt; \"(\" &lt;&lt; result_color.x() &lt;&lt; \",\" &lt;&lt; result_color.y() &lt;&lt; \",\" &lt;&lt; result_color.z() &lt;&lt; \")\" &lt;&lt; std::endl;    }    return result_color * 255.f;}\n\n\n    \n\n\nTexture Shader FragmentTexture çš„å®ç°åªéœ€è¦å°†çº¹ç†åæ ‡å¯¹åº”çš„é¢œè‰²ä¼ ç»™ kd å³å¯ï¼Œçº¹ç†åæ ‡ä¼šå‡ºç°è´Ÿå€¼ï¼Œæ‰€ä»¥æŠŠ ï¼Œ åæ ‡é™å®šåœ¨  èŒƒå›´å†…\nEigen::Vector3f getColor(float u, float v){\t// åæ ‡é™å®š\tif (u &lt; 0) u = 0;\tif (u &gt; 1) u = 1;\tif (v &lt; 0) v = 0;\tif (v &gt; 1) v = 1;    auto u_img = u * width;    auto v_img = (1 - v) * height;    auto color = image_data.at&lt;cv::Vec3b&gt;(v_img, u_img);    return Eigen::Vector3f(color[0], color[1], color[2]);}\n\nEigen::Vector3f texture_fragment_shader(const fragment_shader_payload&amp; payload){    Eigen::Vector3f return_color = {0, 0, 0};    if (payload.texture)    {        // TODO: Get the texture value at the texture coordinates of the current fragment        auto texcoord = payload.tex_coords;        return_color = payload.texture-&gt;getColor(texcoord.x(), texcoord.y());    }    Eigen::Vector3f texture_color;    texture_color &lt;&lt; return_color.x(), return_color.y(), return_color.z();    Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = texture_color / 255.f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = texture_color;    Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);    }    return result_color;}\n\n\n    \n\n\nBump Mappingæ³•çº¿è´´å›¾åŸç†  å¦‚æœæ³•çº¿å¤„äºä¸–ç•Œåæ ‡ä¸­çš„ï¼ˆWorld Spaceï¼‰ï¼Œé‚£ç§°ä¸º World Space Normalã€‚å¦‚æœæ˜¯å¤„äºç‰©ä½“æœ¬èº«å±€éƒ¨åæ ‡ä¸­çš„ï¼Œé‚£ç§°ä¸º Object Space Normalã€‚\nWorld Space Normal ä¸€æ—¦ä»è´´å›¾é‡Œè§£å‹å‡ºæ¥åï¼Œå°±å¯ä»¥ç›´æ¥ç”¨äº†ï¼Œæ•ˆç‡å¾ˆé«˜ã€‚ä½†æ˜¯æœ‰ä¸ªç¼ºç‚¹ï¼Œè¿™ä¸ª World Space Normal æ˜¯å›ºå®šäº†ï¼Œå¦‚æœç‰©ä½“æ²¡æœ‰ä¿æŒåŸæ¥çš„æ–¹å‘å’Œä½ç½®ï¼Œé‚£åŸæ¥ç”Ÿæˆçš„æ³•çº¿è´´å›¾å°±ä½œåºŸäº†ã€‚\nå› æ­¤ä¿å­˜äº† Object Space Normalã€‚å®ƒä»è´´å›¾é‡Œè§£å‹ï¼Œè¿˜éœ€è¦ä¹˜ä»¥æ¨¡å‹ - è§†å›¾ï¼ˆModel-Viewï¼‰çŸ©é˜µè½¬æ¢åˆ°ä¸–ç•Œåæ ‡ï¼Œæˆ–è€…è½¬æ¢åˆ°å…¶ä»–åæ ‡å–å†³äºè®¡ç®—è¿‡ç¨‹åŠéœ€æ±‚ã€‚Object Space Normal ç”Ÿæˆçš„è´´å›¾ï¼Œç‰©ä½“å¯ä»¥è¢«æ—‹è½¬å’Œä½ç§»ã€‚ä½†ä»æœ‰ä¸€ä¸ªç¼ºç‚¹ã€‚å°±æ˜¯ ** ä¸€å¼ è´´å›¾åªèƒ½å¯¹åº”ç‰¹å®šçš„ä¸€ä¸ªæ¨¡å‹ï¼Œæ¨¡å‹ä¸èƒ½æœ‰å˜å½¢ (deform)**ã€‚\nå˜å½¢æ—¶ï¼Œé¡¶ç‚¹å…³ç³»æ”¹å˜äº†ï¼Œå³é¢çš„å½¢çŠ¶ï¼Œæ–¹å‘æ”¹å˜äº†ã€‚å¦‚æœé¢ä¸Šå­˜åœ¨ä¸€ä¸ªå›ºå®šçš„åæ ‡ç³»ï¼Œé‚£å½“ç‰©ä½“å˜å½¢ã€ç§»åŠ¨ã€æ—‹è½¬æ—¶ï¼Œè¿™ä¸ªåæ ‡ç³»å¿…å®šè·Ÿç€é¢ä¸€èµ·è¿åŠ¨ï¼Œé‚£ä¹ˆåœ¨è¿™ä¸ªåæ ‡ç³»é‡Œçš„æŸä¸ªç‚¹æˆ–å‘é‡ï¼Œä¸éœ€è¦å˜åŠ¨ã€‚å½“æ•´ä¸ªé¢å‘ç”Ÿå˜åŒ–æ—¶ï¼Œåªéœ€è¦è®¡ç®—é¢ä¸Šçš„åæ ‡ç³»åˆ°ä¸–ç•Œåæ ‡ç³»çš„è½¬æ¢çŸ©é˜µï¼Œé‚£ä¹ˆå®šä¹‰åœ¨è¿™ä¸ªé¢ä¸Šçš„ç‚¹æˆ–åæ ‡ï¼ˆå›ºå®šçš„ï¼‰, ä¹˜ä»¥è¿™ä¸ªçŸ©é˜µå³å¯å¾—åˆ°åœ¨ä¸–ç•Œä¸­çš„åæ ‡ã€‚è¿™ä¸ªåæ ‡ç³»æœ¯è¯­é‡Œç§°ä¸ºåˆ‡çº¿ç©ºé—´ï¼ˆTangent Spaceï¼‰ã€‚\nUV ä¸ TB çš„å…³ç³»  ä¸€ä¸ªé¡¶ç‚¹ç»“æ„ä¸­åŒ…å«å¾ˆå¤šä¿¡æ¯ï¼Œå…¶ä¸­å°±æœ‰é¡¶ç‚¹åœ¨ä¸‰ç»´ç©ºé—´ä¸­çš„ä½ç½®ä¿¡æ¯ï¼Œä»¥åŠé¡¶ç‚¹åœ¨å±•å¼€çš„ UV ä¸­çš„ UV åæ ‡ï¼Œä¸”ä¸‰ç»´ç©ºé—´ä¸‹ä¸‰è§’å½¢ä¸­çš„æ¯ä¸€ä¸ªç‚¹éƒ½å¿…èƒ½åœ¨ UV ä¸Šæ‰¾åˆ°å¯¹åº”çš„ç‚¹ï¼Œåä¹‹äº¦ç„¶ã€‚\n\n    \n\n\nå‡è®¾  çš„ä¸‰ä¸ªé¡¶ç‚¹ä»¥é€†æ—¶é’ˆæ’åˆ—ï¼Œåˆ™å¯¹äºç‚¹ ï¼Œå°† è®°ä¸º ã€ è®°ä¸º ï¼Œ ä»£è¡¨ Tangentï¼ˆåˆ‡çº¿ï¼‰ï¼Œä»£è¡¨ ** Bitangent**ï¼ˆå‰¯åˆ‡çº¿ï¼‰ã€‚è‹¥è®¾ï¼ŒUV åæ ‡ä¸ºã€ï¼ŒUV åæ ‡ä¸ºã€ï¼ŒUV åæ ‡ä¸ºï¼Œå¯¹åº”çš„çº¹ç†åæ ‡æ’å€¼ï¼š\nåˆ™æœ‰å¦‚ä¸‹å…¬å¼ï¼ˆï¼Œåˆ†åˆ«å’Œçº¹ç†åæ ‡è½´ ï¼Œ æ˜¯å¹³è¡Œçš„ï¼Œæ ¹æ®å‘é‡åŠ æ³•å¯å¾—ï¼‰ï¼š\nç”¨çŸ©é˜µæ¥è¡¨ç¤ºï¼šç»§è€Œå¾—å‡ºï¼š\n\n    \n\nåœ¨è¿™ç§ç‰¹æ®Šæƒ…å†µä¸‹ï¼Œæ­¤æ—¶çš„  æ˜¾ç„¶æ°å¥½ä¸ U åœ¨ä¸‰ç»´ç©ºé—´ä¸Šçš„æ˜ å°„æ–¹å‘ç›¸åŒã€åŒç†  ä¹Ÿä¸  æ–¹å‘ç›¸åŒã€‚ç›´è§‚ä¸Šï¼Œè¯¥å…¬å¼æè¿°çš„æ•°å­¦æ„ä¹‰æ˜¯ï¼Œå¦‚ä½•å°†ä¸€ä¸ªç‚¹ä» UV ç©ºé—´æ˜ å°„åˆ°ä¸‰ç»´ç©ºé—´ï¼Œå…¶ä¸­ TB ä½œä¸ºåŸºçŸ¢ï¼Œä»¥ UV ç©ºé—´ä¸­çš„ U å’Œ V çš„å¢é•¿ä½œä¸ºæ§åˆ¶å‚æ•°ã€‚å‡è®¾ä¸‰è§’å½¢ä¸­å­˜åœ¨ä¸€ç‚¹ ï¼Œåˆ™å‘é‡ï¼Œåªè¦çŸ¥é“ ç‚¹çš„ UV åæ ‡å€¼ï¼Œå³å¯å¾—åˆ°  ç‚¹çš„ä¸‰ç»´åæ ‡å€¼ã€‚\n\nå¦‚æœåœ¨ä¸‰ç»´ç©ºé—´ä¸‹å°†ä¸‰è§’å½¢åšä¸€ç‚¹æ‹‰ä¼¸ï¼Œå˜æˆå¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œåˆ™ UV å‘é‡åœ¨ä¸‰ç»´ç©ºé—´çš„æ–¹å‘å°†ä¸å†å‚ç›´ï¼Œä½†ä¾ç„¶å¯ä»¥å¾ˆæ–¹ä¾¿çš„è¾¨è®¤å‡ºçº¹ç†åæ ‡æ˜ å°„çš„ä½ç½®ã€‚\n\n    \n\n\nç›®å‰ç®—å‡ºæ¥çš„  è¿˜ä¸æ˜¯çœŸæ­£çš„åˆ‡çº¿ä¸å‰¯åˆ‡çº¿ï¼Œéœ€è¦ç»è¿‡æ­£äº¤åŒ–å¾—åˆ°  çŸ©é˜µï¼š\nEigen::Vector3f bump_fragment_shader(const fragment_shader_payload&amp; payload){        Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;     Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    float kh = 0.2, kn = 0.1;    // TODO: Implement bump mapping here    // Let n = normal = (x, y, z)    // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))    // Vector b = n cross product t    // Matrix TBN = [t b n]    // dU = kh * kn * (h(u+1/w,v)-h(u,v))    // dV = kh * kn * (h(u,v+1/h)-h(u,v))    // Vector ln = (-dU, -dV, 1)    // Normal n = normalize(TBN * ln)    auto n = normal.normalized();    Eigen::Vector3f t;    t &lt;&lt; n.x() * n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z()),        std::sqrt(n.x() * n.x() + n.z() * n.z()),        n.z()* n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z());    auto b = n.cross(t);    Eigen::Matrix3f TBN;    TBN &lt;&lt; t, b, n;        float w = payload.texture-&gt;width;    float h = payload.texture-&gt;height;    auto texcoord = payload.tex_coords;    auto dU = kh * kn * (payload.texture-&gt;getColor(texcoord.x() + 1 / w, texcoord.y()).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    auto dV = kh * kn * (payload.texture-&gt;getColor(texcoord.x(), texcoord.y() + 1 / h).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    Eigen::Vector3f ln;    ln &lt;&lt; -dU, -dV, 1.0f;    normal = TBN * ln;    normal = normal.normalized();    Eigen::Vector3f result_color = {0, 0, 0};    result_color = normal;    return result_color * 255.f;}\n\n\n    \n\n\nDisplacement Mappingåœ¨ Bump çš„åŸºç¡€ä¸Šåº”ç”¨äº† Blinn-Phong æ¨¡å‹\nEigen::Vector3f displacement_fragment_shader(const fragment_shader_payload&amp; payload){        Eigen::Vector3f ka = Eigen::Vector3f(0.005, 0.005, 0.005);    Eigen::Vector3f kd = payload.color / 255.0f;    Eigen::Vector3f ks = Eigen::Vector3f(0.7937, 0.7937, 0.7937);    auto l1 = light{{20, 20, 20}, {500, 500, 500}};    auto l2 = light{{-20, 20, 0}, {500, 500, 500}};    std::vector&lt;light&gt; lights = {l1, l2};    Eigen::Vector3f amb_light_intensity{10, 10, 10};    Eigen::Vector3f eye_pos{0, 0, 10};    float p = 150;    Eigen::Vector3f color = payload.color;     Eigen::Vector3f point = payload.view_pos;    Eigen::Vector3f normal = payload.normal;    float kh = 0.2, kn = 0.1;        // TODO: Implement displacement mapping here    // Let n = normal = (x, y, z)    // Vector t = (x*y/sqrt(x*x+z*z),sqrt(x*x+z*z),z*y/sqrt(x*x+z*z))    // Vector b = n cross product t    // Matrix TBN = [t b n]    // dU = kh * kn * (h(u+1/w,v)-h(u,v))    // dV = kh * kn * (h(u,v+1/h)-h(u,v))    // Vector ln = (-dU, -dV, 1)    // Position p = p + kn * n * h(u,v)    // Normal n = normalize(TBN * ln)        auto n = normal.normalized();    Eigen::Vector3f t;    t &lt;&lt; n.x() * n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z()),        std::sqrt(n.x() * n.x() + n.z() * n.z()),        n.z()* n.y() / std::sqrt(n.x() * n.x() + n.z() * n.z());    auto b = n.cross(t);    Eigen::Matrix3f TBN;    TBN &lt;&lt; t, b, n;    float w = payload.texture-&gt;width;    float h = payload.texture-&gt;height;    auto texcoord = payload.tex_coords;    auto dU = kh * kn * (payload.texture-&gt;getColor(texcoord.x() + 1 / w, texcoord.y()).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    auto dV = kh * kn * (payload.texture-&gt;getColor(texcoord.x(), texcoord.y() + 1 / h).norm() - payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm());    Eigen::Vector3f ln;    ln &lt;&lt; -dU, -dV, 1.0f;    point = point + kn * n * payload.texture-&gt;getColor(texcoord.x(), texcoord.y()).norm();    normal = TBN * ln;    normal = normal.normalized();        Eigen::Vector3f result_color = {0, 0, 0};    for (auto&amp; light : lights)    {        // TODO: For each light source in the code, calculate what the *ambient*, *diffuse*, and *specular*         // components are. Then, accumulate that result on the *result_color* object.        Eigen::Vector3f v = (eye_pos - point).normalized();        Eigen::Vector3f l = (light.position - point).normalized();        auto r = l.dot(l);        auto h = (v + l).normalized();        auto ls = ks.cwiseProduct(light.intensity / r) * std::pow(std::max(0.0f, normal.normalized().dot(h)), p);        auto la = ka.cwiseProduct(amb_light_intensity);        auto ld = kd.cwiseProduct(light.intensity / r) * std::max(0.0f, normal.normalized().dot(l));        result_color += (la + ld + ls);    }    return result_color * 255.f;}\n\n\n    \n\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"ç°ä»£å›¾å½¢å­¦å…¥é—¨","url":"/2021/11/04/1/","content":"\n    \n\n\n\n\nRasterizationWhatâ€™s After MVP?\nModel transformation (placing objects)\nView transformation (placing camera)\nProjection transformation\nOrthographic projection (cuboid to â€œcanonicalâ€ cube)\nPerspective projection (frustun to â€œcanonicalâ€ cube)\n\n\n\nSampling Artifacts in Computer Graphics\nSignal are changing too fast (high frequency), but sampled too slowly\n\nSampling = Repeat Frequency Contents\n\nAliasing = Mixed Frequency Contents\n\nAntialiasing = Limit, then repeating\n\nMSAA (Multi-Sample AA)\nFXAA (Fast Approximate AA å›¾åƒçš„åå¤„ç†æ–¹æ³•ï¼‰ \nTAA (Temporal AA åˆ©ç”¨ä¸Šä¸€å¸§çš„ä¿¡æ¯ï¼‰\n\n\n\nVisibility / OcclusionPainterâ€™s AlgorithmPaint from back to front, overwirte in the framebuffer\nZ-Buffer\nStore current min. z-value for each sample (pixel)\nNeed an additional buffer for depth values\nframe buffer stores color values\ndepth buffer stores (z-buffer) depth\n\n\nz is always positive value\nsamller z -&gt; closer\nlarger z -&gt; further\n\n\n\nZ-Buffer Algorithm\nInitialize depth buffer to \nDuring rasterization:\n\nfor (each triangle T)    for (each sample (x, y, z) in T)        if (z &lt; zbuffer[x, y])            framebuffer[x, y] = rgb;            zbuffer[x, y] = z        else            ...\n\nShadingDefinition\nIn Merriam-Webster Dictionary\nThe darkening or coloring of an illustration or diagram with parallel lines or a block of color.\n\nIn Compute Graphics\nThe process of applying a material to an object.ä¸åŒç‰©ä½“åº”ç”¨ä¸ç”¨çš„æè´¨ã€‚\n\n\nLambertian (Diffuse) Shading\n\n: diffusely reflected light: diffuse coefficient (color) å¦‚æœ  æ˜¯ä¸€ä¸ªè¡¨ç¤ºé¢œè‰²çš„å‘é‡ï¼Œå¯ä»¥è¡¨ç¤ºåœ¨ shading point ä¸Šå¸æ”¶ / åå°„çš„é¢œè‰²: engry arrived at the shading point: engry received by the shading point\n\næ¼«åå°„æ–¹å‘å’Œè§†è§’æ–¹å‘æ²¡æœ‰å…³ç³»\n\nSpecular Term (Blinn-Phong)\nè§‚å¯Ÿæ–¹å‘å’Œé•œé¢åå°„çš„æ–¹å‘æ¥è¿‘çš„æ—¶å€™ï¼Œå°±èƒ½å¾—åˆ°é«˜å…‰\n close to mirror direction  half vector near normal\n\n\n\nç»™å®šå…¥å°„æ–¹å‘å’Œæ³•çº¿æ–¹å‘ï¼Œä¹Ÿå¯ä»¥ç®—å‡ºåå°„æ–¹å‘è¿›è€Œè®¡ç®—å‡ºé«˜å…‰é¡¹ï¼Œä½†è®¡ç®—é‡ä¸Šè¦æ¯”åŠç¨‹å‘é‡å¤æ‚\næŒ‡æ•°ï¼šç‚¹ä¹˜å‘é‡èƒ½ä½“ç°ä¸¤ä¸ªå‘é‡æ˜¯å¦è¶³å¤Ÿæ¥è¿‘ï¼Œç”¨æ¥æ§åˆ¶é«˜å…‰çš„å¤§å°\n\nAmbient Term\nAdd constant color to account for disregarded illumination and fill in black shadows\nThis is approximate\n\nGraphics Pipeline\nInterpolation Across Triangles\nWhy do we want to interpolate?\n\nSpecify values at vertices \nObtain smoothly varying values across triangles â€“å¸Œæœ›åœ¨ä¸‰è§’å½¢å†…éƒ¨å®ç°å¹³æ»‘è¿‡æ¸¡\n\n\nWhat do we want to interpolate?\n\nTexture coordinates, colors, normal vectors, â€¦ â€“å¯ä»¥å¯¹ä¸‰è§’å½¢ä¸Šä»»æ„å±æ€§è¿›è¡Œæ’å€¼\n\n\nHow do we interpolate?\n\nBarycentric coordinates\n\n\n\nBarycentric CoordinatesA coordinate system for triangles \n\n\n\né‡å¿ƒåæ ‡ï¼šä¸‰è§’å½¢æ‰€åœ¨å¹³é¢ä¸Šä»»æ„ä¸€ç‚¹éƒ½å¯ä»¥è¡¨ç¤ºä¸‰ä¸ªé¡¶ç‚¹åæ ‡çš„çº¿æ€§ç»„åˆï¼Œæ¡ä»¶æ˜¯çº¿æ€§ç»„åˆçš„ç³»æ•°ä¹‹å’Œä¸º 1Inside the triangle if all three coordinates are non-negative\n\nTexture MappingSimple Texture Mappingfor each rasterized screen sample (x, y): // usually a pixel's center    (u, v) = evaluate texture coordinate at (x, y); // using barycentric coordinateï¼ˆé‡å¿ƒåæ ‡ï¼‰    texcolor = texture.sample(u, v);    set sample's color to texcolor; // using the diffuse albedo Kd\n\n\nä¸€ç§è§£é‡Šæ–¹æ³•  å‡è®¾éœ€è¦ç”¨çš„çº¹ç†ï¼ˆæ¯”å¦‚æ˜¯ï¼‰æ¸²æŸ“å·¦è¾¹çš„ä¸¤ä¸ªä¸‰è§’å½¢ï¼ˆæ¯”å¦‚æ˜¯ï¼‰ï¼Œä½†æ˜¯çº¹ç†å¹³é¢éå¸¸å°ï¼Œé‚£ä¹ˆæœ€åå¯¼è‡´çš„ç»“æœå°±æ˜¯ä¸€ä¸ªçº¹ç´ è¦å¯¹åº” 4 ä¸ªåƒç´ ï¼Œè¿™æ ·åœ¨å®é™…æ¸²æŸ“æ—¶äº§ç”Ÿçš„æ•ˆæœå°±æ˜¯çº¹ç†è¢«æ‹‰ä¼¸ï¼Œè§†è§‰ä¸Šä¼šæœ‰æ¨¡ç³Šçš„æ„Ÿè§‰\nå¦ä¸€ç§è§£é‡Šæ–¹æ³•  çº¹ç†æ˜ å°„çš„è¿‡ç¨‹ä¼šæ ¹æ®ç›®æ ‡ç‚¹ç¦»ç›¸æœºçš„è¿œè¿‘ï¼Œå ç”¨å±å¹•ä¸Šä¸åŒå¤§å°çš„èŒƒå›´çš„åƒç´ ï¼Œä¾‹å¦‚ä¸€ä¸ªä¸‰è§’é¢åœ¨è·ç¦»ç›¸æœº 20m æ—¶å ç”¨ 100 ä¸ªå±å¹•åƒç´ ï¼Œå½“ä¸‰è§’é¢ç¦»ç›¸æœºæ›´è¿œæ—¶ä¼šçœ‹èµ·æ¥æ›´å°ï¼Œæ­¤æ—¶å¯èƒ½å ç”¨ 20 ä¸ªå±å¹•åƒç´ ï¼Œä½†æ˜¯åœ¨ä¸¤ç§æƒ…å†µä¸‹è¿™ä¸ªä¸‰è§’é¢ä½¿ç”¨çš„çº¹ç†è´´å›¾çš„å¤§å°æ˜¯ä¸å˜çš„ã€‚æ¢å¥è¯è¯´ï¼Œç”±äºçº¹ç†åŒ–è¡¨é¢å¯ä»¥ç›¸å¯¹äºè§‚å¯Ÿè€…å¤„äºä»»æ„è·ç¦»å’Œæœå‘ï¼Œå› æ­¤ä¸€ä¸ªåƒç´ é€šå¸¸ä¸ç›´æ¥å¯¹åº”äºä¸€ä¸ªçº¹ç†åƒç´ ã€‚å¿…é¡»åº”ç”¨æŸç§å½¢å¼çš„æ»¤æ³¢æ¥ç¡®å®šåƒç´ çš„æœ€ä½³é¢œè‰²\n\nTexture Magnification çº¹ç†æ”¾å¤§ What if the texture is too small? å°±æ˜¯è¯´ç›¸å¯¹äºè¦æ¸²æŸ“çš„ç‰©ä½“ï¼Œçº¹ç†çš„åˆ†è¾¨ç‡ä¸å¤ªé«˜\nç”±äºè¦æ¸²æŸ“çš„ç‰©ä½“å¤§äºçº¹ç†å¹³é¢ï¼Œæ‰€ä»¥ç‰©ä½“ä¸­çš„ä¸€äº›éƒ¨åˆ†å¯¹åº”åˆ°çº¹ç†å¹³é¢åæ ‡å¯èƒ½å°±ä¸æ˜¯æ•´æ•°äº†ï¼Œè€Œæ˜¯å°æ•°\n\n\nNearest\n\nBilinear\n\nLinear interpolation(1D)\nTwo helper lerps\n\n\nåŒçº¿æ€§æ’å€¼å…¶å®å°±æ˜¯æ¨ªå‘å’Œçºµå‘ä¸¤ä¸ªæ–¹å‘åšæ’å€¼\n\nBicubic\n\n\nWhat if the texture is too large?å¦ä¸€ç§æƒ…å†µå°±æ˜¯çº¹ç†ç›¸æ¯”äºè¦æ¸²æŸ“çš„ç‰©ä½“å¤§ï¼Œè¿™æ ·å°±ä¼šå¯¼è‡´çº¹ç†ç¼©å°ï¼Œå³ä¸€ä¸ªåƒç´ ä¼šè¦†ç›–å¤šä¸ªçº¹ç´ \n\né™¤äº†çº¹ç†åˆ†è¾¨ç‡å¤§äºè¦æ¸²æŸ“çš„ç‰©ä½“ï¼Œåœ¨å¦‚ä¸‹æƒ…å†µä¸­ä¹Ÿä¼šå‡ºç°  çº¹ç†ç¼©å°  çš„é—®é¢˜ï¼ˆé€šè¿‡é€è§†æŠ•å½±å°†ç‰©ä½“æ˜ å°„åˆ°å¹³é¢ï¼Œä¼šé€ æˆè¿‘å¤„çº¹ç†å¤§ï¼Œè¿œå¤„çº¹ç†å°çš„è§†è§‰æ•ˆæœï¼‰ã€‚æ¢å¥è¯è¯´å°±æ˜¯è¿‘å¤„çš„ä¸€ä¸ªåƒç´ å¯èƒ½åªè¦†ç›–ä¸€ä¸ªçº¹ç´ ï¼Œæˆ–è€…ä¸€ä¸ªçº¹ç´ è¦†ç›–å¤šä¸ªåƒç´ ï¼ˆè¿™ç§æƒ…å†µå¯ç”¨åŒçº¿æ€§æ’å€¼è§£å†³ï¼‰ï¼Œä½†å¯¹äºè¿œå¤„çš„åƒç´ è€Œè¨€ï¼Œä¸€ä¸ªåƒç´ ä¼šè¦†ç›–å¤šä¸ªçº¹ç´ ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ˆè“ç‚¹è¡¨ç¤ºä¸€ä¸ªåƒç´ ç‚¹ï¼Œæ¡†è¡¨ç¤ºè¯¥åƒç´ ç‚¹æ‰€èƒ½è¦†ç›–çš„çº¹ç´ æ•°é‡ï¼‰\n\nMipmapAllowing (fast, approx., square) range quries.\nâ€œMipâ€ comes from the Latin â€œmultum in parvoâ€, meaning a multitude in a small space.\nComputing Mipmap Level D\n\nåˆ©ç”¨é‡å¿ƒåæ ‡æ˜ å°„åˆ°çº¹ç†åæ ‡\nè®¡ç®—å‡ºçº¹ç†ä¸Šè¿‘ä¼¼æ­£æ–¹åŒºåŸŸçš„è¾¹é•¿\n\n\nTrilinear Interpolation\nLinear interpolation based on continuous D value\nMipmap limitations: overblur\nGeometryImplicit Geometry\nPoints satisfy some specified relationshipE.g. sphere: all points in 3D, where . More generally, .\n\nConstructive Solid GeometryCombine implict geometry via Boolean operations.\n\nDistance Functions\n\nFractals\n\n\nExplict GeometryAll points are given directly or via parameter mapping.\n\nPoint Cloud\n\n Curvede Castekjau AlgorithmEvaluating  Curves Algebraic Formula\nExample: quadratic  curve from three points\n\n\ntå¯ä»¥ç†è§£ä¸ºæŸä¸€æ—¶åˆ»\n\n\nBernstein form of a  curve of order n:\n\n:  control points: Bernstein polynomial\n\n\n SurfacesShadow MappingRender from light\ndepth image from light source ï¼ˆåªéœ€è¦æ·±åº¦å›¾ï¼‰\n\nRender from eye\nStandard image (with depth) from eye\n\nProject to light\nProject visible points in eye view back to light source\nCompare the depths from light and eye\n\nRay TracingRecursive (Whitted-Style) Ray TracingRay-Surface Intersection\nRay equation:\n\nRay intersection with sphere\nSphere: \n\nRay intersection with implicit surface\nGeneral implicit surface: Solve for real, positive roots\n\nRay intersection with triangle mesh\nPlane equation (if  satisfies it, then  is on the plane):\nSolve for intersection\n\n\n\nA faster approach, giving barycentric coordinateï¼ˆé‡å¿ƒåæ ‡ï¼‰ directly\n\n\nRay Intersection with Axis-Aligned Bounding Box\nThe ray enters the box only when it enters all pairs of slabs\nThe ray exits the box as long as it exits any pair of slabs\nFor each pair, calcute the  and  (negative is fine)\nFor the 3D box, , \nif , we know ray stays a while in the box.\n\n\n\nSpatial Partitionsï¼ˆç©ºé—´åˆ’åˆ†ï¼‰\nOct-Tree\nKD-Tree\nBSP-Tree\n\nObject Partitionsï¼ˆç‰©ä½“åˆ’åˆ†ï¼‰ &amp; Bounding Volume Hierarchy (BVH)Radiometryï¼ˆè¾å°„åº¦é‡å­¦ï¼‰\nRadiant Energy and Flux (Power)\n\nå¼ºåº¦\nèƒ½é‡ \n\n\nImport Light Measurements of Interest\n\nRadiant Intensity: power per solid angle\nSolid Angleï¼ˆç«‹ä½“è§’ï¼‰\nIrradianceï¼ˆè¾å°„ç…§åº¦ï¼‰: power per unit area\nRadianceï¼ˆè¾å°„äº®åº¦ï¼‰: power per unit solid angle, per projected unit area.\n\n\nIrradiance vs.Radiance\n\nIrradiance: total power received by area \nRadiance: power received by area  from â€œdirectionâ€ \n\n\n\n**radiance æ˜¯æ¥è‡ªå››é¢å…«æ–¹çš„ irradiance ** çš„å’Œï¼ˆç§¯åˆ†ï¼‰\n\n\n\nBidirectional Reflectance Distribution Function (BRDF)Refection at a point\nå¦‚æœæœ‰ä¸€æŸå…‰çº¿è¿›å…¥ï¼Œä¸åŒçš„åå°„æ–¹å‘ä¸Šçš„èƒ½é‡åˆ†å¸ƒã€‚\n\nThe BRDF represents how much light is reflected into each outgoing direction  from each incoming direction\nThe Reflection Equation\nThe Rendering Equationby adding an Emission term ot make it general\n\n\n: Reflected Light\n: Emissionï¼ˆè‡ªå‘å…‰ï¼‰\n: Incident Light\n: BRDF\n: Cosine of Incident angle\n\nRendering Equation as Intergral Equation\n\n: Emission directly from light sources  Shading in Rasterization\n: Direct Illumination on surfaces  Shading in Rasterization\n: Indirect Illumination(one bounce indirect)[mirrors, refraction]\n: Two bounce indirect illum.\n\nPath TracingMaterials and AppearancesDiffuse / Lambertian Material\næ¼«åå°„ç³»æ•°\n\n\n\nDiffuseâ€™s BRDF:  ä¸ºåå°„ç‡ (albedo)\n\nGlossy MaterialPerfect Specular Reflection\n\n\n\nä¸¤ä¸ªå‘é‡  å’Œçš„å’Œä¸€å®šæ²¿ç€æ³•å‘é‡çš„æ–¹å‘ï¼Œé•¿åº¦æ˜¯ 2 å€çš„çº¢é¢œè‰²çš„é•¿åº¦ï¼Œå³å…¥å°„æ–¹å‘æŠ•å½±åˆ°æ³•çº¿æ–¹å‘çš„é•¿åº¦ï¼ˆï¼‰çš„ 2 å€\n\nSpecular Refraction\nSnellâ€™s Law\n\nFresnel Reflection / TermMicroFacet MaterialMicrofacet Theory\nMacroscale: flat &amp; rough\nMicroscale: bumpyï¼ˆå‡¹å‡¸çš„ï¼‰ &amp; specular\n\nMicroface BRDF\n\n: Frenel term\n: shadowing-masking termï¼ˆå¾®è¡¨é¢çš„è‡ªé®æŒ¡ã€è‡ªæŠ•å½±å¤„ç†ï¼‰\n: distribution of normals\n\nProperties of BRDFs\nNon-negativity\nLinearity\nReciprocity principleï¼ˆå¯é€†æ€§ï¼‰\nEnergy conservationï¼ˆèƒ½é‡å®ˆæ’ï¼‰\nIsotropicï¼ˆå„é¡¹å¼‚æ€§ï¼‰ &amp; Anisotropicï¼ˆå„é¡¹åŒæ€§ï¼‰\n\nMeasuring BRDFsCameras, Lensesï¼ˆæ£±é•œï¼‰ and Light Fieldsï¼ˆå…‰åœºï¼‰\nField of View\n\nIt it common to refer to angular field of view by focal lengthï¼ˆç„¦è·ï¼‰ of a lens used on a 35mm-format film(36  24mm)\n\n\nExposure\n\n\nExposure = time  irradiance\nExposure time:\nControl by shutter\n\n\nIrradiance:\nPower of light falling on a unit area of sensor\nControlled by lens apertureï¼ˆå…‰åœˆï¼‰ and focal length\n\n\n\n\nExposure Controls in Photography\nAperture size: Change the f-stop by opening / closing the aperture\nf-stop æ•°è¶Šå¤§å…‰åœˆè¶Šå°\nF-Number definiton: the focal length divided by the diameter of the aperture\n\n\nShutter speed\nIOS gainï¼ˆæ„Ÿå…‰åº¦ï¼‰\n\n\n\n\nDepth of Fieldï¼ˆæŒ‡æˆåƒæ¸…æ™°çš„ä¸€æ®µèŒƒå›´ï¼‰\n\n\nColor and PerceptionAddtive Colorï¼ˆåŠ è‰²ç³»ç»Ÿï¼‰\nGiven a set of primary lights, each with its own spectral distribution\n, , \n\n\nAdjust the brightness of these lights and add them together\n\n\n\n\nColor Spaces\nStandardized RGB(sRGB)\n\nPerceptually Organized Color Spaces\n\nHSV Color Space(Hue-Saturation-Value)\nHue: è‰²è°ƒ\nSaturation: é¥±å’Œåº¦\nValue: äº®åº¦\n\n\nL*a*b*\nL* is lightness\na* and b* are color-opponentï¼ˆäº’è¡¥è‰²ï¼‰ pairs\na* is red-green\nb* is blue-yellow\n\n\n\n\nCMYK: A Subtractive Color Space\n\nCyan, Magenta, Yellow and Key Widely\n\n\n\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"é¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨","url":"/2021/11/12/11/","content":"\n\né¡¶ç‚¹ç€è‰²å™¨\né¡¶ç‚¹ç€è‰²å™¨è´Ÿè´£çš„åŠŸèƒ½æ˜¯æŠŠè¾“å…¥çš„æ•°æ®è¿›è¡Œ  åæ ‡å˜æ¢ï¼Œè®¡ç®—å…‰ç…§å…¬å¼ç”Ÿæˆæ¯ä¸ªç‚¹é¢œè‰²ï¼Œè®¡ç®—çº¹ç†åæ ‡ã€‚å¹¶ä¸”æŠŠä½ç½®å’Œçº¹ç†åæ ‡å‘é€åˆ°ç‰‡å…ƒç€è‰²å™¨ã€‚\nè¾“å…¥å‚æ•°\nattributeï¼šç©ºé—´åæ ‡ã€æ³•å‘é‡ã€çº¹ç†åæ ‡åŠé¡¶ç‚¹é¢œè‰²ã€‚\nuniformï¼šuniformä¿å­˜ç”±åº”ç”¨ç¨‹åºä¼ é€’ç»™ç€è‰²å™¨çš„åªè¯»å¸¸é‡æ•°æ®ã€‚åœ¨é¡¶ç‚¹ç€è‰²å™¨ä¸­ï¼Œè¿™äº›æ•°æ®é€šå¸¸æ˜¯å˜æ¢çŸ©é˜µã€å…‰ç…§å‚æ•°ã€é¢œè‰²ç­‰ã€‚ç”± uniform ä¿®é¥°ç¬¦ä¿®é¥°çš„å˜é‡å±äºå…¨å±€å˜é‡ã€‚\nsamplerï¼šä¸€ç§ç‰¹æ®Šçš„ uniformï¼Œç”¨äºå‘ˆç°çº¹ç†ã€‚sampler å¯ç”¨äºé¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡å…ƒç€è‰²å™¨ã€‚\n\nè¾“å‡ºå‚æ•°\nvaryingï¼šç”¨äºå­˜å‚¨é¡¶ç‚¹ç€è‰²å™¨çš„è¾“å‡ºæ•°æ®ï¼Œvaryingå˜é‡ä¼šåœ¨å…‰æ …åŒ–å¤„ç†é˜¶æ®µè¢«çº¿æ€§æ’å€¼ã€‚\ngl_Positionï¼šä½ç½®ä¿¡æ¯\ngl_PointSizeï¼šç‚¹å¤§å°\n\nç‰‡å…ƒç€è‰²å™¨\nç‰‡å…ƒç€è‰²å™¨çš„ä½œç”¨æ˜¯å¤„ç†ç”±å…‰æ …åŒ–é˜¶æ®µç”Ÿæˆçš„æ¯ä¸ªç‰‡å…ƒï¼Œæœ€ç»ˆè®¡ç®—å‡ºæ¯ä¸ªåƒç´ çš„æœ€ç»ˆé¢œè‰²ã€‚å½’æ ¹ç»“åº•ï¼Œå®é™…ä¸Šå°±æ˜¯æ•°æ®çš„é›†åˆã€‚è¿™ä¸ªæ•°æ®é›†åˆåŒ…å«æ¯ä¸ªåƒç´ çš„å„ä¸ªé¢œè‰²åˆ†é‡å’Œåƒç´ é€æ˜åº¦çš„å€¼ã€‚\nè¾“å…¥å‚æ•°\nshader programï¼šç”± main å£°æ˜çš„ä¸€æ®µç¨‹åºæºç ï¼Œæè¿°åœ¨ç‰‡å…ƒä¸Šæ‰§è¡Œçš„æ“ä½œã€‚\nvaryingï¼šé¡¶ç‚¹ç€è‰²å™¨é˜¶æ®µè¾“å‡ºçš„ varying å˜é‡åœ¨å…‰æ …åŒ–é˜¶æ®µè¢«çº¿æ€§æ’å€¼åè¾“å‡ºåˆ°ç‰‡å…ƒç€è‰²å™¨ä½œä¸ºå®ƒçš„è¾“å…¥ã€‚\nuniformï¼šç”¨äºç‰‡å…ƒç€è‰²å™¨çš„å¸¸é‡ï¼Œå¦‚çº¹ç†å‚æ•°ç­‰ã€‚\nsamplerï¼šä¸€ç§ç‰¹æ®Šçš„uniformï¼Œç”¨äºå‘ˆç°çº¹ç†ã€‚\n\nè¾“å‡ºå‚æ•° gl_FragColorï¼šåœ¨é¡¶ç‚¹ç€è‰²å™¨é˜¶æ®µåªæœ‰å”¯ä¸€çš„varying è¾“å‡ºå˜é‡gl_FragColorã€‚\n","categories":["Learning OpenGL"],"tags":["Graphics","OpenGL"]},{"title":"å„ç§æ•°æ®ç»“æ„åŠå…¶åº•å±‚å®ç°","url":"/2021/11/12/12/","content":"\nvectorï¼šåº•å±‚æ•°æ®ç»“æ„ä¸ºæ•°ç»„ï¼Œæ”¯æŒå¿«é€Ÿéšæœºè®¿é—®ã€‚\næ‰©å®¹è§„åˆ™ä¸ºï¼šå½“æ–°å»ºä¸€ä¸ª vector æ—¶ï¼Œä¼šé¦–å…ˆåˆ†é…ä¸€å—è¿ç»­çš„å†…å­˜ç©ºé—´ï¼Œå½“å‘å…¶ä¸­å¢åŠ å…ƒç´ æ˜¯ï¼Œå¦‚æœåˆå§‹åˆ†é…ç©ºé—´å·²æ»¡ï¼Œå°±ä¼šå¼•èµ· vector æ‰©å®¹ã€‚é¦–å…ˆé‡æ–°ç”³è¯·ä¸€ä¸ª 2 å€å¤§çš„å†…å­˜ç©ºé—´ï¼›ç„¶åå°†åŸç©ºé—´çš„å†…å®¹æ‹·è´è¿‡æ¥ï¼›æœ€åå°†åŸç©ºé—´å†…å®¹è¿›è¡Œé‡Šæ”¾ï¼Œå°†å†…å­˜äº¤è¿˜ç»™æ“ä½œç³»ç»Ÿã€‚\nåœ¨æ’å…¥ä½ç½®å’Œåˆ é™¤ä½ç½®ä¹‹åçš„å¤šæœ‰è¿­ä»£å™¨å’ŒæŒ‡é’ˆå¼•ç”¨éƒ½ä¼šå¤±æ•ˆï¼ŒåŒç†ï¼Œæ‰©å®¹ä¹‹åçš„æ‰€æœ‰è¿­ä»£å™¨æŒ‡é’ˆå’Œå¼•ç”¨ä¹Ÿéƒ½ä¼šå¤±æ•ˆã€‚\n\n\nlistï¼šåŒå‘é“¾è¡¨ï¼Œæ”¯æŒå¿«é€Ÿå¢åˆ ã€‚\ndequeï¼šåº•å±‚ä¸ºä¸€ä¸ªä¸­å¤®æ§åˆ¶å™¨å’Œå¤šä¸ªç¼“å†²åŒºï¼Œæ”¯æŒæ”¶å°¾å¿«é€Ÿå¢åˆ ï¼Œä¹Ÿæ”¯æŒéšæœºè®¿é—®ã€‚dequeæ˜¯ä¸€ä¸ªåŒç«¯é˜Ÿåˆ—ï¼ˆdouble-ended queueï¼‰ï¼Œçœ‹èµ·æ¥åƒæ˜¯ list å’Œvectorçš„ç»“åˆå“ã€‚\nstackï¼šåº•å±‚ä¸€èˆ¬ç”¨ list æˆ–dequeå®ç°ï¼Œå°é—­å¤´éƒ¨å³å¯ï¼Œä¸ç”¨ vector çš„åŸå› æ˜¯å®¹é‡å¤§å°æœ‰é™åˆ¶ï¼Œæ‰©å®¹è€—æ—¶ã€‚\nqueueï¼šå•å‘é˜Ÿåˆ—ï¼Œä¸ºå…ˆå…¥å…ˆå‡ºåŸåˆ™ã€‚\nproority_queueï¼šæ ¹æ®å †çš„å¤„ç†è§„åˆ™æ¥è°ƒæ•´å…ƒç´ ä¹‹é—´çš„ä½ç½®ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—ç›¸å½“äºä¸€ä¸ªæœ‰æƒå€¼çš„å•å‘é˜Ÿåˆ— queueï¼Œåœ¨è¿™ä¸ªé˜Ÿåˆ—ä¸­ï¼Œæ‰€æœ‰å…ƒç´ æ˜¯æŒ‰ç…§ä¼˜å…ˆçº§æ’åˆ—çš„ã€‚æ ¹æ®å †çš„ç‰¹æ€§ï¼Œä¼˜å…ˆçº§é˜Ÿåˆ—å®ç°äº†  å–å‡ºæœ€å¤§æœ€å°å…ƒç´   æ—¶é—´å¤æ‚åº¦ä¸º , å¯¹äº æ’å…¥å’Œåˆ é™¤ï¼Œå…¶æœ€åæƒ…å†µä¸ºã€‚\nsetï¼šçº¢é»‘æ ‘ï¼Œæœ‰åºï¼Œä¸é‡å¤ã€‚\nmultisetï¼šçº¢é»‘æ ‘ï¼Œæœ‰åºï¼Œå¯é‡å¤ã€‚\nmapï¼šçº¢é»‘æ ‘ï¼Œæœ‰åºï¼Œä¸é‡å¤ï¼Œå¯ä»¥å®ç°  çš„æŸ¥æ‰¾ï¼Œæ’å…¥å’Œåˆ é™¤ã€‚\nmultimapï¼šçº¢é»‘æ ‘ï¼Œæœ‰åºï¼Œå¯é‡å¤ï¼Œå¯ä»¥å®ç°  çš„æŸ¥æ‰¾ï¼Œæ’å…¥å’Œåˆ é™¤ã€‚\nunordered_setï¼šhash è¡¨ï¼Œæ— åºï¼Œä¸é‡å¤ã€‚\nunordered_multisetï¼šhash è¡¨ï¼Œæ— åºï¼Œä¸é‡å¤ã€‚\nunordered_mapï¼šhash è¡¨ï¼Œæ— åºï¼Œä¸é‡å¤ï¼ŒæŸ¥æ‰¾  æ—¶é—´å¤æ‚åº¦ç†è®ºä¸Šè¾¾åˆ°äº†ã€‚\nunordered_multimapï¼šhash è¡¨ï¼Œæ— åºï¼Œä¸é‡å¤ï¼ŒæŸ¥æ‰¾  æ—¶é—´å¤æ‚åº¦ç†è®ºä¸Šè¾¾åˆ°äº†ã€‚\n\n","categories":["æ•°æ®ç»“æ„"],"tags":["æ•°æ®ç»“æ„"]},{"title":"å±±åŠ¿éƒå´”åµ¬ï¼Œä¹‹ç½˜å…¥æµ·æ¥","url":"/2021/11/15/13/","content":"\n","categories":["ç›¸å†Œ"],"tags":["çƒŸå°"]},{"title":"è”¬é£Ÿæˆä¹¦","url":"/2021/11/15/14/","content":"æ–°æ´¥éŸ­é»„å¤©ä¸‹æ— ï¼Œè‰²å¦‚é¹…é»„ä¸‰å°ºä½™ã€‚ä¸œé—¨  å½˜è‚‰æ›´å¥‡ç»ï¼Œè‚¥ç¾ä¸å‡èƒ¡ç¾Šé…¥ã€‚è´µç  è®µæ•¢æ‚å¸¸  é¦”ï¼Œæ¡‚ç‚Šè–ç±³åœ†æ¯”ç ã€‚è¿˜å´æ­¤å‘³é‚£å¤æœ‰ï¼Œæ—¥é¥­è„±ç²Ÿç„šæ¯é±¼ã€‚äººç”Ÿå£è…¹ä½•è¶³é“ï¼Œå¾€å¾€åå½¹ä¸ƒå°ºèº¯ã€‚è†»è¤ä»ä»Šä¸€æ‰«é™¤ï¼Œå¤œç…®ç™½çŸ³ç¬ºé˜´ç¬¦ã€‚\n\n\n\n    .cd-timeline.svelte-1t2uafz .svelte-1t2uafz,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::after,.cd-timeline.svelte-1t2uafz .svelte-1t2uafz::before{-webkit-box-sizing:border-box;box-sizing:border-box}.cd-timeline.svelte-1t2uafz{font-size:1.6rem;font-family:\"Droid Serif\", serif;color:#7f8c97;background-color:#e9f0f5}.cd-timeline.svelte-1t2uafz a{color:#acb7c0;text-decoration:none}.cd-timeline.svelte-1t2uafz img{max-width:100%}.cd-timeline.svelte-1t2uafz h1,h2{font-family:\"Open Sans\", sans-serif;font-weight:bold}.cd-timeline.svelte-1t2uafz{overflow:hidden;margin:2em auto}.cd-timeline__container.svelte-1t2uafz{position:relative;width:90%;max-width:1170px;margin:0 auto;padding:2em 0}.cd-timeline__container.svelte-1t2uafz::before{content:'';position:absolute;top:0;left:18px;height:100%;width:4px;background:#d7e4ed}@media only screen and (min-width: 1170px){.cd-timeline.svelte-1t2uafz{margin-top:3em;margin-bottom:3em}.cd-timeline__container.svelte-1t2uafz::before{left:50%;margin-left:-2px}}.cd-timeline__block.svelte-1t2uafz{position:relative;margin:2em 0}.cd-timeline__block.svelte-1t2uafz:after{content:\"\";display:table;clear:both}.cd-timeline__block.svelte-1t2uafz:first-child{margin-top:0}.cd-timeline__block.svelte-1t2uafz:last-child{margin-bottom:0}@media only screen and (min-width: 1170px){.cd-timeline__block.svelte-1t2uafz{margin:4em 0}}.cd-timeline__img.svelte-1t2uafz{position:absolute;top:0;left:0;width:40px;height:40px;border-radius:50%;-webkit-box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05);box-shadow:0 0 0 4px white, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05)}.cd-timeline__img.svelte-1t2uafz{background:#75ce66}@media only screen and (min-width: 1170px){.cd-timeline__img.svelte-1t2uafz{width:60px;height:60px;left:50%;margin-left:-30px;-webkit-transform:translateZ(0);transform:translateZ(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}@keyframes svelte-1t2uafz-cd-bounce-1{0%{opacity:0;-webkit-transform:scale(0.5);transform:scale(0.5)}60%{opacity:1;-webkit-transform:scale(1.2);transform:scale(1.2)}100%{-webkit-transform:scale(1);transform:scale(1)}}.cd-timeline__content.svelte-1t2uafz{position:relative;margin-left:60px;background:white;border-radius:0.25em;padding:1em;-webkit-box-shadow:0 3px 0 #d7e4ed;box-shadow:0 3px 0 #d7e4ed}.cd-timeline__content.svelte-1t2uafz:after{content:\"\";display:table;clear:both}.cd-timeline__content.svelte-1t2uafz::before{content:'';position:absolute;top:16px;right:100%;height:0;width:0;border:7px solid transparent;border-right:7px solid white}.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{color:#303e49}.cd-timeline__content.svelte-1t2uafz p,.cd-timeline__date.svelte-1t2uafz{font-size:1.3rem}.cd-timeline__content.svelte-1t2uafz p{margin:1em 0;line-height:1.6}.cd-timeline__date.svelte-1t2uafz{display:inline-block}.cd-timeline__date.svelte-1t2uafz{float:left;padding:.8em 0;opacity:.7}@media only screen and (min-width: 768px){.cd-timeline__content.svelte-1t2uafz h2.svelte-1t2uafz{font-size:2rem}.cd-timeline__content.svelte-1t2uafz p{font-size:1.6rem}.cd-timeline__date.svelte-1t2uafz{font-size:1.4rem}}@media only screen and (min-width: 1170px){.cd-timeline__content.svelte-1t2uafz{margin-left:0;padding:1.6em;width:45%;-webkit-transform:translateZ(0);transform:translateZ(0)}.cd-timeline__content.svelte-1t2uafz::before{top:24px;left:100%;border-color:transparent;border-left-color:white}.cd-timeline__date.svelte-1t2uafz{position:absolute;width:100%;left:122%;top:6px;font-size:1.6rem}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz{float:right}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__content.svelte-1t2uafz::before{top:24px;left:auto;right:100%;border-color:transparent;border-right-color:white}.cd-timeline__block.svelte-1t2uafz:nth-child(even) .cd-timeline__date.svelte-1t2uafz{left:auto;right:122%;text-align:right}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2{0%{opacity:0;-webkit-transform:translateX(-100px);transform:translateX(-100px)}60%{opacity:1;-webkit-transform:translateX(20px);transform:translateX(20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@-webkit-keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}@keyframes svelte-1t2uafz-cd-bounce-2-inverse{0%{opacity:0;-webkit-transform:translateX(100px);transform:translateX(100px)}60%{opacity:1;-webkit-transform:translateX(-20px);transform:translateX(-20px)}100%{-webkit-transform:translateX(0);transform:translateX(0)}}\n    \n\n    \n        \n            \n            \n            \n                \n                \nå¨è‰ºé¢‡è§é•¿è¿›\nğŸ“ä¸Šæµ·Â·é—µè¡Œ\n\n                2021-07-04 - 2021-11-13\n            \n        \n            \n            \n            \n                \n                \né€åˆ«é˜¿æ–Œï¼Œåƒçƒ¤ç¾Šè…¿\nğŸ“ä¸Šæµ·Â·æ¾æ±Ÿ\n\n                2021-06-02\n            \n        \n            \n            \n            \n                \n                \né€åˆ«å®å“¥ï¼Œåƒé¾™è™¾\nğŸ“ä¸Šæµ·Â·æ¾æ±Ÿ\n\n                2021-04-27\n            \n        \n            \n            \n            \n                \n                \nåœ¨è˜åº„çš„æœ€åä¸€é¤â€”â€”æ—¥æ–™\nğŸ“ä¸Šæµ·Â·é—µè¡ŒåŒºÂ·è˜æœ±è·¯Â·430 å·\n\n                2021-04-18\n            \n        \n            \n            \n            \n                \n                \nç»ˆäºåƒåˆ°äº†ä¼ è¯´ä¸­çš„é³ä¸é¢ @è€é‚¢ğŸ˜\nğŸ“ä¸Šæµ·Â·é—µè¡ŒåŒºÂ·è˜æœ±è·¯\n\n                2021-04-11\n            \n        \n            \n            \n            \n                \n                \nç¬¬ä¸€æ¬¡åƒæ»¡è®°ç”œå“\nğŸ“ä¸Šæµ·Â·é—µè¡ŒåŒºÂ·è˜ä¸œè·¯\n\n                2021-03-20\n            \n        \n            \n            \n            \n                \n                \nå¹´å¤œé¥­\nğŸ“å±±ä¸œÂ·çƒŸå°Â·è±å·å¸‚\n\n                2021-02-11 - 2021-02-13\n            \n        \n            \n            \n            \n                \n                \nå¤±è´¥çš„åœ°ç“œé¥¼\n\n                2021-01-24\n            \n        \n            \n            \n            \n                \n                \nç¬¬ä¸€æ¬¡ä¸¤ä¸ªäººåŒ…é¥ºå­\n\n                2020-12-06\n            \n        \n            \n            \n            \n                \n                \nè¿™ä¸ªé¸¡çˆªä¸é”™å“ŸğŸ¥°\n\n                2020-12-06\n            \n        \n            \n            \n            \n                \n                \nç¬¬ä¸€æ¬¡ä¸€èµ·åƒç«é”…\n\n                2020-11-22\n            \n        \n            \n            \n            \n                \n                \né‡åº†ä¹‹æ—…â€”â€”è¾£\nğŸ“é‡åº†\n\n                2020-11-06 - 2020-11-09\n            \n        \n            \n            \n            \n                \n                \næ–°ç™½é¹¿è¿˜æ˜¯ä¸é”™æ»´\nğŸ“æµ™æ±ŸÂ·æ­å·Â·æ»¨æ±ŸåŒº\n\n                2020-10-07\n            \n        \n            \n            \n            \n                \n                \nå–åˆ°äº†æ­£å®—çš„èƒ¡è¾£æ±¤\nğŸ“æ²³å—Â·æ¼¯æ²³Â·èˆé˜³å¿\n\n                2020-10-05\n            \n        \n            \n            \n            \n                \n                \nç¬¬ä¸€æ¬¡å»æ¢¦æ¢¦å®¶\nğŸ“å®‰å¾½Â·åˆè‚¥Â·è‚¥è¥¿å¿\n\n                2020-10-02\n            \n        \n            \n            \n            \n                \n                \nç¾å›¢ä¹å—ä¹ä¹°äº†ä»€ä¹ˆç©æ„å¿˜äº†\nğŸ“ä¸Šæµ·Â·é—µè¡ŒåŒºÂ·å®åŸè·¯\n\n                2020-09-19\n            \n        \n            \n            \n            \n                \n                \né€åˆ«æ˜æ˜Ÿï¼Œåƒçƒ¤è‚‰ï¼Œå–å¤šäº†ğŸ¤®\nğŸ“ä¸Šæµ·Â·æ¾æ±Ÿ\n\n                2020-07-31\n            \n        \n            \n            \n            \n                \n                \nä¹‹åçš„è‹¥å¹²æ¬¡å°è¯•\nğŸ“ä¸Šæµ·Â·æ¾æ±Ÿ\n\n                2020-05-02 - 2020-07-19\n            \n        \n            \n            \n            \n                \n                \nç¬¬ä¸€æ¬¡å°è¯•åšé¥­\nğŸ“ä¸Šæµ·Â·æ¾æ±Ÿ\n\n                2020-04-18\n            \n        \n    \n\n","categories":["ç›¸å†Œ"],"tags":["ç¾é£Ÿç¥­"]},{"title":"åŒ…å›´ç›’","url":"/2021/11/17/15/","content":"è½´å¯¹é½åŒ…å›´ç›’ï¼ˆAxis-Aligned Bounding Boxï¼ŒAABBï¼‰ä¸‰ç»´çš„ AABB å°±æ˜¯ä¸€ä¸ªç®€å•çš„å…­é¢ä½“ï¼Œæ¯ä¸€è¾¹éƒ½å¹³è¡Œäºä¸€ä¸ªåæ ‡å¹³é¢ï¼ŒçŸ©å½¢è¾¹ç•Œæ¡†ä¸ä¸€å®šéƒ½æ˜¯ç«‹æ–¹ä½“ï¼Œå®ƒçš„é•¿ã€å®½ã€é«˜å¯ä»¥å½¼æ­¤ä¸åŒã€‚AABB å†…çš„ç‚¹æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ï¼šä¼˜ç‚¹æ˜¯ç®€å•ï¼›ç¼ºç‚¹æ˜¯ç´§å¯†å‹è¾ƒå·®ã€‚\næœ‰å‘åŒ…å›´ç›’ï¼ˆOriented Bounding Boxï¼ŒOBBï¼‰OBB åŒ…å›´ç›’æ ¹æ®ç‰©ä½“æœ¬èº«çš„å‡ ä½•å½¢çŠ¶æ¥å†³å®šåŒ…å›´ç›’çš„å¤§å°å’Œæ–¹å‘ï¼ŒåŒ…å›´ç›’æ— é¡»å’Œåæ ‡è½´å‚ç›´ã€‚è¿™æ ·å¯ä»¥é€‰æ‹©æœ€é€‚åˆã€æœ€ç´§å‡‘çš„åŒ…å›´ç›’ã€‚ä¸€èˆ¬é€šè¿‡ç‰©ä½“æ¨¡å‹æ‰€æœ‰é¡¶ç‚¹åœ¨ç©ºé—´çš„åˆ†å¸ƒæ±‚å¾—ã€‚\nOBB çš„ç”Ÿæˆæ€è·¯ç®€å•æ¥è¯´å°±æ˜¯åˆ†å±€ç‰©ä½“è¡¨é¢çš„é¡¶ç‚¹ï¼Œé€šè¿‡ PCAï¼ˆä¸»æˆåˆ†åˆ†æï¼‰è·å¾—ç‰¹å¾å‘é‡ã€‚ä¸»æˆåˆ†åˆ†ææ˜¯ä¸€ç§é€šè¿‡æ­£äº¤å˜æ¢ï¼Œå°†ä¸€ç»„å¯èƒ½ç›¸å…³çš„å˜é‡é›†åˆå˜æ¢æˆä¸€ç»„çº¿æ€§ä¸ç›¸å…³çš„å˜é‡é›†åˆã€‚\nå¼•å…¥åæ–¹å·®çš„æ¦‚å¿µï¼Œåæ–¹å·®è¡¨ç¤ºä¸¤ä¸ªå˜é‡ä¹‹é—´çš„çº¿æ€§ç›¸å…³ç¨‹åº¦ã€‚åæ–¹å·®è¶Šå°åˆ™ä¸¤ä¸ªå˜é‡ä¹‹é—´è¶Šç‹¬ç«‹ï¼Œç›¸å…³æ€§è¶Šå°ã€‚é€šè¿‡åæ–¹å·®çš„è®¡ç®—å…¬å¼ï¼Œå¯ä»¥å¾—åˆ°åæ–¹å·®çŸ©é˜µ  å†å°†åæ–¹å·®çŸ©é˜µ  å¯¹è§’åŒ–ä¸º ï¼Œå¾—åˆ°ç”± ä¸ªç‰¹å¾å‘é‡ç»„æˆçš„ç‰¹å¾çŸ©é˜µã€‚ ä¸ªç‰¹å¾å‘é‡è¡¨ç¤º OBB åŒ…å›´ç›’çš„æ–¹å‘ã€‚\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics"]},{"title":"Lua GC æœºåˆ¶","url":"/2021/11/22/16/","content":"åƒåœ¾å›æ”¶  é‡‡ç”¨äº†è‡ªåŠ¨å†…å­˜ç®¡ç†ã€‚ è¿™æ„å‘³ç€ä½ ä¸ç”¨æ“å¿ƒæ–°åˆ›å»ºçš„å¯¹è±¡éœ€è¦çš„å†…å­˜å¦‚ä½•åˆ†é…å‡ºæ¥ï¼Œ ä¹Ÿä¸ç”¨è€ƒè™‘åœ¨å¯¹è±¡ä¸å†è¢«ä½¿ç”¨åæ€æ ·é‡Šæ”¾å®ƒä»¬æ‰€å ç”¨çš„å†…å­˜ã€‚\nLua è¿è¡Œäº†ä¸€ä¸ªåƒåœ¾æ”¶é›†å™¨æ¥æ”¶é›†æ‰€æœ‰æ­»å¯¹è±¡ ï¼ˆå³åœ¨ Lua ä¸­ä¸å¯èƒ½å†è®¿é—®åˆ°çš„å¯¹è±¡ï¼‰æ¥å®Œæˆè‡ªåŠ¨å†…å­˜ç®¡ç†çš„å·¥ä½œã€‚ Lua ä¸­æ‰€æœ‰ç”¨åˆ°çš„å†…å­˜ï¼Œå¦‚ï¼šå­—ç¬¦ä¸²ã€è¡¨ã€ç”¨æˆ·æ•°æ®ã€å‡½æ•°ã€çº¿ç¨‹ã€ å†…éƒ¨ç»“æ„ç­‰ï¼Œéƒ½æœä»è‡ªåŠ¨ç®¡ç†ã€‚\nåƒåœ¾å›æ”¶å™¨å‡½æ•°-- collectgarbage(&quot;collect&quot;): åšä¸€æ¬¡å®Œæ•´çš„åƒåœ¾æ”¶é›†å¾ªç¯ã€‚é€šè¿‡å‚æ•° opt å®ƒæä¾›äº†ä¸€ç»„ä¸åŒçš„åŠŸèƒ½-- collectgarbage(&quot;count&quot;): ä»¥ K å­—èŠ‚æ•°ä¸ºå•ä½è¿”å› Lua ä½¿ç”¨çš„æ€»å†…å­˜æ•°ã€‚ è¿™ä¸ªå€¼æœ‰å°æ•°éƒ¨åˆ†ï¼Œæ‰€ä»¥åªéœ€è¦ä¹˜ä¸Š 1024 å°±èƒ½å¾—åˆ° Lua ä½¿ç”¨çš„å‡†ç¡®å­—èŠ‚æ•°ï¼ˆé™¤éæº¢å‡ºï¼‰ã€‚-- collectgarbage(&quot;restart&quot;): é‡å¯åƒåœ¾æ”¶é›†å™¨çš„è‡ªåŠ¨è¿è¡Œã€‚-- collectgarbage(&quot;setpause&quot;): å°† arg è®¾ä¸ºæ”¶é›†å™¨çš„ é—´æ­‡ç‡ã€‚ è¿”å› é—´æ­‡ç‡ çš„å‰ä¸€ä¸ªå€¼ã€‚-- collectgarbage(&quot;setstepmul&quot;): è¿”å› æ­¥è¿›å€ç‡ çš„å‰ä¸€ä¸ªå€¼ã€‚-- collectgarbage(&quot;step&quot;): å•æ­¥è¿è¡Œåƒåœ¾æ”¶é›†å™¨ã€‚ æ­¥é•¿ &quot; å¤§å° &quot; ç”± arg æ§åˆ¶ã€‚ ä¼ å…¥ 0 æ—¶ï¼Œæ”¶é›†å™¨æ­¥è¿›ï¼ˆä¸å¯åˆ†å‰²çš„ï¼‰ä¸€æ­¥ã€‚ ä¼ å…¥é 0 å€¼ï¼Œ æ”¶é›†å™¨æ”¶é›†ç›¸å½“äº Lua åˆ†é…è¿™äº›å¤šï¼ˆK å­—èŠ‚ï¼‰å†…å­˜çš„å·¥ä½œã€‚ å¦‚æœæ”¶é›†å™¨ç»“æŸä¸€ä¸ªå¾ªç¯å°†è¿”å› true ã€‚-- collectgarbage(&quot;stop&quot;): åœæ­¢åƒåœ¾æ”¶é›†å™¨çš„è¿è¡Œã€‚ åœ¨è°ƒç”¨é‡å¯å‰ï¼Œæ”¶é›†å™¨åªä¼šå› æ˜¾å¼çš„è°ƒç”¨è¿è¡Œã€‚test = &#123;&quot;W&quot;,&quot;L&quot;,&quot;Q&quot;&#125;print(collectgarbage(&quot;count&quot;))test = nilprint(collectgarbage(&quot;count&quot;))print(collectgarbage(&quot;collect&quot;))print(collectgarbage(&quot;count&quot;))\n\ngc ç®—æ³•åˆ†æ Lua gc é‡‡ç”¨çš„æ˜¯ æ ‡è®° - æ¸…é™¤  ç®—æ³•ï¼Œå³ä¸€æ¬¡ gc åˆ†ä¸¤æ­¥ï¼š\n\nåœ¨æ ‡è®°é˜¶æ®µï¼Œä»æ ¹é›†å¯¹è±¡å¼€å§‹æ ‡è®°ï¼ŒæŠŠæ•´ä¸ªå¯¹è±¡å±‚çº§éƒ½æ ‡è®°å®Œï¼Œè¿™äº›è¢«æ ‡è®°åˆ°çš„å¯¹è±¡ç§°ä¸ºå¯è¾¾åˆ°çš„å¯¹è±¡ã€‚\nåœ¨æ¸…é™¤é˜¶æ®µï¼Œéå†ä¸Šé¢æåˆ°çš„å¯¹è±¡é“¾è¡¨ï¼Œå¦‚æœå¯¹è±¡è¢«æ ‡è®°è¿‡åˆ™æ“¦é™¤æ ‡è®°å¹¶è·³è¿‡ï¼Œå¦‚æœå¯¹è±¡æ²¡æœ‰è¢«æ ‡è®°è¯´æ˜ä»–ä¸å¯è¾¾åˆ°ï¼Œé‚£å°±æŠŠå®ƒé‡Šæ”¾æ‰ã€‚\n\nlua5.1 å¼€å§‹é‡‡ç”¨äº†ä¸€ç§ä¸‰è‰²å›æ”¶çš„ç®—æ³•\n\nç™½è‰²ï¼šè¡¨ç¤ºå¯¹è±¡æœªè¢«æ ‡è®°ï¼Œåœ¨ GC å‘¨æœŸå¼€å§‹ä¹‹å‰å¯¹è±¡ä¸ºç™½è‰²ï¼Œå¦‚æœåˆ°æ¸…é™¤é˜¶æ®µè¿˜æ˜¯ç™½è‰²ï¼Œé‚£å°±è¯´æ˜è¯¥å¯¹è±¡ä¸å¯åˆ°è¾¾ï¼Œè¦è¢«æ¸…é™¤æ‰ã€‚\nç°è‰²ï¼šè¡¨ç¤ºå¯¹è±¡æœ¬èº«å·²æ ‡è®°ï¼Œä½†å®ƒå¼•ç”¨çš„å¯¹è±¡æœªè¢«æ ‡è®°ï¼Œæ¯”å¦‚ä¸€ä¸ªè¡¨å·²è¢«æ ‡è®°ï¼Œå®ƒçš„é”®å€¼å¯¹è±¡è¿˜æœªè¢«æ ‡è®°ã€‚è¿™è¡¨ç¤ºå¯¹è±¡æ ‡è®°çš„ä¸€ä¸ªä¸­é—´çŠ¶æ€ã€‚\né»‘è‰²ï¼šè¡¨ç¤ºå¯¹è±¡å’Œå®ƒå¼•ç”¨çš„å¯¹è±¡éƒ½å·²è¢«æ ‡è®°ï¼Œåœ¨æ¸…é™¤é˜¶æ®µé»‘è‰²å¯¹è±¡ä¸ºå¯åˆ°è¾¾å¯¹è±¡ã€‚\n\nå¯¹è±¡é“¾è¡¨ global_State æœ‰å¥½å¤šå’Œ GC ç›¸å…³çš„å­—æ®µï¼Œå…¶ä¸­æœ‰ä¸€äº›é‡è¦é“¾è¡¨ã€‚æ‰€æœ‰ GC å¯¹è±¡æ€»æ˜¯åœ¨ä¸‹é¢çš„é“¾è¡¨ä¸­ï¼š\n\nallgcï¼šæ‰€æœ‰æœªè¢«æ ‡è®°ä¸ºç»ˆç»“çš„å¯¹è±¡\nfinobjï¼šæ‰€æœ‰æ ‡è®°ä¸ºç»ˆç»“çš„å¯¹è±¡\ntobefnzï¼šæ‰€æœ‰å‡†å¤‡ç»ˆç»“çš„å¯¹è±¡ï¼ˆå‡†å¤‡è°ƒç”¨ __gc çš„å¯¹è±¡ï¼‰\nfixedgcï¼šä¸ä¼šè¢«å›æ”¶çš„å¯¹è±¡\n\næ­£å¸¸æƒ…å†µä¸‹ï¼Œæ–°å»ºå¯¹è±¡éƒ½ä¼šè¿›å…¥ allgc é“¾è¡¨ã€‚\nå¦‚æœå¯¹è±¡è®¾ç½®ä¸€ä¸ªå…ƒè¡¨ï¼Œä¸”å…ƒè¡¨æœ‰ __gc å…ƒæ–¹æ³•ï¼Œé‚£ä¹ˆå®ƒä¼šä» allgc å–å‡ºï¼ŒåŠ å…¥åˆ° finobj å»ï¼Œå¹¶è®¾ç½®å¯¹è±¡çš„ FINALIZEDBIT æ ‡è®°ä¸ºã€‚\nåœ¨æ ‡è®°é˜¶æ®µï¼Œfinobjä¸­çš„ç™½å¯¹è±¡ä¼šç§»åˆ° tobefnz é“¾è¡¨å»ï¼Œç„¶åæ ‡è®°è¿™äº›å¯¹è±¡ï¼Œè¿™æ ·å½“å‰å‘¨æœŸä¸ä¼šé‡Šæ”¾è¿™äº›å¯¹è±¡ï¼›æ¸…é™¤å®Œä¹‹åä¼šè¿›å…¥ GCScallfin é˜¶æ®µï¼Œåœ¨è¿™é‡Œè°ƒç”¨ tobefnz å¯¹è±¡çš„ gc æ–¹æ³•ï¼ŒåŒæ—¶æŠŠå¯¹è±¡ç§»å› allgc é“¾è¡¨ï¼›å¦‚æœ gc ä¸­ä½¿å¯¹è±¡é‡æ–°å˜æˆå¯åˆ°è¾¾ï¼Œåˆ™å¯¹è±¡å¤æ´»è¿‡æ¥ï¼›å¦åˆ™ä¸‹ä¸ªå‘¨æœŸè¿™ä¸ªå¯¹è±¡å°±ä¼šè¢«æ­£å¸¸æ¸…é™¤ã€‚\nfixedgcæ˜¯é‚£äº›ä¸ä¼šè¢«å›æ”¶çš„å¯¹è±¡ï¼Œåœ¨æ–°å»ºå®Œå¯¹è±¡åï¼Œå¿…é¡»é©¬ä¸Šè°ƒç”¨ luaC_fic æŠŠå¯¹è±¡ä» allgc ç§»åˆ° fixedgc å»ã€‚GC çš„è¿‡ç¨‹ä¸ä¼šå¯¹ fixedgc è¿›è¡Œæ¸…é™¤ã€‚\n\nluajit ä½¿ç”¨çŠ¶æ€æœºæ¥æ‰§è¡Œ gc ç®—æ³•ï¼Œå…±æœ‰ 6 ä¸­çŠ¶æ€ï¼š\n\nGCSpauseï¼š gc å¼€å§‹é˜¶æ®µï¼Œåˆå§‹åŒ–ä¸€äº›å±æ€§ï¼Œå°†ä¸€äº›è·ŸèŠ‚ç‚¹ï¼ˆä¸»çº¿ç¨‹å¯¹è±¡ï¼Œä¸»çº¿ç¨‹ç¯å¢ƒå¯¹è±¡ï¼Œå…¨å±€å¯¹è±¡ç­‰ï¼‰push åˆ°ç°è‰²é“¾è¡¨ä¸­\nGCSpropagateï¼š åˆ†æ­¥è¿›è¡Œæ‰«æï¼Œæ¯æ¬¡ä»ç°è‰²é“¾è¡¨ pop ä¸€ä¸ªå¯¹è±¡ï¼Œéå†è¯¥å¯¹è±¡çš„å­å¯¹è±¡ï¼Œä¾‹å¦‚å¦‚æœè¯¥å¯¹è±¡ä¸º tableï¼Œå¹¶ä¸” value æ²¡æœ‰è®¾ç½®ä¸º weekï¼Œåˆ™ä¼šéå† table æ‰€æœ‰ table å¯è¾¾çš„ valueï¼Œå¦‚æœ value ä¸º gc å¯¹è±¡ä¸”ä¸ºç™½è‰²ï¼Œåˆ™ä¼šè¢« push åˆ°ç°è‰²é“¾è¡¨ä¸­ï¼Œè¿™ä¸€æ­¥å°†ä¸€ç›´æŒç»­åˆ°ç°è‰²é“¾è¡¨ä¸ºç©ºçš„æ—¶å€™\nGCSatomicï¼š åŸå­æ“ä½œï¼Œå› ä¸º GCSpropagate æ˜¯åˆ†æ­¥çš„ï¼Œæ‰€ä»¥åˆ†æ­¥è¿‡ç¨‹ä¸­å¯èƒ½ä¼šæœ‰æ–°çš„å¯¹è±¡åˆ›å»ºï¼Œè¿™æ—¶å€™å°†å†è¿›è¡Œä¸€æ¬¡è¡¥å……éå†ï¼Œè¿™éå†æ˜¯ä¸èƒ½è¢«æ‰“æ–­çš„ï¼Œä½†å› ä¸ºç»å¤§éƒ¨åˆ†å·¥ä½œè¢« GCSpropagate åšäº†ï¼Œæ‰€ä»¥è¿‡ç¨‹ä¼šå¾ˆå¿«ã€‚æ–°åˆ›å»ºçš„æ²¡æœ‰è¢«å¼•ç”¨çš„ userdataï¼Œå¦‚æœè¯¥userdata è‡ªå®šä¹‰äº† gc å…ƒæ–¹æ³•ï¼Œåˆ™ä¼šåŠ å…¥åˆ°å…¨å±€çš„ userdata é“¾è¡¨ä¸­ï¼Œè¯¥é“¾è¡¨ä¼šåœ¨æœ€åä¸€æ­¥ GCSfinalize å¤„ç†\nGCSsweepstringï¼š éå†å…¨å±€å­—ç¬¦ä¸² hash è¡¨ï¼Œæ¯æ¬¡éå†ä¸€ä¸ª hash èŠ‚ç‚¹ï¼Œå¦‚æœ hash å†²çªä¸¥é‡ï¼Œä¼šåœ¨è¿™é‡Œå½±å“ gcã€‚å¦‚æœå­—ç¬¦ä¸²ä¸ºç™½è‰²å¹¶ä¸”æ²¡æœ‰è¢«è®¾ç½®ä¸ºå›ºå®šä¸é‡Šæ”¾ï¼Œåˆ™è¿›è¡Œé‡Šæ”¾\nGCSsweepï¼š éå†æ‰€æœ‰å…¨å±€ gc å¯¹è±¡ï¼Œæ¯æ¬¡éå† 40 ä¸ªï¼Œå¦‚æœ gc å¯¹è±¡ä¸ºç™½è‰²ï¼Œå°†è¢«é‡Šæ”¾\nGCSfinalizeï¼š éå† GCSatomic ç”Ÿæˆçš„ userdata é“¾è¡¨ï¼Œå¦‚æœè¯¥ userdata è¿˜å­˜åœ¨ gc å…ƒæ–¹æ³•ï¼Œè°ƒç”¨è¯¥å…ƒæ–¹æ³•ï¼Œæ¯æ¬¡å¤„ç†ä¸€ä¸ª\n\nä»€ä¹ˆæ—¶å€™ä¼šå¯¼è‡´ gcglobal_stateæœ‰ä¸¤ä¸ªå­—æ®µæ˜¯å…³äº Lua çš„å†…å­˜ç»Ÿè®¡çš„ï¼š\nl_mem totalbytes;l_mem GCdebt;\nåœ¨ lua_newstate å‡½æ•°é‡Œï¼Œè¿™ä¸¤ä¸ªå­—æ®µåˆå§‹ä¸ºï¼š\ng-&gt;totalbytes = sizeof(LG);g-&gt;GCdebt = 0;\nåœ¨å†…å­˜åˆ†é…å‡½æ•° luaM_realloc_ é‡Œï¼Œä¼šæ ¹æ®åˆ†é…æˆ–é‡Šæ”¾å†…å­˜è°ƒæ•´ GCdebt çš„å€¼ï¼š\nvoid *luaM_realloc_(lua_State* L, void* block, size_t osize, size_t, nsize) &#123;    ...    g-&gt;GCdebt = (g-&gt;GCdebt + nsize) - realosize;    ...&#125;\nåˆ¤æ–­æ˜¯å¦è§¦å‘ GC çš„å®æ˜¯ï¼š\n#define lauC_condGC(L, pre, pos) \\    &#123; if (G(L)-&gt;GCdebt &gt; 0) &#123; pre; luaC_step(L); pos; &#125;; \\        condchangemem(L, pre, pos); &#125;\ng-&gt;GCdebtå¦‚æœå¤§äº 0ï¼Œå°±æ‰§è¡Œä¸€æ¬¡luaC_stepã€‚\nå›æ”¶æ§åˆ¶ luaC_step æ‰§è¡Œä¸€æ­¥ GCï¼š\nvoid luaC_step(lua_State* L) &#123;    global_State* g = G(L);    // 1. è®¡ç®— GC çš„å†…å­˜å€ºåŠ¡    l_mem debt = getdebt(g);    ...    // 2. å¾ªç¯æ‰§è¡Œ singlestepï¼ŒçŸ¥é“ GC å‘¨æœŸå®Œæ¯•ï¼Œæˆ– debt å°äºæŸä¸ªå€¼    do &#123;        lu_mem work = singlestep(L);        debt -= work;    &#125; while (debt &gt; -GCSTEPSIZE &amp;&amp; g-&gt;gcstate != GCSpause);        // 3. å¦‚æœ GC ç»“æŸï¼Œè®¡ç®—ä¸‹ä¸€ä¸ªé˜ˆå€¼    if (g-&gt;gcstate == GCSpause)        setpause(g);    else &#123;    // 4. å¦åˆ™è®¡ç®—ä¸‹ä¸€æ¬¡è§¦å‘çš„æ—¶æœº        debt = (debt / g-&gt;gcstepmul) * STEPMULADJ;        luaE_setdebt(g, debt);        runafewinalizers(L);    &#125;&#125;\n\n\nGC çš„è¿‡ç¨‹Lua ä¼šè‡ªåŠ¨ç®¡ç†å†…å­˜ï¼Œå®ƒé€šè¿‡åƒåœ¾æ”¶é›†å™¨å›æ”¶æ‰ä¸å†ä½¿ç”¨çš„å¯¹è±¡ï¼Œæ‰€è°“ä¸å†ä½¿ç”¨ï¼Œå¯ä»¥ç®€å•ç†è§£ä¸ºæ²¡æœ‰å…¶ä»–å¯¹è±¡å¼•ç”¨çš„å¯¹è±¡ã€‚\nLua ä½¿ç”¨ç®€å•çš„æ ‡è®°å’Œæ¸…é™¤çš„åƒåœ¾å›æ”¶å®¹å™¨ï¼Œæ¯æ¬¡å®Œæ•´çš„ GC åˆ†ä¸º 4 ä¸ªé˜¶æ®µï¼š\n\næ ‡è®°ï¼ˆmarkï¼‰ï¼šLua å°†æ ¹é›†å¯¹è±¡æ ‡è®°ä¸ºæ´»çš„ï¼Œæ ¹é›†å¯¹è±¡å®é™…ä¸Šå°±æ˜¯ C æ³¨å†Œè¡¨ï¼Œåƒä¸»çº¿ç¨‹å’Œå…¨å±€ç¯å¢ƒéƒ½æ˜¯æ³¨å†Œè¡¨çš„é¢„å®šä¹‰é¡¹ã€‚ä»æ ¹é›†å¯¹è±¡ä¸€ç›´å¾€ä¸‹æ ‡è®°ï¼Œä»»ä½•å­˜åœ¨äºæ´»å¯¹è±¡ä¸­çš„å¯¹è±¡ï¼Œåªè¦ç¨‹åºå¯è¾¾ï¼ˆå¼±è¡¨é™¤å¤–ï¼‰ï¼Œä¹Ÿä¼šè¢«æ ‡è®°ä¸ºæ´»çš„ã€‚\næ¸…ç†ï¼ˆcleaningï¼‰ï¼šè¿™ä¸€é˜¶æ®µï¼ŒLua éå†é‚£äº›æœªæ ‡è®°çš„å¯¹è±¡ï¼Œå¦‚æœå®ƒä»¬æœ‰ç»ˆç»“å‡½æ•°ï¼Œå°†å®ƒä»¬ç§»å‡ºåˆ°å¦ä¸€ä¸ªåˆ—è¡¨ä¸­ï¼Œåé¢ç¬¬ 4 ä¸ªé˜¶æ®µä¼šç”¨åˆ°ã€‚æ¥ç€éå† Lua å¼±è¡¨ï¼ŒæŠŠå…¶ä¸­ key æˆ– value æœªè¢«æ ‡è®°çš„å¯¹è±¡ä»å¼±è¡¨ç§»é™¤ã€‚\næ¸…é™¤ï¼ˆsweepï¼‰ï¼šLua éå†æ‰€æœ‰å¯¹è±¡ï¼Œå¦‚è¡¨æœªè¢«æ ‡è®°åˆ™å›æ”¶æ‰ï¼Œå¦‚æœæœ‰æ ‡è®°åˆ™æ¸…é™¤æ ‡è®°ã€‚\nç»ˆç»“ï¼ˆfinalizationï¼‰ï¼šåœ¨æ¸…ç†é˜¶æ®µå°†æœ‰ç»ˆç»“å‡½æ•°ï¼Œä¸”æœªè¢«æ ‡è®°çš„å¯¹è±¡éƒ½ç§»åˆ°ä¸€ä¸ªç‹¬ç«‹çš„åˆ—è¡¨ä¸­ï¼Œè¿™é˜¶æ®µå°±æ˜¯éå†è¿™ä¸ªåˆ—è¡¨ï¼Œå¹¶è°ƒç”¨å®ƒä»¬çš„ç»ˆç»“å‡½æ•°ã€‚è€Œè¿™äº›æœªæ´»çš„å¯¹è±¡ï¼Œå®é™…ä¸Šåº”è¯¥ä¼šåœ¨ä¸‹ä¸€ä¸ª GC å‘¨æœŸæ‰è¢«å›æ”¶æ‰ã€‚\n\nåœ¨ Lua5.1 ä»¥ä¸Šçš„ç‰ˆæœ¬ï¼ŒGC è¢«ä¼˜åŒ–æˆå¢é‡å¼çš„ï¼Œå®ƒå’Œè§£é‡Šå™¨äº¤é”™è¿è¡Œï¼Œå³æ¯ä¸€ä¸ª GC åªæ‰§è¡Œä¸€éƒ¨åˆ†ï¼Œè¿™æ ·å°±æœ‰æ•ˆé¿å… GC çš„æ—¶å€™è§£é‡Šå™¨åœé¡¿å¤ªä¹…ã€‚\nå¼±è¡¨  ä¸‹é¢çš„ä¾‹å­èƒ½è¯´æ˜å¼±è¡¨çš„è¡Œä¸ºï¼š\na = &#123;&#125;mt = &#123;__mode = &#x27;k&#x27;&#125; -- è®¾ç½®ä¸º k è¡¨ç¤º a çš„ key æ˜¯å¼±å¼•ç”¨ï¼›è®¾ç½®ä¸º v è¡¨ç¤º value æ˜¯å¼±å¼•ç”¨ï¼›è®¾ç½®ä¸º kv è¡¨ç¤º key å’Œ value éƒ½æ˜¯å¼±å¼•ç”¨setmetatable(a, mt)k1 = &#123;&#125;a[k1] = 1k2 = &#123;&#125;a[k2] = 2k1 = nil -- å°† k1 åˆ é™¤ï¼Œk1 å¼•ç”¨çš„é‚£ä¸ªè¡¨åªå­˜åœ¨äº aï¼Œä½† a æ˜¯ key çš„å¼±å¼•ç”¨ï¼Œæ‰€ä»¥è¿™ä¸ªè¡¨è¢« GCcollectgarbage()for k, v in pairs(a) do print(v) end-- &gt; 2\n\nç»ˆç»“å‡½æ•°  å°±æ˜¯å…ƒè¡¨æœ‰æŒ‡å®š __gc å…ƒæ–¹æ³•ï¼Œå¦‚ï¼š\no = &#123;x = &#x27;hi&#x27;&#125;setmetatable(o, &#123;__gc = function(o) print(o.x) end&#125;)o = nilcollectgarbage() -- &gt; hi\n\nå¦‚æœä¸€ä¸ªå¯¹è±¡ï¼ˆæœ‰ç»ˆç»“å‡½æ•°ï¼‰åœ¨ç¨‹åºç»“æŸçš„æ—¶å€™è¿˜æœªè¢«å›æ”¶ï¼ŒLua ä¼šåœ¨ç»“æŸçš„æ—¶å€™è°ƒç”¨è¯¥å¯¹è±¡çš„ç»ˆç»“å‡½æ•°ï¼Œå¯ä»¥åˆ©ç”¨è¿™ä¸ªç‰¹æ€§æ¥ç›‘æ§ç¨‹åºç»“æŸã€‚\n","categories":["Lua"],"tags":["lua"]},{"title":"çº¢é»‘æ ‘","url":"/2021/11/22/17/","content":"çº¢é»‘æ ‘  è™½ç„¶å¹³è¡¡æ ‘è§£å†³äº†äºŒå‰æŸ¥æ‰¾æ ‘é€€åŒ–ä¸ºè¿‘ä¼¼é“¾è¡¨çš„ç¼ºç‚¹ï¼Œä¸è¿‡ä¸æ˜¯æœ€ä½³æ–¹æ¡ˆã€‚å› ä¸ºå¹³è¡¡æ ‘è¦æ±‚æ¯ä¸ªèŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„é«˜åº¦å·®è‡³å¤šç­‰äº 1ï¼Œè¿™ä¸ªè¦æ±‚å®åœ¨æ˜¯å¤ªä¸¥äº†ï¼Œå¯¼è‡´æ¯æ¬¡è¿›è¡Œæ’å…¥ / åˆ é™¤èŠ‚ç‚¹çš„æ—¶å€™ï¼Œå‡ ä¹éƒ½ä¼šç ´åå¹³è¡¡æ ‘çš„ç¬¬äºŒä¸ªè§„åˆ™ï¼Œè¿›è€Œæˆ‘ä»¬éƒ½éœ€è¦é€šè¿‡å·¦æ—‹å’Œå³æ—‹æ¥è¿›è¡Œè°ƒæ•´ï¼Œä½¿ä¹‹å†æ¬¡æˆä¸ºä¸€é¢—ç¬¦åˆè¦æ±‚çš„å¹³è¡¡æ ‘ã€‚æ˜¾ç„¶ï¼Œå¦‚æœåœ¨é‚£ç§æ’å…¥ã€åˆ é™¤å¾ˆé¢‘ç¹çš„åœºæ™¯ä¸­ï¼Œå¹³è¡¡æ ‘éœ€è¦é¢‘ç¹ç€è¿›è¡Œè°ƒæ•´ï¼Œè¿™ä¼šä½¿å¹³è¡¡æ ‘çš„æ€§èƒ½å¤§æ‰“æŠ˜æ‰£ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œäºæ˜¯æœ‰äº†çº¢é»‘æ ‘ã€‚Â #f8dcf8\nçº¢é»‘æ ‘çš„æ€§è´¨\næ¯ä¸ªèŠ‚ç‚¹è¦ä¹ˆæ˜¯é»‘è‰²ï¼Œè¦ä¹ˆæ˜¯çº¢è‰²\næ ¹èŠ‚ç‚¹æ˜¯é»‘è‰²\næ¯ä¸ªå¶å­èŠ‚ç‚¹ï¼ˆNILï¼‰æ˜¯é»‘è‰²\næ¯ä¸ªçº¢è‰²èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹ä¸€å®šéƒ½æ˜¯é»‘è‰²ï¼Œä¸èƒ½æœ‰ä¸¤ä¸ªçº¢è‰²ç»“ç‚¹ç›¸è¿\nä»»æ„ä¸€ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­èŠ‚ç‚¹çš„è·¯å¾„éƒ½åŒ…å«æ•°é‡ç›¸åŒçš„é»‘èŠ‚ç‚¹\n\n\nçº¢é»‘æ ‘çš„æ•°æ®ç»“æ„enum Color{    RED = 0,    BLACK = 1};struct RBTreeNode{    RBTreeNode * parent;    RBTreeNode * left;    RBTreeNode * right;    int key;    int data;    Color color;}\n\nçº¢é»‘æ ‘çš„æ—¶é—´å¤æ‚åº¦  çº¢é»‘æ ‘æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶ä¸ä¼šä¸ºæœ€ç³Ÿç³•çš„ï¼Œå…¶æ“ä½œæ—¶é—´å¤æ‚åº¦æœ€ç³Ÿç³•æ˜¯ï¼Œè¿™æ˜¯å› ä¸ºå®ƒåœ¨äºŒå‰æŸ¥æ‰¾æ ‘çš„åŸºç¡€ä¸Šå¢åŠ äº†ç€è‰²å’Œç›¸å…³çš„æ€§è´¨ä½¿å¾—çº¢é»‘æ ‘ç›¸å¯¹å¹³è¡¡ã€‚å¯¹äºçº¢é»‘æ ‘ï¼Œæ’å…¥ï¼Œåˆ é™¤ï¼ŒæŸ¥æ‰¾çš„å¹³å‡å¤æ‚åº¦éƒ½æ˜¯ï¼Œä¸”ä¸ä¼šéšç€èŠ‚ç‚¹æ•°çš„å¢åŠ è€Œæ¶åŒ–ã€‚èƒ½ä¿è¯åœ¨æœ€åæƒ…å†µä¸‹ï¼ŒåŸºæœ¬çš„åŠ¨æ€å‡ ä½•æ“ä½œçš„æ—¶é—´å‡ä¸ºã€‚\nçº¢é»‘æ ‘ä¿æŒå¹³è¡¡çš„ä¸‰ç§æ“ä½œ\nå·¦æ—‹ï¼šä»¥æŸä¸ªèŠ‚ç‚¹ä½œä¸ºæŒ‡ç‚¹ï¼ˆæ—‹è½¬èŠ‚ç‚¹ï¼‰ï¼Œå…¶å³å­èŠ‚ç‚¹å˜ä¸ºæ—‹è½¬èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹å˜ä¸ºé€‰è£…èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹ä¿æŒä¸å˜ã€‚\nå³æ—‹ï¼šä»¥æŸä¸ªèŠ‚ç‚¹ä½œä¸ºæ”¯ç‚¹ï¼ˆæ—‹è½¬èŠ‚ç‚¹ï¼‰ï¼Œå…¶å·¦å­èŠ‚ç‚¹å˜ä¸ºæ—‹è½¬èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œå·¦å­èŠ‚ç‚¹çš„å³å­èŠ‚ç‚¹å˜ä¸ºæ—‹è½¬èŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ï¼Œå³å­èŠ‚ç‚¹ä¿æŒä¸å˜ã€‚\nå˜è‰²ï¼šèŠ‚ç‚¹çš„é¢œè‰²ç”±çº¢å˜é»‘æˆ–ç”±é»‘è¾¹çº¢ã€‚\n\nå·¦æ—‹\nå³æ—‹\n","categories":["æ•°æ®ç»“æ„"],"tags":["æ•°æ®ç»“æ„","çº¢é»‘æ ‘"]},{"title":"Vulkan Note","url":"/2021/11/22/18/","content":"Vulkan çš„ä¼˜åŠ¿ \n\n æ˜¾å¼çš„ GPU æ§åˆ¶ \nVulkan æŠŠ API éªŒè¯ã€å†…å­˜ç®¡ç†ã€å¤šçº¿ç¨‹ç®¡ç†ç­‰å·¥ä½œäº¤ç”±å¼€å‘è€…è´Ÿè´£ã€‚ä¸€æ—¦ API ä½¿ç”¨å‡ºé”™ï¼Œåº”ç”¨å°±ä¼šå‡ºç° crash\n\nCPU å¤šçº¿ç¨‹çš„æ•ˆç‡æå‡ \nVulkan ä¸­å¼•å…¥äº† Command Buffer çš„æ¦‚å¿µï¼Œæ¯ä¸ªçº¿ç¨‹éƒ½å¯ä»¥å¾€ Command Buffer æäº¤æ¸²æŸ“å‘½ä»¤ï¼Œç»™å¼€å‘è€…æä¾›äº†å……åˆ†å‘æŒ¥ CPU å¤šæ ¸å¤šçº¿ç¨‹çš„ä¼˜åŠ¿ã€‚åœ¨å¤æ‚åœºæ™¯ä¸‹ï¼Œæ€§èƒ½çš„æå‡éå¸¸å®¢è§‚ \n\n å¯ç§»æ¤æ€§ \n\nVulkan å’Œ OpenGL æ€§èƒ½å¯¹æ¯” \n\n\n\n\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Vulkan","API"]},{"title":"Latex å…¬å¼","url":"/2021/11/22/19/","content":"\n    \n\n\n\n# å¸Œè…Šå­—æ¯  # ç®­å¤´ # æ±‚å’Œ   #ç§¯åˆ†    #æé™  #æ‹¬å·  #æ–¹ç¨‹ç»„  #å¯¹é½  #çŸ©é˜µ\n\n\nå¸Œè…Šå­—æ¯\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\alpha\n\n\\theta\n\no\n\n\\upsilon\n\n\n\n\\beta\n\n$\\vartheta\n\n\\pi\n\n\\phi\n\n\n\n\\gamma\n\n\\iota\n\n\\varpi\n\n\\varphi\n\n\n\n\\delta\n\n\\kappa\n\n\\rho\n\n\\chi\n\n\n\n\\epsilon\n\n\\lambda\n\n\\varrho\n\n\\psi\n\n\n\n\\varepsilon\n\n\\mu\n\n\\sigma\n\n\\omega\n\n\n\n\\zeta\n\n\\nu\n\n\\varsigma\n\n\n\n\n\n\\eta\n\n\\xi\n\n\\tau\n\n\n\n\n\n\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\Ggamma\n\n\\lambda\n\n\\Sigma\n\n\\Psi\n\n\n\n\\Delta\n\n\\Xi\n\n\\Upsilon\n\n\\Omega\n\n\n\n\\Theta\n\n\\Pi\n\n\\Phi\n\n\n\n\näºŒå…ƒæ“ä½œç¬¦\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\pm\n\n\\cap\n\n\\diamond\n\n\\oplus\n\n\n\n\\mp\n\n$\\cup\n\n\\bigtriangleup\n\n\\ominus\n\n\n\n\\times\n\n\\uplus\n\n\\bigtriangledown\n\n\\otimes\n\n\n\n\\div\n\n\\sqcap\n\n\\triangleleft\n\n\\oslash\n\n\n\n\\ast\n\n\\sqcup\n\n\\triangleleft\n\n\\odot\n\n\n\n\\star\n\n\\vee\n\n\\lhd\n\n\\bigcirc\n\n\n\n\\circ\n\n\\wedge\n\n\\rhd\n\n\\dagger\n\n\n\n\\bullet\n\n\\setminus\n\n\\unlhd\n\n\\ddagger\n\n\n\n\\cdot\n\n\\wr\n\n\\unrhd\n\n\\amalg\n\n\n\n+\n\n-\n\n\n\n\n\n\nå…³ç³»è¿ç®—ç¬¦\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\leq\n\n\\geq\n\n\\equiv\n\n\\models\n\n\n\n\\prec\n\n\\succ\n\n\\sim\n\n\\perp\n\n\n\n\\preceq\n\n\\succeq\n\n\\simeq\n\n\\mid\n\n\n\n\\ll\n\n\\gg\n\n\\asymp\n\n\\parallel\n\n\n\n\\subset\n\n\\supset\n\n\\approx\n\n\\bowtie\n\n\n\n\\subseteq\n\n\\supseteq\n\n\\cong\n\n\\Join\n\n\n\n\\sqsubsete\n\n\\sqsupset\n\n\\neq\n\n\\smile\n\n\n\n\\sqsubseteq\n\n\\sqsupseteq\n\n\\doteq\n\n\\frown\n\n\n\n\\in\n\n\\ni\n\n\\propto\n\n=\n\n\n\n\\vdash\n\n\\dashv\n\n&lt;\n\n&gt;\n\n\n\n:\n\n\n\n\n\n\n\n\næ ‡ç‚¹ç¬¦å·\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n,\n\n;\n\n\\colon\n\n\\ldotp\n\n\\cdotp\n\n\nç®­å¤´\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\leftarrow\n\n\\longleftarrow\n\n\\uparrow\n\n\n\n\\Leftarrow\n\n$\\Longleftarrow\n\n\\Uparrow\n\n\n\n\\rightarrow\n\n\\longrightarrow\n\n\\downarrow\n\n\n\n\\Rightarrow\n\n\\Longrightarrow\n\n\\Downarrow\n\n\n\n\\leftrightarrow\n\n\\longleftrightarrow\n\n\\updownarrow\n\n\n\n\\Leftrightarrow\n\n\\Longleftrightarrow\n\n\\Updownarrow\n\n\n\n\\mapsto\n\n\\longmapsto\n\n\\nearrow\n\n\n\n\\hookleftarrow\n\n\\hookrightarrow\n\n\\searrow\n\n\n\n\\leftharpoonup\n\n\\rightharpoonup\n\n\\swarrow\n\n\n\n\\leftharpoondown\n\n\\rightharpoondown\n\n\\nwarrow\n\n\n\n\\rightleftharpoons\n\n\\leadsto\n\n\n\n\nå…¶ä»–ç¬¦å·\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\ldots\n\n\\cdots\n\n\\vdots\n\n\\ddots\n\n\n\n\\aleph\n\n$\\prime\n\n\\forall\n\n\\infty\n\n\n\n\\hbar\n\n\\emptyset\n\n\\exists\n\n\\Box\n\n\n\n\\imath\n\n\\nabla\n\n\\neg\n\n\\Diamond\n\n\n\n\\jmath\n\n\\supset\n\n\\flat\n\n\\triangle\n\n\n\n\\ell\n\n\\top\n\n\\natural\n\n\\clubsuit\n\n\n\n\\wp\n\n\\bot\n\n\\sharp\n\n\\diamondsuit\n\n\n\n\\Re\n\n|\n\n\\backslash\n\n\\heartsuit\n\n\n\n\\Im\n\n\\angle\n\n\\partial\n\n\\spadesuit\n\n\n\n\\mho\n\n.\n\n\n\n\n\n\nå¤§å°å¯å˜ç¬¦å·\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\sum\n\n\\bigcap\n\n\\bigodot\n\n\n\n\\prod\n\n$\\bigcup\n\n\\bigotimes\n\n\n\n\\coprod\n\n\\bigsqcup\n\n\\bigoplus\n\n\n\n\\int\n\n\\bigvee\n\n\\biguplus\n\n\n\n\\oint\n\n\\bigwedge\n\n\n\n\nåˆ†éš”ç¬¦\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n(\n\n)\n\n\\uparrow\n\n\\Uparrow\n\n\n\n[\n\n]\n\n\\downarrow\n\n\\Downarrow\n\n\n\n\\{\n\n\\}\n\n\\updownarrow\n\n\\Updownarrow\n\n\n\n\\lfloor\n\n\\rfloor\n\n\\lceil\n\n\\rceil\n\n\n\n\\langle\n\n\\rangle\n\n\\arrowvert\n\n\\Arrowvert\n\n\n\n\\rmoustache\n\n\\lmoustache\n\n\\rgroup\n\n\\lgroup\n\n\nâª\n\\bracevert\n\n\n\n\n\n\n\n\né‡éŸ³ç¬¦å·\n\n\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\hat{a}\n\n\\acute{a}\n\n\\bar{a}\n\n\\dot{a}\n\n\n\n\\check{a}\n\n\\grave{a}\n\n\\vec{a}\n\n\\ddot{a}\n\n\n\n\\breve{a}\n\n\\tilde{a}\n\n\n\n\n\n\næ•°å­¦å…¬å¼  å¸¸ç”¨å…¬å¼\n\n\nsymbol\nlatex\nsymbol\nlatex\n\n\n\n\n\\sqrt[5]{ab}\n\n\\sideset{^1_2}{^3_4}\\otimes\n\n\n\n\\${}^{12}_{\\phantom{1}6}\\textrm{C}\n\n1+\\frac{a}{\\frac{b}{c} + 1}\n\n\n\n1+\\cfrac{a}{\\cfrac{b}{c} + 1}\n\n1+\\frac{a}{\\dfrac{b}{c} + 1}\n\n\n\n1+\\frac{a}{\\tfrac{b}{c} + 1}\n\n\\binom{a}{b^2}\n\n\n\n\\dbinom{a}{b^2}\n\n\\tbinom{a}{b^2}\n\n\n\n\\stackrel{a}{b}\n\n{a \\atop b+c}\n\n\n\n{a \\choose b+c}\n\n\n\n\n\n\\sum_{i=1}^{n} c_i\n\n\\sum\\nolimits_{i=1}^{n} c_i\n\n\n\n\\prod_{i=1}^{n} c_i\n\n\\prod\\nolimits_{i=1}^{n} c_i\n\n\n\n\\lim_{i=1}^{n} c_i\n\n\\lim\\nolimits_{i=1}^{n} c_i\n\n\n\n\\int_{i=1}^{n} c_i\n\n\\int\\nolimits_{i=1}^{n} c_i\n\n\n\n\\iint\n\niiint\n\n\n\n\\iiiint\n\n\\idotsint\n\n\n\n\\overrightarrow{x + y}\n\n\\overline{a + b}\n\n\n\n\\overbrace{a \\dots a}^{n}\n\n\\underbrace{a \\dots a}^{n}\n\n\n\n\\widetilde{xyz}\n\n\\widehat{xyz}\n\n\næ‹¬å·\n\\Bigg(\\bigg( \\Big( \\big( (x) \\big) \\Big) \\bigg) \\Bigg)\n\n\n\n\n\\Bigg\\{ \\bigg\\{ \\Big\\{ \\big\\{ \\{x\\} \\big\\} \\Big\\} \\bigg\\} \\Bigg\\}\n\n\n\næ–¹ç¨‹ç»„\naligned\n\n\n\\begin{aligned}f(x) &amp;= \\cos x \\\\f\\prime(x) &amp;= -\\sin x \\\\\\int_{0}^{x} f(y)dy &amp;= \\sin x\\end{aligned}\n\n\narray\n\n\n\\left\\{  \\begin{array}{c}  a_{0}+a_{1}x_{0}+...+a_{n}x_{0}^{n}=y_{0} \\\\  a_{0}+a_{1}x_{1}+...+a_{n}x_{1}^{n}=y_{1} \\\\  \\vdots\\\\  a_{0}+a_{1}x_{n}+...+a_{n}x_{n}^{n}=y_{n}   \\end{array}\\right.\n\n\ncases\n\n\n\\begin{cases}3x + 5y + z \\\\7x - 2y + 4z \\\\-6x + 3y + 2z\\tag{1}\\end{cases}\n\nçŸ©é˜µ\nmatrixã€pmatrixã€bmatrixã€Bmatrixã€vmatrixã€Vmatrix\n\n\n\\begin{gathered}\\begin{matrix} 0 &amp; 1 \\\\ 1 &amp; 0 \\end{matrix}\\quad\\begin{pmatrix} 0 &amp; -i \\\\ i &amp; 0 \\end{pmatrix}\\quad\\begin{bmatrix} 0 &amp; -1 \\\\ 1 &amp; 0 \\end{bmatrix}\\quad\\begin{Bmatrix} 1 &amp; 0 \\\\ 0 &amp; -1 \\end{Bmatrix}\\quad\\begin{vmatrix} a &amp; b \\\\ c &amp; d \\end{vmatrix}\\quad\\begin{Vmatrix} i &amp; 0 \\\\ 0 &amp; -i \\end{Vmatrix}\\end{gathered}\n\n\narray\n\n\n\\left(% å·¦æ‹¬å·  \\begin{array}{ccc}   % è¯¥çŸ©é˜µä¸€å…± 3 åˆ—ï¼Œæ¯ä¸€åˆ—éƒ½å±…ä¸­æ”¾ç½®    a11 &amp; a12 &amp; a13\\\\  % ç¬¬ä¸€è¡Œå…ƒç´     a21 &amp; a22 &amp; a23\\\\  % ç¬¬äºŒè¡Œå…ƒç´   \\end{array}\\right)                 % å³æ‹¬å·\n\n","categories":["Latex"],"tags":["ç¬¦å·","å…¬å¼"]},{"title":"OpenGL åŸºç¡€","url":"/2021/11/04/2/","content":"OpenGL ä¸Šä¸‹æ–‡ï¼ˆContextï¼‰å¸§ç¼“å†²åŒº (FrameBufferï¼‰\næ‰€æœ‰çš„è¿ç®—ç»“æœæœ€ç»ˆéƒ½æ˜¯éœ€è¦é€šè¿‡å›¾åƒè¿›è¡Œè¾“å‡ºçš„\nå¸§ç¼“å†²åŒº  å°±æ˜¯ OpenGL ä¸­çš„ç”»æ¿\nå¸§ç¼“å†²åŒº  å¹¶ä¸æ˜¯å®é™…å­˜å‚¨æ•°æ®çš„å¯¹è±¡\nå®é™…å­˜å‚¨æ•°æ®çš„ Attachment æ‰€æŒ‡å‘çš„å¯¹åº”ç¼“å†²åŒº\n\nAttachmentå¸§ç¼“å†²åŒºä¸­æœ‰ä¸‰ç§ Attachmentï¼ŒColor Attachmentï¼ŒDepth Attachmentï¼ŒStencil Attachmentã€‚è¿™ä¸‰ç§Attachment å¯¹åº”çš„ç¼“å†²åŒºåˆ†åˆ«æ˜¯é¢œè‰²ç¼“å†²åŒºï¼ˆColor Bufferï¼‰ï¼Œæ·±åº¦ç¼“å†²åŒºï¼ˆDepth Bufferï¼‰ï¼Œæ¨¡æ¿ç¼“å†²åŒºï¼ˆStencil Bufferï¼‰ã€‚\nçº¹ç†ï¼ˆTextureï¼‰å’Œæ¸²æŸ“ç¼“å†²åŒºï¼ˆRender Bufferï¼‰\nçº¹ç†å’Œæ¸²æŸ“ç¼“å†²åŒºéƒ½æ˜¯å­˜å‚¨å›¾åƒçš„å¯¹è±¡\næ¸²æŸ“ç¼“å†²åŒºå¯¹åº”æ“ä½œç³»ç»Ÿæä¾›çš„çª—å£ï¼Œè€Œçº¹ç†ä»£è¡¨ç¦»å±çš„å›¾åƒå­˜å‚¨åŒºåŸŸ\næ¸²æŸ“ç¼“å†²åŒºéƒ½æ˜¯ 2D çš„å›¾åƒç±»å‹\nçº¹ç†ä¸€èˆ¬æœ‰ç«‹æ–¹ä½“çº¹ç†ï¼Œ1Dã€2Dã€3D çº¹ç†ç­‰ç±»å‹\næ¸²æŸ“ç¼“å†²åŒºå’Œçº¹ç†ä¸èƒ½åŒæ—¶æŒ‚è½½åœ¨åŒä¸€ä¸ªå¸§ç¼“å†²åŒºä¸Š\n\né¡¶ç‚¹æ•°ç»„ï¼ˆVertex Arrayï¼‰å’Œé¡¶ç‚¹ç¼“å†²åŒºï¼ˆVertex Bufferï¼‰OpenGL ä¸­çš„å›¾åƒéƒ½æ˜¯ç”±å›¾å…ƒç»„æˆçš„ï¼Œç”±ä¸‰ç§ç±»å‹çš„å›¾å…ƒï¼šç‚¹ã€çº¿ã€ä¸‰è§’å½¢ã€‚\n\né¡¶ç‚¹æ•°æ®ä»¥æ•°ç»„çš„å½¢å¼å­˜å‚¨åœ¨å†…å­˜å½“ä¸­ç§°ä¸º  é¡¶ç‚¹æ•°ç»„\né¡¶ç‚¹æ•°æ®å­˜åœ¨æ˜¾å­˜å½“ä¸­ç§°ä¸º  é¡¶ç‚¹ç¼“å†²åŒº\n\nç´¢å¼•æ•°ç»„ï¼ˆElement Arrayï¼‰å’Œç´¢å¼•ç¼“å†²åŒºï¼ˆElement Bufferï¼‰\nç´¢å¼•æ•°æ®çš„ç›®çš„ä¸»è¦æ˜¯ä¸ºäº†å®ç°é¡¶ç‚¹çš„å¤ç”¨ï¼Œé€šè¿‡ç´¢å¼•æ•°æ®æŒ‡ç¤º OpenGL ç»˜åˆ¶é¡¶ç‚¹çš„é¡ºåºï¼Œèƒ½é˜²æ­¢é¡¶ç‚¹çš„é‡å¤è¿ç®—\nç´¢å¼•æ•°æ®ä»¥æ•°ç»„çš„å½¢å¼å­˜åœ¨å†…å­˜å½“ä¸­æˆä¸º  ç´¢å¼•æ•°ç»„\nç´¢å¼•æ•°æ®å­˜åœ¨æ˜¾å­˜å½“ä¸­ç§°ä¸º  ç´¢å¼•ç¼“å†²åŒº\nOpenGL æä¾›äº† 2 ä¸­ä¸»è¦çš„ç»˜åˆ¶æ–¹æ³•ï¼šglDrawArrayå’ŒglDrawElementsï¼Œå‰è€…å¯¹åº”çš„æ—¶æ²¡æœ‰ç´¢å¼•æ•°æ®çš„æƒ…å†µï¼Œåè€…å¯¹åº”çš„æ—¶ç”±ç´¢å¼•æ•°æ®çš„æƒ…å†µ\n\né¡¶ç‚¹ç€è‰²å™¨ï¼ˆVertex Shaderï¼‰\né¡¶ç‚¹ç€è‰²å…¶æ—¶ OpenGL ä¸­ç”¨äºè®¡ç®—é¡¶ç‚¹å±æ€§çš„ç¨‹åºã€‚æ¯ä¸ªé¡¶ç‚¹æ•°æ®éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡é¡¶ç‚¹ç€è‰²å™¨ï¼ˆå¹¶è¡Œçš„ï¼‰ï¼Œå¹¶ä¸”é¡¶ç‚¹ç€è‰²å™¨è¿ç®—è¿‡ç¨‹ä¸­æ— æ³•è®¿é—®å…¶ä»–é¡¶ç‚¹çš„æ•°æ®\né¡¶ç‚¹ç€è‰²å™¨çš„æ•°æ®è¾“å…¥ä¸»è¦æœ‰ä¸¤ç§ï¼š\nç»Ÿä¸€å˜é‡ï¼ˆUniformï¼‰ï¼šåœ¨æ‰€æœ‰é¡¶ç‚¹è¿ç®—ä¸­æ˜¯ä¸€æ ·çš„\né¡¶ç‚¹å±æ€§ï¼ˆVertex Attributeï¼‰ï¼šä»å¤–éƒ¨è¾“å…¥çš„é¡¶ç‚¹æ•°æ®ä¸­è·å–ï¼Œä¸€èˆ¬åœ¨æ¯ä¸ªé¡¶ç‚¹è¿ç®—ä¸­ä¸åŒ\n\n\nå…¸å‹çš„éœ€è¦è®¡ç®—çš„é¡¶ç‚¹å±æ€§ä¸»è¦åŒ…æ‹¬é¡¶ç‚¹åæ ‡å˜æ¢ã€é€é¡¶ç‚¹å…‰ç…§è¿ç®—ç­‰ç­‰\né¡¶ç‚¹ç€è‰²å™¨çš„è¾“å‡ºç»“æœä¹Ÿä¼šä½œä¸ºç‰‡æ®µç€è‰²å™¨çš„è¾“å…¥\n\nç‰‡æ®µç€è‰²å™¨ï¼ˆFragment Shaderï¼‰\nç‰‡æ®µç€è‰²å™¨æ˜¯ OpenGL ä¸­ç”¨äºè®¡ç®—ç‰‡æ®µï¼ˆåƒç´ ï¼‰é¢œè‰²çš„ç¨‹åºã€‚æ¯ä¸ªåƒç´ éƒ½ä¼šæ‰§è¡Œä¸€æ¬¡ç‰‡æ®µç€è‰²å™¨ã€‚\nç‰‡æ®µç€è‰²å™¨æœ‰ä¸‰ç§ï¼š\nç»Ÿä¸€å˜é‡ï¼ˆUniformï¼‰ï¼šåœ¨åŒä¸€ä¸ª OpenGL ç€è‰²å™¨ç¨‹åºä¸­é¡¶ç‚¹ç€è‰²å™¨å’Œç‰‡æ®µç€è‰²å™¨æ˜¯ä¸€è‡´çš„\né¡¶ç‚¹ç€è‰²å™¨è¾“å…¥å˜é‡ï¼ˆVaryingï¼‰ï¼šåœ¨æ¯ä¸ªåƒç´ è¿ç®—ä¸­ä¸€èˆ¬æ˜¯ä¸åŒçš„ï¼Œå®ƒçš„å€¼ç”±ç»„æˆå›¾å…ƒé¡¶ç‚¹çš„é¡¶ç‚¹ç€è‰²å™¨è¿ç®—è¾“å‡ºçš„å€¼ï¼Œæ ¹æ®åƒç´ ä½ç½®è¿›è¡Œæ’å€¼çš„ç»“æœè€Œå†³å®š\né‡‡æ ·å™¨ï¼ˆSamplerï¼‰ï¼šä»è®¾å®šå¥½çš„çº¹ç†ä¸­è·å–çº¹ç†çš„åƒç´ é¢œè‰²\n\n\n\né€ç‰‡å…ƒæ“ä½œï¼ˆPer-Fragment Operationï¼‰æµ‹è¯•ï¼ˆTestï¼‰\næµ‹è¯•ä¸»è¦å¯ä»¥åˆ†ä¸ºåƒç´ æ‰€æœ‰è€…æµ‹è¯•ï¼ˆPixelOwnership Testï¼‰ã€è£å‰ªæµ‹è¯•ï¼ˆScissor Testï¼‰ã€æ¨¡æ¿æµ‹è¯•ï¼ˆStencil Testï¼‰å’Œæ·±åº¦æµ‹è¯•ï¼ˆDepth Testï¼‰\næ¨¡æ¿æµ‹è¯•ï¼šé€šè¿‡æ¨¡æ¿æµ‹è¯•å†³å®šæœ€ç»ˆçš„åƒç´ æ˜¯å¦ä¸¢å¼ƒï¼Œæ ¹æ® OpenGL çš„æ¨¡æ¿è¦†å†™çŠ¶æ€å†³å®šæ˜¯å¦æ›´æ–°åƒç´ çš„æ¨¡æ¿å€¼\næ·±åº¦æµ‹è¯•ï¼šä¸»è¦é€šè¿‡å¯¹åƒç´ çš„è¿ç®—å‡ºæ¥çš„æ·±åº¦è¿›è¡Œå¯¹æ¯”ï¼Œæ ¹æ® OpenGL è®¾å®šå¥½çš„æ·±åº¦æµ‹è¯•ç¨‹åºï¼Œå†³å®šæ˜¯å¦æœ€ç»ˆæ¸²æŸ“åˆ°ç”»å¸ƒä¸Šã€‚\n\næ··åˆï¼ˆBlendingï¼‰åœ¨æ··åˆé˜¶æ®µï¼Œåƒç´ çš„é¢œè‰²å’Œå¸§ç¼“å†²åŒºä¸­é¢œè‰² Attachment ä¸Šçš„é¢œè‰²è¿›è¡Œæ··åˆï¼Œæ··åˆçš„ç®—æ³•å¯ä»¥é€šè¿‡ OpenGL çš„å‡½æ•°è¿›è¡ŒæŒ‡å®šã€‚ä½†æ˜¯ OpenGL æä¾›çš„æ··åˆç®—æ³•æ˜¯æœ‰é™çš„ï¼Œå¦‚æœéœ€è¦æ›´åŠ å¤æ‚çš„æ··åˆç®—æ³•ï¼Œä¸€èˆ¬å¯ä»¥é€šè¿‡åƒç´ ç€è‰²å™¨è¿›è¡Œå®ç°ï¼Œå½“ç„¶æ€§èƒ½å›é¿åŸç”Ÿçš„æ··åˆç®—æ³•å·®ä¸€äº›\næŠ–åŠ¨ï¼ˆDitheringï¼‰æŠ–åŠ¨æ˜¯ä¸€ç§é’ˆå¯¹äºå¯ç”¨é¢œè‰²è¾ƒå°‘çš„ç³»ç»Ÿï¼Œå¯ä»¥ä»¥ç‰ºç‰²åˆ†è¾¨ç‡ä¸ºä»£ä»·ï¼Œé€šè¿‡é¢œè‰²å€¼çš„æŠ–åŠ¨æ¥å¢åŠ å¯ç”¨é¢œè‰²æ•°é‡çš„æŠ€æœ¯\næ¸²æŸ“åˆ°çº¹ç†  æœ‰äº› OpenGL ç¨‹åºå¹¶ä¸å¸Œæœ›æ¸²æŸ“å‡ºæ¥çš„å›¾åƒç«‹å³æ˜¾ç¤ºåœ¨å±å¹•ä¸Šï¼Œè€Œæ˜¯éœ€è¦å¤šæ¬¡æ¸²æŸ“ã€‚å¯èƒ½å…¶ä¸­ä¸€æ¬¡æ¸²æŸ“çš„ç»“æœæ˜¯ä¸‹æ¬¡æ¸²æŸ“çš„è¾“å…¥ã€‚å› æ­¤ï¼Œå¦‚æœå¸§ç¼“å†²åŒºçš„é¢œè‰² Attachment è®¾ç½®ä¸ºä¸€å¼ çº¹ç†ï¼Œé‚£ä¹ˆæ¸²æŸ“å®Œæˆä¹‹åï¼Œå¯ä»¥é‡æ–°æ„é€ æ–°çš„ç¼“å†²åŒºï¼Œå¹¶å°†ä¸Šæ¬¡æ¸²æŸ“å‡ºæ¥çš„çº¹ç†ä½œä¸ºè¾“å…¥ï¼Œé‡æ–°è¿›è¡Œå‰é¢æ‰€è¿°çš„æµç¨‹\næ¸²æŸ“ä¸Šå± / äº¤æ¢ç¼“å†²åŒºï¼ˆSwap Bufferï¼‰\næ¸²æŸ“ç¼“å†²åŒºä¸€èˆ¬æ˜ å°„çš„ç³»ç»Ÿèµ„æºæ¯”å¦‚çª—å£ï¼Œå¦‚æœæ¯ä¸ªçª—å£åªæœ‰ä¸€ä¸ªç¼“å†²åŒºï¼Œé‚£ä¹ˆåœ¨ç»˜åˆ¶è¿‡ç¨‹ä¸­å±å¹•è¿›è¡Œäº†åˆ·æ–°ï¼Œçª—å£å¯èƒ½æ˜¾ç¤ºå‡ºä¸å®Œæ•´çš„å›¾åƒ\nå¸¸è§„çš„ OpenGL ç¨‹åºè‡³å°‘éƒ½ä¼šç”±ä¸¤ä¸ªç¼“å†²åŒºã€‚æ˜¾ç¤ºåœ¨å±å¹•ä¸Šçš„ç§°ä¸ºå±å¹•ç¼“å†²åŒºï¼Œæ²¡æœ‰æ˜¾ç¤ºçš„ç§°ä¸ºç¦»å±ç¼“å†²åŒº\nå‚ç›´åŒæ­¥ï¼šç”±äºæ˜¾ç¤ºå™¨åˆ·æ–°ä¸€èˆ¬æ˜¯é€è¡Œè¿›è¡Œçš„ï¼Œå› æ­¤ä¸ºäº†é˜²æ­¢äº¤æ¢ç¼“å†²åŒºçš„æ—¶å€™å±å¹•ä¸Šä¸‹åŒºåŸŸçš„å›¾åƒåˆ†å±ä¸¤ä¸ªä¸åŒçš„å¸§ï¼Œå› æ­¤äº¤æ¢ä¸€èˆ¬ä¼šç­‰å¾…æ˜¾ç¤ºå™¨åˆ·æ–°å®Œæˆçš„ä¿¡å·ï¼Œåœ¨æ˜¾ç¤ºå™¨ä¸¤æ¬¡åˆ·æ–°çš„é—´éš”ä¸­è¿›è¡Œäº¤æ¢ï¼Œè¿™ä¸ªä¿¡å·å°±è¢«ç§°ä¸º  å‚ç›´åŒæ­¥ä¿¡å· ï¼Œè¿™ä¸ªæŠ€æœ¯ç§°ä¸º å‚ç›´åŒæ­¥\nä½¿ç”¨äº†åŒç¼“å†²åŒºå’Œå‚ç›´åŒæ­¥æŠ€æœ¯ä¹‹åï¼Œç”±äºæ€»æ˜¯è¦ç­‰å¾…ç¼“å†²åŒºäº¤æ¢ä¹‹ååœ¨è¿›è¡Œä¸‹ä¸€å¸§çš„æ¸²æŸ“ï¼Œä½¿å¾—å¸§ç‡æ— æ³•è¾¾åˆ°ç¡¬ä»¶å…è®¸çš„æœ€é«˜æ°´å¹³ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¼•å…¥äº†ä¸‰ç¼“å†²åŒºæŠ€æœ¯ï¼Œåœ¨ç­‰å¾…å‚ç›´åŒæ­¥æ—¶ï¼Œæ¥å›äº¤æ›¿æ¸²æŸ“ä¸¤ä¸ªç¦»å±çš„ç¼“å†²åŒºï¼Œè€Œå‚ç›´åŒæ­¥å‘ç”Ÿæ—¶ï¼Œå±å¹•ç¼“å†²åŒºå’Œæœ€è¿‘æ¸²æŸ“å®Œæˆçš„ç¦»å±ç¼“å†²åŒºäº¤æ¢ï¼Œå®ç°å……åˆ†åˆ©ç”¨ç¡¬ä»¶æ€§èƒ½çš„ç›®çš„\n\n","categories":["Learning OpenGL"],"tags":["Graphics","OpenGL"]},{"title":"BÃ©zier Curve","url":"/2021/11/22/20/","content":"de Castekjau Algorithm\n    \n\n\nå¦‚å›¾æ‰€ç¤ºï¼Œå¯¹äº 3 é˜¶çš„ BÃ©zier æ›²çº¿åœ¨  æ—¶åˆ»éœ€è¦å¯»æ‰¾ 3 æ¬¡æ’å€¼ç‚¹ï¼šç¬¬ä¸€æ¬¡ä¸º ï¼Œ å’Œï¼›ç¬¬äºŒæ¬¡ä¸º  å’Œï¼›ç¬¬ä¸‰æ¬¡ä¸ºï¼Œå³æ›²çº¿ä¸Šçš„ç‚¹ã€‚å¯¹åº”çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š\nrecursiveï¼ˆæ’å€¼ç‚¹ / æ§åˆ¶ç‚¹ (points)ï¼Œæ—¶åˆ» (t))ï¼š    // é€’å½’ç»ˆæ­¢æ¡ä»¶    åªæœ‰ä¸€ä¸ªæ’å€¼ç‚¹ï¼š        return è¯¥æ’å€¼ç‚¹ï¼›    // è¿›è¡Œé€’å½’    æ ¹æ® æ’å€¼ç‚¹ / æ§åˆ¶ç‚¹ (points) è®¡ç®—ä¸‹ä¸€æ¬¡çš„ æ’å€¼ç‚¹ / æ§åˆ¶ç‚¹ (_points);    return recursiveï¼ˆæ’å€¼ç‚¹ / æ§åˆ¶ç‚¹ (_points), æ—¶åˆ» (t));\n\nç›¸å…³ä»£ç cv::Point2f recursive_bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, float t){    // TODO: Implement de Casteljau's algorithm    if (control_points.size() == 1)        return control_points[0];    else    {        std::vector&lt;cv::Point2f&gt; points;        for (auto i = 0; i &lt; control_points.size() - 1; i += 1)        {            auto &amp;p0 = control_points[i];            auto &amp;p1 = control_points[i + 1];            points.emplace_back((1 - t) * p0 + t * p1);        }        return recursive_bezier(points, t);    }}\n\nvoid bezier(const std::vector&lt;cv::Point2f&gt;&amp; control_points, cv::Mat&amp; window){    // TODO: Iterate through all t = 0 to t = 1 with small steps, and call de Casteljau's     // recursive Bezier algorithm.    for (double t = 0.0; t &lt;= 1.0; t += 0.001)    {        auto point = recursive_bezier(control_points, t);        window.at&lt;cv::Vec3b&gt;(point.y, point.x)[2] = 255;    }}\n\nç»“æœ\n    \n\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"Whitted Style Ray Tracing","url":"/2021/11/22/21/","content":"\nä» main å‡½æ•°å¼€å§‹ï¼Œå®šä¹‰åœºæ™¯çš„å‚æ•°ï¼Œæ·»åŠ ç‰©ä½“ï¼ˆçƒä½“æˆ–ä¸‰è§’å½¢ï¼‰åˆ°åœºæ™¯ä¸­ï¼Œå¹¶è®¾ç½®å…¶æè´¨ï¼Œç„¶åå°†å…‰æºæ·»åŠ åˆ°åœºæ™¯ä¸­\nè°ƒç”¨ Render å‡½æ•°ã€‚åœ¨éå†æ‰€æœ‰åƒç´ çš„å¾ªç¯é‡Œï¼Œç”Ÿæˆå¯¹åº”çš„å…‰çº¿å¹¶å°†è¿”å›çš„é¢œè‰²ä¿å­˜åœ¨  å¸§ç¼“å†²åŒº  ä¸­ã€‚åœ¨æ¸²æŸ“è¿‡ç¨‹ç»“æŸåï¼Œå¸§ç¼“å†²åŒºä¸­çš„ä¿¡æ¯å°†è¢«ä¿å­˜ä¸ºå›¾åƒ\nåœ¨ç”Ÿæˆåƒç´ å¯¹åº”çš„å…‰çº¿åï¼Œè°ƒç”¨ CastRay å‡½æ•°ï¼Œè¯¥å‡½æ•°è°ƒç”¨ trace æ¥æŸ¥è¯¢å…‰çº¿ä¸åœºæ™¯ä¸­æœ€è¿‘çš„å¯¹è±¡çš„äº¤ç‚¹\n\n\n\nä»æ‘„åƒæœºä½ç½®å‘å±å¹•åƒç´ ç‚¹å‘å°„å…‰çº¿ Render å‡½æ•°éœ€è¦ä¸ºæ¯ä¸€ä¸ªåƒç´ ç”Ÿæˆä¸€æ¡å¯¹åº”çš„å…‰çº¿ï¼Œç„¶åè°ƒç”¨å‡½æ•°  castRay æ¥å¾—åˆ°é¢œè‰²ï¼Œæœ€åå°†é¢œè‰²å­˜å‚¨åœ¨å¸§ç¼“å†²åŒºçš„ç›¸åº”åƒç´ ä¸­ã€‚ å°±æ˜¯ä¸ºå±å¹•ä¸Šçš„æ¯ä¸€ä¸ªç‚¹ç”Ÿæˆä¸€æ¡ç”±  è§†ç‚¹  åˆ°å±å¹•ä¸Šçš„ç‚¹çš„æ–¹å‘å‘é‡ï¼Œå°†å±å¹•ä¸Šçš„ç‚¹ä¸è¿‘å¹³é¢ä¸Šçš„ç‚¹ä¸€ä¸€å¯¹åº”å³å¯ï¼šè®¡ç®—å‡ºåƒç´ ç‚¹åœ¨è¿‘å¹³é¢åæ ‡ç³»ä¸Šçš„ä½ç½® ï¼›å°† åˆ†åˆ«ä¹˜ä»¥è¿‘å¹³é¢åœ¨  å’Œæ–¹å‘ä¸Šçš„å®é™…é•¿åº¦\n\n    \n\n\nå¦‚å›¾ï¼Œå¯¹äºå±å¹•ä¸Šçš„ä¸€ä¸ªç‚¹ ï¼Œå¦‚æœå±å¹•é•¿ã€å®½åˆ†åˆ«å ã€ ä¸ªåƒç´ ï¼Œå¯ä»¥è®¡ç®—å‡ºå®ƒåœ¨è¿‘å¹³é¢åæ ‡ç³»ä¸Šçš„åæ ‡ä¸ºï¼š\n\n ä»£ç éå†æ˜¯ä» 0 å¼€å§‹ï¼Œéœ€è¦åŠ ä¸Š 0.5 ä½¿å…¶ç§»åŠ¨åˆ°åƒç´ ä¸­å¿ƒï¼Œå†è¿›è¡Œåæ ‡å˜æ¢\n\nç”±é€è§†å˜æ¢ä¸­çš„å…¬å¼å¯å¾—\nvoid Renderer::Render(const Scene&amp; scene){    std::vector&lt;Vector3f&gt; framebuffer(scene.width * scene.height);    float scale = std::tan(deg2rad(scene.fov * 0.5f));    float imageAspectRatio = scene.width / (float)scene.height;    // Use this variable as the eye position to start your rays.    Vector3f eye_pos(0);    int m = 0;    for (int j = 0; j &lt; scene.height; ++j)    {        for (int i = 0; i &lt; scene.width; ++i)        {            // generate primary ray direction            float x;            float y;            // TODO: Find the x and y positions of the current pixel to get the direction            // vector that passes through it.            // Also, don't forget to multiply both of them with the variable *scale*, and            // x (horizontal) variable with the *imageAspectRatio*            \t    x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale;            y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;            Vector3f dir = Vector3f(x, y, -1) - eye_pos; // Don't forget to normalize this direction!            dir = normalize(dir);            framebuffer[m++] = castRay(eye_pos, dir, scene, 0);        }        //UpdateProgress(j / (float)scene.height);    }    // save framebuffer to file    FILE* fp = fopen(\"binary.ppm\", \"wb\");    (void)fprintf(fp, \"P6\\n%d %d\\n255\\n\", scene.width, scene.height);    for (auto i = 0; i &lt; scene.height * scene.width; ++i) {        static unsigned char color[3];        color[0] = (char)(255 * clamp(0, 1, framebuffer[i].x));        color[1] = (char)(255 * clamp(0, 1, framebuffer[i].y));\tcolor[2] = (char)(255 * clamp(0, 1, framebuffer[i].z));\t//std::cout &lt;&lt; '(' &lt;&lt; color[0] &lt;&lt; \",\" &lt;&lt; color[1] &lt;&lt; \",\" &lt;&lt; color[2] &lt;&lt; \")\" &lt;&lt; std::endl;        fwrite(color, 1, 3, fp);    }    fclose(fp);    }\n\næ˜¯å¦ä¸ä¸‰è§’å½¢ç›¸äº¤ v0ï¼Œv1ï¼Œv2 æ˜¯ä¸‰è§’å½¢çš„ä¸‰ä¸ª é¡¶ç‚¹ï¼Œorigæ˜¯å…‰çº¿çš„èµ·ç‚¹ï¼Œdiræ˜¯å…‰çº¿å•ä½åŒ–çš„æ–¹å‘å‘é‡ï¼Œæ ¹æ® Moller-Trumbore ç®—æ³•æ¥æ±‚è§£  å…¶ä¸­ ã€ã€ æ˜¯é‡å¿ƒåæ ‡\nbool rayTriangleIntersect(const Vector3f&amp; v0, const Vector3f&amp; v1, const Vector3f&amp; v2, const Vector3f&amp; orig,                          const Vector3f&amp; dir, float&amp; tnear, float&amp; u, float&amp; v){    // TODO: Implement this function that tests whether the triangle    // that's specified bt v0, v1 and v2 intersects with the ray (whose    // origin is *orig* and direction is *dir*)    // Also don't forget to update tnear, u and v.    auto e1 = v1 - v0;    auto e2 = v2 - v0;    auto s = orig - v0;    auto s1 = crossProduct(dir, e2);    auto s2 = crossProduct(s, e1);    auto coeff = 1 / dotProduct(s1, e1);    auto t = coeff * dotProduct(s2, e2);    auto b1 = coeff * dotProduct(s1, s);    auto b2 = coeff * dotProduct(s2, dir);    if (t &gt;= 0 &amp;&amp; b1 &gt;= 0 &amp;&amp; b2 &gt;= 0 &amp;&amp; (1 - b1 - b2) &gt;= 0)    {        tnear = t;        u = b1;        v = b2;        return true;    }    return false;}\n\næœ€ç»ˆç»“æœ\n    \n\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"æ—¶åŸŸå’Œé¢‘åŸŸ","url":"/2021/11/24/22/","content":"å‚…é‡Œå¶çº§æ•°  çš„é¢‘è°±\næ­£å¼¦æ³¢\næ­£å¼¦æ³¢å°±æ˜¯ä¸€ä¸ªåœ†å‘¨è¿åŠ¨åœ¨ä¸€æ¡ç›´çº¿ä¸Šçš„æŠ•å½±ã€‚æ‰€ä»¥é¢‘åŸŸçš„åŸºæœ¬å•å…ƒä¹Ÿå¯ä»¥ç†è§£ä¸ºä¸€ä¸ªå§‹ç»ˆåœ¨æ—‹è½¬çš„åœ†\n\n   \n\n\n\n    \n\nå¦‚å‰ä¸¤å¹…å›¾æ‰€ç¤ºï¼Œéšç€æ­£å¼¦æ³¢æ•°é‡é€æ¸çš„å¢é•¿ï¼Œå®ƒä»¬æœ€ç»ˆä¼šå åŠ æˆä¸€ä¸ªæ ‡å‡†çš„çŸ©å½¢ã€‚å¦‚æœæ¢ä¸€ä¸ªè§’åº¦æ¥çœ‹ï¼Œä¾¿ä¼šå‘ç°çŸ©å½¢æ³¢åœ¨é¢‘åŸŸçš„æ ·å­ï¼ˆå³ç¬¬å››å¹…å›¾ï¼‰ç§°ä¸ºé¢‘åŸŸå›¾åƒï¼Œä¹Ÿæˆä¸ºé¢‘è°±ã€‚å®Œæ•´æµç¨‹å¦‚ä¸‹ï¼š\n\n\n    \n\n\nå‚…é‡Œå¶çº§æ•°  çš„çš„ç›¸ä½è°±  å‚…é‡Œå¶åˆ†æçš„ç”¨å¤„  å›¾åƒå¤„ç†\nå›¾åƒå¢å¼ºä¸å›¾åƒå»å™ª\nå›¾åƒåˆ†å‰²ä¹‹è¾¹ç¼˜æ£€æµ‹\nå›¾åƒç‰¹å¾æå–\nå›¾åƒå‹ç¼©\n\nå·¥ç¨‹åº”ç”¨  é€šè¿‡å‚…é‡Œå¶å˜æ¢å’Œåå˜æ¢ï¼Œä»ä¸€ä¸ªå®Œå…¨æ‚ä¹±æ— ç« çš„ä¿¡å·é‡Œé¢ï¼Œå¯ä»¥æå–å‡ºæœŸæœ›çš„ä½é¢‘ä¿¡å·ï¼Œè€Œæ»¤æ‰äº†é«˜é¢‘ä¿¡å·ã€‚\n\næ¯”å¦‚ï¼Œæ£€æµ‹åˆ°ä¸€ä¸ªä¿¡å·æ˜¯è¿™æ ·çš„\n\n    \n\n\nå¯èƒ½çš„æ›²çº¿æ–¹ç¨‹å¼ä¸ºï¼šéœ€è¦æŠŠ  ä»å›¾åƒä¸­å‰”é™¤ï¼Œåœ¨æ—¶åŸŸä¸Šå¾ˆéš¾å®Œæˆï¼Œä½†æ˜¯åœ¨é¢‘åŸŸåè€Œå¾ˆå®¹æ˜“\næ‰€ä»¥å¾ˆå¤šåœ¨æ—¶åŸŸçœ‹ä¼¼ä¸å¯èƒ½åšåˆ°çš„æ•°å­¦æ“ä½œï¼Œè€Œç»è¿‡å‚…é‡Œå¶å˜æ¢ï¼Œåœ¨é¢‘åŸŸç›¸åå¾ˆå®¹æ˜“ã€‚å°¤å…¶æ˜¯ä»æŸæ¡æ›²çº¿ä¸­å»é™¤ä¸€äº›ç‰¹å®šçš„é¢‘ç‡æˆåˆ†ï¼Œè¿™åœ¨å·¥ç¨‹ä¸Šç§°ä¸ºæ»¤æ³¢ï¼Œæ˜¯ä¿¡å·å¤„ç†æœ€é‡è¦çš„æ¦‚å¿µä¹‹ä¸€ï¼Œåªæœ‰åœ¨é¢‘åŸŸæ‰èƒ½è½»æ¾çš„åšåˆ°ã€‚\n\næ±‚è§£å¾®åˆ†æ–¹ç¨‹  æ±‚è§£å¾®åˆ†æ–¹ç¨‹æ˜¯ä¸€ä»¶ç›¸å½“éº»çƒ¦çš„äº‹æƒ…ã€‚å› ä¸ºé™¤äº†è¦è®¡ç®—åŠ å‡ä¹˜é™¤ï¼Œè¿˜è¦è®¡ç®—å¾®åˆ†ç§¯åˆ†ã€‚è€Œå‚…é‡Œå¶å˜æ¢åˆ™å¯ä»¥è®©å¾®åˆ†å’Œç§¯åˆ†åœ¨é¢‘åŸŸä¸­å˜ä¸ºä¹˜æ³•å’Œé™¤æ³•\nç›¸ä½è°±\n    \n\n\né€šè¿‡æ—¶åŸŸåˆ°é¢‘åŸŸçš„å˜æ¢ï¼Œå¾—åˆ°äº†ä¸€ä¸ªä»ä¾§é¢çœ‹çš„é¢‘è°±ï¼Œä½†æ˜¯è¿™ä¸ªé¢‘è°±å¹¶æ²¡æœ‰åŒ…å«æ—¶åŸŸä¸­å…¨éƒ¨çš„ä¿¡æ¯ã€‚å› ä¸ºé¢‘è°±åªä»£è¡¨æ¯ä¸€ä¸ªå¯¹åº”çš„æ­£å¼¦æ³¢çš„æŒ¯å¹…æ˜¯å¤šå°‘ï¼Œè€Œæ²¡æœ‰æåˆ°ç›¸ä½ã€‚é¦–å…ˆå…ˆæ˜ç¡®  ç›¸ä½  çš„å«ä¹‰ï¼Œåœ¨ä¿¡å·ä¸ç³»ç»Ÿä¸­ï¼Œç›¸ä½  ä»£è¡¨çš„æ˜¯æ­£å¼¦é‡çš„å¹…è§’ï¼Œè¿™é‡Œä¸ºåˆç›¸è§’ï¼ˆä¸‰è§’å‡½æ•°  ä¸­ä¸ºç›¸ä½ï¼Œä¸ºåˆç›¸ï¼‰ã€‚è€Œ  ç›¸ä½è°±  è¡¨ç¤ºçš„æ˜¯  ç›¸ä½  éšé¢‘ç‡çš„å˜åŒ–æƒ…å†µï¼Œä»£è¡¨æ¯ä¸ªé¢‘ç‡åˆ†é‡åœ¨æ—¶é—´åŸç‚¹æ‰€å…·æœ‰çš„  ç›¸ä½ã€‚\n\nç›¸ä½è°±çš„æ„Ÿæ€§ç†è§£\nå½“èˆ¹åœ¨å¤§æµ·ä¸­é‡åˆ°å¤šç§æ³¢å…±åŒä½œç”¨ï¼Œç”±äºæ¯ä¸€ç§éƒ½å¯ä»¥è¢«åˆ†è§£ä¸ºå¤šä¸ªå›ºå®šé¢‘ç‡æ³¢çš„å åŠ ï¼Œæ•…å¯ç®€åŒ–ä¸ºèˆ¹åªå—åˆ°å¤šç§å›ºå®šé¢‘ç‡æ³¢å åŠ ï¼Œå§‘ä¸”ç®—åšä¸¤ä¸ªå§ï¼Œå¦‚æœè¿™ä¸¤ä¸ªæ³¢çš„ç›¸å¯¹ç›¸ä½ï¼ˆè‹¥åˆå§‹ç›¸ä½ç¡®å®šåˆ™ç›¸å¯¹ç›¸ä½ä¹Ÿå°±ç¡®å®šäº†ï¼‰ä¸åŒï¼Œé‚£ä¹ˆèˆ¹çš„ç»“æœå°±å¯èƒ½å®Œå…¨ä¸åŒã€‚ä¸€ç»´æƒ…å†µæ—¶ï¼Œä¸¤ä¸ªæ³¢æ¥è‡ªäºåŒä¸€æ–¹å‘ï¼Œè‹¥èˆ¹æ°å¥½å¤„äºä¸¤ä¸ªæ³¢åŒç›¸ç‚¹å¤„ï¼Œé‚£æ­¤æ—¶æ³¢æµªå¯¹èˆ¹çš„ä½œç”¨æœ€å¼ºï¼Œå¯èƒ½å¯¼è‡´ç¿»èˆ¹ï¼Œå½“ç„¶è‹¥èˆ¹å¤„äºä¸¤ä¸ªæ³¢çš„åç›¸ç‚¹å¤„ï¼Œæ³¢æµªå¯¹èˆ¹çš„ä½œç”¨æœ€å°ï¼Œæ­¤å¤„å®‰å…¨æ€§æœ€é«˜ï¼ˆä»¥èˆ¹ä¸ºåˆ†æå¯¹è±¡ï¼Œåˆ™å¯¹èˆ¹æ¥è¯´ï¼Œèˆ¹çš„ä½ç½®å¤„ç®—æ˜¯é›¶ç‚¹ï¼Œæ­¤å¤„çš„ç›¸ä½ä¹Ÿå°±æ˜¯åˆç›¸ï¼Œä¸¤ä¸ªæ³¢å„è‡ªçš„åˆç›¸ä¸åŒæ—¶ï¼Œé‚£ä¹ˆæ­¤å¤„ç»¼åˆä¿¡å·å¼ºåº¦ä¸åŒå¯¹èˆ¹çš„ä½œç”¨æ•ˆæœä¸åŒï¼‰[2]ã€‚\n\næ—¶é—´å·®å¹¶ä¸æ˜¯ç›¸ä½å·®ã€‚å¦‚æœå°†å…¨éƒ¨å‘¨æœŸçœ‹ä½œ  çš„è¯ï¼Œç›¸ä½å·®åˆ™æ˜¯æ—¶é—´å·®åœ¨ä¸€ä¸ªå‘¨æœŸä¸­æ‰€å çš„æ¯”ä¾‹ã€‚å°†æ—¶é—´å·®é™¤å‘¨æœŸå†ä¹˜ï¼Œå°±å¾—åˆ°äº†ç›¸ä½å·®ã€‚\n\n    \n\nå°†æŠ•å½±å¾—åˆ°çš„æ—¶é—´å·®ä¾æ¬¡é™¤ä»¥æ‰€åœ¨é¢‘ç‡çš„å‘¨æœŸï¼Œå°±å¾—åˆ°äº†ç›¸ä½è°±ã€‚æ‰€ä»¥ï¼Œé¢‘è°±æ˜¯ä»ä¾§é¢çœ‹ï¼Œç›¸ä½è°±æ˜¯ä»ä¸‹é¢çœ‹ã€‚\n\nå‚…é‡Œå¶å˜æ¢\nå‚…é‡Œå¶å˜æ¢  æ˜¯ä¸€ç§çº¿æ€§ç§¯åˆ†å˜æ¢ï¼Œç”¨äºä¿¡å·åœ¨æ—¶åŸŸï¼ˆæˆ–ç©ºåŸŸï¼‰å’Œé¢‘åŸŸä¹‹é—´çš„å˜æ¢ï¼Œåœ¨ç‰©ç†å­¦å’Œå·¥ç¨‹å­¦ä¸­æœ‰è®¸å¤šåº”ç”¨ã€‚å› å…¶åŸºæœ¬æ€æƒ³é¦–å…ˆç”±æ³•å›½å­¦è€…çº¦ç‘Ÿå¤«Â·å‚…é‡Œå¶ç³»ç»Ÿåœ°æå‡ºï¼Œæ‰€ä»¥ä»¥å…¶åå­—æ¥å‘½åä»¥ç¤ºçºªå¿µã€‚å®é™…ä¸Šå‚…é‡Œå¶å˜æ¢å°±åƒåŒ–å­¦åˆ†æï¼Œç¡®å®šç‰©è´¨çš„åŸºæœ¬æˆåˆ†ï¼›ä¿¡å·æ¥è‡ªè‡ªç„¶ç•Œï¼Œä¹Ÿå¯å¯¹å…¶è¿›è¡Œåˆ†æï¼Œç¡®å®šå…¶åŸºæœ¬æˆåˆ†ã€‚\n\nç»å‚…é‡Œå¶å˜æ¢ç”Ÿæˆçš„å‡½æ•°  ç§°ä½œåŸå‡½æ•°çš„  å‚…é‡Œå¶å˜æ¢ã€äº¦ç§°é¢‘è°±ã€‚åœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œå‚…é‡Œå¶å˜æ¢æ˜¯å¯é€†çš„ï¼Œå³å¯é€šè¿‡ å¾—åˆ°å…¶åŸå‡½æ•° ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œ æ˜¯å®æ•°å‡½æ•°ï¼Œè€Œ   åˆ™æ˜¯å¤å‡½æ•°ï¼Œç”¨ä¸€ä¸ªå¤æ•°æ¥è¡¨ç¤ºæŒ¯å¹…å’Œç›¸ä½ã€‚\nâ€œå‚…é‡Œå¶å˜æ¢â€ä¸€è¯æ—¢æŒ‡å˜æ¢æ“ä½œæœ¬èº«ï¼ˆå°†å‡½æ•°  è¿›è¡Œå‚…é‡Œå¶å˜æ¢ï¼‰ï¼ŒåˆæŒ‡è¯¥æ“ä½œæ‰€ç”Ÿæˆçš„å¤æ•°å‡½æ•°ï¼ˆ  æ˜¯  çš„å‚…é‡Œå¶å˜æ¢ï¼‰ã€‚\n\nå‚…é‡Œå¶çº§æ•° ï¼Œåœ¨æ—¶åŸŸæ˜¯ä¸€ä¸ªå‘¨æœŸä¸”è¿ç»­çš„å‡½æ•°ï¼Œè€Œåœ¨é¢‘åŸŸæ˜¯ä¸€ä¸ªéå‘¨æœŸç¦»æ•£çš„å‡½æ•°ã€‚ å‚…é‡Œå¶å˜æ¢ï¼Œåˆ™æ˜¯å°†ä¸€ä¸ªæ—¶åŸŸéå‘¨æœŸçš„è¿ç»­ä¿¡å·ï¼Œè½¬æ¢ä¸ºä¸€ä¸ªåœ¨é¢‘åŸŸéå‘¨æœŸçš„è¿ç»­ä¿¡å·ã€‚\n\n\n    \n\n\nä¹Ÿå¯ä»¥æ¢ä¸€ä¸ªè§’åº¦ç†è§£ï¼šå‚…é‡Œå¶å˜æ¢å®é™…ä¸Šæ˜¯å¯¹ä¸€ä¸ªå‘¨æœŸæ— é™å¤§çš„å‡½æ•°è¿›è¡Œå‚…é‡Œå¶å˜æ¢ã€‚\næ¬§æ‹‰å…¬å¼\nè™šæ•°  çš„æ„ä¹‰\n\n\n\n\nåœ¨æ•°è½´ä¸Šæœ‰ä¸€ä¸ªé»‘è‰²çš„çº¿æ®µï¼Œå®ƒçš„é•¿åº¦æ˜¯ 1ã€‚å½“å®ƒä¹˜ä»¥ 3 çš„æ—¶å€™ï¼Œå®ƒçš„é•¿åº¦å‘ç”Ÿäº†å˜åŒ–ï¼Œå˜æˆäº†æ©™è‰²çš„çº¿æ®µï¼Œè€Œå½“å®ƒä¹˜ä»¥ -1 çš„æ—¶å€™ï¼Œå°±å˜æˆäº†çº¢è‰²çš„çº¿æ®µï¼Œæˆ–è€…è¯´çº¿æ®µåœ¨æ•°è½´ä¸Šå›´ç»•åŸç‚¹æ—‹è½¬äº† 180Â°ã€‚    \nä¹˜ -1 å…¶å®å°±æ˜¯ä¹˜äº†ä¸¤æ¬¡ ä½¿çº¿æ®µæ—‹è½¬äº† 180Â°ï¼Œé‚£ä¹ˆä¹˜ä¸€æ¬¡ å°±æ˜¯æ—‹è½¬äº† 90Â°ã€‚\n\n\n\n\nå®æ•°è½´ä¸è™šæ•°è½´å…±åŒæ„æˆäº†ä¸€ä¸ªå¤æ•°çš„å¹³é¢ï¼Œä¹Ÿç§°å¤å¹³é¢ã€‚\n\næœ‰äº†è™šæ•°è½´çš„æ¦‚å¿µï¼Œæ¬§æ‹‰å…¬å¼å¦‚ä¸‹ï¼šè¿™ä¸ªå…¬å¼å…³é”®çš„ä½œç”¨ï¼Œæ˜¯å°†æ­£å¼¦æ³¢ç»Ÿä¸€æˆäº†ç®€å•çš„æŒ‡æ•°å½¢å¼\næ¬§æ‹‰å…¬å¼æ‰€æç»˜çš„ï¼Œæ˜¯ä¸€ä¸ªéšç€æ—¶é—´å˜åŒ–ï¼Œåœ¨å¤å¹³é¢ä¸Šåšåœ†å‘¨è¿åŠ¨çš„ç‚¹ï¼Œéšç€æ—¶é—´çš„æ”¹å˜ï¼Œåœ¨æ—¶é—´è½´ä¸Šå°±æˆäº†ä¸€æ¡èºæ—‹çº¿ã€‚å¦‚æœåªçœ‹å®ƒçš„å®æ•°éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯èºæ—‹çº¿åœ¨å·¦ä¾§çš„æŠ•å½±ï¼Œå°±æ˜¯ä¸€ä¸ªæœ€åŸºç¡€çš„ä½™å¼¦å‡½æ•°ã€‚è€Œå³ä¾§çš„æŠ•å½±åˆ™æ˜¯ä¸€ä¸ªæ­£å¼¦å‡½æ•°ã€‚\næŒ‡æ•°å½¢å¼çš„å‚…é‡Œå¶å˜æ¢  æœ‰äº†æ¬§æ‹‰å…¬å¼ä¾¿çŸ¥é“ï¼šæ­£å¼¦æ³¢çš„å åŠ  ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸º èºæ—‹çº¿çš„å åŠ   åœ¨å®æ•°ç©ºé—´çš„æŠ•å½±ã€‚å…‰æ³¢  å°±æ˜¯èºæ—‹çº¿å åŠ çš„å½¢è±¡ä¾‹å­\n\n\n\n\nä½†ä¸åŒçš„æ˜¯ï¼Œå‚…é‡Œå¶å˜æ¢å‡ºæ¥çš„é¢‘è°±ä¸ä»…ä»…æ˜¯  å¯è§å…‰  è¿™æ ·é¢‘ç‡èŒƒå›´æœ‰é™çš„å åŠ ï¼Œè€Œæ˜¯é¢‘ç‡ä» 0 åˆ°æ— ç©·æ‰€æœ‰é¢‘ç‡çš„ç»„åˆã€‚\nå†æ¬¡ç†è§£æ­£å¼¦æ³¢  æ­£å¼¦æ³¢å¯ä»¥ç†è§£ä¸ºèºçº¿åœ¨å®æ•°è½´çš„æŠ•å½±ï¼Œè¿˜å¯ä»¥å€ŸåŠ©æ¬§æ‹‰å…¬å¼çš„å¦ä¸€ç§å½¢å¼å»ç†è§£ï¼šå°†ä¿©ä¸ªå¼å­ç›¸åŠ å†é™¤ 2ï¼Œå¯å¾—ï¼šå¯ä»¥ç†è§£ä¸ºä¸€æ¡é€†æ—¶é’ˆæ—‹è½¬çš„èºæ—‹çº¿ï¼Œé‚£ä¹ˆ  å¯ä»¥ç†è§£ä¸ºä¸€æ¡é¡ºæ—¶é’ˆæ—‹è½¬çš„èºæ—‹çº¿ã€‚è€Œ  åˆ™æ˜¯è¿™ä¸¤æ¡æ—‹è½¬æ–¹å‘ä¸åŒçš„èºæ—‹çº¿å åŠ çš„ä¸€åŠï¼ˆå› ä¸ºè¿™ä¸¤æ¡èºæ—‹çº¿çš„è™šæ•°éƒ¨åˆ†ç›¸äº’æŠµæ¶ˆæ‰äº†ï¼‰ã€‚è¿™é‡Œï¼Œé€†æ—¶é’ˆæ—‹è½¬çš„ç§°ä¸ºæ­£é¢‘ç‡ï¼Œè€Œé¡ºæ—¶é’ˆæ—‹è½¬çš„ç§°ä¸ºè´Ÿé¢‘ç‡ã€‚\nå›¾åƒå‚…é‡Œå¶å˜æ¢å’Œå‚…é‡Œå¶é€†å˜æ¢åŸç†åŠå®ç°  ä»»æ„ä¿¡å·ï¼ŒåŒ…æ‹¬éå‘¨æœŸä¿¡å·éƒ½å¯ä»¥ç”¨å‚…é‡Œå¶å˜æ¢è½¬åˆ°é¢‘åŸŸï¼š\n\nè¿ç»­çš„ï¼š\n\nç¦»æ•£çš„ï¼š\n\n\nå¯¹å›¾åƒè¿›è¡Œå‚…é‡Œå¶å˜æ¢çš„åŸç†å¦‚ä¸‹å…¬å¼ï¼š\nç›¸å…³ä»£ç  [3] æ™®é€šå›¾åƒçš„å‚…é‡Œå¶å˜æ¢ç»“æœ  ä¸‹é¢çš„ä»£ç æ˜¾ç¤ºäº†å¦‚ä½•å°†è¾“å…¥å›¾åƒè¿›è¡Œå‚…é‡Œå¶å˜æ¢ã€‚å‚…é‡Œå¶å˜æ¢çš„ç»“æœæ˜¯å¤æ•°æ•°ç»„ï¼Œå±•ç¤ºäº†å¦‚ä½•è·å–å…¶å®éƒ¨å’Œè™šéƒ¨ï¼Œå¹¶æ±‚å–å…¶å¹…åº¦ã€‚æ¥ä¸‹æ¥ï¼Œç”±äºå˜æ¢åå›¾åƒçš„é¢‘è°±åˆ†å¸ƒå…·æœ‰ä¸­å¿ƒå¯¹ç§°æ€§ï¼Œå°†å…¶é¢‘è°±ä¸­å¿ƒç§»åˆ°äº†å›¾åƒçš„ä¸­é—´å¹¶è¿›è¡Œæ˜¾ç¤ºã€‚\nfrom PIL import Imageimport numpy as npimport matplotlib.pyplot as pltimport cv2from skimage.io import imreadfrom scipy.fftpack import ifftn, fft2, ifft2import matplotlib.pyplot as pltimport matplotlib.cm as cmimport cmathimport warnings%matplotlib inlinewarnings.filterwarnings(action='ignore')\n\ndef fliproi(img,ranges):    roi=img[ranges[0]:ranges[1], ranges[2]:ranges[3]]    roi=np.flip(roi,1)    roi=np.flip(roi,0)    img[ranges[0]:ranges[1], ranges[2]:ranges[3]]=roi        img=cv2.imread('./imgs/lena.png', cv2.IMREAD_GRAYSCALE)def getShiftedFreqSpectrum(img):    fimg=fft2(img, shape=img.shape, axes=tuple((0, 1)))    fimgamp=np.abs(fimg)    fimgphase=np.angle(fimg)    roilen=img.shape[0]//2    for y in [0,1]:        for x in [0, 1]:            ranges=[y*roilen, (y+1)*roilen,x*roilen,(x+1)*roilen]            fliproi(fimgamp,ranges)            fliproi(fimgphase,ranges)    return fimg, fimgamp, fimgphasedef getFreqSpectrum(img):    fimg=fft2(img, shape=img.shape, axes=tuple((0, 1)))    fimgamp=np.abs(fimg)    fimgphase=np.angle(fimg)    return fimg, fimgamp, fimgphasefimg,fimgamp, fimgphase=getShiftedFreqSpectrum(img)\n\nplt.figure(figsize=(20,20))plt.subplot(1,3,1)plt.imshow(img, cmap=\"gray\")plt.title(\"Orignal Image\")plt.subplot(1,3,2)plt.imshow(np.log(fimgamp), cmap=\"gray\")plt.title(\"Frequency Spectrum Amplification (Zero centered)\")plt.subplot(1,3,3)plt.imshow(np.abs(fimgphase), cmap=\"gray\")plt.title(\"Frequency Spectrum Phase Angle (Zero centered)\")plt.show()\n\n\n\n\n\n\n[1]  å‚…é‡Œå¶åˆ†æä¹‹ææ­»æ•™ç¨‹ [2]   å…³äºå‚…é‡Œå¶å˜æ¢ä¸­çš„ç›¸ä½ [3]   å›¾åƒçš„å‚…é‡Œå¶å˜æ¢\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }ï¼›\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["çŸ¥è¯†åº“"],"tags":["ä¿¡å·","æ—¶åŸŸ","é¢‘åŸŸ"]},{"title":"Accelerate Ray Tracing","url":"/2021/11/24/23/","content":"å‘å°„å…‰çº¿å’Œä¸å…‰çº¿ä¸‰è§’å½¢æ±‚äº¤  å‘å°„å…‰çº¿  ä¸ Whitted Style Ray Tracing ä¸­çš„ Render å‡½æ•°ç›¸åŒ\nfloat x = (2 * (i + 0.5) / (float)scene.width - 1) * imageAspectRatio * scale;float y = (1 - 2 * (j + 0.5) / (float)scene.height) * scale;\n\nå…‰çº¿ä¸ä¸‰è§’å½¢ç›¸äº¤inline Intersection Triangle::getIntersection(Ray ray){    Intersection inter;    //    // Moller-Trumbore ç®—æ³•     //    // TODO find ray triangle intersection    if (t_tmp &lt; 0)        return inter;    inter.happened = true;    inter.coords = Vector3f(u * v0 + v * v1 + (1 - u - v) * v2);    inter.normal = ray(t_tmp);    inter.distance = t_tmp;    inter.m = this-&gt;m;    inter.obj = this;    return inter;}\n\n\nhappenedï¼šå…‰çº¿æ˜¯å¦ä¸ä¸‰è§’å½¢ç›¸äº¤\n\ncoordsï¼šäº¤ç‚¹åæ ‡\n\nRayé‡è½½äº† () è¿ç®—ç¬¦\nVector3f operator()(double t) const{    return origin + direction * t;}\n\n\nnormalï¼šä¸‰è§’å½¢çš„æ³•å‘é‡\n\ndistanceï¼šæ—¶é—´æ—¢æ˜¯è·ç¦»ï¼Œå³t_tmp\n\nmï¼šæè´¨\n\nobjï¼šä»£è¡¨ä¸‰è§’å½¢æœ¬èº«\n\n\næ˜¯å¦ä¸åŒ…å›´ç›’ç›¸äº¤\n    \n\n\nç©ºé—´ä¸­çš„å°„çº¿å¯ä»¥ç”±èµ·ç‚¹  å’Œæ—¶é—´ ï¼Œä»¥åŠæ–¹å‘ ç»„æˆï¼šè€ƒè™‘äºŒç»´å¹³é¢çš„æƒ…å†µï¼Œå³  é‚£ä¹ˆé’ˆå¯¹  å’Œæ–¹å‘ä¸Šçš„å°„çº¿å¯ä»¥ç”¨å¦‚ä¸‹æ–¹å¼æè¿°ï¼š\n\nåœ¨ä¸‰ç»´ç©ºé—´ä¸­ï¼Œä½¿å¾—å…‰çº¿ç»è¿‡åŒ…å›´ç›’çš„æ¡ä»¶æ˜¯ï¼šå…‰çº¿å†åŒ…å›´ç›’ä¸Šçš„ä¸¤ä¸ªç‚¹  å’Œåœ¨åŒ…å›´ç›’å»¶å±•è½´çš„  æ’æ§½  é‡Œï¼Œå³ï¼šdirIsNegè¡¨ç¤ºå…‰çº¿åœ¨æŸä¸ªæ–¹å‘ä¸Šçš„æŠ•å½±æ˜¯å¦ä¸ºåå‘ï¼ˆä¾‹å¦‚å½“ dirIsNeg[1] == 0 æ—¶ï¼Œè¡¨ç¤ºå…‰ä¼ æ’­æ–¹å‘åœ¨  è½´ä¸Šæ˜¯è´Ÿæ–¹å‘çš„ï¼‰ï¼Œæ­¤æ—¶éœ€è¦å°†  å’Œäº¤æ¢\ninline bool Bounds3::IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg) const{    // invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division    // dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic    // TODO test if ray bound intersects    // according to the formula : P(t) = origin + direction * t    float tx_min = (pMin.x - ray.origin.x) * invDir.x;    float tx_max = (pMax.x - ray.origin.x) * invDir.x;    float ty_min = (pMin.y - ray.origin.y) * invDir.y;    float ty_max = (pMax.y - ray.origin.y) * invDir.y;    float tz_min = (pMin.z - ray.origin.z) * invDir.z;    float tz_max = (pMax.z - ray.origin.z) * invDir.z;    if (!dirIsNeg[0])    {    \tfloat t = tx_min;    \ttx_min = tx_max;    \ttx_max = t;    }    if (!dirIsNeg[1])    {    \tfloat t = ty_min;    \tty_min = ty_max;    \tty_max = t;    }    if (!dirIsNeg[2])    {    \tfloat t = tz_min;    \ttz_min = tz_max;    \ttz_max = t;    }    float t_enter = std::max(tx_min, std::max(ty_min, tz_min));    float t_exit = std::min(tx_max, std::min(ty_max, tz_max));    if (t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= 0)    {    \treturn true;    }    return false;}\n\nBVH TraversalBVH æœ¬è´¨ä¸Šæ˜¯æŠŠåœºæ™¯ä¸­çš„ä¸‰è§’å½¢ç”¨äºŒå‰æ ‘çŠ¶çš„ç»“æ„è¿›è¡Œè¡¨ç¤ºï¼Œä¸­é—´ç»“ç‚¹åŒ…å«è¿™ä¸ªç»“ç‚¹æ‰€åŒ…å«å‡ ä½•ä½“çš„åŒ…å›´ç›’ä»¥åŠæŒ‡å‘å¶å­ç»“ç‚¹çš„æŒ‡é’ˆï¼Œå¶å­èŠ‚ç‚¹åŒ…å«ç‰©ä½“åˆ—è¡¨å’ŒåŒ…å›´ç›’ï¼Œå½“åˆ¤æ–­å…‰çº¿ä¸ç‰©ä½“æ˜¯å¦ç›¸äº¤æ—¶ï¼Œåªéœ€è¦é€’å½’çš„åˆ¤æ–­åŒ…å›´ç›’æ˜¯å¦ä¸å…‰çº¿ç›¸äº¤å³å¯ï¼š\n\n    \n\n\nIntersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray&amp; ray) const{    // TODO Traverse the BVH to find intersection    Vector3f invDir = Vector3f{1.0f / ray.direction.x, 1.0f / ray.direction.y, 1.0f / ray.direction.z };    std::array&lt;int, 3&gt; dirIsNeg = {ray.direction.x &gt; 0, ray.direction.y &gt; 0, ray.direction.z &gt; 0 };    if (!node-&gt;bounds.IntersectP(ray, invDir, dirIsNeg))    {    \treturn {};    }    if (node-&gt;left == nullptr &amp;&amp; node-&gt;right == nullptr)    {    \treturn node-&gt;object-&gt;getIntersection(ray);    }    Intersection h1 = getIntersection(node-&gt;left, ray);    Intersection h2 = getIntersection(node-&gt;right, ray);        return h1.distance &lt; h2.distance ? h1 : h2;}\n\nç»“æœ\n    \n\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"å³¨çœ‰å±±æœˆåŠè½®ç§‹ï¼Œå½±å…¥å¹³ç¾Œæ±Ÿæ°´æµ","url":"/2021/11/25/24/","content":" å³¨çœ‰å±±æœˆåŠè½®ç§‹ï¼Œå½±å…¥å¹³ç¾Œæ±Ÿæ°´æµã€‚\n å¤œå‘æ¸…æºªå‘ä¸‰å³¡ï¼Œæ€å›ä¸è§ä¸‹æ¸å·ã€‚\nâ€”â€”æç™½ \n\n\n\n","categories":["ç›¸å†Œ"],"tags":["é‡åº†"]},{"title":"Path Tracing","url":"/2021/12/02/25/","content":"åœ¨æœ¬æ¬¡å®éªŒä¸­ï¼Œåªéœ€è¦ä¿®æ”¹è¿™ä¸€ä¸ªå‡½æ•°ï¼š\n\ncastRay(const Ray ray, int depth)in Scene.cppï¼šåœ¨å…¶ä¸­å®ç° Path Tracing ç®—æ³•\n\nå¯èƒ½ç”¨åˆ°çš„å‡½æ•°æœ‰ï¼š\n\nintersect(const Ray ray)in Scene.cppï¼šæ±‚ä¸€æ¡å…‰çº¿ä¸åœºæ™¯çš„äº¤ç‚¹\nsampleLight(Intersection pos, float pdf) in Scene.cppï¼šåœ¨åœºæ™¯çš„æ‰€æœ‰å…‰æºä¸ŠæŒ‰é¢ç§¯ ç»Ÿä¸€é‡‡æ ·ä¸€ä¸ªç‚¹ï¼Œå¹¶è®¡ç®—è¯¥é‡‡æ ·ç‚¹çš„æ¦‚ç‡å¯†åº¦\nsample(const Vector3f wi, const Vector3f N) in Material.cppï¼šæŒ‰ç…§è¯¥æè´¨çš„æ€§è´¨ï¼Œç»™å®šå…¥å°„æ–¹å‘ä¸æ³•å‘é‡ï¼Œç”¨æŸç§åˆ†å¸ƒé‡‡æ ·ä¸€ä¸ªå‡ºå°„æ–¹å‘\npdf(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.cppï¼šç»™å®šä¸€å¯¹å…¥å°„ã€å‡ºå°„æ–¹å‘ä¸æ³•å‘é‡ï¼Œè®¡ç®— sample æ–¹æ³•å¾—åˆ°è¯¥å‡ºå°„æ–¹å‘çš„æ¦‚ç‡å¯†åº¦\neval(const Vector3f wi, const Vector3f wo, const Vector3f N) in Material.cppï¼šç»™å®šä¸€å¯¹å…¥å°„ã€å‡ºå°„æ–¹å‘ä¸æ³•å‘é‡ï¼Œè®¡ç®—è¿™ç§æƒ…å†µä¸‹çš„  å€¼\n\nå¯èƒ½ç”¨åˆ°çš„å˜é‡æœ‰ï¼š\n\nRussianRoulette in Scene.cppï¼š P_RR\n\nPath Tracing ä¼ªä»£ç ï¼š\nshade(p, wo)    sampleLight(inter , pdf_light)    Get x, ws, NN, emit from inter    Shoot a ray from p to x    If the ray is not blocked in the middle    \tL_dir = emit * eval(wo, ws, N) * dot(ws, N) * dot(ws, NN) / |x-p| ^2 / pdf_light    L_indir = 0.0    Test Russian Roulette with probability RussianRoulette    wi = sample(wo, N)    Trace a ray r(p, wi)    If ray r hit a non -emitting object at q    \tL_indir = shade(q, wi) * eval(wo, wi, N) * dot(wi, N) / pdf(wo, wi, N) / RussianRoulette        Return L_dir + L_indir\n\n\n\nMonte Carlo Integrationæ¦‚ç‡ç›¸å…³çŸ¥è¯†  è®¾æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œæ˜¯ä»»æ„å®æ•°ï¼Œåˆ™ç§°  ä¸ºçš„ç´¯è®¡åˆ†å¸ƒå‡½æ•°ï¼ˆCumulative Distribution Functionï¼ŒCDFï¼‰ã€‚å¦‚æœå¯¹äºéšæœºå˜é‡  çš„ç´¯è®¡åˆ†å¸ƒå‡½æ•° ï¼Œå­˜åœ¨éè´Ÿå‡½æ•°ï¼Œä½¿å¯¹ä»»æ„å®æ•°ï¼Œæœ‰ åˆ™ç§°  ä¸ºè¿ç»­æ€§éšæœºå˜é‡ï¼Œå…¶ä¸­å‡½æ•°  ç§°ä¸º  çš„æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œç®€ç§°æ¦‚ç‡å¯†åº¦ï¼ˆProbability Distribution Functionï¼ŒPDFï¼‰ã€‚æ¦‚ç‡å¯†åº¦å…·æœ‰ä»¥ä¸‹å‡ ä¸ªæ€§è´¨ï¼š\n\n\n\nå¯¹äºä»»æ„å®æ•°ï¼Œæœ‰\nè‹¥  åœ¨ç‚¹  å¤„è¿ç»­ï¼Œåˆ™æœ‰\n\nè®¾è¿ç»­æ€§éšæœºå˜é‡  çš„æ¦‚ç‡å¯†åº¦å‡½æ•°ä¸º ï¼Œè‹¥ç§¯åˆ† ç»å¯¹æ”¶æ•›ï¼Œåˆ™ç§°ç§¯åˆ†  çš„å€¼ä¸ºéšæœºå˜é‡  çš„æ•°å­¦æœŸæœ›ï¼Œè®°ä¸º ï¼Œç®€ç§°ä¸ºæœŸæœ›ï¼š è®¾æ˜¯ä¸€ä¸ªéšæœºå˜é‡ï¼Œè‹¥å­˜  åœ¨ï¼Œåˆ™ç§°å®ƒçš„å€¼ä¸º  çš„æ–¹å·®ï¼Œè®°ä¸º ï¼Œå³ï¼š åŒæ—¶  çš„æ ‡å‡†å·®æˆ–å‡æ–¹å·®ä¸º ï¼Œè®°ä¸ºï¼Œæ–¹å·®è¡¨ç¤ºçš„æ˜¯éšæœºå˜é‡ä¸å…¶å‡å€¼çš„åç§»ç¨‹åº¦ï¼Œéšæœºå˜é‡çš„æ–¹å·® å¯æŒ‰ä¸‹åˆ—å…¬å¼è®¡ç®—ï¼š\n\nå‡ ä¸ªå®šç†  åˆ‡æ¯”é›ªå¤«  ä¸ç­‰å¼ ï¼šè®¾éšæœºå˜é‡ å…·æœ‰æ•°å­¦æœŸæœ› ï¼Œæ–¹å·®ï¼Œåˆ™å¯¹äºä»»æ„æ­£æ•°ï¼Œä¸ç­‰å¼ æˆç«‹ã€‚è¿™ä¸€ä¸ç­‰å¼ç§°ä¸ºåˆ‡æ¯”é›ªå¤«ä¸ç­‰å¼\nè¾›é’¦å¤§æ•°å®šç† ï¼šè®¾ æ˜¯ç›¸äº’ç‹¬ç«‹ï¼Œæœä»åŒä¸€åˆ†å¸ƒéšæœºå˜é‡åºåˆ—ï¼Œä¸”å…·æœ‰æ•°å­¦æœŸæœ› ï¼Œä½œå‰ ä¸ªå˜é‡çš„ç®—æœ¯å¹³å‡ ï¼Œåˆ™å¯¹äºä»»æ„ï¼Œæœ‰ï¼š ä¼¯åŠªåˆ©å¤§æ•°å®šç† ï¼šè®¾ æ˜¯æ¬¡ç‹¬ç«‹é‡å¤è¯•éªŒä¸­äº‹ä»¶ A å‘ç”Ÿçš„æ¬¡æ•°ï¼Œæ˜¯äº‹ä»¶ A åœ¨æ¯æ¬¡è¯•éªŒä¸­å‘ç”Ÿçš„æ¦‚ç‡ï¼Œåˆ™å¯¹äºä»»æ„æ­£æ•° ï¼Œæœ‰ï¼š è¾›é’¦å¤§æ•°å®šç†è§£é‡Šäº†ï¼šåœ¨å¤§é‡é‡å¤è¯•éªŒä¸‹ï¼Œæ ·æœ¬çš„å¹³å‡å€¼çº¦ç­‰å¼æ€»ä½“çš„å¹³å‡å€¼ã€‚ä¼¯åŠªåˆ©å¤§æ•°å®šç†è§£é‡Šäº†ï¼šåœ¨å¤§é‡é‡å¤è¯•éªŒä¸‹ï¼Œæ ·æœ¬çš„é¢‘ç‡æ”¶æ•›äºå…¶æ¦‚ç‡ã€‚\n\nè’™ç‰¹å¡æ´›æ³•ç§¯åˆ†  é‡‡ç”¨è’™ç‰¹å¡æ´›æ–¹æ³•æ¥è®¡ç®—å‡½æ•°ç§¯åˆ†ï¼Œä¸€èˆ¬çš„å®šä¹‰ä¸ºï¼šè®¾  æ˜¯ç›¸äº’ç‹¬ç«‹çš„æ ·æœ¬ä¸”æœä»åŒä¸€åˆ†å¸ƒï¼Œæ¦‚ç‡å¯†åº¦å‡½æ•°è¡¨ç¤ºä¸º ï¼Œåˆ™å‡½æ•°çš„ç§¯åˆ†å¯ä»¥è¡¨ç¤ºä¸ºï¼š è¿™å°±æ˜¯è’™ç‰¹å¡æ´›æ³•ç§¯åˆ†çš„ä¸€èˆ¬ç­‰å¼\né‡è¦æ€§é‡‡æ ·  é‡è¦æ€§é‡‡æ ·  æ˜¯å·²çŸ¥è¢«ç§¯å‡½æ•°çš„ä¸€äº›åˆ†å¸ƒä¿¡æ¯è€Œé‡‡ç”¨çš„ä¸€ç§ç¼©å‡æ–¹å·®çš„ç­–ç•¥ï¼Œè¿˜æœ‰åˆ«çš„ç­–ç•¥åƒ  ä¿„ç½—æ–¯è½®ç›˜åˆ‡å‰² ï¼Œ åˆ†å±‚é‡‡æ · ï¼Œ æ‹‰ä¸è¶…ç«‹æ–¹ä½“é‡‡æ ·  ç­‰ï¼Œæ˜¯é€šè¿‡æ§åˆ¶é‡‡æ ·çš„ç­–ç•¥è¾¾åˆ°ç¼©å‡æ–¹å·®çš„ç›®çš„\n\nè€ƒè™‘ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œè®¾ä¸€ä¸ªå‡½æ•°ä¸º\né‡‡ç”¨è’™ç‰¹å¡æ´›æ³•ä¼°è®¡å®ƒçš„ç§¯åˆ†ï¼Œé€‰æ‹©åŒºé—´  ä¹‹é—´çš„å‡åŒ€åˆ†å¸ƒä½œä¸ºå®ƒçš„éšæœºæ•°ï¼Œé‚£ä¹ˆå­˜åœ¨ç»å¤§éƒ¨åˆ†çš„é‡‡æ ·ç‚¹åœ¨åŒºé—´  ä¹‹é—´ï¼Œä½†æ˜¯å®ƒå¯¹ç§¯åˆ†ä¼°è®¡çš„è´¡çŒ®åªæœ‰ 0.01ï¼Œå°éƒ¨åˆ†é‡‡æ ·ç‚¹åœ¨åŒºé—´  ä¹‹é—´ï¼Œå®ƒå¯¹ç§¯åˆ†ä¼°è®¡çš„è´¡çŒ®å´éå¸¸çš„å¤§ï¼Œè¿™ç§ç°è±¡å°±ä¼šå¯¼è‡´è¯¯å·®éå¸¸çš„å¤§ï¼Œç®€å•æé«˜é‡‡æ ·æ•°å¯¹ä¼°è®¡é‡æ”¶æ•›çš„å½±å“è¾ƒå°ã€‚é‚£ä¹ˆï¼Œå¦‚æœç®€å•çš„é€‰æ‹©ä¸€ä¸ªé‡‡æ ·ç­–ç•¥ï¼šå¤šé‡‡æ ·åŒºé—´  çš„æ ·æœ¬ç‚¹ï¼Œå°‘é‡‡æ ·  çš„æ ·æœ¬ç‚¹ï¼Œè¿™å°±è¿èƒŒäº†è’™ç‰¹å¡æ´›æ³•çš„æœ¬è´¨ï¼Œäº§ç”Ÿçš„ç»Ÿè®¡ç»“æœå°±æ²¡æœ‰ä»»ä½•æ„ä¹‰ã€‚è’™ç‰¹å¡æ´›æ³•çš„æ ¸å¿ƒï¼Œæ˜¯æ ¹æ®æŸä¸€æ¦‚ç‡åˆ†å¸ƒæ¥éšæœºé‡‡æ ·ã€‚\nGGXï¼ˆTrowbridge-Reitzï¼‰åˆ†å¸ƒ GGX å³ Trowbridge-Reitz åˆ†å¸ƒï¼Œæœ€åˆç”± Trowbridge å’Œ Reitz[Trowbridge 1975] æ¨å¯¼å‡ºï¼Œåœ¨ Blinn 1977 å¹´çš„è®ºæ–‡ [Blinn 1977]ä¸­ä¹Ÿæœ‰æ¨èæ­¤åˆ†å¸ƒå‡½æ•°ï¼Œä½†ä¸€ç›´æ²¡æœ‰å—åˆ°å›¾å½¢å­¦ç•Œçš„å¤ªå¤šå…³æ³¨ã€‚30 å¤šå¹´åï¼ŒTrowbridge-Reitz åˆ†å¸ƒè¢« Walter ç­‰äººç‹¬ç«‹é‡æ–°å‘ç° [Walter 2007]ï¼Œå¹¶å°†å…¶å‘½åä¸º GGX åˆ†å¸ƒã€‚ä¹‹åï¼ŒGGX åˆ†å¸ƒé‡‡ç”¨é£æ½®å¼€å§‹åœ¨ç”µå½±[Burley 2012] å’Œæ¸¸æˆ [Karis 2013]ï¼Œ[Lagarde 2014] è¡Œä¸šä¸­å¹¿æ³›ä¼ æ’­ï¼Œæˆä¸ºäº†å¦‚ä»Šæ¸¸æˆè¡Œä¸šå’Œç”µå½±è¡Œä¸šä¸­æœ€å¸¸ç”¨çš„æ³•çº¿åˆ†å¸ƒå‡½æ•°ã€‚\n\n    \n\n\nGGX åˆ†å¸ƒçš„å…¬å¼ä¸ºï¼š\nPath TracingA Simple Monte Carlo Solutionåœ¨ç›´æ¥å…‰ç…§çš„ç¯å¢ƒä¸‹ï¼Œæ¸²æŸ“ä¸‹å›¾ä¸­ä¸€ä¸ªç‚¹\n\n    \n\n\nè®¡ç®—  ç‚¹çš„åœ¨ç›¸æœºæ–¹å‘ä¸Šçš„ radiance æœ‰ä»¥ä¸‹æ¸²æŸ“æ–¹ç¨‹  å¯¹äº  è’™ç‰¹å¡æ´› ï¼šï¼Œ å°±æ˜¯ ï¼Œ æ¦‚ç‡å¯†åº¦å‡½æ•°  å¯ä»¥æ˜¯ ï¼ˆåœ¨åŠçƒé¢ä¸Šè¿›è¡Œå‡åŒ€é‡‡æ ·ï¼‰ã€‚æ‰€ä»¥ ç‚¹çš„ radiance å¯ä»¥è¡¨ç¤ºä¸ºï¼š\nIntroducing Global Illumination\n    \n\n\nå¯ä»¥å†™å‡ºå¦‚ä¸‹ä¼ªä»£ç ï¼š\nshade(p, wo)    Randomly choose N directions wi~pdf    Lo = 0.0    For each wi        Trace a ray r(p, wi)        If ray r hit the light            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi)        Else If ray r hit an object at q            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi)    Return Lo\n\nProblem 1: Explosion of #rays as #bounces go upä½†æ˜¯å…‰çº¿çš„æ•°é‡éšç€å¼¹å°„çš„æ¬¡æ•°å¢åŠ ï¼Œä»¥æŒ‡æ•°çš„é‡çº§å¢é•¿ #rays = N#bouncesï¼Œæ‰€ä»¥å‡è®¾æ¯ä¸€ä¸ªç€è‰²ç‚¹åªæœ‰ä¸€æ¡å…‰çº¿ï¼Œéšä¹‹è€Œæ¥çš„å°±æ˜¯ä¼šå­˜åœ¨å¤§é‡çš„å™ªéŸ³ï¼Œé€šè¿‡å¢åŠ ç»è¿‡æ¯ä¸ªåƒç´ çš„ ** paths**ï¼Œå†åš radiance çš„å‡å€¼ä¾¿å¯ä»¥å‡å°‘å™ªéŸ³ã€‚\n\n    \n\n\nç”Ÿæˆ ** paths ** çš„ä¼ªä»£ç å¦‚ä¸‹ï¼š\nray_generation(camPos, pixel)    Uniformly choose N sample positions within the pixel    pixel_radiance = 0.0    For each sample in the pixel        Shoot a ray r(camPos, cam_to_sample)        If ray r hit the scene at p            pixel_radiance += 1 / N * shade(p, sample_to_cam)    Return pixel_radiance\n\nProblem 2: The recursive algorithm will never stopå¯ä»¥é€šè¿‡ Russian Rouletteï¼ˆRRï¼‰ï¼ˆå³ä»¥ä¸€ä¸ªå›ºå®šçš„æ¦‚ç‡ å†³å®š  è·¯å¾„è¿½è¸ª  æ˜¯å¦å¯ä»¥ç»§ç»­â€”â€”æ˜¯å¦å‘ä»ç›¸æœºå¤„å°„å°„çº¿ï¼‰ï¼Œæ¥è§£å†³é€’å½’ç®—æ³•æ— æ³•ç»“æŸçš„é—®é¢˜ã€‚å¦‚æœé‡‡ç”¨ RR çš„æ–¹æ³•éœ€è¦æ›´æ”¹æ¯ä¸€æ¬¡  è·¯å¾„è¿½è¸ª  åradianceçš„å€¼ ï¼Œä½¿å¾—è¯¥ç‚¹radiance ä¸å®é™…ç›¸å·®ä¸å¤§ã€‚å°†  é™¤ä»¥æ¦‚ç‡ ï¼Œå³ã€‚é‚£ä¹ˆå¯ä»¥æ±‚å‡º çš„æœŸæœ›ï¼Œå¯ä»¥è¯æ˜ RR çš„åˆç†æ€§ï¼šå¯ä»¥å†™å‡ºå¦‚ä¸‹ä¼ªä»£ç ï¼š\nshade(p, wo)    Manually specify a probability P_RR    Randomly select ksi in a uniform dist. in [0, 1]    If (ksi &gt; P_RR)        return 0.0        Randomly choose N directions wi~pdf    Lo = 0.0    For each wi        Trace a ray r(p, wi)        If ray r hit the light            Lo += (1 / N) * L_i * f_r * cosine / pdf(wi) / P_RR        Else If ray r hit an object at q            Lo += (1 / N) * shade(q, -wi) * f_r * cosine / pdf(wi) / P_RR    Return Lo\n\nSampling the Light\n    \n\n\nå…‰æºç¦»ç‰©ä½“è¶Šè¿œï¼Œéœ€è¦ä»ç›¸æœºå‘å°„çš„å°„çº¿è¶Šå¤šï¼ˆåœ¨åŠçƒä¸Šé‡‡æ ·æ¬¡æ•°è¶Šå¤šï¼‰æ‰èƒ½åˆ°è¾¾å…‰æºï¼Œè¿™æ ·ä¼šé€ æˆæ€§èƒ½ä¸Šçš„é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡å¯¹å…‰æºçš„é‡‡æ ·æ¥è§£å†³åœ¨åŠçƒä¸Šé‡‡æ ·æ¬¡æ•°è¶Šå¤šçš„é—®é¢˜ï¼Œå³å¯¹äºç›´æ¥å…‰ç…§ï¼ŒåŸæ¥æ˜¯ä»  ç‚¹æ‰€åœ¨çš„åŠçƒè¿›è¡Œé‡‡æ ·ï¼Œå˜æˆå¯¹  æ‰€åœ¨çš„å…‰æºå¹³é¢é‡‡æ ·ã€‚\n\n    \n\n\næ­¤æ—¶  æ¦‚ç‡å¯†åº¦å‡½æ•°  ä¸ºï¼ˆï¼‰ï¼Œä½†ä¹‹å‰çš„æ¸²æŸ“æ–¹ç¨‹æ˜¯å¯¹ç«‹ä½“è§’è¿›è¡Œç§¯åˆ†ï¼Œç°åœ¨éœ€è¦å¯¹é¢ç§¯è¿›è¡Œç§¯åˆ†ã€‚ç”±ä¸Šå›¾å’Œç«‹ä½“è§’çš„å®šä¹‰ï¼ˆProjected area on the unit sphereï¼‰å¯å¾—  æ­¤æ—¶æ¸²æŸ“æ–¹ç¨‹ä¹Ÿå¯ä»¥å†™ä¸ºï¼šç°åœ¨çš„æ¸²æŸ“è¿­ä»£æµç¨‹ä¸»è¦è€ƒè™‘ä»¥ä¸‹ä¸¤ä¸ªéƒ¨åˆ†ï¼š\n\nå…‰æºèƒ½å¤Ÿç›´æ¥åˆ°è¾¾çš„ç‚¹ï¼Œé€šè¿‡å¯¹å…‰æºé‡‡æ ·åè®¡ç®— radiance çš„ï¼ˆéœ€è¦åˆ¤æ–­æ˜¯å¦å­˜åœ¨é®æŒ¡ï¼‰ï¼ŒåŒæ—¶ä¸éœ€è¦è€ƒè™‘ RR\né€’å½’çš„é—´æ¥å…‰ç…§ï¼Œéœ€è¦è€ƒè™‘ RR\n\næœ€ç»ˆçš„ä¼ªä»£ç å¦‚ä¸‹ï¼š\nshade(p, wo)    # Contribution from the light source.    Uniformly sample the light at xâ€™ (pdf_light = 1 / A)    Shoot a ray from p to xâ€™    If the ray is not blocked in the middle        L_dir = L_i * f_r * cos Î¸ * cos Î¸â€™ / |xâ€™ - p|^2 / pdf_light            # Contribution from other reflectors.    L_indir = 0.0    Test Russian Roulette with probability P_RR    Uniformly sample the hemisphere toward wi (pdf_hemi = 1 / 2pi)    Trace a ray r(p, wi)    If ray r hit a non-emitting object at q        L_indir = shade(q, -wi) * f_r * cos Î¸ / pdf_hemi / P_RR          Return L_dir + L_indir\n\nç›¸å…³ä»£ç // Implementation of Path TracingVector3f Scene::castRay(const Ray &amp;ray, int depth) const{    // TO DO Implement Path Tracing Algorithm here    Vector3f ldir = {0, 0, 0 };    Vector3f lindir = {0, 0, 0 };    Intersection objectInter = intersect(ray);    if (!objectInter.happened)    {    \treturn {};    }       if (objectInter.m-&gt;hasEmission())    {        return objectInter.m-&gt;getEmission();    }    Intersection lightInter;    float lightPdf = 0.0f;    sampleLight(lightInter, lightPdf);    Vector3f obj2light = lightInter.coords - objectInter.coords;    Vector3f obj2lightdir = obj2light.normalized();    float distancePow2 = obj2light.x * obj2light.x + obj2light.y * obj2light.y + obj2light.z * obj2light.z;    Ray obj2lightray = {objectInter.coords, obj2lightdir};    Intersection t = intersect(obj2lightray);    if (t.distance - obj2light.norm() &gt; -EPSILON)    {        ldir = lightInter.emit * objectInter.m-&gt;eval(ray.direction, obj2lightdir, objectInter.normal) * dotProduct(obj2lightdir, objectInter.normal) * dotProduct(-obj2lightdir, lightInter.normal) / distancePow2 / lightPdf;    }    if (get_random_float() &gt; RussianRoulette)    {        return ldir;    }    Vector3f obj2nextobjdir = objectInter.m-&gt;sample(ray.direction, objectInter.normal).normalized();    Ray obj2nextobjray = {objectInter.coords, obj2nextobjdir};    Intersection nextObjInter = intersect(obj2nextobjray);    if (nextObjInter.happened &amp;&amp; !nextObjInter.m-&gt;hasEmission())    {        float pdf = objectInter.m-&gt;pdf(ray.direction, obj2nextobjdir, objectInter.normal);        lindir = castRay(obj2nextobjray, depth + 1) * objectInter.m-&gt;eval(ray.direction, obj2nextobjdir, objectInter.normal) * dotProduct(obj2nextobjdir, objectInter.normal) / pdf / RussianRoulette;    }    return ldir + lindir;}\n\nç›¸å…³å‡½æ•° Scene::sampleLightâ†’MeshTriangle::Sampleâ†’BVHAccel::Sample æœ€ç»ˆç»“æœæ˜¯é€šè¿‡éå† BVH æ ‘åˆ°å­èŠ‚ç‚¹ï¼Œè®¡ç®—å­èŠ‚ç‚¹å…‰æº Object çš„ä¸‰è§’å½¢é¢ç§¯ï¼Œå­˜åœ¨ç–‘é—®ï¼Ÿ\nMaterial::sample\né¦–å…ˆåœ¨å±€éƒ¨åæ ‡ç³»ä¸‹çš„åŠçƒé¢ä¸Šè¿›è¡Œé‡‡æ ·å¾—åˆ°localRayï¼Œå…¶ä¸­ï¼Œ\næœä»ä¸Šå›¾åˆ†å¸ƒï¼Œé™åˆ¶äº†ä¸ŠåŠçƒã€‚\n\nç„¶åé€šè¿‡è¯¥ç‚¹çš„æ³•å‘é‡  å°†localRayè½¬æ¢æˆä¸–ç•Œåæ ‡ç³»ä¸­çš„å‘é‡\n\nCoordinate system from a vector\nWe can use the fact that the cross product gives a vector orthogonal to the two vectors to write a function that takes one vector and returns two new vectors so that the three of them form an orthonormal coordiante system. Specifically, all three of the vectors will be perpendicular to each other. Note that the other two vectors returned are only unique up to a rotation about the given vector. This function assumes that the vector passed in, , has already been normalized. We first construct a perpendicular vector by zeroing one of the two components of the original vector and permuting the remaining two. Inspection of the two cases should make clear that  will be normalized and that the dot product  will be equal to zero. Given these two perpendicular vectors, one more cross product wraps things up to give us the third, which by definition of the cross product will be be perpendicular to the first two[1].\ninline void CoordinateSystem(const Vector &amp;v1, Vector *v2, Vector *v3) {    if (fabsf(v1.x) &gt; fabsf(v1.y)) {        Float invLen = 1.f / sqrtf(v1.x*v1.x + v1.z*v1.z);        *v2 = Vector(-v1.z * invLen, 0.f, v1.x * invLen);    }    else {        Float invLen = 1.f / sqrtf(v1.y*v1.y + v1.z*v1.z);        *v2 = Vector(0.f, v1.z * invLen, -v1.y * invLen);    }    *v3 = Cross(v1, *v2);}\n\n\n\n\nScene::intersecté€šè¿‡æ„å»ºçš„ BVH å¯»æ‰¾å°„çº¿ä¸åœºæ™¯ä¸­ç‰©ä½“çš„äº¤ç‚¹\nMaterial::pdfè®¡ç®—äº¤ç‚¹å¤„çš„  æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œåœ¨åŠçƒå†…çš„è¿”å›å¸¸æ•°0.5f / M_PI\nMaterial::evalè®¡ç®—äº¤ç‚¹å¤„çš„æ¼«åå°„ç³»æ•°ï¼Œåœ¨åŠçƒå†…çš„è¿”å›å¸¸æ•°Kd / M_PI\nç»“æœ\n    \n\n\n\n[1]  Physically&nbsp;Based&nbsp;Image&nbsp;Synthesis:&nbsp;Design&nbsp;and&nbsp;Implementation&nbsp;of&nbsp;A&nbsp;Rendering&nbsp;Sysytem\n\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }ï¼›\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"æ ‘æ·±æ—¶è§é¹¿ï¼Œæºªåˆä¸é—»é’Ÿ","url":"/2021/12/07/26/","content":"\n","categories":["ç›¸å†Œ"],"tags":["é£æ™¯","ä¸Šæµ·"]},{"title":"åœ¨ Windows ä¸­å°† VSCode æ·»åŠ è‡³å³é”®èœå•","url":"/2021/12/09/27/","content":"Windows ä¸Šé¢å®‰è£… Visual Studio Code åï¼Œå°† Open with Code æ·»åŠ åˆ°é¼ æ ‡å³é”®èœå•é‡Œ\n\n\nWindows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\*\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\*\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%1\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot; Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;D:\\\\Microsoft VS Code\\\\Code.exe&quot; [HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\VSCode\\command]@=&quot;\\&quot;D:\\\\Microsoft VS Code\\\\Code.exe\\&quot; \\&quot;%V\\&quot;&quot;\n\nå°†ä»¥ä¸Šä»£ç å¤åˆ¶åˆ°åç¼€ä¸º .reg çš„æ–‡ä»¶ä¸­ï¼ŒåŒå‡»ç¡®å®šå³å¯ã€‚\n","categories":["Tools"],"tags":["vscode","å³é”®èœå•","æ³¨å†Œè¡¨"]},{"title":"ä¸‡æˆ·åƒé—¨æ°”éƒè‘±ï¼Œæ±‰å®¶åŸé˜™ç”»å›¾ä¸­","url":"/2021/12/10/28/","content":"\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }ï¼›\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["ç›¸å†Œ"],"tags":["åŒ—äº¬"]},{"title":"Windows Terminal é…ç½®","url":"/2021/12/14/29/","content":"\n\n\nAppearance profile settings in Windows Terminaldefaults&quot;defaults&quot;:&#123;    &quot;acrylicOpacity&quot;: 0.1, // èƒŒæ™¯é€æ˜åº¦ (0-1)    &quot;useAcrylic&quot;: true, // å¯ç”¨æ¯›ç»ç’ƒ    &quot;backgroundImage&quot;: &quot;C:/Users/xxx/Pictures/ella-baxter-EfmG0wTPyvQ-unsplash.jpg&quot;,    // èƒŒæ™¯å›¾ç‰‡    &quot;backgroundImageOpacity&quot;: 0.9, // å›¾ç‰‡é€æ˜åº¦ï¼ˆ0-1ï¼‰    &quot;experimental.retroTerminalEffect&quot;: false, // å¤å¤çš„ CRT æ•ˆæœ    &quot;backgroundImageStretchMode&quot;: &quot;uniformToFill&quot;, // èƒŒæ™¯å›¾ç‰‡å¡«å……æ¨¡å¼    // &quot;icon&quot;: &quot;ms-appx:///ProfileIcons/&#123;9acb9455-ca41-5af7-950f-6bca1bc9722f&#125;.png&quot;, // å›¾æ ‡    &quot;font&quot;: &#123;      &quot;face&quot;:&quot;MesloLGL NF&quot;, // å­—ä½“      &quot;size&quot;: 10, // æ–‡å­—å¤§å°      &quot;weight&quot;: &quot;thin&quot; // æ–‡å­—å®½åº¦ï¼Œå¯è®¾ç½®åŠ ç²—    &#125;,    &quot;colorScheme&quot;: &quot;Solarized Dark&quot;, // ä¸»é¢˜åå­—    &quot;cursorColor&quot;: &quot;#FFFFFF&quot;, // å…‰æ ‡é¢œè‰²    &quot;cursorShape&quot;: &quot;bar&quot;, // å…‰æ ‡å½¢çŠ¶    &quot;startingDirectory&quot;: &quot;E://Blog//&quot;, // èµ·å§‹ç›®å½•    &quot;antialiasingMode&quot;: &quot;cleartype&quot;, // æ¶ˆé™¤æ–‡å­—é”¯é½¿    &quot;adjustIndistinguishableColors&quot;: true,    // &quot;tabColor&quot;: &quot;#000000&quot;,    &quot;background&quot;: &quot;#000000&quot;&#125;,\n\nå®‰è£… Scoop# å…è®¸æœ¬åœ°è„šæœ¬çš„æ‰§è¡Œ set-executionpolicy remotesigned -scope currentuser#  å®‰è£… ScoopInvoke-Expression (New-Object System.Net.WebClient).DownloadString(&#x27;https://get.scoop.sh&#x27;)# ç”±äºæŸäº›åŸå› ä¸èƒ½åŠ å…¥ä¸»è½¯ä»¶æºçš„é™„åŠ æº scoop bucket add &#x27;extras&#x27; # NF å­—ä½“æºscoop bucket add &#x27;nerd-fonts&#x27; # Scoop è‡ªåŠ¨è¡¥å…¨æºscoop bucket add scoop-completion https://github.com/Moeologist/scoop-completion#  åŠ é€Ÿä¸‹è½½ scoop install aria2 #  è‡ªåŠ¨è¡¥å…¨ scoop install scoop-completion #  å¸¸ç”¨å­—ä½“scoop install Firacodescoop install Meslo-NF  # å¿…é¡»å®‰è£…scoop install Font-Awesomescoop install Source-Han-Serif-SC\n\nç¾åŒ– Power Shell# å®‰è£…ç›¸å…³æ¨¡å— Install-Module oh-my-posh -Scope CurrentUserInstall-Module posh-git -Scope CurrentUser -AllowClobberInstall-Module Terminal-Icons -Scope CurrentUser #  å¦‚éœ€å¸è½½ï¼Œå‘½ä»¤å¦‚ä¸‹Uninstall-Module -Name oh-my-posh -AllVersions -ForceUninstall-Module -Name posh-git -AllVersions -ForceUninstall-Module -Name Terminal-Icons -AllVersions -Force\n\nThemesè®¾ç½® Themes# code $PROFILEImport-Module posh-gitImport-Module oh-my-poshSet-PoshPromt jblab2021\n","categories":["Tools"],"tags":["windows","terminal","theme"]},{"title":"æ¿€æ´» Typora","url":"/2022/01/04/30/","content":"\n    \n\n\n\n\nå…‹éš† GitHub ä»“åº“git clone https://github.com/Mas0nShi/typoraCracker.git\n\nå®‰è£…ä¾èµ–ç¯å¢ƒpip install -r requirements.txt\n\n\nå¯èƒ½æŠ¥é”™ï¼Œè¿è¡Œå¦‚ä¸‹å‘½ä»¤\npip install jsbeautifierpip install jsminpip install logurupip install pycryptodome\n\nåˆ›å»ºè¾“å‡ºç›®å½•mkdir \\typoraCracker\\output\\mkdir \\typoraCracker\\out_app_asar\\\n\nç”Ÿæˆç ´è§£æ–‡ä»¶python .\\typora.py \\Typora\\resources\\app.asar .\\output\\\n\n\nå¯èƒ½æŠ¥å¦‚ä¸‹é”™è¯¯\nTraceback (most recent call last):  File &quot;\\typoraCracker\\typora.py&quot;, line 8, in &lt;module&gt;    from Crypto.Cipher import AESModuleNotFoundError: No module named &#x27;Crypto&#x27;\n\n\næ‰“å¼€ \\Python\\Python37\\Lib\\site-packages è¿™ä¸ªè·¯å¾„ï¼Œæ‰¾åˆ° crypto è¿™ä¸ªæ–‡ä»¶å¤¹\nå°† crypto è¿™ä¸ªæ–‡ä»¶å¤¹é‡å‘½åä¸ºCrypto\n\n\næ›¿æ¢ License.js æ–‡ä»¶move .\\example\\patch\\License.js .\\output\\dec_app\\\n\né‡æ–°ç”Ÿæˆ app.asar æ–‡ä»¶python .\\typora.py -u .\\key\\outfile\\dec_app\\ .\\output\\out_app_asar\\\n\næ›¿æ¢app.asarmove .\\output\\out_app_asar\\app.asar \\Typora\\resources\\app.asar\n\nç”Ÿæˆåºåˆ—å·node .\\example\\keygen.js\n","categories":["Tools"],"tags":["typora","crack"]},{"title":"æ—¥å¸¸å¼€å‘ç¬”è®°","url":"/2021/11/05/3/","content":"Git ç›¸å…³\nç›¸å…³å‘½ä»¤\nåˆ†æ”¯\n\ngit å›é€€æœ¬åœ°ä¿®æ”¹\ngit checkout &lt;filename&gt;git checkout .\nåˆ‡æ¢åˆ°åˆ†æ”¯\ngit checkout &lt;branch&gt; # åˆ‡æ¢åˆ° &lt;branch&gt; åˆ†æ”¯git checkout -b &lt;branch&gt; # åˆ›å»º &lt;branch&gt; åˆ†æ”¯å¹¶åˆ‡æ¢åˆ°è¯¥åˆ†æ”¯\nåˆ é™¤åˆ†æ”¯\n\nåˆ é™¤æœ¬åœ°åˆ†æ”¯\ngit branch -d &lt;branch&gt;\nåˆ é™¤è¿œç¨‹åˆ†æ”¯\ngit push origin -d &lt;branch&gt;\n\n\n\n\næ¸…ç©º git ç¼“å­˜\ngit rm -r --cached .\næ—¥å¿—\ngit log\n\n\n-&lt;n&gt;ï¼šæ˜¾ç¤ºæ—¥å¿—ï¼ˆq é€€å‡ºï¼‰ï¼Œæ˜¾ç¤º n æ¡æ—¥å¿—\n--statï¼šæ¯ä¸ªæäº¤éƒ½åˆ—å‡ºäº†ä¿®æ”¹è¿‡çš„æ–‡ä»¶ï¼Œä»¥åŠå…¶ä¸­æ·»åŠ å’Œç§»é™¤çš„è¡Œæ•°ï¼Œå¹¶åœ¨æœ€ååˆ—å‡ºæ‰€æœ‰å¢å‡è¡Œæ•°\nauthorï¼šæ˜¾ç¤ºæŒ‡å®šä½œè€…çš„æäº¤\n--grepï¼šè¿‡æ»¤æäº¤è¯´æ˜ä¸­çš„æ–‡å­—\n--&lt;path&gt;ï¼šå¦‚æœåªå…³å¿ƒæŸä¸ªæ–‡ä»¶æˆ–è€…ç›®å½•çš„å†å²æäº¤ï¼Œå¯ä»¥åœ¨ git log æœ€åæŒ‡å®šè·¯å¾„\n\n\næ¯”è¾ƒå·¥ä½œåŒºå’Œä¸Šä¸ªæäº¤ç‰ˆæœ¬çš„åŒºåˆ«\ngit diff &lt;filename&gt;\næ‹‰å–\ngit fetch # æ‹‰å–æ‰€æœ‰åˆ†æ”¯çš„å˜åŒ–git fetch -p # æ‹‰å–æ‰€æœ‰åˆ†æ”¯çš„å˜åŒ–ï¼Œå¹¶å°†è¿œç«¯ä¸å­˜åœ¨çš„åˆ†æ”¯åŒæ­¥ç§»é™¤git fetch &lt;origin master&gt; # æ‹‰å–æŒ‡å®šåˆ†æ”¯çš„å˜åŒ–\nå›æ»š\ngit reset # å°†æäº¤è®°å½•å›æ»šï¼Œä»£ç ä¸å›æ»šgit reset --hard # å°†æäº¤è®°å½•å’Œä»£ç å…¨éƒ¨å›æ»š\nstash\n\ngit stash # å°†å½“å‰å·¥ä½œåŒºçš„çŠ¶æ€å­˜å‚¨ä¸‹æ¥git stash list # æŸ¥çœ‹å½“å‰æœ‰å¤šå°‘ stashgit stash apply --index # æŠŠæŸä¸€ä¸ª stash åº”ç”¨å›å½“å‰çš„åˆ†æ”¯git stash -include-untracked # æœ‰äº›æ–‡ä»¶æ²¡æœ‰åœ¨ git çš„ track é‡Œï¼Œå¯ä»¥æ·»åŠ å‚æ•°æ¥å­˜å‚¨å¯¹åº”çš„æ–‡ä»¶\n\n\nç”¨ git stash apply å‘½ä»¤æ¢å¤ï¼Œä½†æ˜¯æ¢å¤åï¼Œstashå†…å®¹å¹¶ä¸åˆ é™¤ï¼Œéœ€è¦ç”¨ git stash drop æ¥åˆ é™¤\nç”¨ git stash pop å‘½ä»¤ï¼Œæ¢å¤çš„åŒæ—¶æŠŠ stash å­˜å‚¨åˆ—è¡¨çš„å†…å®¹ä¹Ÿåˆ é™¤\n\n\næŸ¥çœ‹æŸä¸ª hash æ‰€å¯¹åº”çš„ object ä¸­çš„å†…å®¹\ngit cat-file -p &lt;commit_id&gt;\nä¸¢å¼ƒæœ¬åœ°ä¿®æ”¹çš„æ‰€æœ‰æ–‡ä»¶ï¼ˆæ–°å¢ã€åˆ é™¤ã€ä¿®æ”¹ï¼‰\ngit checkout . # æœ¬åœ°æ‰€æœ‰ä¿®æ”¹çš„ã€‚æ²¡æœ‰çš„æäº¤çš„ï¼Œéƒ½è¿”å›åˆ°åŸæ¥çš„çŠ¶æ€ git stash # æŠŠæ‰€æœ‰æ²¡æœ‰æäº¤çš„ä¿®æ”¹æš‚å­˜åˆ° stash é‡Œé¢ã€‚å¯ç”¨ git stash pop å›å¤git reset --hard HASH # è¿”å›åˆ°æŸä¸ªèŠ‚ç‚¹ï¼Œä¸ä¿ç•™ä¿®æ”¹ï¼Œå·²æœ‰çš„æ”¹åŠ¨ä¼šä¸¢å¤±git reset --soft HASH # è¿”å›åˆ°æŸä¸ªèŠ‚ç‚¹ï¼Œä¿ç•™ä¿®æ”¹ï¼Œå·²æœ‰çš„æ”¹åŠ¨ä¼šä¿ç•™ï¼Œåœ¨æœªæäº¤ä¸­ï¼Œgit status æˆ– git diff å¯çœ‹git clean -df # è¿”å›åˆ°æŸä¸ªèŠ‚ç‚¹ï¼Œï¼ˆæœªè·Ÿè¸ªæ–‡ä»¶çš„åˆ é™¤ï¼‰git clean å‚æ•°  # -n ä¸å®é™…åˆ é™¤ï¼Œåªæ˜¯è¿›è¡Œæ¼”ç»ƒï¼Œå±•ç¤ºå°†è¦è¿›è¡Œçš„æ“ä½œï¼Œæœ‰å“ªäº›æ–‡ä»¶å°†è¦è¢«åˆ é™¤ã€‚ï¼ˆå¯å…ˆä½¿ç”¨è¯¥å‘½ä»¤å‚æ•°ï¼Œç„¶åå†å†³å®šæ˜¯å¦æ‰§è¡Œï¼‰  # -f åˆ é™¤æ–‡ä»¶  # -i æ˜¾ç¤ºå°†è¦åˆ é™¤çš„æ–‡ä»¶  # -d é€’å½’åˆ é™¤ç›®å½•åŠæ–‡ä»¶ï¼ˆæœªè·Ÿè¸ªçš„ï¼‰  # -q ä»…æ˜¾ç¤ºé”™è¯¯ï¼ŒæˆåŠŸåˆ é™¤çš„æ–‡ä»¶ä¸æ˜¾ç¤º æ³¨ï¼šgit reset # åˆ é™¤çš„æ˜¯å·²è·Ÿè¸ªçš„æ–‡ä»¶ï¼Œå°†å·² commit çš„å›é€€git clean # åˆ é™¤çš„æ˜¯æœªè·Ÿè¸ªçš„æ–‡ä»¶git clean -nxdf # æŸ¥çœ‹è¦åˆ é™¤çš„æ–‡ä»¶åŠç›®å½•ï¼Œç¡®è®¤æ— è¯¯åå†ä½¿ç”¨ä¸‹é¢çš„å‘½ä»¤è¿›è¡Œåˆ é™¤git checkout . &amp;&amp; git clean -xdf\n\nHexo éƒ¨ç½²çš„åšå®¢ Git æäº¤åˆ° Github è´¦æˆ·é”™ä¹±çš„é—®é¢˜  ç”±äºé€šè¿‡ ** SmartGit ** è®¾ç½®äº†  å…¨å±€çš„ç”¨æˆ·å  å’Œå…¨å±€çš„é‚®ç®±ï¼ˆå·¥ä½œç”¨çš„ Git è´¦å·å’Œé‚®ç®±ï¼‰å¯¼è‡´æäº¤åˆ° Github ä¸Šçš„ç‰ˆæœ¬ä¸æ˜¯è‡ªå·±çš„è´¦æˆ·\n\n\nè§£å†³æ–¹æ³•  åœ¨åšå®¢ç›®å½•ä¸‹æ‰¾åˆ° .deploy_git ç›®å½•ï¼ˆæ²¡æœ‰çš„è¯ç”¨ hexo g ç”Ÿæˆä¸€ä¸‹å°±å¯ä»¥ï¼‰ï¼Œç„¶åå¯ä»¥çœ‹åˆ°å½“å‰ç›®å½•çš„ç”¨æˆ·åå’Œé‚®ç®±ä¸è‡ªå·±çš„ä¸ä¸€è‡´ï¼Œé€šè¿‡ä»¥ä¸‹å‘½ä»¤å¯ä»¥æ›´æ”¹ä¸ºä¸€è‡´çš„ç”¨æˆ·åå’Œé‚®ç®±ï¼š\ngit config user.name SilhouettesForYougit config user.email mgze.wang@gmail.com\n\n\nä¹‹åå†è¿›è¡Œåšå®¢çš„  å‘å¸ƒ  ä¾¿å¯ä»¥ç”¨æ­£ç¡®çš„ç”¨æˆ·æäº¤åˆ° Github\nGit æ–‡ä»¶ç›®å½•ç»“æ„è§£æ.git |-- COMMIT_EDITMSG  // æäº¤ commit æ—¶çš„ä¿¡æ¯è®°å½•|-- FETCH_HEAD  // è®°å½•äº†ä¸Šæ¬¡ fetch çš„åˆ†æ”¯çš„ commit çš„ HASH|-- HEAD   // è®°å½•äº†å½“å‰å¤´æŒ‡é’ˆåœ¨ã€‚git å­˜å‚¨çš„åœ°å€ï¼Œå¦‚ refs/heads/brancha|-- ORIG_HEAD |-- branches|-- config  // ä¸€äº›å¼€å…³ &amp; è®°å½•äº†æ‰€æœ‰åˆ†æ”¯çš„ fetch&amp;merge çš„ç­–ç•¥ï¼Œåœ¨ checkout -b æˆ– --set-upstream-to            // æ—¶å°†å‘ config ä¸­æ·»åŠ æœ¬åœ°åˆ†æ”¯å¯¹åº”çš„è¿œç«¯åˆ†æ”¯ä¿¡æ¯|-- description|-- hooks  //hook è„šæœ¬çš„å­˜å‚¨ä½ç½®ï¼Œé‡Œé¢æœ‰ä¸€äº› sample è„šæœ¬|   |-- applypatch-msg.sample|   |-- commit-msg.sample|   |-- post-update.sample|   |-- pre-applypatch.sample|   |-- pre-commit.sample|   |-- pre-push.sample|   |-- pre-rebase.sample|   |-- prepare-commit-msg.sample|   |-- update.sample|-- index|-- info|   `-- exclude|-- logs  // å¤´æŒ‡é’ˆæ”¹å˜çš„æ—¥å¿—æ–‡ä»¶|   |-- HEAD  // å¯¹äºæ•´ä¸ªä»“åº“çš„å¤´æŒ‡é’ˆæ”¹å˜çš„è®°å½•|   `-- refs|       |-- heads  // å¯¹äºå•ä¸ªæœ¬åœ°ä»“åº“å¤´æŒ‡é’ˆæ”¹å˜çš„è®°å½•ï¼ˆä¼šè®°å½•åŒ…å«å†²çªçš„çŠ¶æ€ï¼‰|       |   |-- brancha|       |   |-- branchb|       |   `-- main|       `-- remotes   |           `-- origin|               |-- HEAD|               |-- brancha|               `-- branchb|-- objects // æ‰€æœ‰ commitã€treeã€... çš„å¿«ç…§ï¼Œå°† commit çš„ HASH å€¼çš„å‰ä¸¤ä½ä½œä¸ºæ–‡ä»¶å¤¹åï¼Œåé¢çš„å€¼ä½œä¸ºå¿«ç…§å|   |-- 12 //commit çš„ HASH å€¼çš„å‰ä¸¤ä½|   |   `-- d4b6c73ffad196c6972c93e5ce9e691e5862c0  //commit çš„ HASH å€¼é™¤äº†å‰ä¸¤ä½|   |-- 1d|   |   `-- b538af883f712194118c2d98eb63422dc62d94|   |-- 21|   |   `-- a23a99b0430e5a7aa5cdd8c56012f89318c9fe|   |-- 2c|   |   `-- 0b785731151d48705e4985aad2520f21c36bbb|   |-- 3b|   |   `-- 18e512dba79e4c8300dd08aeb37f8e728b8dad|   |-- info|   `-- pack|       |-- pack-0aa3e5057acbdff932634f63ea390953828409dd.idx|       `-- pack-0aa3e5057acbdff932634f63ea390953828409dd.pack|-- packed-refs`-- refs  // å¤´æŒ‡é’ˆç­‰ä¿¡æ¯çš„è®°å½•    |-- heads  // è®°å½•äº†æ¯ä¸ªæœ¬åœ°åˆ†æ”¯å½“å‰å¤´æŒ‡é’ˆæ‰€åœ¨ commit çš„ HASH    |   |-- brancha    |   |-- branchb    |   `-- main    |-- remotes  // è®°å½•äº†æ¯ä¸ªè¿œç¨‹åˆ†æ”¯å½“å‰å¤´æŒ‡é’ˆæ‰€åœ¨ commit çš„ HASH    |   `-- origin    |       |-- HEAD    |       |-- brancha    |       `-- branchb    `-- tags\n\nGit åˆ‡æ¢è¿œç«¯åˆ†æ”¯  æŸ¥çœ‹æ‰€æœ‰åˆ†æ”¯git branch -a | grep key-wordgit branch -a | grep skilltestremotes/origin/feature_4it01_skilltesttoolsremotes/origin/feature_ghs_4it01_skilltesttools\n\n\ngit branchä¸å¸¦å‚æ•°ï¼Œåˆ—å‡ºæœ¬åœ°å·²ç»å­˜åœ¨çš„åˆ†æ”¯ï¼Œå¹¶ä¸”åœ¨å½“å‰åˆ†æ”¯çš„å‰é¢ç”¨ * æ ‡è®°ï¼ŒåŠ ä¸Š -a å‚æ•°å¯ä»¥æŸ¥çœ‹æ‰€æœ‰åˆ†æ”¯åˆ—è¡¨ï¼ŒåŒ…æ‹¬æœ¬åœ°å’Œè¿œç¨‹ï¼Œè¿œç¨‹åˆ†æ”¯ä¸€èˆ¬ä¼šç”¨çº¢è‰²å­—ä½“æ ‡è®°å‡ºæ¥  å¦‚æœç”¨git branch -a æ²¡æœ‰æ˜¾ç¤ºå…¨éƒ¨çš„è¿œç¨‹åˆ†æ”¯ï¼Œå¯ä»¥é€šè¿‡ git fetch å°†æœ¬åœ°è¿œç¨‹è·Ÿè¸ªåˆ†æ”¯è¿›è¡Œæ›´æ–°ï¼Œä¸è¿œç¨‹åˆ†æ”¯ä¿æŒä¸€è‡´\n\næ–°å»ºåˆ†æ”¯å¹¶åˆ‡æ¢åˆ°æŒ‡å®šåˆ†æ”¯git checkout -b feature_4it01_skilltesttools origin/feature_4it01_skilltesttools\n\nè¯¥å‘½ä»¤å¯ä»¥å°†è¿œç¨‹ git ä»“åº“é‡Œçš„æŒ‡å®šåˆ†æ”¯æ‹‰å–åˆ°æœ¬åœ°ï¼Œè¿™æ ·å°±åœ¨æœ¬åœ°æ–°å»ºäº†ä¸€ä¸ª feature_4it01_skilltesttools åˆ†æ”¯ï¼Œå¹¶å’ŒæŒ‡å®šçš„è¿œç¨‹åˆ†æ”¯ origin/feature_4it01_skilltesttools å…³è”äº†èµ·æ¥ã€‚\næŸ¥çœ‹æœ¬åœ°åˆ†æ”¯åŠè¿½è¸ªçš„åˆ†æ”¯git branch -vvdevelop                      98e306d76c5 [origin/develop: behind 1461] [AUTO COMMIT OFFLINES]commit by tools* feature_4it01_skilltesttools c44dbb8584f [origin/feature_4it01_skilltesttools] Merge branch 'all.dev.ep7' into all.ep7.it01\n\n*è¡¨ç¤ºå½“å‰æ‰€åœ¨åˆ†æ”¯ï¼Œ[è¿œç¨‹åˆ†æ”¯] è¡¨ç¤ºå½“å‰æœ¬åœ°åˆ†æ”¯è¿½è¸ªçš„è¿œç¨‹åˆ†æ”¯ï¼Œæœ€åä¸€ä¸ªæ˜¯æœ€è¿‘ä¸€æ¬¡æäº¤çš„æ³¨é‡Šã€‚\ngit cherry-pickç”¨æ³•  å¯¹äºå¤šåˆ†æ”¯çš„ä»£ç åº“ï¼Œå°†ä»£ç ä»ä¸€ä¸ªåˆ†æ”¯è½¬ç§»åˆ°å¦ä¸€ä¸ªåˆ†æ”¯æ˜¯å¸¸è§éœ€æ±‚ã€‚å¦‚æœéœ€è¦å¦ä¸€ä¸ªåˆ†æ”¯çš„æ‰€æœ‰ä»£ç å˜åŠ¨ï¼Œé‚£ä¹ˆå°±é‡‡ç”¨git mergeï¼›å¦‚æœåªéœ€è¦éƒ¨åˆ†ä»£ç å˜åŠ¨ï¼ˆæŸå‡ ä¸ªæäº¤ï¼‰ï¼Œè¿™æ—¶å¯ä»¥é‡‡ç”¨git cherry-pickï¼Œå®ƒçš„åŠŸèƒ½æ˜¯æŠŠå·²ç»å­˜åœ¨çš„ ** commit ** è¿›è¡ŒæŒ‘é€‰ï¼Œç„¶åé‡æ–°æäº¤ã€‚\nè½¬ç§»ä¸€ä¸ªæäº¤\nå…ˆåˆ‡æ¢åˆ° A åˆ†æ”¯git checkout A\næ‰¾åˆ°è¿™æ¬¡æäº¤git logï¼Œèµ‹å€¼&lt;hash code&gt;\nå†åˆ‡æ¢åˆ° B åˆ†æ”¯git chekcou B\næŠŠ A åˆ†æ”¯ä¸‹çš„è‡³æ­¤æäº¤é‡æ–°æäº¤åˆ° B åˆ†æ”¯ä¸‹git cherrt-pick &lt;hash code&gt;\n\nå½“æ‰§è¡Œå®Œ git cherry-pickä»¥åï¼Œå°†ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æäº¤ï¼Œè¿™ä¸ªæ–°çš„æäº¤çš„ hash å€¼å’ŒåŸæ¥çš„ä¸åŒï¼Œä½†æ ‡å¿—åç§°ä¸€æ ·ã€‚\nè½¬ç§»å¤šä¸ªæäº¤git cherry-pick &lt;hash code 1&gt; &lt;hash code 2&gt;git cherry-pick &lt;hash code begin&gt;..&lt;hash code end&gt; # å·¦å¼€å³é—­ï¼Œé¡ºåºå¿…é¡»æ­£ç¡®git cherry-pick &lt;hash code begin&gt;^..&lt;hash code end&gt; # å·¦é—­å³é—­\n\nUnity ç›¸å…³  å‡ ç§ Update æ–¹æ³•çš„åŒºåˆ« UpdateUpdate æ˜¯åœ¨æ¯æ¬¡æ¸²æŸ“æ–°çš„ä¸€å¸§çš„æ—¶å€™æ‰ä¼šè°ƒç”¨\nFixedUpdateè¯¥å‡½æ•°ç”¨äºå›ºå®šæ›´æ–°ï¼Œåœ¨æ¸¸æˆè¿è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œæ¯ä¸€å¸§çš„å¤„ç†æ—¶é—´æ˜¯ä¸å›ºå®šçš„ï¼Œå½“éœ€è¦å›ºå®šé—´éš”æ—¶é—´æ‰§è¡ŒæŸäº›ä»£ç æ—¶ï¼Œå°±ä¼šç”¨åˆ° FixedUpdate() å‡½æ•°\nLastUpdateè¯¥å‡½æ•°æ˜¯å»¶è¿Ÿæ›´æ–°å‡½æ•°ï¼Œå¤„äºæ¿€æ´»çŠ¶æ€è™¾çš„è„šæœ¬åœ¨æ¯ä¸€å¸§é‡Œéƒ½ä¼šåœ¨ Update() å‡½æ•°æ‰§è¡Œåè°ƒç”¨è¯¥å‡½æ•°ï¼Œé€šå¸¸ç”¨æ¥è°ƒæ­£ä»£ç æ‰§è¡Œçš„é¡ºåºã€‚æ¯”å¦‚ç©å®¶çš„è§’è‰²éœ€è¦ä¸€ä¸ªæ‘„åƒæœºæ¥è·Ÿéšï¼Œé‚£ä¹ˆé€šå¸¸è§’è‰²çš„ç§»åŠ¨é€»è¾‘ä¼šå†™åœ¨ Update() é‡Œï¼Œè€Œæ‘„åƒæœºè·Ÿéšå†™åœ¨ LastUpdate() é‡Œã€‚è¿™æ ·å¯ä»¥ç¡®ä¿åœ¨è§’è‰²çš„ä½ç½®è®¡ç®—å®Œæ¯•åï¼Œå†æ ¹æ®è§’è‰²ä½ç½®ç¡®å®šæ‘„åƒæœºçš„ä½ç½®å’Œè§†è§’\nUnity3D å†…å­˜ç®¡ç†â€”â€”å¯¹è±¡æ± ï¼ˆObject Poolï¼‰using System.Collections.Generic;using UnityEngine.Events;namespace UnityEngine.UI{    internal class ObjectPool&lt;T&gt; where T : new()    {        private readonly Stack&lt;T&gt; m_Stack = new Stack&lt;T&gt;();        private readonly UnityAction&lt;T&gt; m_ActionOnGet;        private readonly UnityAction&lt;T&gt; m_ActionOnRelease;        public int countAll {get; private set; }        public int countActive {get { return countAll - countInactive; } }        public int countInactive {get { return m_Stack.Count; } }        public ObjectPool(UnityAction&lt;T&gt; actionOnGet, UnityAction&lt;T&gt; actionOnRelease)        {            m_ActionOnGet = actionOnGet;            m_ActionOnRelease = actionOnRelease;        }        public T Get()        {            T element;            if (m_Stack.Count == 0)            {                element = new T();                countAll++;            }            else            {                element = m_Stack.Pop();            }            if (m_ActionOnGet != null)                m_ActionOnGet(element);            return element;        }        public void Release(T element)        {            if (m_Stack.Count &gt; 0 &amp;&amp; ReferenceEquals(m_Stack.Peek(), element))                Debug.LogError(\"Internal error. Trying to destroy object that is already released to pool.\");            if (m_ActionOnRelease != null)                m_ActionOnRelease(element);            m_Stack.Push(element);        }    }}\n\nObjectPoolä½¿ç”¨äº†ä¸€ä¸ªæ ˆï¼ˆåè¿›å…ˆå‡ºçš„æ•°æ®ç»“æ„ï¼‰ï¼Œå½“éœ€è¦æ–°å»ºï¼ˆGetï¼‰ä¸€ä¸ªæ–°çš„å¯¹è±¡çš„æ—¶å€™å…ˆä»æ ˆé¡¶å–å‡ºç¬¬ä¸€ä¸ªï¼Œå½“ä½¿ç”¨ç»“æŸçš„æ—¶å€™å°†å…¶é‡Šæ”¾æ‰ï¼ˆRelaeaseï¼‰ï¼Œå°±æ˜¯å°†å…¶é‡æ–°æ”¾å›æ ˆé‡Œé¢ï¼Œè€Œä¸æ˜¯æ¯æ¬¡éƒ½å®ä¾‹åŒ–ä¸€ä¸ªæ–°çš„å¯¹è±¡ã€‚\nåç¨‹  åç¨‹ä¸æ˜¯çº¿ç¨‹ï¼Œä¸æ˜¯å¼‚æ­¥æ‰§è¡Œã€‚åç¨‹å’Œ MonoBehaviour çš„Updateå‡½æ•°ä¸€æ ·åœ¨ä¸»çº¿ç¨‹ä¸­æ‰§è¡Œï¼ŒUnity åœ¨æ¯ä¸€å¸§éƒ½ä¼šå¤„ç†å¯¹è±¡ä¸Šçš„åç¨‹ã€‚\nåç¨‹çš„æ‰§è¡ŒåŸç† IEnumberator åç¨‹å‡½æ•°çš„è¿”å›å€¼æ—¶IEnumberatorï¼Œå®ƒæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯ä»¥æŠŠå®ƒå½“æˆæ‰§è¡Œä¸€ä¸ªåºåˆ—çš„æŸä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆã€‚å®ƒ 3 ä¸ªæ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯\n\nCurrentï¼šè¿”å›å½“å‰æŒ‡å‘çš„å…ƒç´ \nMoveNextï¼šå°†æŒ‡é’ˆå‘åç§»åŠ¨ä¸€ä¸ªå•ä½ï¼Œå¦‚æœç§»åŠ¨æˆåŠŸï¼Œåˆ™è¿”å›true\nResetï¼šæŠŠä½ç½®é‡ç½®ä¸ºåˆå§‹çŠ¶æ€\n\nyieldyieldå…³é”®å­—ç”¨æ¥å£°æ˜åºåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªå€¼æˆ–è€…æ˜¯ä¸€ä¸ªæ— æ„ä¹‰çš„å€¼ã€‚\nå½“ç”¨ yield return xï¼ˆx æ˜¯æŒ‡ä¸€ä¸ªå…·ä½“çš„å¯¹è±¡æˆ–æ•°å€¼ï¼‰æŒ‚èµ·åç¨‹ï¼šMoveNextè¿”å›ä¸º trueï¼ŒCurrent è¢«èµ‹å€¼ä¸º xï¼›å½“ç”¨yield break æŒ‚èµ·åç¨‹ï¼ŒMoveNextè¿”å›ä¸º falseã€‚ å¦‚æœ MoveNext å‡½æ•°è¿”å›ä¸º true  æ„å‘³ç€åç¨‹çš„æ‰§è¡Œæ¡ä»¶è¢«æ»¡è¶³ï¼Œåˆ™èƒ½å¤Ÿä»å½“å‰ä½ç½®ç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œå¦åˆ™ä¸èƒ½ä»å½“å‰ä½ç½®ç»§ç»­å¾€ä¸‹æ‰§è¡Œã€‚åªæœ‰å½“ MoveNext è¿”å› false æ—¶ï¼Œæ‰ä¼šæ‰§è¡Œ yield return åé¢çš„è¯­å¥ã€‚\nä¸­æ–­å‡½æ•°ç±»å‹\n\n\nè¯­å¥\nå«ä¹‰\n\n\n\nyield return null/yield return 0;\nç¨‹åºåœ¨ä¸‹ä¸€å¸§ä¸­ä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield return new WaitForSeconds(N);\nç¨‹åºç­‰å¾… N ç§’åä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield new WaitForEndOfFrame();\nåœ¨æ‰€æœ‰çš„æ¸²æŸ“ä»¥åŠ GUI ç¨‹åºæ‰§è¡Œå®Œæˆåä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield new WaitForFixedUpdate();\næ‰€æœ‰è„šæœ¬ä¸­çš„ FixedUpdate() å‡½æ•°éƒ½è¢«æ‰§è¡Œåä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield return WWW;\nç­‰å¾…ä¸€ä¸ªç½‘ç»œè¯·æ±‚å®Œæˆåä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield return StartCoroutine(xxx);\nç­‰å¾…ä¸€ä¸ª xxx çš„åç¨‹æ‰§è¡Œå®Œæˆåä»å½“å‰ä½ç½®ç»§ç»­æ‰§è¡Œ\n\n\nyield break;\nè·³å‡ºåç¨‹\n\n\n\nWhat is the difference between â€œyield return 0â€ and â€œyield return nullâ€ in Coroutine\nBoth yield return 0 and yield return null yields for a single frame. The biggest difference is that yield return 0 allocates memory because of boxing and unboxing of the 0 that happens under the hood, but yield return null does not allocate memory. Because of this, it is highly recommended to use yield return null if you care about performance.\n\nUnity EditorWindow çš„ OnGUI åˆ·æ–°  åœ¨ç¼–è¾‘å™¨æ¨¡å¼ä¸‹ï¼ŒOnGUIåªæœ‰åœ¨çª—å£æ¿€æ´»çš„çŠ¶æ€ï¼ˆå³é¼ æ ‡ç§»åŠ¨åˆ°çª—å£ä¸Šã€ç‚¹å‡»äº‹ä»¶ç­‰ï¼‰æ‰ä¼šåˆ·æ–°ï¼Œæ‰§è¡ŒOnGUIã€‚å¦‚æœéœ€è¦å®æ—¶åˆ·æ–°çš„è¯ï¼Œå¯ç”¨ OnInspectorUpdate å¼€å¯çª—å£é‡ç»˜ï¼ŒUnity ä¼šæ¯ç§’ 10 å¸§é‡ç»˜çª—å£ã€‚\n\nC# ç›¸å…³ C# æ³›å‹çº¦æŸ åœ¨å®šä¹‰æ³›å‹ç±»æ—¶ã€‚å¯ä»¥å¯¹ä»£ç èƒ½å¤Ÿåœ¨å®ä¾‹åŒ–ç±»æ—¶ç”¨äºç±»å‹å‚æ•°çš„ç±»å‹ç§ç±»åŠ é™åˆ¶ã€‚å¦‚æœä»£ç å°è¯•ä½¿ç”¨æŸä¸ªçº¦æŸæ‰€ä¸å…è®¸çš„ç±»å‹æ¥å®ä¾‹åŒ–ç±»ï¼Œåˆ™ä¼šäº§ç”Ÿç¼–è¯‘é”™è¯¯ã€‚è¿™äº›é™åˆ¶æˆä¸ºçº¦æŸï¼Œçº¦æŸæ˜¯ä½¿ç”¨ where ä¸Šä¸‹æ–‡å…³é”®å­—æŒ‡å®šçš„ã€‚\n\n\n\nçº¦æŸ\nè¯´æ˜\n\n\n\nT : struct\nç±»å‹å‚æ•°ç¢§è¡€æ˜¯å€¼ç±»å‹ï¼Œå¯ä»¥æŒ‡å®šé™¤ Nullable ä»¥å¤–çš„ä»»ä½•å€¼ç±»å‹\n\n\nT : class\nç±»å‹å‚æ•°å¿…é¡»æ˜¯å¼•ç”¨ç±»å‹ï¼ŒåŒ…æ‹¬ä»»ä½•ç±»ã€æ¥å£ã€å§”æ‰˜æˆ–æ•°ç»„ç±»å‹\n\n\nT : new()\nç±»å‹å‚æ•°å¿…é¡»å…·æœ‰æ— å‚æ•°çš„å…¬å…±æ„é€ å‡½æ•°ï¼Œå½“ä¸å…¶ä»–çº¦æŸä¸€èµ·ä½¿ç”¨æ—¶ï¼Œnew()çº¦æŸå¿…é¡»æœ€åæŒ‡å®š\n\n\nT : &lt; åŸºç±»å &gt;\nç±»å‹å‚æ•°å¿…é¡»æ˜¯æŒ‡å®šçš„åŸºç±»æˆ–æ´¾ç”Ÿè‡ªæŒ‡å®šçš„åŸºç±»\n\n\nT : &lt; æ¥å£å &gt;\nç±»å‹å‚æ•°å¿…é¡»æ˜¯æŒ‡å®šçš„æ¥å£æˆ–å®ç°æŒ‡å®šçš„æ¥å£ï¼Œå¯ä»¥æŒ‡å®šå¤šä¸ªæ¥å£çº¦æŸï¼Œæ¥å£çº¦æŸä¹Ÿå¯ä»¥æ˜¯æ³›å‹çš„\n\n\nT : U\nä¸º T æä¾›çš„ç±»å‹å‚æ•°å¿…é¡»æ˜¯ä¸º U æä¾›çš„å‚æ•°æˆ–æ´¾ç”Ÿè‡ªä¸º U æä¾›çš„å‚æ•°ï¼Œè¿™æˆä¸ºè£¸ç±»å‹çº¦æŸ\n\n\ndefaultå‡½æ•° default(T) å¯ä»¥å¾—åˆ°è¯¥ç±»å‹çš„é»˜è®¤å€¼ï¼ŒC# åœ¨åˆå§‹åŒ–æ—¶ï¼Œä¼šç»™æœªæ˜¾ç¤ºè‚¤è´¨çš„å­—æ®µã€å±æ€§èµ‹ä¸Šé»˜è®¤å€¼ï¼Œä½†å€¼å˜é‡å´ä¸ä¼šï¼Œå€¼å˜é‡å¯ä»¥ä½¿ç”¨é»˜è®¤æ„é€ å‡½æ•°èµ‹å€¼ï¼Œæˆ–è€…ä½¿ç”¨ default(T) èµ‹å€¼ã€‚\n\n\n\nå€¼ç±»å‹\né»˜è®¤å€¼\n\n\n\nbool\nfalse\n\n\nbyte/int/sbyte /short /uint /ulong /ushort\n0\n\n\ndecimal\n0.0M\n\n\ndouble\n0.0D\n\n\nfloat\n0.0F\n\n\nlong\n0L\n\n\nenum\nè¡¨è¾¾å¼ (E)0 äº§ç”Ÿçš„å€¼ï¼Œå…¶ä¸­ E ä¸ºenumæ ‡è¯†ç¬¦\n\n\nstruct\nå°†æ‰€æœ‰çš„å€¼ç±»å‹å­—æ®µè®¾ç½®ä¸ºé»˜è®¤å€¼å¹¶å°†æ‰€æœ‰çš„å¼•ç”¨ç±»å‹å­—æ®µè®¾ç½®ä¸º null æ—¶äº§ç”Ÿçš„å€¼\n\n\nå¼•ç”¨ç±»å‹\nnull\n\n\nC# ä¸­ isï¼Œasï¼Œusing å…³é”®å­—çš„ä½¿ç”¨\nisï¼šç”¨äºæ£€æŸ¥å¯¹è±¡æ˜¯å¦ä¸ç»™å®šç±»å‹å…¼å®¹ï¼Œä¸ä¼šæŠ›å‡ºå¼‚å¸¸\nasï¼šç”¨äºå¼•ç”¨ç±»å‹ä¹‹é—´è½¬æ¢ï¼Œç›´æ¥è¿›è¡Œè½¬æ¢ï¼Œè‹¥è½¬æ¢æˆåŠŸï¼Œåˆ™è¿”å›è½¬æ¢åçš„å¯¹è±¡ï¼Œè‹¥è½¬æ¢å¤±è´¥åˆ™è¿”å›nullï¼Œä¸ä¼šæŠ›å‡ºå¼‚å¸¸\nusingï¼šå¼•ç”¨å‘½åç©ºé—´ï¼Œæœ‰æ•ˆå›æ”¶èµ„æºï¼Œusingå…³é”®å­—å¯ä»¥å›æ”¶å¤šä¸ªå¯¹è±¡çš„èµ„æºï¼Œå…³é”®å­—åé¢çš„å°æ‹¬å·å†…åˆ›å»ºçš„å¯¹è±¡å¿…é¡»å®ç° IDisposanble æ¥å£ï¼Œæˆ–è€…è¯¥ç±»çš„åŸºç±»å·²ç»å®ç°äº† IDisposable æ¥å£ã€‚å›æ”¶èµ„æºçš„æ—¶æœºæ˜¯åœ¨ using å…³é”®å­—ä¸‹é¢çš„ä»£ç å—æ‰§è¡Œå®Œæˆä¹‹åè‡ªåŠ¨è°ƒç”¨æ¥å£æ–¹æ³• Dispose() é”€æ¯å¯¹è±¡\n\nrefå’Œ out å…³é”®å­—C# çš„æ•°æ®ç±»å‹æœ‰ä¸¤ç§ï¼šä¸€ç§æ˜¯å€¼ç±»å‹ï¼ˆvalue typeï¼‰ï¼Œä¸€ç§æ˜¯å¼•ç”¨ç±»å‹ï¼ˆreference typeï¼‰ã€‚\n\nå€¼ç±»å‹ï¼šç»“æ„ä½“ï¼ˆæ•°å€¼ç±»å‹ï¼Œboolï¼Œç”¨æˆ·è‡ªå®šä¹‰ç»“æ„ä½“ï¼‰ã€æšä¸¾å’Œå¯ç©ºç±»å‹ã€‚\nå¼•ç”¨ç±»å‹ï¼šæ•°ç»„ã€ç”¨æˆ·å®šä¹‰çš„ç±»ã€æ¥å£ã€å§”æ‰˜ã€objectã€å­—ç¬¦ä¸²ã€‚\n\nå€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹çš„åŒºåˆ«åœ¨äºï¼šå‡½æ•°ä¼ é€’çš„æ—¶å€™ï¼Œå€¼ç±»å‹æŠŠè‡ªå·±çš„å€¼å¤åˆ¶ä¸€ä»½ä¼ é€’ç»™åˆ«çš„å‡½æ•°ï¼›å¼•ç”¨ç±»å‹åˆ™æ˜¯æŠŠè‡ªå·±çš„åœ°å€ä¼ é€’ç»™å‡½æ•°ã€‚\nrefå’Œ out éƒ½æ˜¯æŒ‰åœ°å€ä¼ é€’çš„ï¼Œä½¿ç”¨åéƒ½å°†æ”¹å˜åŸæ¥å‚æ•°çš„æ•°å€¼ã€‚refå¯ä»¥æŠŠå‚æ•°çš„æ•°å€¼ä¼ é€’è¿›å‡½æ•°ï¼Œä¼ é€’åˆ° ref å‚æ•°å¿…é¡»åˆå§‹åŒ–ï¼Œå¦åˆ™ä¼šæŠ¥é”™ï¼›ä½†æ˜¯ out æ˜¯è¦æŠŠå‚æ•°æ¸…ç©ºï¼Œæ— æ³•æŠŠä¸€ä¸ªæ•°å€¼ä» out ä¼ é€’è¿›å»ï¼Œä¼ é€’è¿›å»åå¿…é¡»åˆå§‹åŒ–ä¸€æ¬¡ã€‚\nC# ç‰¹æ€§æ ‡ç­¾ï¼ˆAttributeï¼‰å…¬å…±è¯­è¨€è¿è¡Œæ—¶èƒ½å¤Ÿæ·»åŠ ç±»ä¼¼äºå…³é”®å­—çš„æè¿°æ€§å£°æ˜ç§°ä¸ºç‰¹æ€§ï¼Œä»¥ä¾¿æ‰¹æ³¨ç¼–ç¨‹å…ƒç´ ï¼ˆå¦‚ç±»å‹ã€å­—æ®µã€æ–¹æ³•å’Œå±æ€§ï¼‰ã€‚å°†ç‰¹æ€§ä¸ç¨‹åºå®ä½“ç›¸å…³è”åï¼Œå¯ä»¥åœ¨è¿è¡Œæ—¶ä½¿ç”¨  åå°„  æŸ¥è¯¢ç‰¹æ€§ã€‚\nå¯ä»¥å°†ç‰¹æ€§é™„åŠ åˆ°å‡ ä¹ä»»ä½•å£°æ˜ä¸­ã€‚åœ¨ C# ä¸­ï¼Œé€šè¿‡ç”¨æ–¹æ‹¬å·ï¼ˆ[]ï¼‰å°†ç‰¹æ€§åç§°æ‹¬èµ·æ¥ï¼Œå¹¶ç½®äºåº”ç”¨è¯¥ç‰¹æ€§çš„å®ä½“çš„å£°æ˜ä¸Šæ–¹ä»¥æŒ‡å®šç‰¹æ€§ã€‚\nåˆ›å»ºè‡ªå®šä¹‰ç‰¹æ€§  å¯ä»¥é€šè¿‡å®šä¹‰ç‰¹æ€§ç±»åˆ›å»ºè‡ªå®šä¹‰ç‰¹æ€§ï¼Œç‰¹æ€§ç±»æ˜¯ç›´æ¥æˆ–é—´æ¥æ´¾ç”Ÿè‡ª Attribute çš„ç±»ï¼Œå¯å¿«é€Ÿè½»æ¾åœ°è¯†åˆ«å…ƒæ•°æ®ä¸­çš„ç‰¹æ€§å®šä¹‰ã€‚\n[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct)]public class AuthorAttribute : System.Attribute{    private string name;    public double version;    public AuthorAttribute(string name)    {        this.name = name;        version = 1.0;    }}\n\nè®¿é—®ç‰¹æ€§  å¯¹äºè‡ªå®šä¹‰ç‰¹æ€§ï¼Œå¯ä»¥ç”¨ Type ä¸­çš„ IsDefined å’ŒGetCustomAttributesæ–¹æ³•æ¥è·å–ã€‚\n\nIsDefinedï¼špublic abstract bool IsDefined(Type attributeType, bool inherit)ï¼Œç”¨æ¥åŠ æµ‹æŸä¸ªç‰¹æ€§æ˜¯å¦åº”ç”¨åˆ°æŸä¸ªç±»ä¸Š\nGetCustomAttributesï¼špublic abstract object[] GetCustomAttributes(bool inherit)ï¼Œè°ƒç”¨å®ƒåï¼Œä¼šåˆ›å»ºä¸€ä¸ªä¸ç›®æ ‡ç›¸å…³è”çš„ç‰¹æ€§çš„å®ä¾‹\n\nç‰¹æ€§ä¸æ³¨é‡Šçš„åŒºåˆ«  æ³¨é‡Šæ˜¯å¯¹ç¨‹åºæºä»£ç çš„ä¸€ç§è¯´æ˜ï¼Œç¨‹åºç¼–è¯‘çš„æ—¶å€™ä¼šå¿½ç•¥å®ƒï¼Œè€Œç‰¹æ€§æ˜¯ä»£ç çš„ä¸€éƒ¨åˆ†ï¼Œå®ƒä¼šè¢«ç¼–è¯‘å™¨ç¼–è¯‘è¿›ç¨‹åºçš„å…ƒæ•°æ®é‡Œï¼Œåœ¨ç¨‹åºè¿è¡Œçš„æ—¶å€™ï¼Œéšæ—¶å¯ä»¥ä»å…ƒæ•°æ®ä¸­æå–å‡ºè¿™äº›é™„åŠ ä¿¡æ¯ã€‚\nActionå§”æ‰˜ä¸ Func å§”æ‰˜ Action ä¸èƒ½æŒ‡å‘æœ‰è¿”å›å€¼çš„æ–¹æ³•ï¼Œä¸èƒ½æœ‰è¿”å›å€¼ã€‚Funcå¯ä»¥æŒ‡å‘æœ‰ä¸€ä¸ªè¿”å›å€¼çš„æ–¹æ³•ï¼Œä¸”å¿…é¡»æœ‰è¿”å›å€¼ã€‚\nActivator.CreateInstance&lt;T&gt;ä¸ newnew å’ŒActivator.CreateInstanceéƒ½ç”¨äºå®ä¾‹åŒ–ä¸€ä¸ªç±»ï¼ŒActivator.CreateInstanceä½¿ç”¨ä¸æŒ‡å®šå‚æ•°åŒ¹é…ç¨‹åº¦æœ€é«˜çš„æ„é€ å‡½æ•°æ¥åˆ›å»ºæŒ‡å®šç±»å‹çš„å®ä¾‹ã€‚\npublic static T Factory&lt;T&gt;() where T : new(){    return new T();}\n\nç¼–è¯‘å™¨ä¼šå°† return new T() è½¬æ¢è°ƒç”¨ Actuvator.CreateInstance æ–¹æ³•ã€‚\nC# èµ„æºå›æ”¶å’Œ IDisposable æ¥å£çš„ä½¿ç”¨\næ‰˜ç®¡èµ„æºå’Œéæ‰˜ç®¡èµ„æº\n\næ‰˜ç®¡èµ„æºç”± CLR æ¥ç»´æŠ¤ï¼Œè‡ªåŠ¨è¿›è¡Œåƒåœ¾å›æ”¶ï¼Œæ¯”å¦‚æ•°ç»„\néæ‰˜ç®¡èµ„æºä¸ä¼šè¿›è¡Œè‡ªåŠ¨åƒåœ¾å›æ”¶ï¼Œéœ€è¦æ‰‹åŠ¨é‡Šæ”¾ï¼Œæ¯”å¦‚å¥æŸ„ã€‚ä½†åœ¨ c# ä¸­çš„éæ‰˜ç®¡èµ„æºå¾ˆå¤šéƒ½è¢«å°è£…åˆ° .NET ç±»ä¸­ï¼Œå½“å¯¹è±¡é‡Šæ”¾æ—¶å†…éƒ¨æ–¹æ³•åŒæ—¶é‡Šæ”¾éæ‰˜ç®¡èµ„æº\n\nåœ¨ C# ä¸­åˆ›å»ºçš„å¯¹è±¡ï¼Œæ•°ç»„ï¼Œåˆ—è¡¨ç­‰ç­‰éƒ½ä¸éœ€è¦è€ƒè™‘èµ„æºé‡Šæ”¾çš„é—®é¢˜ï¼Œå› ä¸ºå®ƒä¼šè¢« CLR çš„åƒåœ¾å›æ”¶æœºåˆ¶è‡ªåŠ¨å›æ”¶ã€‚åˆ›å»ºçš„å¯¹è±¡é‡Šæ”¾æ—¶æ˜¯éšæœºçš„ä¸ç¡®å®šæ—¶é•¿çš„ç­‰å¾…è‡ªåŠ¨å›æ”¶æœºåˆ¶è¿›è¡Œæ”¶å›ï¼Œæœ‰æ²¡æœ‰åŠæ³•ä¸»åŠ¨å›æ”¶è¿™äº›èµ„æºå‘¢ï¼Œæ¯”å¦‚å¯¹è±¡å ç”¨å†…å­˜è¾ƒå¤§ï¼Œæƒ³ä¸»åŠ¨ç«‹å³é‡Šæ”¾è€Œä¸ç­‰å¾…ä¸»åŠ¨å›æ”¶ã€‚å¯ä»¥å†™ä¸€ä¸ªæ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•é‡Œé‡Šæ”¾å¼•ç”¨çš„èµ„æºå°±å¯ä»¥äº†ï¼Œè¿™ä¸ªæ–¹æ³•å¯ä»¥éšä¾¿èµ·åï¼Œå½“ç„¶æ›´è§„èŒƒçš„æ˜¯ç»§æ‰¿ IDisposable æ¥å®ç° Disposable æ–¹æ³•ã€‚\n\n\nC# ä¸­æ•°ç»„ã€ArrayListå’Œ List ä¸‰è€…çš„åŒºåˆ«  æ•°ç»„  æ•°ç»„åœ¨ C# ä¸­æœ€æ—©å‡ºç°çš„ã€‚åœ¨å†…å­˜ä¸­æ˜¯è¿ç»­å­˜å‚¨çš„ï¼Œæ‰€ä»¥å®ƒçš„ç´¢å¼•é€Ÿåº¦éå¸¸å¿«ï¼Œè€Œä¸”èµ‹å€¼ä¸ä¿®æ”¹å…ƒç´ ä¹Ÿå¾ˆç®€å•ã€‚ä½†æ˜¯æ•°ç»„å­˜åœ¨ä¸€äº›ä¸è¶³çš„åœ°æ–¹ã€‚åœ¨æ•°ç»„çš„ä¸¤ä¸ªæ•°æ®é—´æ’å…¥æ•°æ®æ˜¯å¾ˆéº»çƒ¦çš„ï¼Œè€Œä¸”åœ¨å£°æ˜æ•°ç»„çš„æ—¶å€™å¿…é¡»æŒ‡å®šæ•°ç»„çš„é•¿åº¦ï¼Œæ•°ç»„çš„é•¿åº¦è¿‡é•¿ï¼Œä¼šé€ æˆå†…å­˜æµªè´¹ï¼Œè¿‡æ®µä¼šé€ æˆæ•°æ®æº¢å‡ºçš„é”™è¯¯ã€‚å¦‚æœåœ¨å£°æ˜æ•°ç»„æ—¶æˆ‘ä»¬ä¸æ¸…æ¥šæ•°ç»„çš„é•¿åº¦ï¼Œå°±ä¼šå˜å¾—å¾ˆéº»çƒ¦ã€‚\nArrayListArrayListæ˜¯å‘½åç©ºé—´ System.Collections ä¸‹çš„ä¸€éƒ¨åˆ†ï¼Œåœ¨ä½¿ç”¨è¯¥ç±»æ—¶å¿…é¡»è¿›è¡Œå¼•ç”¨ï¼ŒåŒæ—¶ç»§æ‰¿äº† IList æ¥å£ï¼Œæä¾›äº†æ•°æ®å­˜å‚¨å’Œæ£€ç´¢ã€‚ArrayListå¯¹è±¡çš„å¤§å°æ˜¯æŒ‰ç…§å…¶ä¸­å­˜å‚¨çš„æ•°æ®æ¥åŠ¨æ€æ‰©å……ä¸æ”¶ç¼©çš„ã€‚æ‰€ä»¥ï¼Œåœ¨å£°æ˜ ArrayList å¯¹è±¡æ—¶å¹¶ä¸éœ€è¦æŒ‡å®šå®ƒçš„é•¿åº¦ã€‚\n//ArrayListArrayList list1 = new ArrayList(); // æ–°å¢æ•°æ®list1.Add(\"cde\");list1.Add(5678);// ä¿®æ”¹æ•°æ®list[2] = 34;// ç§»é™¤æ•°æ®list.RemoveAt(0);// æ’å…¥æ•°æ®list.Insert(0, \"qwe\");\n\nåœ¨ ArrayList ä¸­ï¼Œä¸ä»…æ’å…¥äº†å­—ç¬¦ä¸²ï¼Œè€Œä¸”æ’å…¥äº†æ•°å­—ã€‚è¿™æ ·åœ¨ ArrayList ä¸­æ’å…¥ä¸åŒç±»å‹çš„æ•°æ®æ˜¯å…è®¸çš„ã€‚å› ä¸º ArrayList ä¼šæŠŠæ‰€æœ‰æ’å…¥å…¶ä¸­çš„æ•°æ®å½“ä½œä¸º object ç±»å‹æ¥å¤„ç†ï¼Œåœ¨ä½¿ç”¨ ArrayList å¤„ç†æ•°æ®æ—¶ï¼Œå¾ˆå¯èƒ½ä¼šæŠ¥ç±»å‹ä¸åŒ¹é…çš„é”™è¯¯ï¼Œä¹Ÿå°±æ˜¯ ArrayList ä¸æ˜¯ç±»å‹å®‰å…¨çš„ ã€‚åœ¨å­˜å‚¨æˆ–æ£€ç´¢å€¼ç±»å‹æ—¶é€šå¸¸å‘ç”Ÿ è£…ç®±  å’Œæ‹†ç®±  æ“ä½œï¼Œå¸¦æ¥å¾ˆå¤§çš„æ€§èƒ½è€—æŸã€‚\næ³›å‹ List å› ä¸º ArrayList å­˜åœ¨ä¸å®‰å…¨ç±»å‹ä¸è£…ç®±æ‹†ç®±çš„ç¼ºç‚¹ï¼Œæ‰€ä»¥å‡ºç°äº†æ³›å‹çš„æ¦‚å¿µã€‚Listç±»æ˜¯ ArrayList ç±»çš„æ³›å‹ç­‰æ•ˆç±»ï¼Œå®ƒçš„å¤§éƒ¨åˆ†ç”¨æ³•éƒ½ä¸ ArrayList ç›¸ä¼¼ï¼Œå› ä¸º List ç±»ä¹Ÿç»§æ‰¿äº† IList æ¥å£ã€‚æœ€å…³é”®çš„åŒºåˆ«åœ¨äºï¼Œåœ¨å£°æ˜ List é›†åˆæ—¶ï¼ŒåŒæ—¶éœ€è¦ä¸ºå…¶å£°æ˜ List é›†åˆå†…æ•°æ®çš„å¯¹è±¡ç±»å‹ã€‚\nLambda è¡¨è¾¾å¼  ä½¿ç”¨ Lambda è¡¨è¾¾å¼æ¥åˆ›å»ºåŒ¿åå‡½æ•°ã€‚ ä½¿ç”¨ lambda å£°æ˜è¿ç®—ç¬¦=&gt; ä»å…¶ä¸»ä½“ä¸­åˆ†ç¦» lambda å‚æ•°åˆ—è¡¨ã€‚Lambda è¡¨è¾¾å¼å¯é‡‡ç”¨ä»¥ä¸‹ä»»æ„ä¸€ç§å½¢å¼ï¼š\n\nè¡¨è¾¾å¼ lambdaï¼Œè¡¨è¾¾å¼ä¸ºå…¶ä¸»ä½“ï¼š\n(input-parameters) =&gt; expression\nè¯­å¥ lambdaï¼Œè¯­å¥å—ä½œä¸ºå…¶ä¸»ä½“ï¼š\n(input-parameters) =&gt; {&lt;sequence-of-statements&gt;}\n\nè‹¥è¦åˆ›å»º Lambda è¡¨è¾¾å¼ï¼Œéœ€è¦åœ¨ Lambda è¿ç®—ç¬¦å·¦ä¾§æŒ‡å®šè¾“å…¥å‚æ•°ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œç„¶ååœ¨å¦ä¸€ä¾§è¾“å…¥è¡¨è¾¾å¼æˆ–è¯­å¥å—ã€‚\nC# API\n\n\nsyntax\ninterpretation\n\n\n\nIsGenericType \nåˆ¤æ–­å±æ€§ç±»å‹æ˜¯å¦ä¸ºæ³›å‹ç±»å‹ï¼Œå¦‚ï¼štypeof(int).IsGenericType --&gt; Falsetypeof(List&lt;int&gt;).IsGenericType --&gt; Truetypeof(Dictionary&lt;int&gt;).IsGenericType --&gt; True\n\n\nC++ ç›¸å…³C++ å‡ ä¸ªé¢„å®šä¹‰çš„å®\n__LINE__ï¼šæºä»£ç è¡Œå·\n__FILE__ï¼šæºæ–‡ä»¶å\n__DATEï¼šç¼–è¯‘æ—¥æœŸ\n__TIME__ï¼šç¼–è¯‘æ—¶é—´\n__STDCï¼šå½“è¦æ±‚ç¨‹åºä¸¥æ ¼éµå¾ª ANSI C æ ‡å‡†æ—¶è¯¥æ ‡è¯†è¢«èµ‹å€¼ä¸º 1\n__cplusplusï¼šå½“ç¼–å†™ C++ ç¨‹åºæ—¶è¯¥è¡¨ç¤ºè¢«å®šä¹‰\n\nLua ç›¸å…³Lua è¯­æ³•\nå®šä¹‰å­—ç¬¦ä¸²\na= \"åŒå¼•å·ä¸­å¯ç›´æ¥ä½¿ç”¨' å•å¼•å· ', ä½† \\\" åŒå¼•å· \\\"è¦è½¬ä¹‰\"b = 'å•å¼•å·ä¸­å¯ç›´æ¥ä½¿ç”¨\" åŒå¼•å· \", ä½† \\' å•å¼•å· \\'è¦è½¬ä¹‰'c = [[åŒæ–¹æ‹¬å·ä¸­  å¯ä»¥ç›´æ¥ä½¿ç”¨ 'å•å¼•å·'å’Œ \"åŒå¼•å·\"ï¼Œè€Œä¸”å¯ä»¥  æ¢è¡Œ]]\næ ¼å¼å­—ç¬¦ä¸²å¯èƒ½åŒ…å«ä»¥ä¸‹çš„è½¬ä¹‰ç \n%c - æ¥å—ä¸€ä¸ªæ•°å­—ï¼Œå¹¶å°†å…¶è½¬åŒ–ä¸º ASCII ç è¡¨ä¸­å¯¹åº”çš„å­—ç¬¦ %dï¼Œ%i - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºæœ‰ç¬¦å·çš„æ•´æ•°æ ¼å¼%o - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºå…«è¿›åˆ¶æ•°æ ¼å¼%u - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºæ— ç¬¦å·æ•´æ•°æ ¼å¼%x - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºåå…­è¿›åˆ¶æ•°æ ¼å¼ï¼Œä½¿ç”¨å°å†™å­—æ¯%X - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºåå…­è¿›åˆ¶æ•°æ ¼å¼ï¼Œä½¿ç”¨å¤§å†™å­—æ¯%e - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºç§‘å­¦è®°æ•°æ³•æ ¼å¼ï¼Œä½¿ç”¨å°å†™å­—æ¯ e%E - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºç§‘å­¦è®°æ•°æ³•æ ¼å¼ï¼Œä½¿ç”¨å¤§å†™å­—æ¯ E%f - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸ºæµ®ç‚¹æ•°æ ¼å¼%g/%G - æ¥å—ä¸€ä¸ªæ•°å­—å¹¶å°†å…¶è½¬åŒ–ä¸º%eï¼ˆ%E, å¯¹åº”%Gï¼‰åŠ%f ä¸­è¾ƒçŸ­çš„ä¸€ç§æ ¼å¼%q - æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å¹¶å°†å…¶è½¬åŒ–ä¸ºå¯å®‰å…¨è¢« Lua ç¼–è¯‘å™¨è¯»å…¥çš„æ ¼å¼ï¼ˆå³å°†è¯¥å­—ç¬¦ä¸²æ·»åŠ äº† ï¼‰%s - æ¥å—ä¸€ä¸ªå­—ç¬¦ä¸²å¹¶æŒ‰ç…§ç»™å®šçš„å‚æ•°æ ¼å¼åŒ–è¯¥å­—ç¬¦ä¸²\n\n\nLua å †æ ˆæ“ä½œ lua å’Œ C++ ä¹‹é—´çš„æ•°æ®äº¤äº’é€šè¿‡æ ˆè¿›è¡Œï¼Œæ ˆä¸­çš„æ•°æ®é€šè¿‡ç´¢å¼•å€¼è¿›è¡Œå®šä½ï¼ˆè‹¥ lua è™šæ‹Ÿæœºå †æ ˆé‡Œæœ‰ ä¸ªå…ƒç´ ï¼Œåˆ™å¯ä»¥ç”¨  ä»æˆ˜åœ°å‘ä¸Šç´¢å¼•ï¼Œä¹Ÿå¯ä»¥ç”¨  å‘ä¸‹ç´¢å¼•ï¼‰ï¼Œæ­£æ•°è¡¨ç¤ºç›¸å¯¹äºæ ˆåº•çš„ä½ç½®åç§»ï¼Œè´Ÿæ•°è¡¨ç¤ºç›¸å¯¹äºæ ˆé¡¶çš„ä½ç½®åç§»ã€‚\n\nlua_gettopï¼šint lua_gettop (lua_State *L);è¿”å›æ ˆé¡¶å…ƒç´ çš„ç´¢å¼•\nlua_settopï¼švoid lua_settop (lua_State *L, int index);å‚æ•°å…è®¸ä¼ å…¥ä»»ä½•å¯æ¥å—çš„ç´¢å¼•ä»¥åŠ 0 ã€‚å®ƒå°†æŠŠå †æ ˆçš„æ ˆé¡¶è®¾ä¸ºè¿™ä¸ªç´¢å¼•ã€‚å¦‚æœæ–°çš„æ ˆé¡¶æ¯”åŸæ¥çš„å¤§ï¼Œè¶…å‡ºéƒ¨åˆ†çš„æ–°å…ƒç´ å°†è¢«å¡«ä¸º nilã€‚å¦‚æœindex ä¸º 0ï¼ŒæŠŠæ ˆä¸Šæ‰€æœ‰å…ƒç´ ç§»é™¤\n\nLua ä¸­çš„æ¨¡å¼åŒ¹é…ï¼ˆPattern Matchingï¼‰character classes\n\n\nç¬¦å·\nåŒ¹é…æ¨¡å¼\n\n\n\n%a\n\n\n\n%c\n\n\n\n%d\n\n\n\n%l\n\n\n\n%p\n\n\n\n%s\nç©ºç™½å­—ç¬¦\n\n\n\n\n\n\nmagic characters\n\n\nç¬¦å·\næè¿°\nå¤‡æ³¨\n\n\n\n()\næ ‡è®°ä¸€ä¸ªå­æ¨¡å¼ï¼Œä¾›åç»­ä½¿ç”¨ï¼Œè·Ÿæ­£åˆ™çš„ç”¨æ³•ç±»ä¼¼\n\n\n\n.\nåŒ¹é…æ‰€æœ‰å­—ç¬¦\nç±»ä¼¼æ­£åˆ™è¡¨è¾¾å¼ï¼Œåªä¸è¿‡æ­£åˆ™è¡¨è¾¾å¼çš„ï¼Œä¸åŒ…æ‹¬å›è½¦\\n\n\n\n%\n1. å¯ç”¨ä½œè½¬ä¹‰ç¬¦ï¼›2. å£°æ˜ character classess;3. è·Ÿ() ç»“åˆç”¨äºå­æ¨¡å¼åŒ¹é…ï¼š%Nï¼ŒNæ˜¯ä¸€ä¸ªæ•°å­—ï¼Œè¡¨ç¤ºåŒ¹é…ç¬¬ N ä¸ªå­ä¸²ï¼Œä¾‹å¦‚ %1,%2, ...ï¼Œè·Ÿæ­£åˆ™è¡¨è¾¾å¼çš„1ï¼Œ2, ... ç±»ä¼¼\n\n\n\n^\nå¦‚æœå¤„äºæ¨¡å¼å¼€å¤´ï¼Œåˆ™è¡¨ç¤ºåŒ¹é…è¾“å…¥å­—ç¬¦ä¸²çš„å¼€å§‹ä½ç½®ï¼Œå¦‚æœæ”¾åœ¨ [] ä¸­ï¼Œè¡¨ç¤ºå–è¡¥é›†\n\n\n\n$\nè¡¨ç¤ºåŒ¹é…è¾“å…¥å­—ç¬¦ä¸²çš„ç»“å°¾ä½ç½®ï¼Œè·Ÿæ­£åˆ™è¡¨è¾¾å¼çš„ç”¨æ³•åŸºæœ¬ä¸€è‡´\n\n\n\n[]\nè¡¨ç¤ºä¸€ä¸ªå­—ç¬¦é›†åˆ\nä¾‹å¦‚ [%w_] è¡¨ç¤ºåŒ¹é…å­—æ¯æ•°å­—å’Œä¸‹åˆ’çº¿ï¼Œ[a-f]è¡¨ç¤ºåŒ¹é…å­—æ¯ a åˆ°f\n\n\n+\n\n\n\n\n-\nåŒ¹é…å‰é¢çš„æ¨¡å¼ 0 æ¬¡æˆ–å¤šæ¬¡ï¼Œè¿”å›æœ€çŸ­çš„åŒ¹é…ç»“æœï¼Œæ¨¡å¼åŒ¹é…ä¸­çš„â€œéè´ªå©ªæ¨¡å¼â€\n\n\n\n*\nåŒ¹é…å‰é¢çš„æ¨¡å¼ 0 æ¬¡æˆ–å¤šæ¬¡\n\n\n\nfunction or expression needs too many registers\nLua ä¸­çš„æ¨¡å—ä¸ module å‡½æ•°  ç¼–å†™æ¨¡å—çš„åŸºæœ¬æ–¹æ³•-- test.lualocal M = {}local modelName = ..._G[modelName] = Mfunction M.play()    print('play')endfunction M.quit()    print('quit')endreturn M\n\næ¨¡å—å†…å‡½æ•°ä¹‹é—´çš„è°ƒç”¨ä»ç„¶è¦ä¿ç•™æ¨¡å—åçš„é™å®šç¬¦ï¼Œå¦‚æœæ˜¯  ç§æœ‰å˜é‡è¿˜éœ€è¦åŠ  local å…³é”®å­— ï¼Œ åŒæ—¶ä¸èƒ½åŠ æ¨¡å—åé™å®šç¬¦ã€‚å¯ä»¥æŠŠ test.lua è¿™ä¸ªæ¨¡å—é‡Œçš„å…¨å±€ç¯å¢ƒè®¾ç½®ä¸º Mï¼Œäºæ˜¯ï¼Œæˆ‘ä»¬ç›´æ¥å®šä¹‰å‡½æ•°çš„æ—¶å€™ï¼Œä¸éœ€è¦å†å¸¦M å‰ç¼€ã€‚å³ï¼š\n-- test.lualocal M = {}local modelName = ..._G[modelName] = Mpackage.loaded[modname] = Msetfenv(1, M)function play()    print('play')endfunction quit()    print('quit')endreturn M\n\nmoduleå‡½æ•°  åœ¨ Lua 5.1 ä¸­ï¼Œå¯ä»¥ç”¨module(...) å‡½æ•°æ¥ä»£æ›¿ï¼Œå¦‚ï¼š\nmodule(..., package.seeall)function play()    print('play')endfunction M.quit()    print('quit')end\n\nç”±äºåœ¨é»˜è®¤æƒ…å†µä¸‹ï¼Œmoduleä¸æä¾›å¤–éƒ¨è®¿é—®ï¼Œå¿…é¡»åœ¨è°ƒç”¨å®ƒä¹‹å‰ï¼Œä¸ºéœ€è¦è®¿é—®çš„å¤–éƒ¨å‡½æ•°æˆ–æ¨¡å—å£°æ˜é€‚å½“çš„å±€éƒ¨å˜é‡ã€‚ç„¶å Lua æä¾›äº†ä¸€ç§æ›´ä¸ºæ–¹ä¾¿çš„å®ç°æ–¹å¼ï¼Œå³åœ¨è°ƒç”¨ module å‡½æ•°æ—¶ï¼Œå¤šä¼ å…¥ä¸€ä¸ª package.seeall çš„å‚æ•°ï¼Œç›¸å½“äºsetmetatable(M, {__index = _G})\næŠµåˆ¶ä½¿ç”¨ module å‡½æ•°æ¥å®šä¹‰ Lua æ¨¡å—  æ—§å¼çš„æ¨¡å—å®šä¹‰æ–¹å¼æ˜¯é€šè¿‡ *module(\"filename\"[,package.seeall])*æ¥æ˜¾ç¤ºå£°æ˜ä¸€ä¸ªåŒ…ï¼Œç°åœ¨å®˜æ–¹ä¸æ¨èå†ä½¿ç”¨è¿™ç§æ–¹å¼ã€‚è¿™ç§æ–¹å¼å°†ä¼šè¿”å›ä¸€ä¸ªç”± filename æ¨¡å—å‡½æ•°ç»„æˆçš„ tableï¼Œå¹¶ä¸”è¿˜ä¼šå®šä¹‰ä¸€ä¸ªåŒ…å«è¯¥table çš„å…¨å±€å˜é‡ã€‚\nå¦‚æœåªç»™ module å‡½æ•°ä¸€ä¸ªå‚æ•°ï¼ˆä¹Ÿå°±æ˜¯æ–‡ä»¶åï¼‰çš„è¯ï¼Œå‰é¢å®šä¹‰çš„å…¨å±€å˜é‡å°±éƒ½ä¸å¯ç”¨äº†ï¼ŒåŒ…æ‹¬ print å‡½æ•°ç­‰ï¼Œå¦‚æœè¦è®©ä¹‹å‰çš„å…¨å±€å˜é‡å¯è§ï¼Œå¿…é¡»åœ¨å®šä¹‰ module çš„æ—¶å€™åŠ ä¸Šå‚æ•° package.seeallã€‚è°ƒç”¨å®Œmodule å‡½æ•°ä¹‹åï¼Œ printè¿™äº›ç³»ç»Ÿå‡½æ•°ä¸å¯ä½¿ç”¨çš„åŸå› ï¼Œæ˜¯å½“å‰çš„æ•´ä¸ªç¯å¢ƒè¢«å‹å…¥æ ˆï¼Œä¸å†å¯è¾¾ã€‚\nmodule(\"filename\", package.seeall)è¿™ç§å†™æ³•ä»ç„¶æ˜¯ä¸æå€¡çš„ï¼Œå®˜æ–¹ç»™å‡ºäº†ä¸¤ç‚¹åŸå› ï¼š\n\npackage.seeallè¿™ç§æ–¹å¼ç ´åäº†æ¨¡å—çš„é«˜å†…èšï¼ŒåŸæœ¬å¼•å…¥ filename æ¨¡å—åªæƒ³è°ƒç”¨å®ƒçš„ foobar() å‡½æ•°ï¼Œä½†æ˜¯å®ƒå´å¯ä»¥è¯»å†™å…¨å±€å±æ€§ï¼Œä¾‹å¦‚filename.osã€‚\nmoduleå‡½æ•°å‹æ ˆæ“ä½œå¼•å‘çš„å‰¯ä½œç”¨ï¼Œæ±¡æŸ“äº†å…¨å±€ç¯å¢ƒå˜é‡ã€‚ä¾‹å¦‚ module(\"filename\") ä¼šåˆ›å»ºä¸€ä¸ª filename çš„tableï¼Œå¹¶å°†è¿™ä¸ª table æ³¨å…¥å…¨å±€ç¯å¢ƒå˜é‡ä¸­ï¼Œè¿™æ ·ä½¿å¾—æ²¡æœ‰å¼•ç”¨å®ƒçš„æ–‡ä»¶ä¹Ÿèƒ½è°ƒç”¨ filename æ¨¡å—çš„æ–¹æ³•ã€‚\n\næ¯”è¾ƒæ¨èçš„æ¨¡å—å®šä¹‰æ–¹æ³•-- square.lua é•¿æ–¹å½¢æ¨¡å—local _M = {}           -- å±€éƒ¨çš„å˜é‡_M._VERSION = '1.0'     -- æ¨¡å—ç‰ˆæœ¬local mt = {__index = _M }function _M.new(self, width, height)    return setmetatable({width=width, height=height}, mt)endfunction _M.get_square(self)    return self.width * self.heightendfunction _M.get_circumference(self)    return (self.width + self.height) * 2endreturn _M\n\nå¼•ç”¨ç¤ºä¾‹ä»£ç local square = require \"square\" local s1 = square:new(1, 2)print(s1:get_square())          --output: 2print(s1:get_circumference())   --output: 6\n\nPython ç›¸å…³  ç”Ÿæˆ requirements.txt æ–‡ä»¶  æ–¹æ³•ä¸€pip freeze &gt; requirements.txt\n\npip freezeå‘½ä»¤è¾“å‡ºçš„æ ¼å¼å’Œ requirements.txt æ–‡ä»¶å†…å®¹æ ¼å¼å®Œå…¨ä¸€æ ·ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥å°† pip freeze çš„å†…å®¹è¾“å‡ºåˆ°æ–‡ä»¶ requirements.txt ä¸­ã€‚åœ¨å…¶ä»–æœºå™¨ä¸Šå¯ä»¥æ ¹æ®å¯¼å‡ºçš„ requirements.txt è¿›è¡ŒåŒ…å®‰è£…ã€‚\næ–¹æ³•äºŒpipreqs . --encoding=utf8 --force\n\nç”ŸæˆæŒ‡å®šç›®å½•ä¸‹çš„ä¾èµ–ç±»åº“\n","categories":["æ—¥å¸¸"],"tags":["git","unity","c#","c++"]},{"title":"tolua åŸç†è§£æ","url":"/2022/01/12/31/","content":"\n    \n\n\n\nlua è™šæ‹Ÿæ ˆlua ä»£ç -- file name: test.luafunction func()    return 1, 2, 3, 4end\n\nC++ ä»£ç #include &lt;iostream&gt;  #include &quot;lua.hpp&quot;   int _tmain(int argc, _TCHAR* argv[])&#123;\t//â‘ æ–°å»ºè™šæ‹Ÿæœº  \tlua_State *L = luaL_newstate();\t//â‘¡è½½å…¥åº“  \tluaL_openlibs(L); \t//â‘¢è¿™é‡Œæ‰§è¡Œ test.lua  Lua æ–‡ä»¶  \tluaL_dofile(L, &quot;test.lua&quot;);\t//â‘£é‡æ–°è®¾ç½®æ ˆåº•\tlua_settop(L, 0); \t//â‘¤è·å– è¿”å›ç»“æœ  \tlua_getglobal(L, &quot;func&quot;); \t//â‘¥æ“ä½œæ ˆè°ƒå›ç»“æœ\tlua_pcall(L, 0, 4, 0);\tprintf(&quot;%s\\n&quot;, lua_tostring(L, 1));\tprintf(&quot;%s\\n&quot;, lua_tostring(L, 2));\tprintf(&quot;%s\\n&quot;, lua_tostring(L, 3));\tprintf(&quot;%s\\n&quot;, lua_tostring(L, 4)); \t//â‘¦å…³é—­è™šæ‹Ÿæœº  \tlua_close(L); \tsystem(&quot;pause&quot;);\treturn 0;&#125;\n\n\nâ‘£ è¿™ä¸ªè¿‡ç¨‹ï¼Œæ˜¯ä¸ºäº†ç¡®è®¤æ ˆåº•æ˜¯ç©ºçš„ï¼Œä»¥ä¾¿åé¢çš„æ“ä½œæ˜¯æŒ‰ç…§é¡ºåºå…¥æ ˆçš„ä¸”ä» 1 å·æ ˆä½å¼€å§‹\n\nâ‘¥æ“ä½œæ ˆè°ƒå›ç»“æœ\n\n C++ å‘Šè¯‰ lua è™šæ‹Ÿæœºï¼Œå‡½æ•°ä»¥è¾“å…¥æ ˆï¼Œå‡½æ•°ä¼ å…¥ 0 ä¸ªå‚æ•°ï¼Œä¼šè¿”å› 4 ä¸ªå‡½æ•°ï¼Œ ä¸éœ€è¦é”™è¯¯ä¿¡æ¯ ã€‚åˆ†åˆ«  å¯¹åº”ä¸Šé¢å››ä¸ªå‚æ•°ã€‚ æ ˆä¸­ä¸€ä¸ªå…ƒç´ ï¼šfunc\nC++ è¯·æ±‚å®Œæ¯•ï¼Œlua è™šæ‹Ÿæœº  å¼€å§‹è®¿é—®æ ˆï¼Œä»æ ˆä¸­å–å‡º funcã€‚ æ ˆä¸­æ— å…ƒç´ \nlua è™šæ‹Ÿæœº  å¾—åˆ° `func` ä¿¡æ¯é€ç»™lua ç¨‹åºã€‚** æ ˆä¸­æ— å…ƒç´  **\nlua ç¨‹åºåœ¨è°ƒç”¨çš„ lua æ–‡ä»¶å…¨å±€è¡¨ ä¸­æŸ¥æ‰¾ funcï¼Œå¹¶è¿è¡Œè¿”å›ç»“æœ1,2,3,4ã€‚ æ ˆä¸­æ— å…ƒç´ \n lua ç¨‹åºå¾—åˆ°è¿”å›ç»“æœ 1,2,3,4 å°†ç»“æœå†å‹å…¥æ ˆï¼›1å…ˆå…¥æ ˆåº•ï¼Œ2å†å…¥æ ˆï¼Œä»¥æ­¤ç±»æ¨ã€‚æ ˆä¸­å››ä¸ªå…ƒç´ ï¼š1,2,3,4ï¼Œé¡ºåºä¸ºæ ˆåº• -&gt; æ ˆé¡¶\næœ€åï¼ŒC++ å†å»æ ˆä¸­è¯»å–æ•°æ®ï¼›è¿™é‡Œ lua_tostring(L, 1) æ˜¯è¯»å–å‡½æ•°ï¼Œä¸ä¼šæ”¹å˜æ ˆå†…çš„ç»“æœçš„ï¼Œæ‰€ä»¥å½“åœ°â‘¥æ­¥æ‰§è¡Œå®Œï¼Œæ ˆä¸­è¿˜æ˜¯å››ä¸ªå…ƒç´ ï¼š1,2,3,4\n\n\nè‹¥ä½¿ç”¨lua_pop(L, 1) å»æ“ä½œçš„è¯ï¼Œå¯ä»¥å¼¹å‡ºæŒ‡å®šçš„ä½ç½®çš„æ ˆå†…å®¹\n\n\n\nlua çƒ­æ›´æ–°åŸç†  ä½¿ç”¨ assetbundle è¿›è¡Œèµ„æºçš„æ›´æ–°ï¼Œè€Œç”±äº lua è¿è¡Œæ—¶æ‰ç¼–è¯‘çš„ç‰¹æ€§ï¼Œæ‰€ä»¥ lua æ–‡ä»¶ä¹Ÿå¯ä»¥è¢«çœ‹æˆæ˜¯ä¸€ç§èµ„æºæ–‡ä»¶ï¼ˆä¸ fbxã€Image ç­‰ä¸€æ ·ï¼‰å¯ä»¥æ‰“è¿› ab åŒ…ä¸­\nC# è°ƒç”¨ lua\nä½¿ç”¨ Tolua çš„ç›¸å…³ç±»å’Œæ–¹æ³•éƒ½éœ€è¦è°ƒç”¨å‘½åç©ºé—´ LuaInterface\n\nè°ƒç”¨ lua è„šæœ¬å¿…é¡»å…ˆåˆ›å»ºä¸€ä¸ª lua è™šæ‹Ÿæœº\nLuaState lua = new LuaState();\nåœ¨ C# ä¸­è¿è¡Œä¸€æ®µ lua è„šæœ¬æœ€ç®€å•çš„æ–¹æ³•å°±æ˜¯ lua.DoString\npublic object[] DoString(string chunk, string chunkName = &quot;LuaState.DoString&quot;)\nä½¿ç”¨å®Œ lua è™šæ‹Ÿæœºä¹‹åè®°è¦é”€æ¯\n\nå…ˆè¿›è¡Œ lua è™šæ‹Ÿæœºçš„åˆ¤ç©ºlua.CheckTop\n\n\n\nlua è°ƒç”¨ C#åå°„ C# ä¸­çš„åå°„ä½¿ç”¨Assembly å®šä¹‰å’ŒåŠ è½½ç¨‹åºé›†ï¼ŒåŠ è½½åœ¨ç¨‹åºé›†æ¸…å•ä¸­åˆ—å‡ºæ¨¡å—ï¼Œä»¥åŠä»æ­¤ç¨‹åºé›†ä¸­æŸ¥æ‰¾ç±»å‹å¹¶åˆ›å»ºè¯¥ç±»å‹çš„å®ä¾‹\nåå°„ç”¨åˆ°çš„å‘½åç©ºé—´System.ReflectionSystem.TypeSystem.Reflection.Assembly\n\nåå°„ç”¨åˆ°çš„ä¸»è¦ç±»\nSystem.Typeç±»ï¼é€šè¿‡è¿™ä¸ªç±»å¯ä»¥è®¿é—®ä»»ä½•ç»™å®šæ•°æ®ç±»å‹çš„ä¿¡æ¯\nSystem.Reflection.Assemblyç±»ï¼å®ƒå¯ä»¥ç”¨äºè®¿é—®ç»™å®šç¨‹åºé›†çš„ä¿¡æ¯ï¼Œæˆ–è€…æŠŠè¿™ä¸ªç¨‹åºé›†åŠ è½½åˆ°ç¨‹åºä¸­\n\nå»åå°„  æŠŠæ‰€æœ‰çš„ c# ç±»çš„ public æˆå‘˜å˜é‡ã€æˆå‘˜å‡½æ•°ï¼Œéƒ½å¯¼å‡ºåˆ°ä¸€ä¸ªç›¸å¯¹åº”çš„ Wrap ç±»ä¸­ï¼Œè€Œè¿™äº›æˆå‘˜å‡½æ•°é€šè¿‡ç‰¹æ®Šçš„æ ‡è®°ï¼Œæ˜ å°„åˆ° lua çš„è™šæ‹Ÿæœºä¸­ï¼Œå½“åœ¨ lua ä¸­è°ƒç”¨ç›¸å¯¹åº”çš„å‡½æ•°æ—¶å€™ï¼Œç›´æ¥è°ƒç”¨æ˜ å°„è¿›å»çš„ wrap å‡½æ•°ï¼Œç„¶åå†è°ƒç”¨åˆ°å®é™…çš„ c# ç±»ï¼Œå®Œæˆè°ƒç”¨è¿‡ç¨‹\nWrapåœ¨ tolua ç”Ÿæˆçš„ Wrap æ–‡ä»¶ä¸­ï¼Œç»å¸¸é‡è§å¦‚æ­¤å†™æ³•\n// XXXWrap.csL.BeginStaticLibs(&quot;XXX&quot;);L.RegFunction(&quot;Log&quot;, Log);L.EndStaticLibs();\n\nBeginStaticLibsé¦–å…ˆ BeginStaticLibs æœ€ç»ˆä¼šèµ°åˆ°è¿™æ¡è¯­å¥ä¸Šæ¥ï¼šLuaDLL.tolua_beginstaticclass(L, name);è¿™è¯­å¥ä¼šæ‰§è¡Œ tolua.dll çš„ C è¯­è¨€å¯¹åº”æ–¹æ³•ï¼Œtolua_beginstaticclassï¼Œè¯¥æ–¹æ³•æœ€ç»ˆä¼šåœ¨ lua_State æ ˆé¡¶ç”Ÿæˆä¸€ä¸ªåä¸º name çš„table\n/* tolua.c */LUALIB_API void tolua_beginstaticclass(lua_State *L, const char *name)&#123;        lua_pushstring(L, name);  /* å°† name å‹å…¥æ ˆä¸­ï¼Œå³ XXX */    lua_newtable(L);/* åˆ›å»ºä¸€ä¸ª table å‹å…¥æ ˆä¸­ */    _addtoloaded(L);    lua_pushvalue(L, -1);      /* è¿™é‡Œå°†æ ˆé¡¶è¡¨å¤åˆ¶äº†ä¸€ä»½å‹å…¥æ ˆä¸­ å³ top [XXX(table),XXX(emptytable)] bottom    */    /* ä»¥ä¸Šæ“ä½œç›¸å½“äºç”Ÿæˆäº†åä¸º name çš„ table :XXX = &#123;&#125;  */       /* ä»¥ä¸‹æ“ä½œæŠ½è±¡ç†è§£ */    /* XXX[&quot;userdata&quot;] = &amp;tag  */    lua_pushlightuserdata(L, &amp;tag);    lua_pushnumber(L, 1);    lua_rawset(L, -3);    /* XXX[&quot;.name&quot;] = XXX  */    lua_pushstring(L, &quot;.name&quot;);    _pushfullname(L, -4);    lua_rawset(L, -3);       /* XXX[&quot;__index&quot;] = static_index_event  */    lua_pushstring(L, &quot;__index&quot;);    lua_pushcfunction(L, static_index_event);    lua_rawset(L, -3);    /* XXX[&quot;__newindex&quot;] = static_newindex_event  */    lua_pushstring(L, &quot;__newindex&quot;);    lua_pushcfunction(L, static_newindex_event);    lua_rawset(L, -3);      &#125;\n\n\n    \n    æœ€ç»ˆä¼šåœ¨ lua_State æ ˆé¡¶ä¼šè¢«å‹å…¥ä¸€ä¸ªåä¸º XXX çš„ Table\n\n\nEndStaticLibsæ¥ç€å…ˆæŠŠå°¾ç»™æ”¶æ‰ï¼ŒEndStaticLibsæœ€åä¼šæ¥åˆ° tolua.c è¿™è¾¹çš„ tolua_endstaticclass æ–¹æ³•ï¼Œè¯¥æ–¹æ³•æœ€ç»ˆä¼šå°†æ ˆé¡¶å…ƒç´ å¼¹å‡ºå¹¶å°†å…¶è®¾ç½®ä¸º - 2 ä½ç½®çš„å…ƒè¡¨\n/* tolua.c */LUALIB_API void tolua_endstaticclass(lua_State *L)&#123;    lua_setmetatable(L, -2);    lua_rawset(L, -3);    &#125;\n\n\n    \n    å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå°†å…¶è®¾ç½®ä¸º XXX(Empty Table) çš„å…ƒè¡¨\n\n\nRegFunctionRegFunctionå…ˆæ˜¯å°†è¦æ³¨å†Œçš„æ–¹æ³•è½¬æ¢æˆäº†ä¾›å¹³å°ä½¿ç”¨çš„æŒ‡é’ˆï¼Œä¼ é€’åˆ° C ä¸­ç”Ÿæˆå¯ä»¥ä¾› lua ä½¿ç”¨çš„ LuaCSFunction å‡½æ•°\n// LuaState.cspublic void RegFunction(string name, LuaCSFunction func)&#123;    IntPtr fn = Marshal.GetFunctionPointerForDelegate(func);    LuaDLL.tolua_function(L, name, fn);            &#125;\n\ntolua.c æ–‡ä»¶ä¸­ tolua_function å¯¹ä¼ å…¥è¿›çš„å‡½æ•°è¿›è¡Œäº†ç»‘å®š\n/* tolua.c */LUALIB_API void tolua_function(lua_State *L, const char *name, lua_CFunction fn)&#123;    lua_pushstring(L, name);    tolua_pushcfunction(L, fn);    lua_rawset(L, -3); // èµ‹å€¼æ“ä½œï¼šå°†æ ˆé¡¶ä½œä¸º v:CClosureï¼Œå€’æ•°ç¬¬äºŒä½ä½œä¸º k:nameï¼Œ-3 ä½ç½®ä½œä¸º table è¿›è¡Œèµ‹å€¼ ï¼Œå³ XXX[name] = CClosure&#125;LUA_API int tolua_pushcfunction(lua_State *L, lua_CFunction fn)&#123;            lua_pushboolean(L, 0); // å‹å…¥å¸ƒå°”å€¼ false top [0(false),name,XXX(table)] bottom    lua_pushcfunction(L, fn); // å‹å…¥å‡½æ•°ï¼Œè¿™é‡Œä¼šä»¥ CClosure ç»“æ„ä½“çš„å½¢å¼è¢«å‹å…¥æ ˆ    lua_pushcclosure(L, tolua_closure, 2); // è¿™é‡Œä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„ CClosure ç»“æ„ï¼Œå¹¶å°†æ ˆé¡¶ 2 ä¸ªå…ƒç´ ï¼ˆä¸€ä¸ªå¸ƒå°”å€¼ä¸ä¸€ä¸ªå­˜æ”¾äº† fn çš„ Closure) å¼¹å‡ºå¹¶å‹å…¥ CClosure ç»“æ„ä½“ä¸­ï¼Œæœ€ç»ˆå°†æ–°çš„ CClosure å‹å…¥æ ˆä¸­    return 0;&#125;\n\n\nlua_rawset(L, -3); \n èµ‹å€¼æ“ä½œï¼šå°†æ ˆé¡¶ä½œä¸º  å€¼â€”â€”CClosureï¼Œå€’æ•°ç¬¬äºŒä½ä½œä¸º  é”®â€”â€”nameï¼Œ-3 ä½ç½®ä½œä¸º table è¿›è¡Œèµ‹å€¼ ï¼Œå³XXX[name] = CClosure\n\n\n    \n\n\nå®é™…ä¸Šä¸€ä¸ª C# æ–¹æ³•çš„æŒ‡é’ˆå…¶å®è¢«å°è£…äº†ä¸¤å±‚ï¼š\n\nlua_pushcfunction(L, fn)æ—¶ å°† fn å°è£…è¿›äº† CClosure ä¸­\nlua_pushcclosure(L, tolua_closure, 2)æ—¶å°†å°è£…äº† fn çš„CClosureå†ä¸€æ¬¡å°è£…è¿›äº†æ–°çš„ CClosure ä¸­\n\nå½“åœ¨ lua ä¸­è°ƒç”¨æ³¨å†Œçš„æ–¹æ³•æ—¶ï¼Œå®é™…ä¸Šæ˜¯åœ¨è°ƒç”¨æœ€å¤–å±‚çš„ CClosure ç»“æ„ä½“ï¼Œå®ƒå…¶ä¸­çš„æ–¹æ³•æ˜¯ tolua_closureï¼Œè€Œ C# æ–¹æ³•æŒ‡é’ˆfn ä½œä¸ºè¯¥ç»“æ„ä½“æ ˆä¸­çš„å€¼è¢«å­˜æ”¾ç€upvalue\nstatic int tolua_closure(lua_State *L)&#123;    /*  è·å–åˆ°æ‰€æ³¨å†Œçš„ C# æ–¹æ³•æŒ‡é’ˆ */    lua_CFunction fn = (lua_CFunction)lua_tocfunction(L, lua_upvalueindex(2));    /*  è¿è¡Œ ï¼Œå› ä¸º lua è·¨è¯­è¨€çš„æ•°æ®äº¤äº’éƒ½å€ŸåŠ©æ ˆæ¥å®Œæˆï¼Œæ‰€ä»¥è¿è¡Œç»“æœéƒ½æ˜¯é€šè¿‡è·å–æ ˆä¸­å…ƒç´ æ¥è·å¾— */    int r = fn(L);           if (lua_toboolean(L, lua_upvalueindex(1)))    &#123;        lua_pushboolean(L, 0);        lua_replace(L, lua_upvalueindex(1));        return lua_error(L);    &#125;       return r;&#125;\n\n\nlua_pushfunctionï¼šå®é™…ä¸Šå‹å…¥å‡½æ•°çš„è¿‡ç¨‹å°±æ˜¯å½¢æˆé—­åŒ…çš„è¿‡ç¨‹ï¼Œåœ¨ lua ä¸­å‡½æ•°æ˜¯ä»¥é—­åŒ…çš„å½¢å¼è¢«ä¿å­˜çš„\n/* lua.h */#define lua_pushcfunction(L,f)  lua_pushcclosure(L, (f), 0) /* å® å‹å…¥é—­åŒ…æ–¹æ³• n ä¸º 0 */\nlua_pushclosureï¼šç”Ÿæˆé—­åŒ…ï¼Œå°†å‡½æ•°å­˜æ”¾åœ¨é—­åŒ…ç»“æ„ä½“ä¸­ï¼Œå¹¶å°†æ ˆé¡¶ n ä¸ªå…ƒç´ ä¸€åŒå‹å…¥é—­åŒ…å†…çš„æ ˆ\ntypedef struct CClosure &#123;  ClosureHeader;  lua_CFunction f;  TValue upvalue[1];  /* list of upvalues */&#125; CClosure;/* lua.h */LUA_API void  (lua_pushcclosure) (lua_State *L, lua_CFunction fn, int n);/* lapi.c */LUA_API void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n) &#123;  lua_lock(L);  if (n == 0) &#123;    setfvalue(L-&gt;top, fn);    api_incr_top(L);  &#125;  else &#123;    CClosure *cl;      api_checknelems(L, n);    api_check(L, n &lt;= MAXUPVAL, &quot;upvalue index too large&quot;);  /* #define MAXUPVAL 255  */    cl = luaF_newCclosure(L, n);/* åˆ›å»ºäº†é—­åŒ…ç»“æ„ä½“  */    cl-&gt;f = fn;    L-&gt;top -= n;  /* å°†æ ˆé¡¶ n ä¸ªå…ƒç´ ç§»é™¤å¹¶å‹å…¥é—­åŒ…çš„æ ˆä¸­ upvalue */    while (n--) &#123;      setobj2n(L, &amp;cl-&gt;upvalue[n], L-&gt;top + n);      /* does not need barrier because closure is white */    &#125;    setclCvalue(L, L-&gt;top, cl);    api_incr_top(L);    luaC_checkGC(L);  &#125;  lua_unlock(L);&#125;\n\n","categories":["Lua"],"tags":["lua"]},{"title":"C++ 11 æ–°ç‰¹æ€§","url":"/2022/01/13/32/","content":"\n    \n\n\n\n\nauto &amp; decltypeå…³äº C++11 æ–°ç‰¹æ€§ï¼Œæœ€å…ˆæåˆ°çš„è‚¯å®šæ˜¯ç±»å‹æ¨å¯¼ï¼ŒC++11 å¼•å…¥äº† auto å’Œdecltypeå…³é”®å­—ï¼Œä½¿ç”¨ä»–ä»¬å¯ä»¥åœ¨ç¼–è¯‘æœŸå°±æ¨å¯¼å‡ºå˜é‡æˆ–è€…è¡¨è¾¾å¼çš„ç±»å‹ï¼Œæ–¹ä¾¿å¼€å‘è€…ç¼–ç ä¹Ÿç®€åŒ–äº†ä»£ç ã€‚\nautoè®©ç¼–è¯‘å™¨åœ¨ç¼–è¯‘å™¨å°±æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹ï¼Œå¯ä»¥é€šè¿‡ç­‰å·å³è¾¹çš„ç±»å‹æ¨å¯¼å‡ºå˜é‡çš„ç±»å‹\ndecltypeç›¸å¯¹äº auto ç”¨äºæ¨å¯¼å˜é‡ç±»å‹ï¼Œè€Œ decltype åˆ™ç”¨äºæ¨å¯¼è¡¨è¾¾å¼ç±»å‹ï¼Œè¿™é‡Œåªç”¨äºç¼–è¯‘å™¨åˆ†æè¡¨è¾¾å¼çš„ç±»å‹ï¼Œè¡¨è¾¾å¼å®é™…ä¸ä¼šè¿›è¡Œè¿ç®—\nå·¦å€¼å’Œå³å€¼\nå·¦å€¼ï¼šå¯ä»¥å–åœ°å€å¹¶ä¸”æœ‰åå­—çš„ä¸œè¥¿å°±æ˜¯å·¦å€¼ã€‚\nå³å€¼ï¼šä¸èƒ½å–åœ°å€çš„æ²¡æœ‰åå­—çš„ä¸œè¥¿å°±æ˜¯å³å€¼ã€‚\nçº¯å³å€¼ï¼šè¿ç®—è¡¨è¾¾å¼äº§ç”Ÿçš„ä¸´æ—¶å˜é‡ã€ä¸å’Œå¯¹è±¡å…³è”çš„åŸå§‹å­—é¢é‡ã€éå¼•ç”¨è¿”å›çš„ä¸´æ—¶å˜é‡ã€lambda è¡¨è¾¾å¼ç­‰éƒ½æ˜¯çº¯å³å€¼ã€‚\nå°†äº¡å€¼ï¼šå¯ä»¥ç†è§£ä¸ºå³å°†è¦é”€æ¯çš„å€¼ã€‚\nå·¦å€¼å¼•ç”¨ï¼šå¯¹å·¦å€¼è¿›è¡Œå¼•ç”¨çš„ç±»å‹ã€‚\nå³å€¼å¼•ç”¨ï¼šå¯¹å³å€¼è¿›è¡Œå¼•ç”¨çš„ç±»å‹ã€‚\nç§»åŠ¨è¯­ä¹‰ï¼šè½¬ç§»èµ„æºæ‰€æœ‰æƒï¼Œç±»ä¼¼äºè½¬è®©æˆ–è€…èµ„æºçªƒå–çš„æ„æ€ï¼Œå¯¹äºé‚£å—èµ„æºï¼Œè½¬ä¸ºè‡ªå·±æ‰€æ‹¥æœ‰ï¼Œåˆ«äººä¸å†æ‹¥æœ‰ä¹Ÿä¸ä¼šå†ä½¿ç”¨ã€‚\nå®Œç¾è½¬å‘ï¼šå¯ä»¥å†™ä¸€ä¸ªæ¥å—ä»»æ„å®å‚çš„å‡½æ•°æ¨¡æ¿ï¼Œå¹¶è½¬å‘åˆ°å…¶å®ƒå‡½æ•°ï¼Œç›®æ ‡å‡½æ•°ä¼šæ”¶åˆ°ä¸è½¬å‘å‡½æ•°å®Œå…¨ç›¸åŒçš„å®å‚ã€‚\nè¿”å›å€¼ä¼˜åŒ–ï¼šå½“å‡½æ•°éœ€è¦è¿”å›ä¸€ä¸ªå¯¹è±¡å®ä¾‹æ—¶å€™ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶å¯¹è±¡å¹¶é€šè¿‡å¤åˆ¶æ„é€ å‡½æ•°å°†ç›®æ ‡å¯¹è±¡å¤åˆ¶åˆ°ä¸´æ—¶å¯¹è±¡ï¼Œè¿™é‡Œæœ‰å¤åˆ¶æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¼šè¢«å¤šä½™çš„è°ƒç”¨åˆ°ï¼Œæœ‰ä»£ä»·ï¼Œè€Œé€šè¿‡è¿”å›å€¼ä¼˜åŒ–ï¼ŒC++ æ ‡å‡†å…è®¸çœç•¥è°ƒç”¨è¿™äº›å¤åˆ¶æ„é€ å‡½æ•°ã€‚\n\nåˆ—è¡¨åˆå§‹åŒ–  åœ¨ C++11 ä¸­å¯ä»¥ç›´æ¥åœ¨å˜é‡ååé¢åŠ ä¸Šåˆå§‹åŒ–åˆ—è¡¨æ¥è¿›è¡Œå¯¹è±¡çš„åˆå§‹åŒ–\nåˆ—è¡¨åˆå§‹åŒ–çš„ä¸€äº›è§„åˆ™  èšåˆç±»å‹\nèšåˆç±»å‹å¯ä»¥è¿›è¡Œç›´æ¥åˆ—è¡¨åˆå§‹åŒ–\n\n\n\nç±»å‹æ˜¯ä¸€ä¸ªæ™®é€šæ•°ç»„ï¼Œå¦‚ int[5]ï¼Œchar[]ï¼Œdouble[] ç­‰\n\nç±»å‹æ˜¯ä¸€ä¸ªç±»ï¼Œä¸”æ»¡è¶³ä»¥ä¸‹æ¡ä»¶\n\næ²¡æœ‰ç”¨æˆ·å£°æ˜çš„æ„é€ å‡½æ•°\næ²¡æœ‰ç”¨æˆ·æä¾›çš„æ„é€ å‡½æ•°ï¼ˆå…è®¸æ˜¾ç¤ºé¢„ç½®æˆ–å¼ƒç½®çš„æ„é€ å‡½æ•°ï¼‰\næ²¡æœ‰ç§æœ‰æˆ–ä¿æŠ¤çš„éé™æ€æ•°æ®æˆå‘˜\næ²¡æœ‰åŸºç±»\næ²¡æœ‰è™šå‡½æ•°\næ²¡æœ‰ {} å’Œ = ç›´æ¥åˆå§‹åŒ–çš„éé™æ€æ•°æ®æˆå‘˜\næ²¡æœ‰é»˜è®¤æˆå‘˜åˆå§‹åŒ–å™¨\n\nstruct A &#123;    int a;    int b;    virtual void func() &#123;&#125; // å«æœ‰è™šå‡½æ•°ï¼Œä¸æ˜¯èšåˆç±»&#125;;struct Base &#123;&#125;;struct B : public Base &#123; // æœ‰åŸºç±»ï¼Œä¸æ˜¯èšåˆç±»      int a;    int b;&#125;;struct C &#123;    int a;    int b = 10; // æœ‰ç­‰å·åˆå§‹åŒ–ï¼Œä¸æ˜¯èšåˆç±»&#125;;struct D &#123;    int a;    int b;private:    int c; // å«æœ‰ç§æœ‰çš„éé™æ€æ•°æ®æˆå‘˜ï¼Œä¸æ˜¯èšåˆç±»&#125;;struct E &#123;      int a;    int b;    E() : a(0), b(0) &#123;&#125; // å«æœ‰é»˜è®¤æˆå‘˜åˆå§‹åŒ–å™¨ï¼Œä¸æ˜¯èšåˆç±»&#125;;\n\nstd::initializer_liststruct CustomVec &#123;    std::vector&lt;int&gt; data;    CustomVec(std::initializer_list&lt;int&gt; list) &#123;        for (auto iter = list.begin(); iter != list.end(); ++iter) &#123;            data.push_back(*iter);        &#125;    &#125;&#125;;\n\nstd::function &amp; std::bind &amp; lambdaè¡¨è¾¾å¼ std::function æ»¡è¶³ä»¥ä¸‹æ¡ä»¶ä¹‹ä¸€å°±å¯ç§°ä¸ºå¯è°ƒç”¨å¯¹è±¡ï¼š\n\næ˜¯ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆ\næ˜¯ä¸€ä¸ªå…·æœ‰ operator() æˆå‘˜å‡½æ•°çš„ç±»å¯¹è±¡ï¼ˆä¼ è¯´ä¸­çš„ä»¿å‡½æ•°ï¼‰ï¼Œlambdaè¡¨è¾¾å¼\næ˜¯ä¸€ä¸ªå¯è¢«è½¬æ¢ä¸ºå‡½æ•°æŒ‡é’ˆçš„ç±»å¯¹è±¡\næ˜¯ä¸€ä¸ªç±»æˆå‘˜ï¼ˆå‡½æ•°ï¼‰æŒ‡é’ˆ\nbind è¡¨è¾¾å¼æˆ–å…¶å®ƒå‡½æ•°å¯¹è±¡\n\nè€Œ std::function å°±æ˜¯ä¸Šé¢è¿™ç§å¯è°ƒç”¨å¯¹è±¡çš„å°è£…å™¨ï¼Œå¯ä»¥æŠŠ std::function çœ‹åšä¸€ä¸ªå‡½æ•°å¯¹è±¡ï¼Œç”¨äºè¡¨ç¤ºå‡½æ•°è¿™ä¸ªæŠ½è±¡æ¦‚å¿µã€‚std::functionçš„å®ä¾‹å¯ä»¥å­˜å‚¨ã€å¤åˆ¶å’Œè°ƒç”¨ä»»ä½•å¯è°ƒç”¨å¯¹è±¡ï¼Œå­˜å‚¨çš„å¯è°ƒç”¨å¯¹è±¡ç§°ä¸º std::function çš„ç›®æ ‡ï¼Œè‹¥ std::function ä¸å«ç›®æ ‡ï¼Œåˆ™ç§°å®ƒä¸ºç©ºï¼Œè°ƒç”¨ç©ºçš„ std::function çš„ç›®æ ‡ä¼šæŠ›å‡º std::bad_function_call å¼‚å¸¸ã€‚\nstd::bindä½¿ç”¨ std::bind å¯ä»¥å°†å¯è°ƒç”¨å¯¹è±¡å’Œå‚æ•°ä¸€èµ·ç»‘å®šï¼Œç»‘å®šåçš„ç»“æœä½¿ç”¨ std::function è¿›è¡Œä¿å­˜ï¼Œå¹¶å»¶è¿Ÿè°ƒç”¨åˆ°ä»»ä½•æˆ‘ä»¬éœ€è¦çš„æ—¶å€™ã€‚std::bindé€šå¸¸æœ‰ä¸¤å¤§ä½œç”¨ï¼š\n\nå°†å¯è°ƒç”¨å¯¹è±¡ä¸å‚æ•°ä¸€èµ·ç»‘å®šä¸ºå¦ä¸€ä¸ª std::function ä¾›è°ƒç”¨\nå°† n å…ƒå¯è°ƒç”¨å¯¹è±¡è½¬æˆ m(m &lt; n) å…ƒå¯è°ƒç”¨å¯¹è±¡ï¼Œç»‘å®šä¸€éƒ¨åˆ†å‚æ•°ï¼Œè¿™é‡Œéœ€è¦ä½¿ç”¨std::placeholders\n\nlambdaè¡¨è¾¾å¼ lambda è¡¨è¾¾å¼å¯ä»¥è¯´æ˜¯ c++11 å¼•ç”¨çš„æœ€é‡è¦çš„ç‰¹æ€§ä¹‹ä¸€ï¼Œå®ƒå®šä¹‰äº†ä¸€ä¸ªåŒ¿åå‡½æ•°ï¼Œå¯ä»¥æ•è·ä¸€å®šèŒƒå›´çš„å˜é‡åœ¨å‡½æ•°å†…éƒ¨ä½¿ç”¨ï¼Œä¸€èˆ¬æœ‰å¦‚ä¸‹è¯­æ³•å½¢å¼ï¼š\nauto func = [capture] (params) opt -&gt; ret &#123; func_body; &#125;;\n\nå…¶ä¸­ func æ˜¯å¯ä»¥å½“ä½œ lambda è¡¨è¾¾å¼çš„åå­—ï¼Œä½œä¸ºä¸€ä¸ªå‡½æ•°ä½¿ç”¨ï¼Œcaptureæ˜¯æ•è·åˆ—è¡¨ï¼Œparamsæ˜¯å‚æ•°è¡¨ï¼Œoptæ˜¯å‡½æ•°é€‰é¡¹ (mutableä¹‹ç±»ï¼‰ï¼Œ retæ˜¯è¿”å›å€¼ç±»å‹ï¼Œfunc_bodyæ˜¯å‡½æ•°ä½“ã€‚\nlambda è¡¨è¾¾å¼å…è®¸æ•è·ä¸€å®šèŒƒå›´å†…çš„å˜é‡ï¼š\n\n[]ä¸æ•è·ä»»ä½•å˜é‡\n[&amp;]å¼•ç”¨æ•è·ï¼Œæ•è·å¤–éƒ¨ä½œç”¨åŸŸæ‰€æœ‰å˜é‡ï¼Œåœ¨å‡½æ•°ä½“å†…å½“ä½œå¼•ç”¨ä½¿ç”¨\n[=]å€¼æ•è·ï¼Œæ•è·å¤–éƒ¨ä½œç”¨åŸŸæ‰€æœ‰å˜é‡ï¼Œåœ¨å‡½æ•°å†…å†…æœ‰ä¸ªå‰¯æœ¬ä½¿ç”¨\n[=, &amp;a]å€¼æ•è·å¤–éƒ¨ä½œç”¨åŸŸæ‰€æœ‰å˜é‡ï¼ŒæŒ‰å¼•ç”¨æ•è· a å˜é‡\n[a]åªå€¼æ•è· a å˜é‡ï¼Œä¸æ•è·å…¶å®ƒå˜é‡\n[this]æ•è·å½“å‰ç±»ä¸­çš„ this æŒ‡é’ˆ\n\nå°ç»“ std::function å’Œstd::bindä½¿å¾—æˆ‘ä»¬å¹³æ—¶ç¼–ç¨‹è¿‡ç¨‹ä¸­å°è£…å‡½æ•°æ›´åŠ çš„æ–¹ä¾¿ï¼Œè€Œ lambda è¡¨è¾¾å¼å°†è¿™ç§æ–¹ä¾¿å‘æŒ¥åˆ°äº†æè‡´ï¼Œå¯ä»¥åœ¨éœ€è¦çš„æ—¶é—´å°±åœ°å®šä¹‰åŒ¿åå‡½æ•°ï¼Œä¸å†éœ€è¦å®šä¹‰ç±»æˆ–è€…å‡½æ•°ç­‰ï¼Œåœ¨è‡ªå®šä¹‰ STL è§„åˆ™æ—¶å€™ä¹Ÿéå¸¸æ–¹ä¾¿ï¼Œè®©ä»£ç æ›´ç®€æ´ï¼Œæ›´çµæ´»ï¼Œæé«˜å¼€å‘æ•ˆç‡\næ¨¡æ¿çš„æ”¹è¿›  æ¨¡æ¿çš„å³å°–æ‹¬å·C++11 ä¹‹å‰æ˜¯ä¸å…è®¸ä¸¤ä¸ªå³å°–æ‹¬å·å‡ºç°çš„ï¼Œä¼šè¢«è®¤ä¸ºæ˜¯å³ç§»æ“ä½œç¬¦ï¼Œæ‰€ä»¥éœ€è¦ä¸­é—´åŠ ä¸ªç©ºæ ¼è¿›è¡Œåˆ†å‰²ï¼Œé¿å…å‘ç”Ÿç¼–è¯‘é”™è¯¯ã€‚\næ¨¡æ¿çš„åˆ«åC++11 å¼•å…¥äº†usingï¼Œå¯ä»¥è½»æ¾çš„å®šä¹‰åˆ«åï¼Œè€Œä¸æ˜¯ä½¿ç”¨ç¹ççš„typedef\nå‡½æ•°æ¨¡æ¿çš„é»˜è®¤æ¨¡æ¿å‚æ•°C++11 ä¹‹å‰åªæœ‰ç±»æ¨¡æ¿æ”¯æŒé»˜è®¤æ¨¡æ¿å‚æ•°ï¼Œå‡½æ•°æ¨¡æ¿æ˜¯ä¸æ”¯æŒé»˜è®¤æ¨¡æ¿å‚æ•°çš„ï¼ŒC++11 åéƒ½æ”¯æŒï¼›åŒæ—¶ C++11 æ”¯æŒå˜é•¿å‚æ•°æ¨¡æ¿\nå¹¶å‘  æ™ºèƒ½æŒ‡é’ˆ  åŸºäºèŒƒå›´çš„ for å¾ªç¯vector&lt;int&gt; vec;for (auto iter = vec.begin(); iter != vec.end(); iter++) &#123; // before c++11    cout &lt;&lt; *iter &lt;&lt; endl;&#125;for (int i : vec) &#123; // c++11 åŸºäºèŒƒå›´çš„ for å¾ªç¯    cout &lt;&lt; &quot;i&quot; &lt;&lt; endl;&#125;\n\nå§”æ‰˜æ„é€ å‡½æ•°  å§”æ‰˜æ„é€ å‡½æ•°å…è®¸åœ¨åŒä¸€ä¸ªç±»ä¸­ä¸€ä¸ªæ„é€ å‡½æ•°è°ƒç”¨å¦å¤–ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œå¯ä»¥åœ¨å˜é‡åˆå§‹åŒ–æ—¶ç®€åŒ–æ“ä½œ\nstruct A &#123;    A()&#123;&#125;    A(int a) &#123; a_ = a; &#125;    A(int a, int b) : A(a) &#123; b_ = b; &#125;    A(int a, int b, int c) : A(a, b) &#123; c_ = c; &#125;    int a_;    int b_;    int c_;&#125;;\n\nç»§æ‰¿æ„é€ å‡½æ•°  ç»§æ‰¿æ„é€ å‡½æ•°å¯ä»¥è®©æ´¾ç”Ÿç±»ç›´æ¥ä½¿ç”¨åŸºç±»çš„æ„é€ å‡½æ•°ï¼Œå¦‚æœæœ‰ä¸€ä¸ªæ´¾ç”Ÿç±»ï¼Œæˆ‘ä»¬å¸Œæœ›æ´¾ç”Ÿç±»é‡‡ç”¨å’ŒåŸºç±»ä¸€æ ·çš„æ„é€ æ–¹å¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨åŸºç±»çš„æ„é€ å‡½æ•°ï¼Œè€Œä¸æ˜¯å†é‡æ–°å†™ä¸€éæ„é€ å‡½æ•°\nstruct Base &#123;    Base() &#123;&#125;    Base(int a) &#123; a_ = a; &#125;    Base(int a, int b) : Base(a) &#123; b_ = b; &#125;    Base(int a, int b, int c) : Base(a, b) &#123; c_ = c; &#125;    int a_;    int b_;    int c_;&#125;;struct Derived : Base &#123;    using Base::Base;&#125;;int main() &#123;    Derived a(1, 2, 3);    return 0;&#125;\n\nå…³é”®å­— nullptrnullptr æ˜¯ c++11 ç”¨æ¥è¡¨ç¤ºç©ºæŒ‡é’ˆæ–°å¼•å…¥çš„å¸¸é‡å€¼ï¼Œåœ¨ c++ ä¸­å¦‚æœè¡¨ç¤ºç©ºæŒ‡é’ˆè¯­ä¹‰æ—¶å»ºè®®ä½¿ç”¨ nullptr è€Œä¸è¦ä½¿ç”¨ NULLï¼Œå› ä¸ºNULL æœ¬è´¨ä¸Šæ˜¯ä¸ª int å‹çš„ 0ï¼Œå…¶å®ä¸æ˜¯ä¸ªæŒ‡é’ˆ\nfinal &amp; overridec++11 å…³äºç»§æ‰¿æ–°å¢äº†ä¸¤ä¸ªå…³é”®å­—ï¼Œfinalç”¨äºä¿®é¥°ä¸€ä¸ªç±»ï¼Œè¡¨ç¤ºç¦æ­¢è¯¥ç±»è¿›ä¸€æ­¥æ´¾ç”Ÿå’Œè™šå‡½æ•°çš„è¿›ä¸€æ­¥é‡è½½ï¼Œoverrideç”¨äºä¿®é¥°æ´¾ç”Ÿç±»ä¸­çš„æˆå‘˜å‡½æ•°ï¼Œæ ‡æ˜è¯¥å‡½æ•°é‡å†™äº†åŸºç±»å‡½æ•°ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°å£°æ˜äº† override ä½†çˆ¶ç±»å´æ²¡æœ‰è¿™ä¸ªè™šå‡½æ•°ï¼Œç¼–è¯‘æŠ¥é”™ï¼Œä½¿ç”¨ override å…³é”®å­—å¯ä»¥é¿å…å¼€å‘è€…åœ¨é‡å†™åŸºç±»å‡½æ•°æ—¶æ— æ„äº§ç”Ÿçš„é”™è¯¯\ndefaultc++11 å¼•å…¥ default ç‰¹æ€§ï¼Œå¤šæ•°æ—¶å€™ç”¨äºå£°æ˜æ„é€ å‡½æ•°ä¸ºé»˜è®¤æ„é€ å‡½æ•°ï¼Œå¦‚æœç±»ä¸­æœ‰äº†è‡ªå®šä¹‰çš„æ„é€ å‡½æ•°ï¼Œç¼–è¯‘å™¨å°±ä¸ä¼šéšå¼ç”Ÿæˆé»˜è®¤æ„é€ å‡½æ•°\ndeletec++ ä¸­ï¼Œå¦‚æœå¼€å‘äººå‘˜æ²¡æœ‰å®šä¹‰ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨åœ¨éœ€è¦ç‰¹æ®Šæˆå‘˜å‡½æ•°æ—¶å€™ä¼šéšå¼è‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªé»˜è®¤çš„ç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œä¾‹å¦‚æ‹·è´æ„é€ å‡½æ•°æˆ–è€…æ‹·è´èµ‹å€¼æ“ä½œç¬¦ã€‚æœ‰æ—¶å€™æƒ³ç¦æ­¢å¯¹è±¡çš„æ‹·è´ä¸èµ‹å€¼ï¼Œå¯ä»¥ä½¿ç”¨ delete ä¿®é¥°\nstruct A &#123;    A() = default;    A(const A&amp;) = delete;    A&amp; operator=(const A&amp;) = delete;    int a;    A(int i) &#123; a = i; &#125;&#125;;int main() &#123;    A a1;    A a2 = a1;  // é”™è¯¯ï¼Œæ‹·è´æ„é€ å‡½æ•°è¢«ç¦ç”¨    A a3;    a3 = a1;  // é”™è¯¯ï¼Œæ‹·è´èµ‹å€¼æ“ä½œç¬¦è¢«ç¦ç”¨&#125;\n\ndeleleå…³é”®å­—åœ¨ c++11 ä¸­å¾ˆå¸¸ç”¨ï¼Œstd::unique_ptrå°±æ˜¯é€šè¿‡ delete ä¿®é¥°æ¥ç¦æ­¢å¯¹è±¡çš„æ‹·è´çš„\nexplicitexplicitä¸“ç”¨äºä¿®é¥°æ„é€ å‡½æ•°ï¼Œè¡¨ç¤ºåªèƒ½æ˜¾å¼æ„é€ ï¼Œä¸å¯ä»¥è¢«éšå¼è½¬æ¢\nä¸ç”¨explicitstruct A &#123;    A(int value) &#123; // æ²¡æœ‰ explicit å…³é”®å­—        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    A a = 1; // å¯ä»¥éšå¼è½¬æ¢    return 0;&#125;\n\nä½¿ç”¨explicitstruct A &#123;    explicit A(int value) &#123;        cout &lt;&lt; &quot;value&quot; &lt;&lt; endl;    &#125;&#125;;int main() &#123;    A a = 1; // errorï¼Œä¸å¯ä»¥éšå¼è½¬æ¢    A aa(2); // ok    return 0;&#125;\n\nconstexprconstexpræ˜¯ c++11 æ–°å¼•å…¥çš„å…³é”®å­—ï¼Œç”¨äºç¼–è¯‘æ—¶çš„å¸¸é‡å’Œå¸¸é‡å‡½æ•°ï¼Œè¿™é‡Œç›´æ¥ä»‹ç» constexpr å’Œconstçš„åŒºåˆ«ï¼šä¸¤è€…éƒ½ä»£è¡¨å¯è¯»ï¼Œconståªè¡¨ç¤º read only çš„è¯­ä¹‰ï¼Œåªä¿è¯äº†è¿è¡Œæ—¶ä¸å¯ä»¥è¢«ä¿®æ”¹ï¼Œä½†å®ƒä¿®é¥°çš„ä»ç„¶æœ‰å¯èƒ½æ˜¯ä¸ªåŠ¨æ€å˜é‡ï¼Œè€Œ constexpr ä¿®é¥°çš„æ‰æ˜¯çœŸæ­£çš„å¸¸é‡ï¼Œå®ƒä¼šåœ¨ç¼–è¯‘æœŸé—´å°±ä¼šè¢«è®¡ç®—å‡ºæ¥ï¼Œæ•´ä¸ªè¿è¡Œè¿‡ç¨‹ä¸­éƒ½ä¸å¯ä»¥è¢«æ”¹å˜ï¼Œconstexprå¯ä»¥ç”¨äºä¿®é¥°å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ä¼šå°½å¯èƒ½åœ¨ç¼–è¯‘æœŸé—´è¢«è®¡ç®—å‡ºæ¥å½“ä½œä¸€ä¸ªå¸¸é‡ï¼Œä½†æ˜¯å¦‚æœç¼–è¯‘æœŸé—´æ­¤å‡½æ•°ä¸èƒ½è¢«è®¡ç®—å‡ºæ¥ï¼Œé‚£å®ƒå°±ä¼šå½“ä½œä¸€ä¸ªæ™®é€šå‡½æ•°è¢«å¤„ç†\nenum classc++11 æ–°å¢æœ‰ä½œç”¨åŸŸçš„æšä¸¾ç±»å‹ï¼Œä¸å¸¦ä½œç”¨åŸŸçš„æšä¸¾ç±»å‹å¯ä»¥è‡ªåŠ¨è½¬æ¢æˆæ•´å½¢ï¼Œä¸”ä¸åŒçš„æšä¸¾å¯ä»¥ç›¸äº’æ¯”è¾ƒï¼Œå¯èƒ½ä¼šå­˜åœ¨æ½œåœ¨çš„éš¾ä»¥è°ƒè¯•çš„ bugï¼›ä½¿ç”¨å¸¦æœ‰ä½œç”¨åŸŸçš„æšä¸¾ç±»å‹åï¼Œå¯¹ä¸åŒçš„æšä¸¾è¿›è¡Œæ¯”è¾ƒä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ï¼Œä½¿ç”¨å¸¦æœ‰ä½œç”¨åŸŸçš„æšä¸¾ç±»å‹åï¼Œå¯¹ä¸åŒçš„æšä¸¾è¿›è¡Œæ¯”è¾ƒä¼šå¯¼è‡´ç¼–è¯‘å¤±è´¥ï¼ŒåŒæ—¶å¸¦ä½œç”¨åŸŸçš„æšä¸¾ç±»å‹å¯ä»¥é€‰æ‹©åº•å±‚ç±»å‹ï¼Œé»˜è®¤æ˜¯intï¼Œå¯ä»¥æ”¹æˆå…¶ä»–ç±»å‹\nå¹³æ—¶ç¼–ç¨‹è¿‡ç¨‹ä¸­ä½¿ç”¨æšä¸¾ï¼Œä¸€å®šè¦ä½¿ç”¨æœ‰ä½œç”¨åŸŸçš„æšä¸¾å–ä»£ä¼ ç»Ÿçš„æšä¸¾\n\n\nsizeofc++11 ä¸­ sizeof å¯ä»¥ç”¨çš„ç±»çš„æ•°æ®æˆå‘˜ä¸Š\nassertionstatic_assert(true/false, message);\n\nc++11 å¼•å…¥ static_assert å£°æ˜ï¼Œç”¨äºåœ¨ç¼–è¯‘æœŸé—´æ£€æŸ¥ï¼Œå¦‚æœç¬¬ä¸€ä¸ªå‚æ•°å€¼ä¸ºfalseï¼Œåˆ™æ‰“å°messageï¼Œç¼–è¯‘å¤±è´¥\nå†…å­˜å¯¹é½  ä»€ä¹ˆæ˜¯å†…å­˜å¯¹é½  ç†è®ºä¸Šè®¡ç®—æœºå¯¹äºä»»ä½•å˜é‡çš„è®¿é—®éƒ½å¯ä»¥ä»ä»»æ„ä½ç½®å¼€å§‹ï¼Œç„¶è€Œå®é™…ä¸Šç³»ç»Ÿä¼šå¯¹è¿™äº›å˜é‡çš„å­˜æ”¾åœ°å€æœ‰é™åˆ¶ï¼Œé€šå¸¸å°†å˜é‡é¦–åœ°å€è®¾ä¸ºæŸä¸ªæ•° N çš„å€æ•°ï¼Œè¿™å°±æ˜¯å†…å­˜å¯¹é½\nä¸ºä»€ä¹ˆè¦å†…å­˜å¯¹é½\nç¡¬ä»¶å¹³å°é™åˆ¶ï¼Œå†…å­˜ä»¥å­—èŠ‚ä¸ºå•ä½ï¼Œä¸åŒç¡¬ä»¶å¹³å°ä¸ä¸€å®šæ”¯æŒä»»ä½•å†…å­˜åœ°å€çš„å­˜å–ï¼Œä¸€èˆ¬å¯èƒ½ä»¥åŒå­—èŠ‚ã€4 å­—èŠ‚ç­‰ä¸ºå•ä½å­˜å–å†…å­˜ï¼Œä¸ºäº†ä¿è¯å¤„ç†å™¨æ­£ç¡®å­˜å–æ•°æ®ï¼Œéœ€è¦è¿›è¡Œå†…å­˜å¯¹é½\næé«˜ CPU å†…å­˜è®¿é—®é€Ÿåº¦ï¼Œä¸€èˆ¬å¤„ç†å™¨çš„å†…å­˜å­˜å–ç²’åº¦éƒ½æ˜¯ N çš„æ•´æ•°å€ï¼Œå‡å¦‚è®¿é—® N å¤§å°çš„æ•°æ®ï¼Œæ²¡æœ‰è¿›è¡Œå†…å­˜å¯¹é½ï¼Œæœ‰å¯èƒ½å°±éœ€è¦ä¸¤æ¬¡è®¿é—®æ‰å¯ä»¥è¯»å–å‡ºæ•°æ®ï¼Œè€Œè¿›è¡Œå†…å­˜å¯¹é½å¯ä»¥ä¸€æ¬¡æ€§æŠŠæ•°æ®å…¨éƒ¨è¯»å–å‡ºæ¥ï¼Œæé«˜æ•ˆç‡\n\nc++11 å…³äºå†…å­˜å¯¹é½æ–°å¢äº†ä¸€äº›å‡½æ•°\nvoid func()&#123;    static std::aligned_storage&lt;sizeof(A), alignof(A)&gt;::type data;    A *attr = new (&amp;data) A;&#125;\n\néšæœºæ•°åŠŸèƒ½c++11 å…³äºéšæœºæ•°åŠŸèƒ½åˆ™è¾ƒä¹‹å‰ä¸°å¯Œäº†å¾ˆå¤šï¼Œå…¸å‹çš„å¯ä»¥é€‰æ‹©æ¦‚ç‡åˆ†å¸ƒç±»å‹\n#include &lt;time.h&gt;#include &lt;iostream&gt;#include &lt;random&gt;using namespace std;int main() &#123;    std::default_random_engine random(time(nullptr));    std::uniform_int_distribution&lt;int&gt; int_dis(0, 100); // æ•´æ•°å‡åŒ€åˆ†å¸ƒ    std::uniform_real_distribution&lt;float&gt; real_dis(0.0, 1.0); // æµ®ç‚¹æ•°å‡åŒ€åˆ†å¸ƒ    for (int i = 0; i &lt; 10; ++i) &#123;        cout &lt;&lt; int_dis(random) &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;    for (int i = 0; i &lt; 10; ++i) &#123;        cout &lt;&lt; real_dis(random) &lt;&lt; &#x27; &#x27;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;\n\næ­£åˆ™è¡¨è¾¾å¼#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;regex&gt;#include &lt;string&gt;int main() &#123;    std::string s = &quot;I know, I&#x27;ll use2 regular expressions.&quot;;    // å¿½ç•¥å¤§å°å†™    std::regex self_regex(&quot;REGULAR EXPRESSIONS&quot;, std::regex_constants::icase);     if (std::regex_search(s, self_regex)) &#123;        std::cout &lt;&lt; &quot;Text contains the phrase &#x27;regular expressions&#x27;\\n&quot;;    &#125;    std::regex word_regex(&quot;(\\\\w+)&quot;);  // åŒ¹é…å­—æ¯æ•°å­—ç­‰å­—ç¬¦    auto words_begin = std::sregex_iterator(s.begin(), s.end(), word_regex);    auto words_end = std::sregex_iterator();    std::cout &lt;&lt; &quot;Found &quot; &lt;&lt; std::distance(words_begin, words_end) &lt;&lt; &quot; words\\n&quot;;    const int N = 6;    std::cout &lt;&lt; &quot;Words longer than &quot; &lt;&lt; N &lt;&lt; &quot; characters:\\n&quot;;    for (std::sregex_iterator i = words_begin; i != words_end; ++i) &#123;        std::smatch match = *i;        std::string match_str = match.str();        if (match_str.size() &gt; N) &#123;            std::cout &lt;&lt; &quot;  &quot; &lt;&lt; match_str &lt;&lt; &#x27;\\n&#x27;;        &#125;    &#125;    std::regex long_word_regex(&quot;(\\\\w&#123;7,&#125;)&quot;);    // è¶…è¿‡ 7 ä¸ªå­—ç¬¦çš„å•è¯ç”¨ [] åŒ…å›´    std::string new_s = std::regex_replace(s, long_word_regex, &quot;[$&amp;]&quot;);    std::cout &lt;&lt; new_s &lt;&lt; &#x27;\\n&#x27;;&#125;\n","categories":["C++"],"tags":["C++","C++ 11"]},{"title":"Lua API","url":"/2022/01/14/33/","content":"lua_gettablevoid lua_gettable(lua_State *L, int index);\n\næŠŠ t[k] å€¼å‹å…¥å †æ ˆï¼Œ è¿™é‡Œçš„ t æ˜¯æŒ‡æœ‰æ•ˆç´¢å¼• index æŒ‡å‘çš„å€¼ï¼Œ è€Œ k åˆ™æ˜¯æ ˆé¡¶æ”¾çš„å€¼ã€‚è¿™ä¸ªå‡½æ•°ä¼šå¼¹å‡ºå †æ ˆä¸Šçš„ keyï¼ˆæŠŠç»“æœæ”¾åœ¨æ ˆä¸Šç›¸åŒä½ç½®ï¼‰ï¼Œåœ¨ Lua ä¸­è¿™ä¸ªå‡½æ•°å¯èƒ½è§¦å‘å¯¹åº” __index äº‹ä»¶çš„å…ƒæ–¹æ³•\n\n    \n\n\nlua_settablevoid lua_settable(lua_State *L, int index);\n\nä½œä¸€ä¸ªç­‰ä»·äº t[k] = v çš„æ“ä½œï¼Œ è¿™é‡Œ t æ˜¯ä¸€ä¸ªç»™å®šæœ‰æ•ˆç´¢å¼• index å¤„çš„å€¼ï¼Œ v æŒ‡æ ˆé¡¶çš„å€¼ï¼Œ è€Œ k æ˜¯æ ˆé¡¶ä¹‹ä¸‹çš„é‚£ä¸ªå€¼ã€‚è¿™ä¸ªå‡½æ•°ä¼šæŠŠé”®å’Œå€¼éƒ½ä»å †æ ˆä¸­å¼¹å‡ºã€‚ åœ¨ Lua ä¸­è¿™ä¸ªå‡½æ•°å¯èƒ½è§¦å‘ __newindex äº‹ä»¶çš„å…ƒæ–¹æ³•\nlua_rawset &amp; lua_rawgetvoid lua_rawset(lua_State *L, int index);void lua_rawget(lua_State *L, int index);\n\nlua_rawsetç±»ä¼¼äº lua_settableï¼Œ ä½†æ˜¯æ˜¯ä½œä¸€ä¸ªç›´æ¥èµ‹å€¼ï¼Œä¸è§¦å‘å…ƒæ–¹æ³•ï¼›lua_rawget ç±»ä¼¼äºlua_gettableï¼Œ ä½†æ˜¯ä½œä¸€æ¬¡ç›´æ¥è®¿é—®ï¼Œä¸è§¦å‘å…ƒæ–¹æ³•\nlua_rawseti &amp; lua_rawgetivoid lua_rawgeti(lua_State *L, int index, int n);void lua_rawseti(lua_State *L, int index, int n);\n\n\nlua_rawgetiï¼šæŠŠ t[n] çš„å€¼å‹æ ˆï¼Œ è¿™é‡Œçš„ t æ˜¯æŒ‡ç»™å®šç´¢å¼• index å¤„çš„ä¸€ä¸ªå€¼ï¼Œ è¿™æ˜¯ä¸€ä¸ªç›´æ¥è®¿é—®ï¼Œä¸ä¼šè§¦å‘å…ƒæ–¹æ³•\nlua_rawsetiï¼šç­‰ä»·äº t[n] = vï¼Œè¿™é‡Œçš„t æ˜¯æŒ‡ç»™å®šç´¢å¼• index å¤„çš„ä¸€ä¸ªå€¼ï¼Œ è€Œ v æ˜¯æ ˆé¡¶çš„å€¼ï¼Œä¸ä¼šè§¦å‘å…ƒæ–¹æ³•\n\n","categories":["Lua"],"tags":["lua"]},{"title":"Perforce å­¦ä¹ ","url":"/2022/01/25/34/","content":"\n    \n\n\n\n\nUsing Changelists to Manage FilesCheckout\n    \n\n\nä¿®æ”¹æ–‡ä»¶ï¼Œå¿…é¡»å°†å…¶ Checkoutï¼Œå½“Checkout æ–‡ä»¶æ˜¯ï¼ŒPerforce ä¼šå°†æœ‰å…³æ–‡ä»¶çš„ä¿¡æ¯æ·»åŠ åˆ° ** Changelistsï¼Œå¹¶å°†æœ¬åœ°å·¥ä½œåŒºä¸­æ–‡ä»¶çš„å¯å†™æ€§ä»  åªè¯»  æ›´æ”¹ä¸º  è¯» / å†™ **\nChangelists\n    \n\n\nä¸€ä¸ª Changelist å®šä¹‰äº†ä¸€ä¸ªæ–‡ä»¶å’Œæ–‡ä»¶å¤¹çš„é€»è¾‘ä¸Šçš„åˆ†ç»„\nChangelist å†…å®¹  ä¸€ä¸ª Changelist ä¸­åŒ…å«çš„ä¿¡æ¯åŒ…æ‹¬ Changelist çš„æ ‡è¯†ç¬¦ã€æ–‡ä»¶åˆ—è¡¨ã€æ›´æ”¹æäº¤çš„æ—¥æœŸç­‰ç­‰ã€‚ä¸€ä¸ª Changelist ä¸­çš„æ–‡ä»¶æ›´æ”¹çš„æ–¹å¼ï¼Œå¯ä»¥æ˜¯ä»»æ„çš„ï¼ŒåŒ…æ‹¬å¯¹æ–‡ä»¶å†…å®¹çš„ç¼–è¾‘ã€æ–‡ä»¶å’Œæ–‡ä»¶å¤¹çš„æ·»åŠ æˆ–åˆ é™¤ã€æ–‡ä»¶é‡å‘½åç­‰\nChangelist ç§ç±»Changelist å¯ä»¥å¤„äºä»¥ä¸‹ä¸‰ç§çŠ¶æ€ä¹‹ä¸€ï¼šPendingã€Submitted å’Œ Shelved\n\n    \n\n\n\næœªæäº¤çš„ Changelist è¢«ç§°ä¸º Pending Changelist ã€‚\nä¸€æ—¦ Changelist æˆåŠŸæäº¤åˆ°æœåŠ¡å™¨ï¼ŒChangelist çŠ¶æ€å°†æ›´æ–°ä¸º Submittedã€‚\nShelved æ˜¯ä¸€ç§ç‰¹æ®Šå½¢å¼çš„å¾…å®š Changelistã€‚å¯ä»¥ä½¿ç”¨ Shelved çš„ Changelist å°†å·¥ä½œåŒºæ–‡ä»¶ä¸´æ—¶å­˜å‚¨åœ¨æœåŠ¡å™¨ä¸Šï¼Œè€Œæ— éœ€å°†æ›´æ”¹æäº¤åˆ°ç‰ˆæœ¬æ–‡ä»¶å­˜å‚¨åº“ã€‚\n\nPerforce æœåŠ¡å™¨ä¼šè¿½è¸ªåœ¨ç³»ç»Ÿå…ƒæ•°æ®ä¸­å­˜å‚¨çš„ Pending Changelist ä¸­ Checkout çš„æ–‡ä»¶ã€‚å½“åœ¨ Perforce GUI å®¢æˆ·ç«¯ä¸­æŸ¥çœ‹ Changelist æ—¶ï¼Œæ­£åœ¨æŸ¥çœ‹çš„æ˜¯å­˜å‚¨åœ¨æœåŠ¡å™¨ä¸Šçš„ Changelist çš„æœ¬åœ°å‰¯æœ¬\né»˜è®¤ Changelist å’Œç¼–å· ChangelistPerforce åœ¨æ¯ä¸ªå·¥ä½œåŒºçš„ç³»ç»Ÿå…ƒæ•°æ®ä¸­ç»´æŠ¤ä¸€ä¸ª  é»˜è®¤  çš„ Pending Changelistã€‚å½“ Checkout æ–‡ä»¶æ—¶ï¼Œå¯ä»¥å°†å…¶æ·»åŠ åˆ°å·¥ä½œåŒºçš„é»˜è®¤ Pending Changelistï¼Œæˆ–åˆ›å»ºä¸€ä¸ªæ–°çš„  ç¼–å· Pending Changelistã€‚\n\n    \n\n\nChangelist ç¼–å·æœºåˆ¶Perforce ç»´æŠ¤ä¸€ä¸ªç¼–å·åºåˆ—ï¼Œç”¨äº Changelist çš„ IDã€‚å½“åˆ›å»ºä¸€ä¸ªæ–°çš„ Pending Changelist æ—¶ï¼ŒPerforce ä¼šä½¿ç”¨åºåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªç¼–å·ä¸º Changelist åˆ†é…ä¸€ä¸ª ID ç¼–å·ã€‚å½“æäº¤åœ¨ç¼–å· Pending Changelist ä¸­çš„ä¿®æ”¹æ—¶ï¼ŒPerforce ä¼šéªŒè¯æœ€åˆåˆ†é…ç»™ Changelist çš„ç¼–å·æ˜¯å¦ä»ç„¶æ˜¯åºåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªç¼–å·ã€‚å¦‚æœä¸æ˜¯ï¼ˆè¿™åœ¨è®¸å¤šäººåŒæ—¶åœ¨åŒä¸€ä¸ªä»“åº“ä¸­å·¥ä½œæ—¶å¾ˆå¸¸è§ï¼‰ï¼ŒPerforce ä¼šåœ¨å°† Changelist å­˜å‚¨åˆ°ç³»ç»Ÿå…ƒæ•°æ®ä¸­ä¹‹å‰ï¼Œä½¿ç”¨åºåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªç¼–å·ä¸º Changelist ç”Ÿæˆä¸€ä¸ªæ–°çš„ ID ç¼–å·ã€‚\nå› ä¸º Perforce æŒ‰é¡ºåºä¸ºæ¯ä¸ªæäº¤çš„ Changelist ç”Ÿæˆå”¯ä¸€çš„ ID å·ï¼Œå› æ­¤ Changelist çš„ ID åæ˜ äº†æ¯ä¸ª Changelist æäº¤åˆ°æœåŠ¡å™¨çš„æ—¶é—´ã€‚\n\n    \n\n\nCleaning up files and directories\nChanges performed by the Clean option are permanent. You cannot revert this operation.\n\n\nSelect a folder and click Actions &gt; Clean, or right-click a folder and select Clean.\nIf there are files that need to be cleaned up, the Clean Workspace (Revert to Depot) dialog appears.\nP4V compares your workspace to the depot and lists the following files:\n\nFiles that were modified locally without being checked out\nLocal files that are not in the depot\nDepot files that are missing from your local workspace\n\n\nBy default, all files are selected for cleanup. If there are any files that you do not want to clean up, clear the respective check boxes.\n\nBy default, files and directories listed in P4IGNORE files are excluded from cleanup and remain unaffected. If you do want to include such files, clear the Apply P4IGNORE files for this workspace check box.\nIn this case, P4V compares your workspace to the depot again and then also lists applicable files that were previously excluded in the respective section.\n\nClick Clean.\n\nIn the Confirm Deleting and Reverting Files dialog, click Continue to confirm the operation.\n\n\n","categories":["æ—¥å¸¸"],"tags":["p4v","ç‰ˆæœ¬æ§åˆ¶"]},{"title":"C++ 14 æ–°ç‰¹æ€§","url":"/2022/02/09/35/","content":"\n    \n\n\n\nå‡½æ•°è¿”å›å€¼ç±»å‹æ¨å¯¼#include &lt;iostream&gt;using namespace std;auto func(int i) &#123;    return i;&#125;int main() &#123;    cout &lt;&lt; func(4) &lt;&lt; endl;    return 0;&#125;\n\nä¸Šé¢çš„ä»£ç ä½¿ç”¨ C++11 æ˜¯ä¸èƒ½é€šè¿‡ç¼–è¯‘çš„ï¼Œè¿™ä¸ªç‰¹æ€§éœ€è¦åˆ° C++14 æ‰è¢«æ”¯æŒ\nè¿”å›å€¼ç±»å‹æ¨å¯¼ä¹Ÿå¯ä»¥ç”¨åœ¨æ¨¡æ¿ä¸­ï¼š\n#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt; auto func(T t) &#123; return t; &#125;int main() &#123;    cout &lt;&lt; func(4) &lt;&lt; endl;    cout &lt;&lt; func(3.4) &lt;&lt; endl;    return 0;&#125;\n\n\n\nå‡½æ•°å†…å¦‚æœæœ‰å¤šä¸ª return è¯­å¥ï¼Œå®ƒä»¬å¿…é¡»è¿”å›ç›¸åŒçš„ç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å¤±è´¥\nå¦‚æœ return è¯­å¥è¿”å›åˆå§‹åŒ–åˆ—è¡¨ï¼Œè¿”å›å€¼ç±»å‹æ¨å¯¼ä¹Ÿä¼šå¤±è´¥\n å¦‚æœå‡½æ•°æ˜¯è™šå‡½æ•°ï¼Œä¸èƒ½ä½¿ç”¨è¿”å›å€¼ç±»å‹æ¨å¯¼\n\n\nlambdaå‚æ•° auto åœ¨ C++11 ä¸­ï¼Œlambdaè¡¨è¾¾å¼å‚æ•°éœ€è¦ä½¿ç”¨å…·ä½“çš„ç±»å‹å£°æ˜ï¼Œåœ¨ C++14 ä¸­ï¼Œå¯¹æ­¤è¿›è¡Œä¼˜åŒ–ï¼Œlambdaè¡¨è¾¾å¼å‚æ•°å¯ä»¥ç›´æ¥æ˜¯auto\nå˜é‡æ¨¡æ¿C++14 æ”¯æŒå˜é‡æ¨¡æ¿\ntemplate&lt;class T&gt;constexpr T pi = T(3.1415926535897932385L);int main() &#123;    cout &lt;&lt; pi&lt;int&gt; &lt;&lt; endl; // 3    cout &lt;&lt; pi&lt;double&gt; &lt;&lt; endl; // 3.14159    return 0;&#125;\n\nåˆ«åæ¨¡æ¿template&lt;typename T, typename U&gt;struct A &#123;    T t;    U u;&#125;;template&lt;typename T&gt;using B = A&lt;T, int&gt;;int main() &#123;    B&lt;double&gt; b;    b.t = 10;    b.u = 20;    cout &lt;&lt; b.t &lt;&lt; endl;    cout &lt;&lt; b.u &lt;&lt; endl;    return 0;&#125;\n\nconstexprçš„é™åˆ¶ C++14 ç›¸è¾ƒäº C++11 å¯¹constexpr å‡å°‘äº†ä¸€äº›é™åˆ¶ï¼š\n\nC++11 ä¸­ constexpr å‡½æ•°å¯ä»¥ä½¿ç”¨é€’å½’ï¼Œåœ¨ C++14 ä¸­å¯ä»¥ä½¿ç”¨å±€éƒ¨å˜é‡å’Œå¾ªç¯\nC++11 ä¸­ constexpr å‡½æ•°å¿…é¡»å¿…é¡»æŠŠæ‰€æœ‰ä¸œè¥¿éƒ½æ”¾åœ¨ä¸€ä¸ªå•ç‹¬çš„ return è¯­å¥ä¸­ï¼Œè€Œ C++14 åˆ™æ— æ­¤é™åˆ¶ï¼š\n\n[[deprecated]]æ ‡è®°C++14 ä¸­å¢åŠ äº† deprecated æ ‡è®°ï¼Œä¿®é¥°ç±»ã€å˜ã€å‡½æ•°ç­‰ï¼Œå½“ç¨‹åºä¸­ä½¿ç”¨åˆ°äº†è¢«å…¶ä¿®é¥°çš„ä»£ç æ—¶ï¼Œç¼–è¯‘æ—¶è¢«äº§ç”Ÿè­¦å‘Šï¼Œç”¨æˆ·æç¤ºå¼€å‘è€…è¯¥æ ‡è®°ä¿®é¥°çš„å†…å®¹å°†æ¥å¯èƒ½ä¼šè¢«ä¸¢å¼ƒï¼Œå°½é‡ä¸è¦ä½¿ç”¨\näºŒè¿›åˆ¶å­—é¢é‡ä¸æ•´å½¢å­—é¢é‡åˆ†éš”ç¬¦C++14 å¼•å…¥äº†äºŒè¿›åˆ¶å­—é¢é‡ï¼Œä¹Ÿå¼•å…¥äº†åˆ†éš”ç¬¦\nint a = 0b0001&#x27;0011&#x27;1010;double b = 3.14&#x27;1234&#x27;1234&#x27;1234;\n\nstd::make_uniqueC++11 ä¸­æœ‰std::make_sharedï¼Œå´æ²¡æœ‰std::make_uniqueï¼Œåœ¨ C++14 å·²ç»æ”¹å–„\nstd::shared_timed_mutexä¸ std::shared_lockC++14 é€šè¿‡std::shared_timed_mutex å’Œstd::shared_lockæ¥å®ç°è¯»å†™é”ï¼Œä¿è¯å¤šä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¯»ï¼Œä½†æ˜¯å†™çº¿ç¨‹å¿…é¡»ç‹¬ç«‹è¿è¡Œï¼Œå†™æ“ä½œä¸å¯ä»¥åŒæ—¶å’Œè¯»æ“ä½œä¸€èµ·è¿›è¡Œ\nstruct ThreadSafe &#123;    mutable std::shared_timed_mutex mutex_;    int value_;    ThreadSafe() &#123;        value_ = 0;    &#125;    int get() const &#123;        std::shared_lock&lt;std::shared_timed_mutex&gt; loc(mutex_);        return value_;    &#125;    void increase() &#123;        std::unique_lock&lt;std::shared_timed_mutex&gt; lock(mutex_);        value_ += 1;    &#125;&#125;;\n\nstd::integer_sequencetemplate&lt;typename T, T... ints&gt;void print_sequence(std::integer_sequence&lt;T, ints...&gt; int_seq)&#123;    std::cout &lt;&lt; &quot;The sequence of size &quot; &lt;&lt; int_seq.size() &lt;&lt; &quot;: &quot;;    ((std::cout &lt;&lt; ints &lt;&lt; &#x27; &#x27;), ...);    std::cout &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123;    print_sequence(std::integer_sequence&lt;int, 9, 2, 5, 1, 9, 1, 6&gt;&#123;&#125;);    return 0;&#125;è¾“å‡ºï¼š7 9 2 5 1 9 1 6\n\nstd::exchangestd::exchangeå®ç°\ntemplate&lt;class T, class U = T&gt;constexpr T exchange(T&amp; obj, U&amp;&amp; new_value) &#123;    T old_value = std::move(obj);    obj = std::forward&lt;U&gt;(new_value);    return old_value;&#125;\n\nstd::quotedC++14 å¼•å…¥ std::quoted ç”¨äºç»™å­—ç¬¦ä¸²æ·»åŠ åŒå¼•å·\nint main() &#123;    string str = &quot;hello world&quot;;    cout &lt;&lt; str &lt;&lt; endl;    cout &lt;&lt; std::quoted(str) &lt;&lt; endl;    return 0;&#125;\n","categories":["C++"],"tags":["C++","C++ 14"]},{"title":"Pytorch ç¬”è®°","url":"/2022/02/21/37/","content":"torch.cat()åœ¨ç»™å®šç»´åº¦ä¸Šå¯¹è¾“å…¥çš„å¼ é‡åºåˆ—è¿›è¡Œè¿æ¥æ“ä½œ\n\nArgs\ntensors (sequence of Tensors): any python sequence of tensors of the same type. ä»»æ„ Tensor ç±»å‹çš„ python åºåˆ—ï¼Œåºåˆ—ä¸­çš„æ•°æ®æ˜¯ä»»æ„ç›¸åŒ shape çš„åŒç±»å‹çš„Tensor\nNon-empty tensors provided must have the same shape, except in the cat dimension.\n\n\ndim (int, optional): the dimension over which the tensors are concatenated ç»´åº¦ä¸èƒ½è¶…è¿‡è¾“å…¥æ•°æ®ä»»æ„ä¸€ä¸ªå¼ é‡çš„ç»´åº¦\n\n\nKeyword args: out (Tensor, optional): the output tensor.\n\ntorch.gather()torch.gather(input, dim, index, *, sparse_grad=False, out=None) -&gt; Tensor\n\næ²¿ç€ç”± dim æŒ‡å®šçš„è½´æ”¶é›†æ•°å€¼\n\ndim = 0çš„æƒ…å†µï¼Œä»£è¡¨çš„æ˜¯æ¨ªå‘ï¼ŒæŒ‰è¡Œå–å€¼\nlengthçŸ©é˜µä¸­çš„æ•°çš„å€¼ä»£è¡¨çš„æ˜¯è¡Œæ•°ï¼Œæ‰€åœ¨åˆ—ä»£è¡¨çš„æ˜¯åˆ—æ•°\n\n\n\ninput = [    [0.0, 0.1, 0.2, 0.3],    [1.0, 1.1, 1.2, 1.3],    [2.0, 2.1, 2.2, 2.3]]#shape [3,4]input = torch.tensor(input)length = torch.LongTensor([    [2,2,2,2],    [1,1,1,1],    [0,0,0,0],    [0,1,2,0]])#[4,4]out = torch.gather(input, dim=0, index=length)\n\ntensor([[2.0000, 2.1000, 2.2000, 2.3000],        [1.0000, 1.1000, 1.2000, 1.3000],        [0.0000, 0.1000, 0.2000, 0.3000],        [0.0000, 1.1000, 2.2000, 0.3000]])\n\nç”¨çŸ©é˜µçš„æ–¹å¼æ¼”ç¤º\n$$\\begin{bmatrix}x_{20} &amp; x_{21} &amp; x_{22} &amp; x_{23} \\\\x_{10} &amp; x_{11} &amp; x_{12} &amp; x_{13} \\\\x_{00} &amp; x_{01} &amp; x_{02} &amp; x_{03} \\\\x_{00} &amp; x_{11} &amp; x_{22} &amp; x_{03} \\\\\\end{bmatrix}$$\nlengthçŸ©é˜µä¸­çš„æ•°çš„å€¼ä»£è¡¨çš„æ˜¯è¡Œæ•°ï¼Œæ•°çš„ä½ç½®ä»£è¡¨çš„åˆ—æ•°ï¼Œæ¯”å¦‚ length çŸ©é˜µä¸­çš„ç¬¬ä¸‰è¡Œç¬¬ä¸‰åˆ—ï¼ˆä» 0 æ•°èµ·ï¼‰çš„æ•° 0ï¼Œå…¶å€¼æ˜¯ 0ï¼Œä»£è¡¨åœ¨ input ä¸­æ‰€å–çš„æ•°æ˜¯ç¬¬ 0 è¡Œï¼Œä½ç½®æ˜¯ç¬¬ä¸‰åˆ—ï¼Œåˆ™è¡¨ç¤ºåœ¨ input ä¸­æ‰€å–çš„æ•°æ˜¯ç¬¬ä¸‰åˆ—ï¼Œ$x_{03} = 0.3$\n\ndim = 1çš„æƒ…å†µ\nlengthçŸ©é˜µä¸­çš„æ•°çš„å€¼ä»£è¡¨çš„æ˜¯åˆ—æ•°ï¼Œæ‰€åœ¨è¡Œä»£è¡¨çš„æ˜¯è¡Œæ•°\n\n\n\ninput = [    [0.0, 0.1, 0.2, 0.3],    [1.0, 1.1, 1.2, 1.3],    [2.0, 2.1, 2.2, 2.3]]#shape [3,4]input = torch.tensor(input)length = torch.LongTensor([    [2,2,2,2],    [1,1,1,1],    [0,1,2,0]])#[3,4]out = torch.gather(input, dim=1, index=length)\n\ntensor([[0.2000, 0.2000, 0.2000, 0.2000],        [1.1000, 1.1000, 1.1000, 1.1000],        [2.0000, 2.1000, 2.2000, 2.0000]])\n\nå¯¹åº”çš„å–å€¼çŸ©é˜µæ˜¯\n$$\\begin{bmatrix}x_{02} &amp; x_{02} &amp; x_{02} &amp; x_{02} \\\\x_{11} &amp; x_{11} &amp; x_{11} &amp; x_{11} \\\\x_{20} &amp; x_{21} &amp; x_{22} &amp; x_{20} \\\\\\end{bmatrix}$$\n","categories":["æ·±åº¦å­¦ä¹ "],"tags":["pytorch","python"]},{"title":"Git å¸¸ç”¨å‘½ä»¤","url":"/2022/02/09/36/","content":"\n    \n\n\n\nå¼ºåˆ¶è¦†ç›–æœ¬åœ°ä»£ç ï¼ˆä¸ git è¿œç¨‹ä»“åº“ä¿æŒä¸€è‡´ï¼‰git fetch --all # æ‹‰å–æ‰€æœ‰æ›´æ–°ï¼Œä¸åŒæ­¥git reset --hard origin/master # æœ¬åœ°ä»£ç åŒæ­¥çº¿ä¸Šæœ€æ–°ç‰ˆæœ¬ï¼ˆä¼šè¦†ç›–æœ¬åœ°æ‰€æœ‰ä¸è¿œç¨‹ä»“åº“ä¸ŠåŒåçš„æ–‡ä»¶ï¼‰git pull # å†æ›´æ–°ä¸€æ¬¡\n\nPlease move or remove them before you can merge\n    \n\n\ngit clean -d -f # To remove &amp; delete all changes\n\nGit æ¨é€æœ¬åœ°åˆ†æ”¯åˆ°è¿œç«¯  è¿œç¨‹å…ˆå¼€å¥½åˆ†æ”¯ç„¶åæ‹‰åˆ°æœ¬åœ°git checkout -b =&lt;branch&gt; origin/&lt;branch&gt;\n\næœ¬åœ°å…ˆå¼€å¥½åˆ†æ”¯ç„¶åæ¨é€åˆ°è¿œç¨‹git checkout -b &lt;branch&gt; # åˆ›å»ºå¹¶åˆ‡æ¢åˆ°åˆ†æ”¯ &lt;branch&gt;  git push origin &lt;branch&gt; # æ¨é€æœ¬åœ°çš„ &lt;branch&gt; åˆ†æ”¯åˆ°è¿œç¨‹ origin çš„ &lt;branch&gt; åˆ†æ”¯\n\nGit å›æ»šä»£ç åˆ°æŸä¸ª commitgit reset --hard HEAD^ # å›é€€åˆ°ä¸Šä¸ªç‰ˆæœ¬git reset --hard HEAD~3 # å›é€€åˆ°å‰ä¸‰æ¬¡æäº¤ä¹‹å‰git reset --hard &lt;commit-id&gt; é€€åˆ° / è¿›åˆ°æŒ‡å®š &lt;commit-id&gt; çš„ hashm\n\n","categories":["æ—¥å¸¸"],"tags":["git"]},{"title":"C++ 17 æ–°ç‰¹æ€§","url":"/2022/02/22/38/","content":"\n    \n\n\n\n\næ„é€ å‡½æ•°æ¨¡æ¿æ¨å¯¼  åœ¨ C++17 å‰æ„é€ ä¸€ä¸ªæ¨¡æ¿ç±»å¯¹è±¡éœ€è¦æŒ‡æ˜ç±»å‹ï¼ŒC++17 å°±ä¸éœ€è¦ç‰¹æ®ŠæŒ‡å®šï¼Œç›´æ¥å¯ä»¥æ¨å¯¼å‡ºç±»å‹\npair&lt;int, double&gt; p(1, 2.2); // before c++17pair p(1, 2.2); // c++17 è‡ªåŠ¨æ¨å¯¼vector v = &#123;1, 2, 3&#125;; // c++17\n\nç»“æ„åŒ–ç»‘å®š if-switch è¯­å¥åˆå§‹åŒ–// if (init; condition)if (int a = GetValue()); a &lt; 101) &#123;    cout &lt;&lt; a;&#125;string str = &quot;Hi World&quot;;if (auto [pos, size] = pair(str.find(&quot;Hi&quot;), str.size()); pos != string::npos) &#123;    std::cout &lt;&lt; pos &lt;&lt; &quot; Hello, size is &quot; &lt;&lt; size;&#125;\n\nå†…è”å˜é‡C++17 å‰åªæœ‰å†…è”å‡½æ•°ï¼Œç°åœ¨æœ‰äº†å†…è”å˜é‡ï¼ŒC++ ç±»çš„é™æ€æˆå‘˜å˜é‡åœ¨å¤´æ–‡ä»¶ä¸­æ˜¯ä¸èƒ½åˆå§‹åŒ–çš„ï¼Œä½†æ˜¯æœ‰äº†å†…è”å˜é‡ï¼Œå°±å¯ä»¥è¾¾åˆ°æ­¤ç›®çš„\n// header filestruct A &#123;    static const int value;  &#125;;inline int const A::value = 10;// ========== æˆ–è€… ========struct A &#123;    inline static const int value = 10;&#125;\n\næŠ˜å è¡¨è¾¾å¼C++17 å¼•å…¥äº†æŠ˜å è¡¨è¾¾å¼ä½¿å¯å˜å‚æ•°æ¨¡æ¿ç¼–ç¨‹æ›´æ–¹ä¾¿\ntemplate &lt;typename ... Ts&gt;auto sum(Ts ... ts) &#123;    return (ts + ...);&#125;int a &#123;sum(1, 2, 3, 4, 5)&#125;; // 15std::string a&#123;&quot;hello &quot;&#125;;std::string b&#123;&quot;world&quot;&#125;;cout &lt;&lt; sum(a, b) &lt;&lt; endl; // hello world\n\nconstexpr lambdaè¡¨è¾¾å¼ C++17 å‰lambda è¡¨è¾¾å¼åªèƒ½åœ¨è¿è¡Œæ—¶ä½¿ç”¨ï¼ŒC++17 å¼•å…¥äº† constexpr lambda è¡¨è¾¾å¼ï¼Œå¯ä»¥ç”¨äºåœ¨ç¼–è¯‘æœŸè¿›è¡Œè®¡ç®—\nint main() &#123; // c++17 å¯ç¼–è¯‘    constexpr auto lamb = [] (int n) &#123; return n * n; &#125;;    static_assert(lamb(3) == 9, &quot;a&quot;);&#125;\n\n\nconstexprå‡½æ•°æœ‰å¦‚ä¸‹é™åˆ¶ï¼šå‡½æ•°ä½“ä¸èƒ½åŒ…å«æ±‡ç¼–è¯­å¥ã€goto è¯­å¥ã€labelã€try å—ã€é™æ€å˜é‡ã€çº¿ç¨‹å±€éƒ¨å­˜å‚¨ã€æ²¡æœ‰åˆå§‹åŒ–çš„æ™®é€šå˜é‡ï¼Œä¸èƒ½åŠ¨æ€åˆ†é…å†…å­˜ï¼Œä¸èƒ½æœ‰ new delete ç­‰ï¼Œä¸èƒ½æ˜¯è™šå‡½æ•°\n\nnamespaceåµŒå¥—namespace A &#123;    namespace B &#123;        namespace C &#123;            void func();        &#125;    &#125;&#125;// c++17ï¼Œæ›´æ–¹ä¾¿æ›´èˆ’é€‚namespace A::B::C &#123;    void func();)&#125;\n\n__has_includeé¢„å¤„ç†è¡¨è¾¾å¼  å¯ä»¥åˆ¤æ–­æ˜¯å¦æœ‰æŸä¸ªå¤´æ–‡ä»¶ï¼Œä»£ç å¯èƒ½ä¼šåœ¨ä¸åŒç¼–è¯‘å™¨ä¸‹å·¥ä½œï¼Œä¸åŒç¼–è¯‘å™¨çš„å¯ç”¨å¤´æ–‡ä»¶æœ‰å¯èƒ½ä¸åŒï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨æ­¤æ¥åˆ¤æ–­\n#if defined __has_include#if __has_include(&lt;charconv&gt;)#define has_charconv 1#include &lt;charconv&gt;#endifstd::optional&lt;int&gt; ConvertToInt(const std::string&amp; str) &#123;    int value&#123;&#125;;#ifdef has_charconv    const auto last = str.data() + str.size();    const auto res = std::from_chars(str.data(), last, value);    if (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) return value;#else    // alternative implementation...    å…¶å®ƒæ–¹å¼å®ç°#endif    return std::nullopt;&#125;\n\nåœ¨ lambda è¡¨è¾¾å¼ç”¨ *this æ•è·å¯¹è±¡å‰¯æœ¬  æ­£å¸¸æƒ…å†µä¸‹ï¼Œlambdaè¡¨è¾¾å¼ä¸­è®¿é—®ç±»çš„å¯¹è±¡æˆå‘˜å˜é‡éœ€è¦æ•è· thisï¼Œä½†æ˜¯è¿™é‡Œæ•è·çš„æ˜¯this æŒ‡é’ˆï¼ŒæŒ‡å‘çš„æ˜¯å¯¹è±¡çš„å¼•ç”¨ï¼Œæ­£å¸¸æƒ…å†µä¸‹å¯èƒ½æ²¡é—®é¢˜ï¼Œä½†æ˜¯å¦‚æœå¤šçº¿ç¨‹æƒ…å†µä¸‹ï¼Œå‡½æ•°çš„ä½œç”¨åŸŸè¶…è¿‡äº†å¯¹è±¡çš„ä½œç”¨åŸŸï¼Œå¯¹è±¡å·²ç»è¢«ææ„äº†ï¼Œè¿˜è®¿é—®äº†æˆå‘˜å˜é‡ï¼Œå°±ä¼šæœ‰é—®é¢˜\næ‰€ä»¥ C++17 å¢åŠ äº†æ–°ç‰¹æ€§ï¼Œæ•è· *thisï¼Œä¸æŒæœ‰this æŒ‡é’ˆï¼Œè€Œæ˜¯æŒæœ‰å¯¹è±¡çš„æ‹·è´\nstruct A &#123;    int a;    void func() &#123;        auto f = [*this] &#123; // è¿™é‡Œ            cout &lt;&lt; a &lt;&lt; endl;        &#125;;        f();    &#125;  &#125;;int main() &#123;    A a;    a.func();    return 0;&#125;\n\næ–°å¢ Attribute åœ¨é¡¹ç›®ä¸­è§è¿‡ declspecï¼Œ__attributeï¼Œ#pragma æŒ‡ç¤ºç¬¦ï¼Œä½¿ç”¨å®ƒä»¬æ¥ç»™ç¼–è¯‘å™¨æä¾›ä¸€äº›é¢å¤–çš„ä¿¡æ¯ï¼Œæ¥äº§ç”Ÿä¸€äº›ä¼˜åŒ–æˆ–ç‰¹å®šçš„ä»£ç ï¼Œä¹Ÿå¯ä»¥ç»™å…¶å®ƒå¼€å‘è€…ä¸€äº›æç¤ºä¿¡æ¯\nstruct A &#123; short f[3]; &#125; __attribute__((aligned(8)));void fatal() __attribute__((noreturn));\n\nåœ¨ C++11 å’Œ C++14 ä¸­æœ‰æ›´æ–¹ä¾¿çš„æ–¹æ³•\n\n[[carries_dependency]]è®©ç¼–è¯‘æœŸè·³è¿‡ä¸å¿…è¦çš„å†…å­˜æ …æ æŒ‡ä»¤\n[[noreturn]]å‡½æ•°ä¸ä¼šè¿”å›\n[[deprecated]]å‡½æ•°å°†å¼ƒç”¨çš„è­¦å‘Š\n[[noreturn]] void terminate() noexcept;\n[[deprecated(&quot;use new func instead&quot;)]] void func() &#123;&#125;\n\nC++17 åˆæ–°å¢äº†ä¸‰ä¸ª\n\n[[fallthrough]]ï¼šç”¨åœ¨ switch ä¸­æç¤ºå¯ä»¥ç›´æ¥è½ä¸‹å»ï¼Œä¸éœ€è¦ breakï¼Œè®©ç¼–è¯‘æœŸå¿½ç•¥è­¦å‘Š\nswitch (i) &#123;&#125;    case 1:        xxx; // warning    case 2:        xxx;         [[fallthrough]];      // è­¦å‘Šæ¶ˆé™¤    case 3:        xxx;       break;&#125;\n\nä½¿å¾—ç¼–è¯‘å™¨å’Œå…¶å®ƒå¼€å‘è€…éƒ½å¯ä»¥ç†è§£å¼€å‘è€…çš„æ„å›¾\n\n[[nodiscard]]ï¼šè¡¨ç¤ºä¿®é¥°çš„å†…å®¹ä¸èƒ½è¢«å¿½ç•¥ï¼Œå¯ç”¨äºä¿®é¥°å‡½æ•°ï¼Œæ ‡æ˜è¿”å›å€¼ä¸€å®šè¦è¢«å¤„ç†\n[[nodiscard]] int func();void F() &#123;    func(); // warning æ²¡æœ‰å¤„ç†å‡½æ•°è¿”å›å€¼&#125;\n[[maybe_unused]]ï¼šæç¤ºç¼–è¯‘å™¨ä¿®é¥°çš„å†…å®¹å¯èƒ½æš‚æ—¶æ²¡æœ‰ä½¿ç”¨ï¼Œé¿å…äº§ç”Ÿè­¦å‘Š\nvoid func1() &#123;&#125;[[maybe_unused]] void func2() &#123;&#125; // è­¦å‘Šæ¶ˆé™¤void func3() &#123;    int x = 1;    [[maybe_unused]] int y = 2; // è­¦å‘Šæ¶ˆé™¤&#125;\n\nå­—ç¬¦ä¸²è½¬æ¢   æ–°å¢from_chars å‡½æ•°å’Œ to_chars å‡½æ•°\n  #include &lt;charconv&gt;int main() &#123;    const std::string str&#123;&quot;123456098&quot;&#125;;    int value = 0;    const auto res = std::from_chars(str.data(), str.data() + 4, value);    if (res.ec == std::errc()) &#123;        cout &lt;&lt; value &lt;&lt; &quot;, distance &quot; &lt;&lt; res.ptr - str.data() &lt;&lt; endl;    &#125; else if (res.ec == std::errc::invalid_argument) &#123;        cout &lt;&lt; &quot;invalid&quot; &lt;&lt; endl;    &#125;    str = std::string(&quot;12.34);    double val = 0;    const auto format = std::chars_format::general;    res = std::from_chars(str.data(), str.data() + str.size(), value, format);    str = std::string(&quot;xxxxxxxx&quot;);    const int v = 1234;    res = std::to_chars(str.data(), str.data() + str.size(), v);    cout &lt;&lt; str &lt;&lt; &quot;, filled &quot; &lt;&lt; res.ptr - str.data() &lt;&lt; &quot; characters \\n&quot;;    // 1234xxxx, filled 4 characters&#125;\n\nstd::variantC++17 å¢åŠ  std::variant å®ç°ç±»ä¼¼ union çš„åŠŸèƒ½ï¼Œä½†å´æ¯” union æ›´é«˜çº§ï¼Œä¸¾ä¸ªä¾‹å­ union é‡Œé¢ä¸èƒ½æœ‰ string è¿™ç§ç±»å‹ï¼Œä½† std::variant å´å¯ä»¥ï¼Œè¿˜å¯ä»¥æ”¯æŒæ›´å¤šå¤æ‚ç±»å‹ï¼Œå¦‚ map ç­‰\nint main() &#123; // c++17 å¯ç¼–è¯‘    std::variant&lt;int, std::string&gt; var(&quot;hello&quot;);    cout &lt;&lt; var.index() &lt;&lt; endl;    var = 123;    cout &lt;&lt; var.index() &lt;&lt; endl;    try &#123;        var = &quot;world&quot;;        std::string str = std::get&lt;std::string&gt;(var); // é€šè¿‡ç±»å‹è·å–å€¼        var = 3;        int i = std::get&lt;0&gt;(var); // é€šè¿‡ index è·å–å¯¹åº”å€¼        cout &lt;&lt; str &lt;&lt; endl;        cout &lt;&lt; i &lt;&lt; endl;    &#125; catch(...) &#123;        // xxx;    &#125;    return 0;&#125;\n\n\nä¸€èˆ¬æƒ…å†µä¸‹ variant çš„ç¬¬ä¸€ä¸ªç±»å‹ä¸€èˆ¬è¦æœ‰å¯¹åº”çš„æ„é€ å‡½æ•°ï¼Œå¦åˆ™ç¼–è¯‘å¤±è´¥\n\n\nstruct A &#123;    A(int i)&#123;&#125;  &#125;;int main() &#123;    std::variant&lt;A, int&gt; var; // ç¼–è¯‘å¤±è´¥&#125;\n\nå¯ä»¥ä½¿ç”¨ std::monostate æ¥æ‰“ä¸ªæ¡©ï¼Œæ¨¡æ‹Ÿä¸€ä¸ªç©ºçŠ¶æ€\nstd::variant&lt;std::monostate, A&gt; var; // å¯ä»¥ç¼–è¯‘æˆåŠŸ\n\nstd::optionalæœ‰æ—¶å€™å¯èƒ½ä¼šæœ‰éœ€æ±‚ï¼Œè®©å‡½æ•°è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œå¦‚ä¸‹ï¼š\nstruct A &#123;&#125;;A func() &#123;    if (flag) return A();    else &#123;        // å¼‚å¸¸æƒ…å†µä¸‹ï¼Œæ€ä¹ˆè¿”å›å¼‚å¸¸å€¼å‘¢ï¼Œæƒ³è¿”å›ä¸ªç©ºå‘¢    &#125;&#125;\n\næœ‰ä¸€ç§åŠæ³•æ˜¯è¿”å›å¯¹è±¡æŒ‡é’ˆï¼Œå¼‚å¸¸æƒ…å†µä¸‹å°±å¯ä»¥è¿”å›nullptrï¼Œä½†æ˜¯è¿™å°±æ¶‰åŠåˆ°äº†å†…å­˜ç®¡ç†ï¼Œä¹Ÿè®¸ä¼šä½¿ç”¨æ™ºèƒ½æŒ‡é’ˆï¼Œä½†è¿™é‡Œå…¶å®æœ‰æ›´æ–¹ä¾¿çš„åŠæ³•å°±æ˜¯std::optional\nstd::optional&lt;int&gt; StoI(const std::string &amp;s) &#123;    try &#123;        return std::stoi(s);    &#125; catch(...) &#123;        return std::nullopt;    &#125;&#125;void func() &#123;    std::string s&#123;&quot;123&quot;&#125;;    std::optional&lt;int&gt; o = StoI(s);    if (o) &#123;        cout &lt;&lt; *o &lt;&lt; endl;    &#125; else &#123;        cout &lt;&lt; &quot;error&quot; &lt;&lt; endl;    &#125;&#125;\n\nstd::anyC++17 å¼•å…¥äº† any å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„å•ä¸ªå€¼\nint main() &#123; // c++17 å¯ç¼–è¯‘    std::any a = 1;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;int&gt;(a) &lt;&lt; endl;    a = 2.2f;    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;float&gt;(a) &lt;&lt; endl;    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a.reset();    if (a.has_value()) &#123;        cout &lt;&lt; a.type().name();    &#125;    a = std::string(&quot;a&quot;);    cout &lt;&lt; a.type().name() &lt;&lt; &quot; &quot; &lt;&lt; std::any_cast&lt;std::string&gt;(a) &lt;&lt; endl;    return 0;&#125;\n\nstd::applyä½¿ç”¨ std::apply å¯ä»¥å°† tuple å±•å¼€ä½œä¸ºå‡½æ•°çš„å‚æ•°ä¼ å…¥\nint add(int first, int second) &#123; return first + second; &#125;auto add_lambda = [](auto first, auto second) &#123; return first + second; &#125;;int main() &#123;    std::cout &lt;&lt; std::apply(add, std::pair(1, 2)) &lt;&lt; &#x27;\\n&#x27;;    std::cout &lt;&lt; add(std::pair(1, 2)) &lt;&lt; &quot;\\n&quot;; // error    std::cout &lt;&lt; std::apply(add_lambda, std::tuple(2.0f, 3.0f)) &lt;&lt; &#x27;\\n&#x27;;&#125;\n\nstd::make_from_tupleä½¿ç”¨ make_from_tuple å¯ä»¥å°† tuple å±•å¼€ä½œä¸ºæ„é€ å‡½æ•°å‚æ•°\nstruct Foo &#123;    Foo(int first, float second, int third) &#123;        std::cout &lt;&lt; first &lt;&lt; &quot;, &quot; &lt;&lt; second &lt;&lt; &quot;, &quot; &lt;&lt; third &lt;&lt; &quot;\\n&quot;;    &#125;&#125;;int main() &#123;   auto tuple = std::make_tuple(42, 3.14f, 0);   std::make_from_tuple&lt;Foo&gt;(std::move(tuple));&#125;\n\nstd::string_viewé€šå¸¸ä¼ é€’ä¸€ä¸ª string æ—¶ä¼šè§¦å‘å¯¹è±¡çš„æ‹·è´æ“ä½œï¼Œå¤§å­—ç¬¦ä¸²çš„æ‹·è´èµ‹å€¼æ“ä½œä¼šè§¦å‘å †å†…å­˜åˆ†é…ï¼Œå¾ˆå½±å“è¿è¡Œæ•ˆç‡ï¼Œæœ‰äº† string_view å°±å¯ä»¥é¿å…æ‹·è´æ“ä½œï¼Œå¹³æ—¶ä¼ é€’è¿‡ç¨‹ä¸­ä¼ é€’ string_view å³å¯\nvoid func(std::string_view stv) &#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;int main(void) &#123;    std::string str = &quot;Hello World&quot;;    std::cout &lt;&lt; str &lt;&lt; std::endl;    std::string_view stv(str.c_str(), str.size());    cout &lt;&lt; stv &lt;&lt; endl;    func(stv);    return 0;&#125;\n\nas_constC++17 ä½¿ç”¨ as_const å¯ä»¥å°†å·¦å€¼è½¬æˆ const ç±»å‹\nstd::string str = &quot;str&quot;;const std::string&amp; constStr = std::as_const(str);\n\nfile_systemC++17 æ­£å¼å°† file_system çº³å…¥æ ‡å‡†ä¸­ï¼Œæä¾›äº†å…³äºæ–‡ä»¶çš„å¤§å¤šæ•°åŠŸèƒ½\nnamespace fs = std::filesystem;fs::create_directory(dir_path);fs::copy_file(src, dst, fs::copy_options::skip_existing);fs::exists(filename);fs::current_path(err_code);\n\nstd::shared_mutexC++17 å¼•å…¥äº†shared_mutexï¼Œå¯ä»¥å®ç°è¯»å†™é”\n","categories":["C++"],"tags":["C++","C++ 17"]},{"title":"å°è¯• Visual Code è°ƒè¯• Lua","url":"/2022/07/27/41/","content":"namespace LuaTools&#123;    static class LuaDebugWithVsCode    &#123;        public static void Debug()        &#123;            IMLua luaEngine = MInterfaceMgr.singleton.GetInterface&lt;IMLua&gt;(MCommonFunctions.GetHash(&quot;MLua&quot;));            if (luaEngine != null)            &#123;                var str = string.Format(@&quot;local func = function()                local path = &quot;&quot;C:/Users/mingzhewang/.vscode/extensions/tangzx.emmylua-0.5.5/debugger/emmy/windows/x64/emmy_core.dll&quot;&quot;                package.cpath = package.cpath..&quot;&quot;;&quot;&quot;..path                local dbg = require(&quot;&quot;emmy_core&quot;&quot;)                dbg.tcpConnect(&quot;&quot;localhost&quot;&quot;, 9966)                end            local handle = function()                logError(&quot;&quot;VS Code æ²¡æœ‰å¼€å¯è°ƒè¯• &quot;&quot;)            end            xpcall(func, handle)&quot;);                luaEngine.DoString(str);            &#125;            else            &#123;                EditorUtility.DisplayDialog(&quot;LuaFast Execute Failed!&quot;, &quot; è·å– luaEngine å¤±è´¥ &quot;, &quot;OK&quot;);            &#125;        &#125;    &#125;&#125;\n","categories":["æ—¥å¸¸"],"tags":["è°ƒè¯• Lua","Visual Code"]},{"title":"é¢†åŸŸé©±åŠ¨è®¾è®¡","url":"/2022/03/07/39/","content":"\n    \n\n\n\n\nDomain Primitive (DP)","categories":["è½¯ä»¶å·¥ç¨‹"],"tags":["DDD","è®¾è®¡"]},{"title":"æ¸²æŸ“ç®¡çº¿","url":"/2021/11/05/4/","content":"\n\nåº”ç”¨é˜¶æ®µ  å‡†å¤‡å¥½åœºæ™¯æ•°æ®ï¼ŒåŒ…æ‹¬ Camera çš„ä½ç½®ã€æœå‘ï¼Œè§†é”¥ä½“ï¼Œåœºæ™¯ç‰©ä»¶ã€å…‰æºä¿¡æ¯ï¼Œæ¸²æŸ“å¯¹è±¡çš„æ¸²æŸ“çŠ¶æ€å‡†å¤‡åŒ…æ‹¬æè´¨ã€çº¹ç†ã€Shader ç­‰åŸºæœ¬ä¿¡æ¯ï¼Œè°ƒç”¨æ¸²æŸ“å›¾å…ƒçš„æŒ‡ä»¤ã€‚\n\næŠŠæ•°æ®åŠ è½½åˆ°æ˜¾å­˜\nè®¾ç½®æ¸²æŸ“çŠ¶æ€\nè°ƒç”¨ DrawCall\n\nå‡ ä½•é˜¶æ®µ  ä¼ å…¥é¡¶ç‚¹æ•°æ®ï¼Œç»è¿‡é¡¶ç‚¹ç€è‰²å™¨ã€æ›²é¢ç»†åˆ†ç€è‰²å™¨ã€å‡ ä½•ç€è‰²å™¨ã€ä¸‰è§’å½¢è£å‰ªã€å±å¹•æ˜ å°„ã€‚\n\né¡¶ç‚¹ç€è‰²å™¨ï¼šæ“ä½œé¡¶ç‚¹ï¼Œå¯ç¼–ç¨‹ã€‚ä¸»è¦æ˜¯åæ ‡å˜æ¢å’Œé€é¡¶ç‚¹å…‰ç…§ï¼Œè¾“å‡ºåç»­é˜¶æ®µéœ€è¦çš„æ•°æ®ï¼Œä»æ¨¡å‹ç©ºé—´åˆ°é½æ¬¡è£å‰ªç©ºé—´ã€‚\næ›²é¢ç»†åˆ†ç€è‰²å™¨ã€å‡ ä½•ç€è‰²å™¨ï¼šç›®å‰åœ¨æ‰‹æœºä¸Šæ”¯æŒä¸æ˜¯å¾ˆå¥½ï¼Œæ‰‹æœºæ¸²æŸ“åŸºæœ¬ä¸Šä¸èƒ½ç”¨ã€‚\nä¸‰è§’å½¢è£å‰ªï¼šæŠŠé‚£äº›ä¸åœ¨æ‘„åƒæœºè§†é‡èŒƒå›´å†…çš„é¡¶ç‚¹è£å‰ªæ‰ï¼Œå¹¶å‰”é™¤æ‰ä¸åœ¨å±å¹•èŒƒå›´å†…çš„é¡¶ç‚¹ã€‚è¿™ä¸ªè¿‡ç¨‹å¯é…ç½®ã€‚\nå±å¹•æ˜ å°„ï¼šæŠŠå›¾å…ƒçš„é¡¶ç‚¹åæ ‡è½¬åŒ–ä¸ºå±å¹•åæ ‡ç³»çš„äºŒç»´åæ ‡ï¼Œè¾“å…¥çš„æ˜¯ä¸‰ç»´åæ ‡ï¼ˆå½’ä¸€åŒ–çš„ NDC åæ ‡ï¼‰ã€‚\n\nå…‰æ …åŒ–é˜¶æ®µ  å…‰æ …åŒ–é˜¶æ®µçš„ç›®çš„æœ‰ä¸¤ä¸ªï¼šâ‘ è®¡ç®—æ¯ä¸ªå›¾å…ƒè¦†ç›–äº†é‚£äº›åƒç´ ï¼Œâ‘¡ä¸ºè¿™äº›åƒç´ è®¡ç®—ä»–ä»¬çš„é¢œè‰²ã€‚\n\nä¸‰è§’å½¢è®¾ç½®ï¼šä¸Šä¸€ä¸ªé˜¶æ®µï¼Œæˆ‘ä»¬å·²ç»æ‹¿åˆ°äº†å›¾å…ƒé¡¶ç‚¹çš„å±å¹•äºŒç»´åæ ‡ï¼ŒåŒ…æ‹¬é¡¶ç‚¹æ³•çº¿ã€æ·±åº¦å€¼ã€è§†è§’æ–¹å‘ç­‰ä¿¡æ¯ï¼Œæ ¹æ®è¿™äº›ä¿¡æ¯ï¼Œæˆ‘ä»¬æ¥è®¡ç®—å…‰æ …åŒ–ä¸€ä¸ªä¸‰è§’å½¢æ‰€éœ€è¦çš„ä¿¡æ¯ï¼Œæ¯”å¦‚è¯¥ä¸‰è§’å½¢åŒ…å«é‚£äº›åƒç´ ç‚¹ç­‰ã€‚\nä¸‰è§’å½¢éå†ï¼šåœ¨è¿™ä¸ªé˜¶æ®µä¼šæ£€æµ‹æ¯ä¸ªåƒç´ çš„ä¸­å¿ƒï¼ˆæˆ–è€…è¯´æ¯ä¸ªé‡‡æ ·ç‚¹ï¼‰æ˜¯å¦è¢«ä¸‰è§’å½¢è¦†ç›–ï¼Œåƒç´ ä¸­ä¸‰è§’å½¢è¦†ç›–çš„éƒ¨åˆ†ä¼šç”Ÿæˆä¸€ä¸ª fragmentï¼Œè€Œå¯»æ‰¾é‡‡æ ·ç‚¹æˆ–è€…åƒç´ ä½äºå“ªä¸ªä¸‰è§’å½¢ä¸Šï¼Œè¿™ä¸€è¿‡ç¨‹è¢«ç§°ä¸ºä¸‰è§’å½¢éå†ã€‚è€Œä¸‰è§’å½¢ä¸­æˆ‘ä»¬æ‰€ç”Ÿæˆçš„æ¯ä¸€ä¸ªfragmentï¼Œå…¶å±æ€§éƒ½ç”±ä¸‰è§’å½¢çš„é¡¶ç‚¹æ’å€¼è€Œæ¥ã€‚è¿™äº›å±æ€§åŒ…æ‹¬fragment çš„æ·±åº¦å’Œä»å‡ ä½•é˜¶æ®µä¼ è¾“æ¥çš„å…¶ä»–ç€è‰²æ•°æ®\nç‰‡å…ƒç€è‰²å™¨ï¼šå¯ç¼–ç¨‹ï¼Œä½œç”¨æ˜¯å¤„ç†ä¸Šä¸€ä¸ªé˜¶æ®µç”Ÿæˆçš„æ¯ä¸ªç‰‡å…ƒï¼Œæœ€ç»ˆè®¡ç®—å‡ºæ¯ä¸ªåƒç´ çš„æœ€ç»ˆé¢œè‰²ã€‚å®é™…ä¸Šå°±æ˜¯æ•°æ®çš„é›†åˆã€‚è¿™ä¸ªæ•°æ®é›†åˆåŒ…å«æ¯ä¸ªåƒç´ çš„å„ä¸ªé¢œè‰²åˆ†é‡å’Œåƒç´ é€æ˜åº¦çš„å€¼ã€‚\né€ç‰‡å…ƒæ“ä½œï¼šä¿®æ”¹é¢œè‰²ï¼Œä¿®æ”¹æ·±åº¦ï¼Œæ··åˆ\nå±å¹•å›¾åƒ\n\n\n\né¡¶ç‚¹æ•°æ®  ä¸€ä¸ªæ¨¡å‹æˆ–è€…å›¾å½¢æ˜¯ç”±ç‚¹çº¿é¢æ„æˆçš„ï¼Œä¸ºäº†è®©è®¡ç®—æœºç»˜åˆ¶å‡ºè¿™ä¸ªå›¾å½¢ï¼Œå°±å¿…é¡»å‘Šè¯‰è®¡ç®—æœºè¿™äº›æ•°æ®çš„å€¼ï¼Œé¡¶ç‚¹æ•°æ®åŒ…æ‹¬é¡¶ç‚¹åæ ‡ã€åæ ‡çš„æ³•çº¿ã€åæ ‡çš„åˆ‡çº¿ã€é¢œè‰²ç­‰ä¿¡æ¯ã€‚ å¯¹äº OpenGLï¼Œè¿™äº›æ•°æ®ä¸€èˆ¬éƒ½æ˜¯å‘é‡ç»“æ„ä½“ã€‚å¯¹äºæ¸¸æˆå¼•æ“ï¼Œè¿™äº›æ•°æ®æ¥è‡ªå¯¼å…¥çš„æ¨¡å‹ä¸­ã€‚åœ¨å¼€å§‹æ¸²æŸ“ä¹‹å‰ï¼ŒCPU ä¼šè·å–è¿™äº›æ•°æ®ï¼Œç„¶åä¼ é€’ç»™ GPUï¼Œä½œä¸ºæœ€åŸå§‹æ•°æ®ï¼Œåšå¥½è®¡ç®—å‡†å¤‡ã€‚\né¡¶ç‚¹ç€è‰²å™¨  é¡¶ç‚¹ç€è‰²å™¨ï¼ˆvertex shaderï¼‰ åœ¨æ¸²æŸ“ç®¡çº¿ä¸­çš„ä½œç”¨éå¸¸å¤§ï¼Œæ˜¯æ¸²æŸ“ç®¡çº¿çš„ç¬¬ä¸€ä¸ªå¯ç¼–ç¨‹ç€è‰²å™¨ã€‚å¤„ç†å•å…ƒæ˜¯é¡¶ç‚¹æ•°æ®ã€‚é¡¶ç‚¹ç€è‰²å™¨çš„ä¸»è¦åŠŸèƒ½æ˜¯å¯¹åæ ‡è¿›è¡Œå˜æ¢ã€‚å°†è¾“å…¥çš„å±€éƒ¨å·¦è¾¹å˜æ¢åˆ°ä¸–ç•Œåæ ‡ã€è§‚å¯Ÿåæ ‡å’Œè£å‰ªåæ ‡ã€‚ é™¤æ­¤ä¹‹å¤–å½“ç„¶ä¹Ÿå¯ä»¥è¿›è¡Œå…‰ç…§ç€è‰²ï¼Œä½†æ˜¯ç€è‰²æ•ˆæœè¿œä¸å¦‚åœ¨ç‰‡å…ƒç€è‰²å™¨ä¸­è¿›è¡Œå…‰ç…§ç€è‰²ï¼Œå› ä¸ºè®¡ç®—é‡è¾ƒå°ã€‚\nå›¾å…ƒè£…é…  å›¾å…ƒè£…é…ï¼ˆprimitive assemblyï¼‰æ˜¯å¯¹ä¼ å…¥çš„é¡¶ç‚¹æ•°æ®è¿›è¡Œé‡æ–°ç»„è£…ï¼Œå°†é¡¶ç‚¹ç€è‰²å™¨çš„è¾“å‡ºä½œä¸ºè¾“å…¥ã€‚ è¿™ä¸€ç‚¹æ­£éªŒè¯äº†æ¸²æŸ“çš„è¿‡ç¨‹æ˜¯ä»¥æµæ°´çº¿çš„å½¢å¼è¿›è¡Œçš„ï¼Œå›¾å…ƒè£…é…ä¼šå°†é¡¶ç‚¹è£…é…æˆæŒ‡å®šçš„å›¾å½¢ï¼Œä¸æ­¤åŒæ—¶ï¼Œä¼šè¿›è¡Œè£å‰ªã€è¡¨é¢å‰”é™¤ç­‰æ“ä½œï¼Œä»¥å‡å°‘ä¸å¿…è¦çš„è®¡ç®—ï¼ŒåŠ é€Ÿæ¸²æŸ“è¿‡ç¨‹ã€‚\nå‡ ä½•ç€è‰²å™¨  å‡ ä½•ç€è‰²å™¨ï¼ˆgeometry shaderï¼‰ä¼šå°†å›¾å…ƒè£…é…é˜¶æ®µçš„æ•°æ®ä½œä¸ºè¾“å…¥æ•°æ®ã€‚å‡ ä½•ç€è‰²å™¨å±äºä¸å¯ç¼–ç¨‹é˜¶æ®µï¼Œç”±ç¡¬ä»¶è®¾å¤‡è‡ªåŠ¨å®Œæˆï¼Œ å…¶é‡è¦ä½œç”¨æ˜¯å¯¹é¡¶ç‚¹æ•°æ®è¿›è¡Œé‡æ„ï¼Œ å¯ä»¥åœ¨æ­¤é˜¶æ®µäº§ç”Ÿæ–°çš„é¡¶ç‚¹æ•°æ®ï¼Œæ¥å¼¥è¡¥ä¹‹å‰å­˜åœ¨çš„ä¸€äº›é—®é¢˜ã€‚ä»¥ä¾¿ä¸ºæ¥ä¸‹æ¥è¦è¿›è¡Œçš„æ“ä½œåšå¥½å……åˆ†çš„å‡†å¤‡å·¥ä½œã€‚\nå…‰æ …åŒ–  å…‰æ …åŒ–é˜¶æ®µï¼ˆrasterization stageï¼‰çš„æ•°æ®è¾“å…¥æ¥è‡ªå‡ ä½•ç€è‰²å™¨çš„è¾“å‡ºæ•°æ®ï¼Œä¸ºäº†å®ç°é¡¶ç‚¹åˆ°å±å¹•åƒç´ çš„æ˜ å°„ã€‚ å…‰æ …åŒ–çš„ä½œç”¨å°±æ˜¯å°†ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´ç¼ºå°‘çš„åƒç´ ç‚¹é€šè¿‡æ’å€¼çš„å½¢å¼è¿›è¡Œè¡¥å……ï¼Œç”Ÿæˆç‰‡å…ƒç€è‰²å™¨å¯ä»¥å¤„ç†çš„ç‰‡æ®µã€‚æ­¤é˜¶æ®µç”±ç¡¬ä»¶å®Œæˆæ’å€¼æç«¯ã€‚åœ¨æ’å€¼çš„è¿‡ç¨‹ä¸­ï¼Œä¼šå°†ä¸å¯è§çš„é¡¶ç‚¹è¿›è¡Œå‰”é™¤ã€‚\nç‰‡å…ƒç€è‰²å™¨  ç‰‡å…ƒç€è‰²å™¨å¤„ç†çš„å¯¹è±¡æ˜¯åƒç´ ç‚¹çš„é¢œè‰²ä¿¡æ¯ï¼Œä¹Ÿæ˜¯æœ€ç»ˆæ˜¾ç¤ºåœ¨å±å¹•ä¸Šçš„åƒç´ ç‚¹ï¼Œåœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œå¯ä»¥å¤„ç†å…‰ç…§å’Œé˜´å½±è®¡ç®—ï¼Œå°†å¤„ç†å®Œçš„å€¼ä¿å­˜è‡³ç¼“å†²åŒºä¸­ã€‚\næ··åˆå¤„ç†é˜¶æ®µ  æ··åˆå¤„ç†é˜¶æ®µå±äºå±å¹•åæœŸæ¢³ç†èŒƒå›´ï¼Œè¿™æ„å‘³ç€æ­¤é˜¶æ®µä¸»è¦åšçš„ä»»åŠ¡ä¸ºå±å¹•ä¼˜åŒ–æ“ä½œï¼Œé€šè¿‡ç‰‡å…ƒç€è‰²å™¨å¾—åˆ°çš„åƒç´ ï¼Œæœ‰äº›ä¸èƒ½è¢«æ˜¾ç¤ºå‡ºæ¥ï¼Œæ¯”å¦‚é€æ˜åº¦ä¸º 0 çš„åƒç´ ç‚¹ï¼Œå¯¹äºè¿™ç±»åƒç´ ç‚¹ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œæµ‹è¯•ï¼Œæµ‹è¯•çš„èŒƒå›´åŒ…æ‹¬ Alpha æµ‹è¯•ã€æ¨¡æ¿æµ‹è¯•å’Œæ·±åº¦æµ‹è¯•ç­‰ã€‚ä¸èƒ½é€šè¿‡æµ‹è¯•çš„åƒç´ ç‚¹å°†ä¼šè¢«ä¸¢å¼ƒï¼Œå°±ä¸ä¼šå‚ä¸æ¥ä¸‹æ¥çš„æ“ä½œï¼›é€šè¿‡æµ‹è¯•çš„åƒç´ ä¼šè¿›å…¥æ··åˆé˜¶æ®µã€‚æ··åˆé˜¶æ®µä¸»è¦æ˜¯å¤„ç†é€æ˜ç‰©ä½“ï¼Œæ··åˆé˜¶æ®µä¸éœ€è¦è¿›è¡Œç¼–ç¨‹ï¼Œä½†æ˜¯å¸¸è§çš„æ¸²æŸ“ç®¡çº¿æ¥å£ä¼šå¼€æ”¾åˆä¸€äº›å‚æ•°ç»™ç¨‹åºå‘˜åšè°ƒæ•´ã€‚\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics"]},{"title":"Shader Variant","url":"/2022/08/06/42/","content":"åŸºç¡€çŸ¥è¯†  ä»€ä¹ˆæ˜¯ Shader Variantåœ¨å†™ Shader æ—¶ï¼Œå¾€å¾€ä¼šåœ¨ Shader ä¸­å®šä¹‰å¤šä¸ªå®ï¼Œå¹¶åœ¨ Shader ä»£ç ä¸­æ§åˆ¶å¼€å¯å®æˆ–å…³é—­å®æ—¶ç‰©ä½“çš„æ¸²æŸ“è¿‡ç¨‹ã€‚æœ€ç»ˆç¼–è¯‘çš„æ—¶å€™ä¹Ÿæ˜¯æ ¹æ®è¿™äº›ä¸åŒçš„å®æ¥ç¼–è¯‘ç”Ÿæˆå¤šç§ç»„åˆå½¢å¼çš„ Shader æºç ã€‚å…¶ä¸­æ¯ä¸€ç§ç»„åˆå°±æ˜¯è¿™ä¸ª Shader çš„ä¸€ä¸ª  å˜ä½“\nMaterial Shader Keywords ä¸ Shader VariantMaterial æ‰€åŒ…å«çš„ Shader Keywords è¡¨ç¤ºå¯ç”¨ Shader ä¸­å¯¹åº”çš„å®ï¼ŒUnity ä¼šè°ƒç”¨å½“å‰å®ç»„åˆæ‰€å¯¹åº”çš„å˜ä½“æ¥ä¸º Material è¿›è¡Œæ¸²æŸ“\n\n\nåœ¨ Editor ä¸‹ï¼Œå¯ä»¥é€šè¿‡å°† Material çš„ Inspector è°ƒæˆ Debug æ¨¡å¼æ¥æŸ¥çœ‹å½“å‰ Material å®šä¹‰çš„ Keywordsï¼Œä¹Ÿå¯ä»¥åœ¨æ­¤æ¨¡å¼ä¸‹ç›´æ¥å®šä¹‰ Keywordsï¼Œç”¨ç©ºæ ¼åˆ†éš” Keyword\nåœ¨ä»£ç ä¸­ï¼Œå¯ç”¨ Material.EnableKeyword()ã€Material.DisableKeyword()ã€Shader.EnableKeyword()ã€Shader.DisableKeyword() æ¥å¯ç”¨ / ç¦ç”¨ç›¸åº”çš„å®\nEnableå‡½æ•°åº”ä¸ Disable å‡½æ•°ç›¸å¯¹åº”ã€‚è‹¥ä¸€ä¸ªå®ç”± Material.EnableKeyword() å¼€å¯ï¼Œåˆ™åº”ç”± Material.DisableKeyword() å…³é—­ï¼ŒShader.DisableKeyword()æ— æ³•å…³é—­è¿™ä¸ªå®\n\n\nmulti_compileä¸ shader_featuremulti_compile çš„ç”¨æ³•è§£æ#paragma multi_compile OFF ON\n\nè¡¨ç¤ºå®šä¹‰äº†ä¸¤ä¸ªå˜ä½“ï¼ŒOFFå’Œ ONã€‚åœ¨è¿è¡Œæ—¶ï¼Œå…¶ä¸­çš„ä¸€ä¸ªå°†è¢«æ¿€æ´»ï¼Œæ ¹æ®æè´¨æˆ–è€…å…¨å±€ç€è‰²å™¨å…³é”®å­—ï¼ˆ#ifdef OFF ä¹‹ç±»çš„å®å‘½ä»¤ä¹Ÿå¯ä»¥ï¼‰æ¥ç¡®å®šæ¿€æ´»å“ªä¸ªã€‚è‹¥ä¸¤ä¸ªå…³é”®è¯éƒ½æ²¡æœ‰å¯ç”¨ï¼Œé‚£ä¹ˆå°†é»˜è®¤ä½¿ç”¨å‰ä¸€ä¸ªé€‰é¡¹ï¼Œä¹Ÿå°±æ˜¯OFFã€‚\nä¹Ÿå¯ä»¥åŒæ—¶åˆ›å»ºå¤šä¸ªå˜ä½“ï¼š\n#paragma multi_compile A B C\n\nè¿˜å¯ä»¥ä½¿ç”¨å¤šè¡ŒæŒ‡ä»¤å¯¹å˜ä½“è¿›è¡Œç»„åˆï¼Œä½†æ˜¯è¿™æ ·åšçš„è¯ï¼Œä¼šå¯¼è‡´å˜ä½“æ•°é‡æˆå€çš„å¢é•¿ï¼Œå¦‚æœä½¿ç”¨ä¸‹é¢çš„ä»£ç ç”Ÿæˆå˜ä½“ï¼Œä¼šå¾—åˆ°  ä¸­ä¸åŒçš„å˜ä½“ï¼š\n#paragma multi_compile A B C#paragma multi_compile D E\n\nshader_featureç”¨æ³•ç®€æ shader_feature çš„ç”¨æ³•ä¸ multi_compile å¤§è‡´ç›¸åŒï¼Œå”¯ä¸€çš„åŒºåˆ«åœ¨äº shader_feature ä¸ä¼šå°†ä¸ç”¨çš„ Shader å˜ä½“æ·»åŠ åˆ°ç¨‹åºä¸­å»ã€‚shader_featureæ›´é€‚ç”¨äºæè´¨çš„å…³é”®å­—ï¼Œè€Œ multi_compile æ›´é€‚ç”¨äºä»£ç çš„å…¨å±€å…³é”®å­—\n#paragma shader_feature A\n\n\nå…¶å® #paragma shader_feature A æ˜¯#paragma shader_feature _ Açš„ç®€å†™ï¼Œä¸‹åˆ’çº¿è¡¨ç¤ºæœªå®šä¹‰å®ï¼ˆNoKeywordï¼‰ã€‚å› æ­¤æ­¤æ—¶ Shader å…¶å®å¯¹åº”äº†ä¸¤ä¸ªå˜ä½“ï¼Œä¸€ä¸ªæ˜¯ NoKeywordï¼Œä¸€ä¸ªæ˜¯å®šä¹‰äº†å® Aã€‚è€Œ#paragma multi_compile A å¹¶ä¸å­˜åœ¨ç®€å†™è¿™ä¸€è¯´ï¼Œæ‰€ä»¥ Shader æ­¤æ—¶åªå¯¹åº” A è¿™ä¸ªå˜ä½“ã€‚è‹¥è¦è¡¨ç¤ºæœªå®šä¹‰ä»»ä½•å˜ä½“ï¼Œåˆ™åº”å†™ä¸º#paragma multi_compile _ A\n\nå¦‚ä½•æ§åˆ¶é¡¹ç›®ä¸­ Shader å˜ä½“çš„ç”Ÿæˆ\n\n\nç”Ÿæˆæ–¹å¼\nä¼˜ç‚¹\nç¼ºç‚¹\n\n\n\nShader ä¸æè´¨æ‰“åœ¨ä¸€ä¸ªåŒ…ä¸­\nå˜ä½“æ ¹æ®æè´¨ä¸­çš„ keywords è‡ªåŠ¨ç”Ÿæˆ\nå¤šä¸ªä¸åŒçš„æè´¨åŒ…ä¸­å¯èƒ½å­˜åœ¨ç›¸åŒçš„ Shader å˜ä½“ï¼Œé€ æˆèµ„æºå†—ä½™  è‹¥åœ¨ç¨‹åºè¿è¡Œæ—¶åŠ¨æ€æ”¹å˜æè´¨çš„ keywordï¼Œä½¿ç”¨ shader_feature å®šä¹‰çš„å®ï¼Œå…¶å˜ä½“å¯èƒ½å¹¶æ²¡æœ‰è¢«ç”Ÿæˆ\n\n\nShader å•ç‹¬æ‰“åŒ…ï¼Œä½¿ç”¨ multi_compile å®šä¹‰å…¨éƒ¨å®\nå…¨éƒ¨å˜ä½“éƒ½è¢«ç”Ÿæˆï¼Œä¸ä¼šå‘ç”Ÿéœ€è¦çš„å˜ä½“æœªç”Ÿæˆçš„æƒ…å†µ\nç”Ÿæˆçš„å˜ä½“æ•°é‡åºå¤§ï¼Œä¸¥é‡æµªè´¹èµ„æº\n\n\nShader å•ç‹¬æ‰“åŒ…ï¼Œshader_featureï¼ˆéœ€è¦ä½¿ç”¨ ShaderVariantCollection ç”Ÿæˆå˜ä½“ï¼‰ä¸multi_compileï¼ˆè¿˜æ˜¯ä¼šç”Ÿæˆæ‰€æœ‰å˜ä½“ï¼‰ç»“åˆä½¿ç”¨\nèƒ½å¤Ÿæœ‰æ•ˆæ§åˆ¶ shader_feature å˜ä½“æ•°é‡\nå¦‚ä½•ç¡®å®šå“ªäº›å˜ä½“éœ€è¦ç”Ÿæˆ  å®¹æ˜“é—æ¼éœ€è¦ç”Ÿæˆçš„å˜ä½“ï¼Œç‰¹åˆ«æ˜¯éœ€è¦åŠ¨æ€æ›¿æ¢çš„å˜ä½“\n\n\nä½¿ç”¨ shader_feature çš„è§£å†³æ–¹æ¡ˆï¼šShaderVariantCollectionShaderVariantCollection ä»‹ç» ShaderVariantCollection çš„å…¶ä¸­ä¸€ä¸ªä½œç”¨å°±æ˜¯ç”¨æ¥è®°å½• Shader ä¸­ä½¿ç”¨shader_feature å®šä¹‰çš„å®äº§ç”Ÿçš„å˜ä½“ã€‚èƒ½å¤Ÿè®¾ç½®ç”Ÿæˆä»»ä½•å˜ä½“ï¼Œä»è€Œé¿å…ç”Ÿæˆä¸å¿…è¦çš„å˜ä½“ï¼›Shader ä¸å¿…å’Œæè´¨æ‰“åœ¨ä¸€ä¸ªåŒ…ä¸­ï¼Œé¿å…äº†å¤šä¸ªåŒ…ä¸­å­˜åœ¨ç›¸åŒçš„å˜ä½“èµ„æºï¼›æ˜ç¡®ç›´è§‚çš„æ˜¾ç¤ºäº†å“ªäº›å˜ä½“æ˜¯éœ€è¦ç”Ÿæˆçš„ã€‚\n\nåœ¨ Unity ä¸­å¯ä»¥é€šè¿‡ Create-&gt;Shader-&gt;Shader Variant Collectionï¼Œå°±å¯ä»¥æ–°å»ºä¸€ä¸ª ShaderVariantCollection æ–‡ä»¶\n\nShaderVariantCollection ç”Ÿæˆé€šè¿‡ shader_feature å®šä¹‰çš„å˜ä½“è§„åˆ™\nå¿…å®šç”Ÿæˆé¦–ä¸ªå®å®šä¹‰å¼€å¯æ‰€å¯¹åº”çš„å˜ä½“\n\npragma shader_feature Aï¼šé™¤äº†ç”Ÿæˆ A çš„å˜ä½“ï¼Œnokeyword æ‰€å¯¹åº”çš„å˜ä½“ä¹Ÿä¼šè¢«ç”Ÿæˆ\npragma shader_feature A B Cï¼šShaderVariantCollection ä¸­å³ä½¿æœªæ·»åŠ å˜ä½“ Aï¼Œè¿™ä¸ªå˜ä½“ä¹Ÿä¼šè¢«ç”Ÿæˆ\n\n\nShader ä¸­åˆå¤šä¸ª Pass æ—¶å˜ä½“çš„ç”Ÿæˆè§„åˆ™\n\nè¯»å– ShaderVariantCollection ä¸­å·²å­˜åœ¨çš„å˜ä½“ï¼Œè·å–ä»–ä»¬çš„ keywords\n\nå°†è¿™äº› keywords åˆ†åˆ«ä¸æ¯ä¸ª Pass çš„å¤šç»„ keywords åˆ—è¡¨æ±‚äº¤é›†ï¼Œå–äº¤é›†ä¸­ keywords æ•°é‡æœ€å¤šçš„é‚£ç»„\n\nç”¨å¾—åˆ°çš„ keywords ä¸å¯¹åº” PassType ç”Ÿæˆ Shader å˜ä½“ï¼Œå¹¶æ·»åŠ åˆ° ShaderVariantCollection ä¸­\n\nè‹¥å¾—åˆ°çš„äº¤é›†ä¸­æœ‰æ–°çš„ keywordsï¼Œåˆ™å›åˆ° 2\n\nä¾‹å¦‚ Shader ä¸­æœ‰ ForwardBaseã€ForwardAddã€Normal ä¸‰ç§ PassTypeï¼Œå®šä¹‰çš„å®å¦‚ä¸‹ï¼š\n\n\n\nForwardBase\nForwardAdd\nNormal\n\n\n\n#pragma shader_feature A#pragma shader_feature B#pragma shader_feature C\n#pragma shader_feature A#pragma shader_feature E\n#pragma shader_feature A#pragma shader_feature B#pragma shader_feature E\n\n\næ­¤æ—¶è‹¥ ShaderVariantCollection ä¸­åŒ…å«çš„å˜ä½“æ˜¯ ForwardBase ABCï¼ŒForwardAdd AEã€‚åˆ™æ­¤æ—¶ç”Ÿæˆçš„å˜ä½“ä¸ºï¼šè¿™ä¸‰ç§ PassType çš„é»˜è®¤å®šä¹‰çš„å® (nokeyword) æ‰€å¯¹åº”çš„å˜ä½“ï¼ˆ3 ä¸ªï¼‰ä»¥åŠåŸå…ˆç›´æ¥åŒ…å«çš„ ForwardBase ABCã€ForwardAdd AEã€‚é™¤æ­¤ä¹‹å¤– Unity è¿˜ä¼šé¢å¤–ç”Ÿæˆ ForwardAdd Aã€ForwardBase Aã€Normal Aã€Normal ABã€ ForwardBase ABã€Normal AE è¿™ 6 ä¸ªå˜ä½“\nABC âˆ© Add AE -&gt; Add A (A is NewKeyword)  A âˆ© Base ABC -&gt; Base A  A âˆ© Normal ABE -&gt; Normal AABC âˆ© Normal ABE -&gt; Normal AB (AB is NewKeyword) AB âˆ© Base ABC -&gt; Base AB AE âˆ© Normal ABE -&gt; Normal AE\n\n\n\n\nå˜ä½“çš„è°ƒç”¨è§„åˆ™  å½“ ShaderVariantCollection å°†å˜ä½“å‡†ç¡®ç”Ÿæˆåï¼Œä¾¿èƒ½åœ¨è¿è¡Œæ—¶é€šè¿‡ä¿®æ”¹æè´¨ä¸­çš„ keywords æ¥å®ç°å¯¹ä¸åŒå˜ä½“çš„è°ƒç”¨ã€‚å‡è®¾æŸ collection ç”Ÿæˆçš„å˜ä½“åªæœ‰ Forward ABCï¼ŒForward ABEï¼ŒForward nokeyword è¿™ä¸‰ç§ï¼Œåˆ™æ­¤æ—¶è°ƒç”¨å…³ç³»å¦‚ä¸‹ï¼š\n\n\n\nMaterial ä¸­çš„ Keywords\nè°ƒç”¨çš„å˜ä½“\nè§£é‡Š\n\n\n\nA B C\nForward A B C\næ­£å¸¸åŒ¹é…\n\n\nA B\nForward nokeyword\næ²¡æœ‰åŒ¹é…çš„å˜ä½“ï¼Œè°ƒç”¨é¦–ä¸ªè¢«å®šä¹‰çš„å® æ‰€å¯¹åº”çš„å˜ä½“\n\n\nA B C D\nForward A B C\nè°ƒç”¨äº¤é›†ä¸­ keyword æ•°é‡å¤šçš„å˜ä½“ ABCD âˆ© ABC = ABC ABCD âˆ© ABE = AB\n\n\nA B C E\nForward A B C\näº¤é›†ä¸­ keyword æ•°é‡ç›¸åŒï¼Œåœ¨ collection ä¸­è°åœ¨å‰å°±è°ƒç”¨è°\n\n\nA B E C\nForward A B C\nä¸åœ¨ material ä¸­çš„å®šä¹‰é¡ºåºæ— å…³\n\n\né¡¹ç›®ä¸­å˜ä½“çš„æ·»åŠ \néå†æ¯ä¸ªæè´¨ï¼Œæå–å…¶ Shader keywords\nå°†è·å¾—çš„ keywords ä¸ Shader çš„æ¯ä¸ª PassType æ‰€åŒ…å«çš„å®å®šä¹‰åšäº¤é›†ï¼Œå¹¶å°†å…¶ç»“æœæ·»åŠ åˆ° ShaderVariantCollection ä¸­\n\nå˜ä½“ä»£ç åœ¨ Shader ä¸­ç¼–å†™è§„èŒƒ\nå»ºè®®ä½¿ç”¨ shader_feature æ—¶å°†å®šä¹‰è¯­å¥å†™æˆå®Œæ•´æ¨¡å¼ï¼Œå¹¶ä¸”ä¸è¦åœ¨ä¸€ä¸ªè¯­å¥ä¸­å®šä¹‰å¤šä¸ªå®\n#pragma shader_feature _ Aï¼Œä¸å»ºè®®å†™æˆ#pragma shader_feature A\n\n\nè‹¥åœ¨ Shader ä¸­ä½¿ç”¨shader_featureï¼Œè¯·ä¸ºè¿™ä¸ª Shader æŒ‡å®šä¸€ä¸ª CustomEditor\n\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Shader","Variant"]},{"title":"ç ´è§£ GitKraken","url":"/2022/03/08/40/","content":"\n    \n\n\n\nGitKraken ç®€ä»‹GitKraken æ˜¯ä¸€æ¬¾ç•Œé¢ååˆ†ç¾è§‚çš„ Git å¯è§†åŒ–ç®¡ç†å·¥å…·ï¼Œæ¯”è¾ƒé—æ†¾çš„æ˜¯ GitKraken æ˜¯æ”¶è´¹è½¯ä»¶ï¼Œç±»ä¼¼çš„å…è´¹è½¯ä»¶æœ‰ Sourcetree ï¼Œä¸è¿‡ä½¿ç”¨ä½“éªŒä¸å¦‚ GitKrakenã€‚\nGitKraken è¿æ¥ GitLabStart a hosted repo\n    \n\n\né€šè¿‡ ** File/Preferences è¿›å…¥åå¥½è®¾ç½®ç•Œé¢ï¼Œé€‰æ‹©  Authentication  ä¸­çš„ GitLab Self-Managed ** é¡µé¢ï¼Œè¾“å…¥ GitLab åœ°å€å’Œ Token\nè·å¾— Personal Access Token\n    \n\n\n\nè¿›å…¥ ** User Settingsï¼Œé€‰æ‹© Access Token**\nè¾“å…¥ä¸€ä¸ª Token çš„åå­—\nå‹¾é€‰ api å’Œread_user\nç”Ÿæˆ Token\nå¤åˆ¶ Tokenï¼ˆè¿™ä¸ª Token ç¦»å¼€é¡µé¢åå°†ä¸è¢«ä¿å­˜ï¼‰\n\nè¿æ¥æˆåŠŸ\n    \n\n\nç ´è§£  å®‰è£…yarnnpm i yarn -g\n\nè¿è¡Œç ´è§£é¡¹ç›®  ç ´è§£å‰å…ˆç¡®ä¿ GitKraken å·²å…³é—­é€€å‡ºï¼Œç ´è§£å·¥å…·åœ¨ Github ä¸Šæ˜¯ä¸€ä¸ªå¼€æºé¡¹ç›® 5cr1pt/GitCracken ï¼Œå°†è¯¥é¡¹ç›® clone åˆ°æœ¬åœ°ï¼Œä½¿ç”¨æ–¹æ³•ä¹Ÿå¯å‚è€ƒé¡¹ç›®çš„ README.md æ–‡ä»¶ï¼Œå¦å¤–ä¹Ÿåœ¨ Gitee ä¸Šä¹Ÿæœ‰ã€‚ä»“åº“æ‹·è´åˆ°æœ¬åœ°åï¼Œè¿›å…¥ä»“åº“çš„ GitCracken/GitCracken ç›®å½•ï¼Œä¾æ¬¡æ‰§è¡Œä»¥ä¸‹æŒ‡ä»¤è¿è¡Œç ´è§£\nyarn installyarn buildnode dist/bin/gitcracken.js patcher\n\n\nè¿è¡Œ yarn install å¯èƒ½ä¼šå‡ºç°è¿æ¥è¶…æ—¶çš„é”™è¯¯\n\n    \n\n\nç›´æ¥å®‰è£…å¯¹åº”çš„ module å³å¯\n\n    \n\n\næ‰§è¡ŒæˆåŠŸåå¯çœ‹åˆ°å¦‚ä¸‹ç•Œé¢\n\n    \n\n\nåœ¨ GitKraken ç•Œé¢å³ä¸‹è§’å¯ä»¥çœ‹åˆ°ç ´è§£åçš„çŠ¶æ€\n\n    \n\n","categories":["Tools"],"tags":["crack","GitKraken"]},{"title":"Lua å°çŸ¥è¯†","url":"/2022/08/15/44/","content":"æ•°ç»„å…ƒç´ çš„æ’å…¥ä¸åˆ é™¤ table.insert ä¸table.removeæ–¹æ³•å¯ä»¥ä»æ•°ç»„ä¸­é—´çš„ä½ç½®æ’å…¥æˆ–ç§»é™¤ä¸€ä¸ªå…ƒç´ ã€‚è¿›è¡Œæ­¤æ“ä½œæ—¶ï¼Œlua æ ¸å¿ƒä¼šå°†æ’å…¥ä½ç½®å¼€å§‹çš„æ‰€æœ‰å…ƒç´   é€ä¸€  å‘åç§»åŠ¨ä¸€ä½ï¼ˆç§»é™¤å…ƒç´ äº¦ç„¶ï¼‰ã€‚å› æ­¤ä»¥ä¸‹ä»£ç ï¼š\nlocal t = {}for i = 1, 10000 do    table.insert(t, 1, i)end\n\nä¼šç§»åŠ¨å…ƒç´   æ¬¡ã€‚\nä¸€èˆ¬çš„è§£å†³æ–¹æ³•ï¼š\n\nå¦‚æœä½ å¹¶ä¸è¦æ±‚è¿™æ˜¯ä¸€ä¸ªæ•°ç»„ï¼ˆæ¯”å¦‚ä½ ä¸ä¼šå»éå†è¿™ä¸ªè¡¨ï¼‰ï¼Œé‚£ä¹ˆä½ å¯ä»¥ç›´æ¥å°†å…ƒç´ ç½®ç©ºï¼Œæˆ–æ˜¯æ’å…¥åˆ°è¡¨çš„ç©ºä½ä¸­ï¼š\n-- åˆ é™¤å…ƒç´ t[100] = nil-- æ’å…¥åˆ°è¡¨çš„ç©ºä½ä¸­t[#t+1] = object-- ä¸Šä¸‹ 2 ç§å†™æ³•ç­‰ä»·ï¼Œä½†æ˜¯ä¸Šé¢çš„å†™æ³•ç•¥å¾®é«˜æ•ˆä¸€äº›table.insert(t, object)\n\næ³¨æ„è¿™é‡Œæ’å…¥åˆ°è¡¨çš„ç©ºä½ä¸­çš„å†™æ³•ï¼Œlua è§„å®šåªæœ‰å½“æ•°ç»„æ˜¯ç´§å¯†çš„æ—¶å€™ï¼Œ #tæ‰èƒ½è¿”å›æ•°ç»„çš„é•¿åº¦ã€‚å½“æ•°ç»„ä¸ºç¨€ç–çš„æ—¶å€™ï¼Œ#tä¼šè¿”å›ä»»æ„ä¸€ä¸ªè¾¹ç•Œï¼ˆ#téç©ºï¼Œä½† #t+1 ä¸ºç©ºï¼‰ï¼Œå› æ­¤ä½¿ç”¨ #t+1 ä¸ä¼šè¦†ç›–å·²æœ‰æ•°æ®ã€‚\n\nå¦‚æœä½ è¦æ±‚ä»–ä¸€å®šæ˜¯æ•°ç»„ï¼Œä½†æ˜¯ä¸è¦æ±‚ä¿æŒé¡ºåºï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ç§»é™¤æ—¶å°†å°¾éƒ¨çš„å…ƒç´ æŒªè¿‡æ¥å¡«è¡¥ç©ºä½ï¼š\n-- åˆ é™¤å…ƒç´ t[100] = t[#t]t[#t]  = nil-- æ–°çš„å…ƒç´ æ€»æ˜¯æ·»åŠ åˆ°æœ«å°¾t[#t+1] = object-- ä¸Šä¸‹ 2 ç§å†™æ³•ç­‰ä»·ï¼Œä½†æ˜¯ä¸Šé¢çš„å†™æ³•ç•¥å¾®é«˜æ•ˆä¸€äº›table.insert(t, object)\nå¦‚æœä½ è¦æ±‚ä»–ä¸€å®šæ˜¯æ•°ç»„ï¼Œä½†æ˜¯ä¸è¦æ±‚ä¿æŒé¡ºåºï¼Œé‚£ä¹ˆå¯ä»¥åœ¨ç§»é™¤æ—¶å°†å°¾éƒ¨çš„å…ƒç´ æŒªè¿‡æ¥å¡«è¡¥ç©ºä½ï¼š\n-- åˆ é™¤å…ƒç´ t[100] = false -- å¾€åŸæ¥çš„ä½ç½®æ”¾ç½®ä¸€ä¸ªå ä½ç¬¦ï¼Œéå†æ—¶è¿‡æ»¤æ‰æ­¤å ä½ç¬¦-- åœ¨é€‚å½“çš„æ—¶å€™ï¼Œæ¸…ç†æ‰æ•°ç»„ä¸­çš„æ‰€æœ‰å ä½ç¬¦local count = 0for i = 1, #t do    if t[i] == false then        t[i] = nil    else        count = count + 1        t[count] = t[i]    endend\n\nTry-Catchä½ å¯ä»¥ä½¿ç”¨ pcall ä¸ xpcall ä»¥ä¿æŠ¤æ¨¡å¼è¿è¡Œä¸€æ®µä»£ç ï¼Œå½“ä»£ç å‘ç”Ÿå¼‚å¸¸åä¼šå¸¦ç€é”™è¯¯æ¶ˆæ¯å›åˆ°æ­¤å‡½æ•°çš„è°ƒç”¨å¤„ï¼Œä¾‹å¦‚ï¼š\n   local suc, res = pcall(function ()    local n = nil + 1    print(n) -- ä¸ä¼šæ‰§è¡Œåˆ°end)print(suc, res) -- false, error message\n\n   xpcall åˆ™å¯ä»¥å†ä¼ å…¥ä¸€ä¸ª catch ï¼Œä½¿å¾—ä½ å¯ä»¥åœ¨ç°åœºæ•è·é”™è¯¯å¹¶æŸ¥çœ‹å †æ ˆ\n   xpcall(function ()     local n = nil + 1    print(n) -- ä¸ä¼šæ‰§è¡Œåˆ°end, function (error_message)    print(debug.traceback(error_message))end)\n\n\nä½ å¯ä»¥ç›´æ¥æŠŠ debug.traceback å½“åš catch ä¼ ç»™ xpcall ï¼Œå› ä¸º debug.traceback çš„åŠŸèƒ½ä¹‹ä¸€æ˜¯æ¥æ”¶ä¸€ä¸ªé”™è¯¯æ¶ˆæ¯ï¼Œç„¶åæŠŠå †æ ˆä¿¡æ¯æ‹¼åœ¨é”™è¯¯æ¶ˆæ¯åé¢è¿”å›å›æ¥ï¼›è€Œ xpcall ä¼šå°† catch çš„è¿”å›å€¼ä½œä¸ºæ–°çš„é”™è¯¯æ¶ˆæ¯è¿”å›å‡ºæ¥ï¼Œè¿™æ ·ä¸€æ¥å°±å¯ä»¥åœ¨è°ƒç”¨å¤„æŸ¥çœ‹é”™è¯¯å †æ ˆã€‚\nlocal suc, res = xpcall(function ()     local n = nil + 1    print(n) -- ä¸ä¼šæ‰§è¡Œåˆ°end, debug.traceback)print(suc, res) -- false, error message with traceback\n\nåˆ¤ç©º  åœ¨ Lua ä¸­åªæœ‰ nil ä¸ false ä¼šè¢«è®¤ä¸ºæ˜¯å‡å€¼ï¼Œè€Œæ‰€æœ‰å…¶ä»–å€¼éƒ½æ˜¯çœŸå€¼ï¼ŒåŒ…æ‹¬ 0 '' {} ã€‚\nå› æ­¤å¤§éƒ¨åˆ†æƒ…å†µä¸‹ä½ åªéœ€è¦ç®€å•çš„é€šè¿‡ if x then æ¥è¿›è¡Œåˆ¤ç©ºã€‚\nä½†æœ‰ä¸€ç§æƒ…å†µæ˜¯ä½ æœ‰ä¸ªéå¸¸é•¿çš„æ“ä½œé“¾ï¼Œä¾‹å¦‚ local x = t.x.y.z()[1]  è€Œ lua å¹¶ä¸æ”¯æŒå¯é€‰æ“ä½œç¬¦ï¼ˆæ¯”å¦‚ TS ä¸­å¯ä»¥è¿™ä¹ˆå†™ï¼š let x = t?.x?.y?.z?.()?.[1])\nå¸¸è§çš„å‡ ç§è§£å†³æ–¹æ¡ˆå¦‚ä¸‹ï¼š\n\nä¾æ¬¡åˆ¤ç©ºï¼Œæœ€æœ´ç´ çš„æ€è·¯ï¼ŒTS ä¸­çš„å¯é€‰æ“ä½œç¬¦æœ€ç»ˆä¹Ÿæ˜¯ç¼–è¯‘ä¸ºä¾æ¬¡åˆ¤ç©ºçš„\nlocal xif t and t.x and t.x.y and t.x.y.z then -- è¿™é‡Œéœ€è¦ç¡®å®šå–å­—æ®µæ²¡æœ‰å‰¯ä½œç”¨    local _r = t.x.y.z() -- å‡½æ•°è°ƒç”¨é€šå¸¸æœ‰å‰¯ä½œç”¨ï¼Œå› æ­¤éœ€è¦ç¼“å­˜ç»“æœ    if _r then        x = _r[1]    else        catchError('z() is nil')    endelse    catchError('x or y or z is nil')end\n\nè¿™ä¸ªå†™æ³•ç®€å•æ˜“æ‡‚ï¼Œå‡ ä¹æ²¡æœ‰é¢å¤–å¼€é”€ï¼Œä½†æ˜¯æ˜¾ç„¶å†™èµ·æ¥å¾ˆå¤æ‚ï¼Œå¾ˆä¸ä¼˜ç¾\n\nåˆ›å»ºé»˜è®¤å€¼ï¼Œè¿™æ˜¯æ¥è‡ªã€ŠLua ç¨‹åºè®¾è®¡ã€‹ä½œè€…çš„æ–¹æ¡ˆ\nlocal x = ((((t or {}).x or {}).z or function () end)() or {})[1]\n\næ ¹æ®æˆ‘ä»¬äººå·¥é¢„æµ‹ï¼Œæ¯æ­¥æ“ä½œå¤§æ¦‚ç‡ä¸ä¼šæ˜¯ç©ºå€¼ï¼Œæ ¹æ® Lua çš„çŸ­è·¯è§„åˆ™ä¸€èˆ¬ä¸ä¼šçœŸçš„åˆ›å»ºå‡ºå¾ˆå¤šå¯¹è±¡ï¼ŒåŸºæœ¬æ²¡æœ‰é¢å¤–å¼€é”€ã€‚è€Œå½“å‡ºç°ç©ºå€¼æ—¶ï¼Œä½œä¸ºå‡ºé”™æƒ…å†µåˆ›å»ºä¸€ç‚¹å¯¹è±¡ä¹Ÿä¸æ˜¯å¾ˆæœ‰æ‰€è°“ã€‚ä¸è¿‡ç¼ºç‚¹å°±æ˜¯æ‹¬å·å®åœ¨æ˜¯å¤ªå¤šäº†ï¼Œå¾ˆéš¾çœ‹æ¸…æ˜¯å¦å†™å¯¹\nå¦‚æœæƒ³æ•è·é”™è¯¯éœ€è¦å†åŠ ä¸ªæ•è·ï¼ˆå‡è®¾æ•è·å‡½æ•° catchError æ²¡æœ‰è¿”å›å€¼ï¼‰ï¼š\nlocal x = ((((     t or catchError('t is nil')   or {})    .x or catchError('x is nil')   or {})    .z or catchError('z is nil')   or function () end)    () or catchError('z() is nil') or {})    [1]\nå°è£…æˆå‡½æ•°\nlocal function getValue(v, ...)    local n = select('#', ...)    for i = 1, n do        local k = select(i, ...)        if v[k] then            v = v[k]        else            catchError(k .. 'is nil')            return nil        end    end    return vend-- ä»¥ä¸Šæ•´ä¸ªå‡½æ•°ç”± copilot ç”Ÿæˆï¼Œæˆ‘æ²¡ä»”ç»†çœ‹ï¼Œæœ‰é—®é¢˜å‘Šè¯‰æˆ‘local x = getValue(t, 'x', 'y', 'z', 1)\n\nè¿™ä¸ªæ–¹æ³•åªèƒ½æ”¯æŒå–å­—æ®µæ“ä½œï¼Œæ²¡æ³•å®ç°å‡½æ•°è°ƒç”¨ã€‚ä½†è€ƒè™‘åˆ°å®é™…å·¥ç¨‹ä¸­å¾ˆå°‘ä¼šæŠŠå‡½æ•°è°ƒç”¨æ”¾åˆ°é•¿æ“ä½œé“¾ä¸­ï¼Œè¿™ä¹Ÿæ˜¯ä¸ªä¸é”™çš„è§£å†³æ–¹æ¡ˆã€‚ç¼ºç‚¹æ˜¯è¯­ä¹‰ä¸å¤ªæ¸…æ™°ï¼Œè€Œä¸”æ— è®ºæ˜¯ä¸æ˜¯ç©ºéƒ½éœ€è¦ä»˜å‡ºå¾ˆå¤šé¢å¤–çš„å‡½æ•°è°ƒç”¨çš„å¼€é”€\n\næ‰€æœ‰çš„æ“ä½œéƒ½ try 1 try\nlocal xxpcall(function ()    x = t.x.y.z()[1]end, catchError)\né‡å†™ nil çš„æ“ä½œã€‚å®é™…å·¥ç¨‹ä¸­æˆ‘ä»¬ç»å¸¸ä¼šé‡åˆ°éœ€è¦è¿ç»­å¤§æ®µçš„è¯»è¡¨ï¼Œç›´æ¥è®© Lua å¯¹ nil è¿›è¡Œè¯»å­—æ®µ / å‡½æ•°è°ƒç”¨ç­‰æ“ä½œ\nLua å¯ä»¥é€šè¿‡ debug.setmetatable ç»™åŸºç¡€ç±»å‹æ·»åŠ å…ƒè¡¨ï¼Œæ‰€æœ‰è¯¥ç±»å‹çš„å€¼ä¼šå…±äº«åŒä¸€ä¸ªå…ƒè¡¨ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ç»™ nil æ·»åŠ ä¸€ä¸ªé‡è½½äº†æ‰€æœ‰è¿ç®—ç¬¦çš„å…ƒè¡¨ï¼Œå…·ä½“ä»£ç æ¯”è¾ƒé•¿å°±ä¸è´´å‡ºæ¥äº†ï¼Œå¯ä»¥åˆ°è¿™é‡Œçœ‹ï¼šhttps://github.com/sumneko/lua-without-check-nil/blob/master/without-check-nil.lua\n\n\néœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåœ¨æˆ‘ä»¬è¿›è¡Œå®Œé•¿é“¾æ“ä½œåéœ€è¦åŠæ—¶ç¦ç”¨æ‰æ­¤åŠŸèƒ½ï¼Œä»¥å…æŠŠä½ å…¶ä»–ä»£ç ä¸­çš„é”™è¯¯åƒæ‰\nå¦å¤–ç”±äº Lua æ— æ³•é‡è½½ asindex ï¼Œå› æ­¤æ— æ³•å¤„ç† t[nil] = 1 è¿™ç§æƒ…å†µ\n\n\nlocal nonil = require 'without-check-nil'nonil.watch = function (ev, exp1, exp2)    catchError(string.format('[%s] error, exp1 = %s, exp2 = %s', ev, exp1, exp2))endnonil.enable()local x = t.x.y.z()[1]nonil.disable()\n\næ€»ç»“\n\n\næ–¹æ¡ˆ\nä¼˜ç‚¹\nç¼ºç‚¹\nå¼€é”€\né”™è¯¯æ•è·\n\n\n\nä¾æ¬¡åˆ¤ç©º\nç®€å•\nå†™èµ·æ¥éº»çƒ¦ çœ‹èµ·æ¥è´¹åŠ² 1 è¡Œå˜ 5 è¡Œ\næœ‰å°‘é‡é¢å¤–å¼€é”€\nå¯ä»¥æ‰‹åŠ¨æ•è·é”™è¯¯ï¼Œä½†æ˜¯ä¼šè®©ä»£ç å†™èµ·æ¥æ›´éº»çƒ¦\n\n\nåˆ›å»ºé»˜è®¤å€¼\nä¸ä¼šå¢åŠ è¡Œæ•°\næ“ä½œé“¾é•¿çš„è¯æ‹¬å·ä¼šå¾ˆå¤š\næœ‰å°‘é‡é¢å¤–å¼€é”€\nå¯ä»¥æ‰‹åŠ¨æ•è·é”™è¯¯ï¼Œä½†æ˜¯ä¼šè®©ä»£ç å†™èµ·æ¥æ›´éº»çƒ¦\n\n\nå°è£…æˆå‡½æ•°\nä¸ä¼šå¢åŠ è¡Œæ•° å†™èµ·æ¥æ¯”è¾ƒç®€å•\nåªèƒ½è¿›è¡Œå–å€¼æ“ä½œ\næœ‰ä¸€äº›é¢å¤–å¼€é”€\nå¯ä»¥åœ¨å°è£…å‡½æ•°ä¸­è‡ªåŠ¨æ•è·\n\n\nTry 1 Try\nå†™èµ·æ¥ç®€å• çœ‹èµ·æ¥ç›´è§‚\n1 è¡Œå˜ 3 è¡Œ\næœ‰ä¸€äº›é¢å¤–å¼€é”€\nç­‰åŒäºæ‰‹åŠ¨æ•è·\n\n\né‡å†™ nil çš„æ“ä½œ\nå‡ ä¹ä¸éœ€è¦ä¿®æ”¹ä»£ç \né‡å†™ nil æ“ä½œä¸ºå…¨å±€å¼€å…³ï¼Œéœ€è¦è®°å¾—å…³ å¦‚æœä¸šåŠ¡å’Œè¯»è¡¨æ··åœ¨ä¸€èµ·ï¼Œå¯èƒ½ä¼šåƒæ‰ä¸šåŠ¡é‡Œçš„é”™è¯¯ æ— æ³•å¤„ç†é”®ä¸ºç©ºçš„é”™è¯¯\næ²¡æœ‰é¢å¤–å¼€é”€\né€šè¿‡æ³¨å†Œ watch å‡½æ•°æ¥å…¨å±€æ•è·\n\n\næå‡æ€§èƒ½çš„å†™æ³•  æœ‰æ—¶æˆ‘ä»¬å¿…é¡»ç”¨ Lua å†™ä¸€äº›è¿ç®—å¯†é›†çš„ä»£ç ï¼Œæ­¤æ—¶å¯ä»¥é€šè¿‡ä¸€äº›å†™æ³•ç•¥å¾®æå‡æ€§èƒ½ã€‚æ³¨æ„ï¼Œä¼˜åŒ–æ€§èƒ½æ—¶ä¼˜å…ˆçº§ç¬¬ä¸€æ˜¯æ‰¾ bugï¼Œç¬¬äºŒæ˜¯æ”¹è¿›ç®—æ³•è®¾è®¡ï¼Œä¹‹åæ‰è½®åˆ°æ›´é«˜æ•ˆçš„å†™æ³•ã€‚æ›´æ”¹å†™æ³•å¾ˆå¯èƒ½ä¼šé™ä½ä»£ç çš„å¯è¯»æ€§ï¼Œä½ éœ€è¦è‡ªå·±å¯»æ‰¾æ€§èƒ½ä¸å¯è¯»æ€§ä¹‹é—´çš„å¹³è¡¡ç‚¹ï¼Œé€‚å½“ç•™ä¸‹æ³¨é‡Šï¼Œå¹¶ä¸”åˆ‡è®°  ä¸è¦è¿‡æ—©ä¼˜åŒ–ã€‚\n\nä½¿ç”¨ t[#t+1] = n ä»£æ›¿ table.insert(t, n) ï¼›ä½¿ç”¨ t[#t] = nil ä»£æ›¿ table.remove(t) ã€‚è¿™æ˜¯å› ä¸º Lua è°ƒç”¨å‡½æ•°çš„å¼€é”€æ¯”è¿ç®—ç¬¦è¦é«˜ã€‚ä½†æ˜¯ä½¿ç”¨è¿™ç§å†™æ³•æ—¶è¯·æ³¨æ„ï¼Œå¦‚æœä½ çš„ t æ˜¯ä¸ªè¡¨è¾¾å¼ï¼Œé‚£ä¹ˆè¿™ä¸ªè¡¨è¾¾å¼ä¼šè¢«æ±‚ 2 æ¬¡\n\nä½¿ç”¨å±€éƒ¨å˜é‡ä»£æ›¿å…¨å±€å˜é‡ï¼Œå¦‚ï¼š\nlocal tinsert = table.insertlocal t = {}for i = 1, 10000 do    tinsert(t, i)end\n\nè¯¥å†™æ³•çš„æå‡å¾ˆå°ï¼Œåªæœ‰åœ¨éå¸¸å¯†é›†çš„å¾ªç¯è¿ç®—ä¸­æ‰æœ‰æ”¹å†™çš„ä»·å€¼\n\nä½¿ç”¨å±€éƒ¨å˜é‡ç¼“å­˜ç»“æœï¼Œå¦‚ï¼š\n-- åŸæœ¬çš„ä»£ç ï¼ša.b.c.d[#a.b.c.d+1] = ncall(a.b.c.d)a.b.c.d[#a.b.c.d] = nil-- å¯ä»¥æ”¹å†™æˆï¼šlocal t = a.b.c.dt[#t+1] = ncall(t)t[#t] = nil\n\nLua çš„å±€éƒ¨å˜é‡æ˜¯æ²¡æœ‰é¢å¤–å¼€é”€çš„ï¼Œå› ä¸º Lua æœ¬èº«å°±ä¼šé€šè¿‡éšè—çš„å±€éƒ¨å˜é‡ï¼ˆå¯„å­˜å™¨ï¼‰æ¥ä¿å­˜ä¸­é—´ç»“æœã€‚ä¾‹å¦‚ä¸Šé¢ä¾‹å­ä¸­åŸæœ¬çš„ä»£ç ï¼ŒLua ç”Ÿæˆçš„å­—èŠ‚ç ä¼ªä»£ç å¦‚ä¸‹ï¼š\nlocal a1, a2, a3a1 = getglobal('a')a1 = getfield(a1, 'b')a1 = getfield(a1, 'c')a1 = getfield(a1, 'd')a2 = getglobal('a')a2 = getfield(a2, 'b')a2 = getfield(a2, 'c')a2 = getfield(a2, 'd')a2 = getlen(a2)a2 = binary('+', a2, 1)a3 = getglobal('n')setfield(a1, a2, a3)\né¿å…åˆ›å»ºå¯¹è±¡ï¼Œä¸»è¦æ˜¯è¡¨\nlocal function isSupported(t)    for _, v in ipairs {'Windows', 'macOS', 'Linux'} do        if t[v] then            return true        end    end    return falseend-- æ”¹å†™ä¸ºlocal supported = {'Windows', 'macOS', 'Linux'}local function isSupported(t)    for _, v in ipairs(supported) do        if t[v] then            return true        end    end    return falseend-- å…¶å®è°ƒç”¨ ipairs ä¹Ÿä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„é—­åŒ…ï¼Œå¦‚æœä½ éå¸¸åœ¨æ„ï¼Œå¯ä»¥å°±æ”¹å†™ä¸ºlocal supported = {'Windows', 'macOS', 'Linux'}local function isSupported(t)    for i = 1, #supported do        local v = supported[i]        if t[v] then            return true        end    end    return falseend-- å¦‚æœä½ è¿å¾ªç¯éƒ½ä¸æƒ³è¦ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ç»ˆææ‰‹æ®µ - æ‰‹åŠ¨å±•å¼€local supported = {'Windows', 'macOS', 'Linux'}local codes = {'local t = ...'}for _, v in ipairs(supported) do    codes[#codes+1] = string.format([[if t[%q] then    return trueend]], v)endcodes[#codes+1] = 'return false'local code = table.concat(codes, '\\n')local isSupported = load(code) -- Lua 5.1 ç”¨ loadstring\n\nä¸€äº›å‘\nLua çš„æ•°ç»„ç´¢å¼•æ˜¯ä» 1 å¼€å§‹çš„\n\nå¦‚æœæ•°ç»„æ„é€ çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå‡½æ•°è°ƒç”¨ï¼Œè¦æ³¨æ„è¿™ä¸ªå‡½æ•°è°ƒç”¨çš„æ‰€æœ‰è¿”å›å€¼éƒ½ä¿å­˜åˆ°è¡¨é‡Œï¼Œä¾‹å¦‚ï¼š\nlocal username = 'sumneko'local platform = 'Windows11'local t = {username, string.gsub(platform, '%d+', '') }print(t[1]) --\"sumneko\"print(t[2]) --\"Windows\"print(t[3]) -- 1           -- è¿™æ˜¯ string.gsub çš„ç¬¬äºŒä¸ªè¿”å›å€¼ï¼Œè¡¨ç¤ºæˆåŠŸæ›¿æ¢äº† 1 æ¬¡\n\nåŒç†å‡½æ•°è°ƒç”¨çš„æœ€åä¸€ä¸ªå‚æ•°ä¹Ÿæœ‰è¿™ä¸ªé—®é¢˜ï¼Œä¾‹å¦‚ï¼š\nlocal input = '#ffcc00'local n = tonumber(string.gsub(input, '#', '0x'))-- ä¸Šé¢è¿™è¡Œä¼šæŠ¥é”™ï¼Œå› ä¸º string.gsub ä¼šè¿”å› 2 ä¸ªè¿”å›å€¼ \"0xffcc00\" ä¸ 1ï¼Œ-- ä¹‹åç›¸å½“äºè°ƒç”¨äº† tonumber(\"0xffcc00\", 1) ï¼Œè¡¨ç¤ºä»¥ 1 è¿›åˆ¶è½¬æ¢è¯¥å­—ç¬¦ä¸²\n\nè§£å†³åŠæ³•ï¼š\n-- 1. åˆ†æˆ 2 è¡Œå†™local input = '#ffcc00'local int16 = string.gsub(input, '#', '0x')local n = tonumber(int16)-- 2. åŠ ä¸ªæ‹¬å·å¼ºåˆ¶ï¼Œå¼ºåˆ¶åªä¿ç•™ç¬¬ä¸€ä¸ªè¿”å›å€¼local input = '#ffcc00'local n = tonumber((string.gsub(input, '#', '0x')))\npairs éå†å“ˆå¸Œè¡¨æ—¶ï¼Œé¡ºåºæœªå®šä¹‰\nlocal t = {    a = 1,    b = 2,    c = 3,    d = 4,}for k in pairs(t) do    print(k)end\npairs éå†å“ˆå¸Œè¡¨æ—¶ï¼Œä¸èƒ½å¾€è¿™å¼ è¡¨é‡Œä¿å­˜æ–°çš„å­—æ®µ\nfor k in pairs(t) do    if string.sub(k, 1, 2) == 'm_' then        local realKey = string.sub(3)        for i = 1, 100 do            local newKey = realKey .. tostring(i)            t[newKey] = true        end    endend-- è¿™ç§å†™æ³•ä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼Œé€šå¸¸è¡¨ç°ä¸ºåŒä¸€ä¸ª key è¢«éå†åˆ°å¤šæ¬¡ï¼Œç”šè‡³æ˜¯æ­»å¾ªç¯-- è¿™ç§å†™æ³•å…¶å®æ¯”è¾ƒå®¹æ˜“çœ‹å‡ºéå†æ—¶ä¿å­˜äº†æ•°æ®ï¼Œéº»çƒ¦çš„æ˜¯ä¸‹é¢è¿™ç§ï¼šfor id, unit in pairs(AllUnitsMap) do    if unit:isRemoved() then        allUnitsMap[id] = nil -- éå†è¡¨çš„æ—¶å€™ä¿®æ”¹æˆ–ç§»é™¤å­˜åœ¨çš„å­—æ®µæ˜¯ OK çš„        eventDispatch('å•ä½ - ç§»é™¤', unit)    endend-- ä¸Šé¢è¿™æ®µä»£ç åœ¨éå†ä¸­ç§»é™¤å…ƒç´ åå‘å¤–æŠ›å‡ºäº†ä¸€ä¸ªäº‹ä»¶ï¼Œ-- è¿™æ˜¯éå¸¸å±é™©çš„ï¼Œå› ä¸ºäº‹ä»¶ä¸­å¯èƒ½ä¼šå¾€è¡¨ä¸­æ·»åŠ å…ƒç´ ã€‚-- åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæœ‰å¯èƒ½æ˜¯ç­–åˆ’å¸Œæœ›åœ¨æŸä¸ªå•ä½è¢«ç§»é™¤ååˆ›å»ºä¸€ä¸ªæ–°çš„å•ä½å‡ºæ¥ï¼Œ-- è€Œæ–°å»ºçš„å•ä½ä¼šè¢«æ·»åŠ åˆ°æ­£åœ¨éå†çš„å…¨å±€è¡¨ä¸­ã€‚\nå±€éƒ¨å‡½æ•°çš„å£°æ˜æ–¹å¼\nlocal f = function ()    f() -- è¿™é‡Œçš„ f æ˜¯å…¨å±€å˜é‡ï¼Œå› æ­¤æ— æ³•é€’å½’å½“å‰å‡½æ•°endlocal function f()    f() -- è¿™é‡Œçš„ f æ˜¯å±€éƒ¨å˜é‡ï¼Œä¼šé€’å½’å½“å‰å‡½æ•°end-- ä¸Šä¸‹ 2 ä¸ªå†™æ³•æ˜¯ç­‰ä»·çš„ï¼Œä¸Šè€…æ˜¯ä¸‹è€…çš„è¯­æ³•ç³–local f;f = function ()    f() -- è¿™é‡Œçš„ f æ˜¯å±€éƒ¨å˜é‡ï¼Œä¼šé€’å½’å½“å‰å‡½æ•°end\nrequire åªä¼šæ‰§è¡Œæ–‡ä»¶ä¸€æ¬¡ï¼Œä¸”åªæ¥å—ä¸€ä¸ªè¿”å›å€¼\n-- æ–‡ä»¶ A.luaprint('loaded')return 1, 2, 3-- æ–‡ä»¶ B.lualocal x1, y1, z1 = require 'A'print(x1) -- 1print(y1) -- \"@A.lua\" # ç¬¬ä¸€æ¬¡ require æ–‡ä»¶æ—¶ï¼Œä¼šè¿”å›æ–‡ä»¶è·¯å¾„ ï¼ˆä»… Lua 5.4ï¼‰print(z1) -- nillocal x2, y2, z2 = require 'A'print(x1) -- 1print(y1) -- nilprint(z1) -- nil-- åªä¼šæ‰“å°ä¸€æ¬¡ 'loaded' ï¼Œå› ä¸ºæ–‡ä»¶ A åªè¢«æ‰§è¡Œäº†ä¸€æ¬¡\n\nä½†æ˜¯ï¼Œå¦‚æœä½ ç”¨ä¸åŒçš„åå­—åŠ è½½åŒä¸€ä¸ªæ–‡ä»¶ï¼Œé‚£ä¹ˆè¿™ä¸ªæ–‡ä»¶å°±ä¼šè¢«åŠ è½½å¤šæ¬¡ï¼Œè¿™æ˜¯ä¸€å®šè¦é¿å…çš„ï¼\n-- æ–‡ä»¶ A/init.luarequire 'A.init' -- é€šè¿‡ '?.lua' æœç´¢åˆ° 'A/init.lua'require 'A/init' -- é€šè¿‡ '?.lua' æœç´¢åˆ° 'A/init.lua'require 'A'      -- é€šè¿‡ '?/init.lua' æœç´¢åˆ° 'A/init.lua'require 'a'      -- é€šè¿‡ '?/init.lua' æœç´¢åˆ° 'a/init.lua'ï¼Œåœ¨ Windows å¹³å°ä¸‹ä¼šæ˜ å°„åˆ° 'A/init.lua'\n\nä¾‹å­ä¸­çš„ 4 è¡Œä»£ç æœ€ç»ˆä½¿å¾—åŒä¸€ä¸ªæ–‡ä»¶è¢«æ‰§è¡Œäº† 4 æ¬¡\n\nos.clock åœ¨ä¸åŒçš„å¹³å°è¡Œä¸ºä¸ä¸€è‡´\nå…¶å®è¿™ä¸ç®—æ˜¯ Lua çš„å‘ï¼Œè¿™æ˜¯ Windows çš„å†å²é—ç•™é—®é¢˜ã€‚ISO æ ‡å‡†ä¸­è§„å®šäº† clock() å‡½æ•°è¿”å›å½“å‰è¿›ç¨‹å ç”¨çš„ CPU æ—¶é—´ï¼Œä½†æ˜¯ Windows é”™è¯¯çš„å®ç°æˆäº†å½“å‰è¿›ç¨‹ä»å¯åŠ¨å¼€å§‹åˆ°ç°åœ¨ç»è¿‡çš„æ€»æ—¶é—´ã€‚å› æ­¤è¦æ³¨æ„ä¸èƒ½æ‹¿ä»–ç”¨äºè·å–ç°å®æ—¶é—´ï¼ˆé™¤éåªåœ¨ Windows è¿è¡Œï¼‰\n\n\næ‹¼æ¥å­—ç¬¦ä¸²Lua çš„å­—ç¬¦ä¸²æ˜¯ä¸å¯å˜å¯¹è±¡ï¼Œå› æ­¤å¯¹å­—ç¬¦ä¸²è¿›è¡Œçš„æ“ä½œéœ€è¦åˆ›å»ºæ–°çš„å­—ç¬¦ä¸²ï¼Œä¾‹å¦‚ï¼š\nlocal str = 'a' .. 'b' .. 'c' .. 'd'-- è¿™æ®µä»£ç ä¼šåˆ›å»º 'ab' 'abc' 'abcd' 3 ä¸ªå­—ç¬¦ä¸²\n\nä¸€èˆ¬æ¥è¯´ï¼Œå¦‚æœä½ çš„å­—ç¬¦ä¸²æ¯”è¾ƒçŸ­æˆ–æ˜¯æ‹¼æ¥æ¬¡æ•°æ¯”è¾ƒå°‘ï¼Œé‚£ä¹ˆæ— éœ€åœ¨æ„ã€‚ä½†å¦‚æœéœ€è¦å†å¾ªç¯ä¸­è¿›è¡Œå¤§é‡æ‹¼æ¥ï¼Œé‚£ä¹ˆåº”å½“ä½¿ç”¨ table.concat æ¥å®ç°ï¼Œä¾‹å¦‚ï¼š\nlocal function f(units)    local str = ''    for _, u in ipairs(units) do        str = str .. u:getUUID() .. ','    end    return strend-- å‡è®¾ units çš„æ•°ç»„é•¿åº¦ä¸º 1000ï¼Œä¸”æ¯ä¸ª unit çš„ UUID é•¿åº¦ä¸º 16 ä¸ªå­—èŠ‚ï¼Œ-- é‚£ä¹ˆä¸Šè¿°ä»£ç ä¸€å…±ä¼šåˆ›å»º 2000 ä¸ªå­—ç¬¦ä¸²ï¼Œå…±ç”³è¯· 17M çš„å†…å­˜ã€‚-- å› æ­¤å°†å…¶æ”¹å†™ä¸ºï¼šlocal function f(units)    local buf = {}    for _, u in ipairs(units) do        buf[#buf+1] = u:getUUID()        buf[#buf+1] = ','    end    return table.concat(buf)end-- å¦‚æ­¤ä¸€æ¥å°±åªä¼šåˆ›å»ºä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œç”³è¯· 17K çš„å†…å­˜\n\nç©ºï¼ˆnoneï¼‰ä¸ nil åœ¨ Lua å±‚ï¼Œç”±äºè·å–ä¸€ä¸ªç©ºå€¼æ—¶ä¼šè¿”å› nilï¼Œå› æ­¤å¾ˆéš¾å¯Ÿè§‰åˆ°ç©ºå€¼çš„å­˜åœ¨ã€‚è€Œåœ¨ C å±‚åˆ™æ˜¯æä¾›äº†lua_isnil/lua_isnone/lua_isnoneornil è¿™ 3 ä¸ª API è¿›è¡ŒåŒºåˆ†ã€‚å¤§éƒ¨åˆ†æƒ…å†µä¸‹æˆ‘ä»¬ç¡®å®ä¸éœ€è¦å…³å¿ƒä»–ä»¬çš„åŒºåˆ«ï¼Œä½†è¿˜æ˜¯æœ‰ä¸€ä¸ªåœ°æ–¹éœ€è¦ç”¨åˆ°ã€‚\nLua é»˜è®¤æä¾›çš„å‡ ä¸ª API ä¼šæ ¹æ®å‚æ•°çš„æ•°é‡å†³å®šä¸åŒçš„è¡Œä¸ºï¼Œä¾‹å¦‚ table.insertï¼š\n\ntable.insert(t, v) åœ¨ t çš„æœ«å°¾æ·»åŠ v\ntable.insert(t, pos, v) tä¸­ä» pos å¼€å§‹çš„å…ƒç´ éƒ½å¾€åç§»åŠ¨ä¸€æ ¼ï¼Œç„¶åå°† v æ”¾åœ¨ t[pos] ä¸Š\n\nè¿™é‡Œå°±æ˜¯æ ¹æ®ä½ ä¼ å…¥çš„å‚æ•°æ•°é‡å†³å®šçš„ï¼Œå› æ­¤ä½ è°ƒç”¨ table.insert(t, v, nil) æ—¶å®é™…ä¸Šè°ƒç”¨çš„æ˜¯ 3 å‚æ•°ç‰ˆæœ¬\nè¿™æ—¶å€™ä½ å¯èƒ½ä¼šè¯´ï¼šä½ å½“æˆ‘çå˜›ï¼Œæˆ‘å½“ç„¶çŸ¥é“è¿™æ˜¯ 3 ä¸ªå‚æ•°ã€‚å®¢å®˜è«æ€¥ï¼Œçœ‹çœ‹è¿™ä¸¤ç§æƒ…å†µï¼š\n\ntable.insert(t, ...)\ntable.insert(t, getValue())\n\nå‰ä¸€ç§ä¸å®šå‚ä¼šå¯¼è‡´ä½ çš„å‚æ•°æ•°é‡ç”±å½“å‰å‡½æ•°çš„è°ƒç”¨è€…å†³å®šï¼Œå› æ­¤ä½ éœ€è¦åšå¥½åˆ¤æ–­çš„å·¥ä½œã€‚åˆ¤æ–­ä¸å®šå‚çš„å‚æ•°æ•°é‡éœ€è¦ç”¨åˆ° select æ–¹æ³•ï¼š\nlocal function count(...)    return select('#', ...)endprint(count()) --&gt; 0print(count(1, 2)) --&gt; 2print(count(1, 2, nil, nil)) --&gt; 4\n\nåä¸€ç§åˆ™æ˜¯è¦ä¿è¯å¥½ç›®æ ‡å‡½æ•°çš„è¿”å›å€¼æ•°é‡ï¼š\nlocal function getValue(n)    if n == 0 then        return    elseif n == 1 then        return nil    elseif n == 2 then        return nil, nil    elseif n == 3 then        return nil, nil, nil    endendprint(select('#', getValue(0))) --&gt; 0print(select('#', getValue(1))) --&gt; 1print(select('#', getValue(2))) --&gt; 2print(select('#', getValue(3))) --&gt; 3\n\nå‰æ–‡â€œä¸€äº›å‘â€ä¸­æœ‰æåˆ°è¿‡ï¼Œå°½é‡ä½¿ç”¨ä¸­é—´å˜é‡æ¥æ˜ç¡®å‡½æ•°è¿”å›å€¼çš„æ•°é‡\nä¸å®šå‚  ä¸å®šå‚æ˜¯ä¸èƒ½è·¨è¶Šå‡½æ•°ï¼ˆä½œä¸ºé—­åŒ…çš„ä¸Šå€¼ï¼‰çš„ï¼Œä¹Ÿå°±æ˜¯ä½ æ— æ³•è¿™ä¹ˆå†™ï¼š\nlocal function factory(...)    return function ()        return ... --&gt; è¯­æ³•é”™è¯¯    endend\n\n\næœ‰æ—¶ä½ ä¼šåœ¨ç½‘ä¸Šçš„æ•™ç¨‹ä¸­çœ‹åˆ°ä¸å®šå‚ä¼šè¢«å­˜åˆ°éšè—å‚æ•° argï¼ˆè¡¨ï¼‰ä¸­ï¼Œè¿™æ˜¯æ—§ç‰ˆ Lua çš„åŠŸèƒ½ï¼Œå‡ºäºæ€§èƒ½è€ƒè™‘å·²è¢«åºŸå¼ƒï¼ˆå½“ç„¶ C ä»£ç ä¸­æœ‰å®å¯ä»¥å¯ç”¨è¿™ä¸ªåŠŸèƒ½ï¼‰\n\nå¦‚æœæœ‰è¿™ä¸ªéœ€æ±‚çš„è¯ï¼Œéœ€è¦å°†ä¸å®šå‚åŒ…è£…åˆ°ä¸€ä¸ªè¡¨ä¸­ï¼Œä¸€èˆ¬æ¥è¯´è¿™ä¹ˆå†™å°±è¶³å¤Ÿäº†\nlocal function factory(...)    local vars = {...}    return function ()        return table.unpack(vars) --&gt; Lua 5.1 ä¸º `unpack`    endend\n\nä½†æœ‰çš„æ—¶å€™æˆ‘ä»¬éœ€è¦ä¿è¯ä¸å®šå‚éœ€è¦è¢«  åŸæ ·  è¿”å›å‡ºå»ï¼Œæ¯”å¦‚è½¬å‘ / ä»£ç†ä»»æ„æ¶ˆæ¯ã€‚å¦‚æœä¸å®šå‚çš„æœ«å°¾è·Ÿç€nilï¼Œä¸Šé¢çš„å†™æ³•ä¼šå¯¼è‡´è¿”å›å‡ºå»çš„å€¼çš„æ•°é‡ä¸åŒï¼Œå› æ­¤éœ€è¦ä¿å­˜ä¸å®šå‚çš„æ•°é‡ï¼š\nlocal function factory(...)    local vars = {...}    local num  = select('#', ...)    return function ()        return table.unpack(vars, 1, num)    endend\n\næ­¤å¤–ä¹Ÿå¯ä»¥ç”¨ table.pack å®ç°ç›¸åŒçš„åŠŸèƒ½ï¼š\nlocal function factory(...)    local vars = table.pack(...) --&gt; Lua 5.1 ä¸å¯ç”¨ï¼›LuaJIT å¯ç”¨    return function ()       return table.unpack(vars, 1, vars.n) --&gt; ä¸å®šå‚é•¿åº¦ä¿å­˜åœ¨å­—æ®µ `n` ä¸­    endend\n\nè¿™ 2 ç§å†™æ³•æ ¹æ®ä½¿ç”¨åœºæ™¯ä¼šæœ‰ä¸€ç‚¹ç‚¹çš„æ€§èƒ½åŒºåˆ«ï¼Œä¾‹å¦‚ï¼š\nlocal function getSum1(...)    local sum = 0    for i = 1, select('#', ...) do        sum = sum + (select('#', i) or 0)    end    return sumendlocal function getSum2(...)    local sum = 0    local vars = table.pack(...)    for i = 1, vars.n do        sum = sum + (vars[i] or 0)    end    return sumend\n\nè‚‰çœ¼å¯è§ï¼Œç¬¬ä¸€ç§å†™æ³•æ¯ä¸ªå‚æ•°éƒ½è¦è°ƒç”¨ä¸€æ¬¡å‡½æ•°ï¼Œç¬¬äºŒç§å†™æ³•åˆ™å›ºå®šè¦åˆ›å»ºä¸€å¼ è¡¨ï¼Œæ‰€ä»¥ä½ å¯ä»¥æ ¹æ®å®é™…æƒ…å†µé¢„ä¼°ä¸€ä¸‹å‚æ•°æ•°é‡å†³å®šä½¿ç”¨å“ªç§å†™æ³•ã€‚ä¸è¿‡è¯´å®è¯å·®åˆ«å¾ˆå°ï¼Œä¸éœ€è¦ç‰¹åˆ«åœ¨æ„\nç¯å¢ƒä¸æ²™ç›’ Lua é€šè¿‡å…¨å±€è¡¨ä¸ç¯å¢ƒè¡¨æ¥å®ç°å…¨å±€å˜é‡ã€‚åœ¨ Lua 5.1 ä¸ LuaJIT ä¸­æ¯ä¸ªå‡½æ•°éƒ½ä¼šç»‘å®šä¸€ä¸ªç¯å¢ƒè¡¨ (envï¼Œé»˜è®¤å°±æ˜¯_G)ï¼Œå½“ä½ è¯»å†™å…¨å±€å˜é‡æ—¶ï¼Œå…¶å®ä¿®æ”¹çš„æ˜¯ç¯å¢ƒè¡¨ä¸­çš„å¯¹è±¡ã€‚æ–°å»ºçš„å‡½æ•°ä¼šç»§æ‰¿çˆ¶å‡½æ•°çš„ç¯å¢ƒï¼ŒåŒæ—¶ä¹Ÿæä¾›äº†å‡½æ•°setfenv æ¥ä¿®æ”¹å‡½æ•°çš„ç¯å¢ƒ\nX = 1 local function f()    Y = Xend\n\n-- ä¸Šé¢çš„ä»£ç åœ¨ Lua 5.1 ä¸­ä¼šè¢«è¿™æ ·è§£é‡Šï¼ˆä¼ªä»£ç ï¼‰ï¼šsetfenv(1, env) -- `env` æ˜¯å½“å‰ç¯å¢ƒï¼Œé»˜è®¤ä¸º `_G`. `env` å¹¶ä¸å­˜åœ¨äºå˜é‡åˆ—è¡¨ä¸­ã€‚getfenv(1)['X'] = 1local function f()    getfenv(1)['Y'] = getfenv(1)['X']endsetfenv(f, getfenv(1))\n\nç„¶è€Œè¿™ä¸ªè®¾è®¡å¼•å‘äº†å¾ˆå¤šå›°æƒ‘ï¼Œä½ æ— æ³•å‡†ç¡®çš„åˆ¤æ–­å‡ºå½“å‰å‡½æ•°çš„å†…çš„å…¨å±€å˜é‡åˆ°åº•æ˜¯ä»å“ªä¸ªç¯å¢ƒé‡Œè¯»å–çš„ï¼Œå› ä¸ºä»»ä½•äººéƒ½æœ‰æƒé™éšæ—¶ä¿®æ”¹ä½ çš„ç¯å¢ƒã€‚\nå¦ä¸€æ–¹é¢ï¼Œå¦‚æœä¸€ä¸ªå‡½æ•°è¿”å›äº†ä¸€ä¸ªé—­åŒ…ï¼Œåˆ›å»ºé—­åŒ…çš„æ—¶å€™é—­åŒ…ä¼šç»§æ‰¿çˆ¶å‡½æ•°çš„ç¯å¢ƒï¼Œä½†ä¹‹åä¿®æ”¹çˆ¶å‡½æ•°çš„ç¯å¢ƒå°†æ— æ³•å†å½±å“é—­åŒ…ã€‚ç›¸å¯¹ä¹‹ä¸‹ä¿®æ”¹ä¸Šå€¼ï¼ˆupvalueï¼‰æ˜¯å¯ä»¥ä½œç”¨äºé—­åŒ…çš„ï¼Œå› æ­¤è¿™åˆå¼•å‘äº†â€œå˜é‡ä½œç”¨åŸŸâ€è§„åˆ™çš„ä¸ä¸€è‡´æ€§ï¼Œå¼•å‘äº†å›°æ‰°\nå› æ­¤ä» Lua 5.2 å¼€å§‹ï¼Œç¯å¢ƒæ”¹ä¸ºé€šè¿‡ä¸Šå€¼æ¥å®ç°ï¼Œä»è€Œç»Ÿä¸€äº†æ¦‚å¿µï¼Œå‡å°‘äº†ç‰¹ä¾‹\n-- ä¸Šé¢çš„ä»£ç åœ¨ Lua 5.2 ä¸­ä¼šè¢«è¿™æ ·è§£é‡Šï¼ˆä¼ªä»£ç ï¼‰ï¼šlocal _ENV = env -- `env` æ˜¯å½“å‰ç¯å¢ƒï¼Œé»˜è®¤ä¸º `_G`._ENV['x'] = 1local function f()    _ENV['Y'] = _ENV['X']end\n\nå…¶ä¸­ _ENV æ˜¯çœŸå®å­˜åœ¨äºå±€éƒ¨å˜é‡åˆ—è¡¨ä¸­çš„ï¼Œè¿™ä½¿å¾—ç¯å¢ƒçš„åŸºç¡€æ¦‚å¿µç”±æ¯ä¸ªå‡½æ•°å•ç‹¬ä¸€ä¸ªç¯å¢ƒå˜ä¸ºäº†åŒä¸€ä¸ªæ–‡ä»¶å…±äº«åŒä¸€ä¸ªç¯å¢ƒã€‚è¿™ä¸ªæ–¹æ¡ˆä½¿å¾—å‡½æ•°çš„ç¯å¢ƒç”±ä»£ç å†™æ³•å†³å®šï¼Œè€Œä¸æ˜¯ç”±è¿è¡Œæ—¶çš„çŠ¶æ€å†³å®šã€‚å½“ä½ ä¿®æ”¹ç¯å¢ƒæ—¶ï¼Œæ‰€æœ‰çš„å‡½æ•°ä¸é—­åŒ…çš„ç¯å¢ƒä¹Ÿä¼šè¢«ä¸€å¹¶ä¿®æ”¹\nlocal print = printlocal pairs = pairs_ENV = nil -- ç¦æ­¢ä¸‹é¢çš„ä»£ç ä½¿ç”¨å…¨å±€å˜é‡ï¼Œé¿å…æ‹¼å†™é”™è¯¯å¯¼è‡´çš„è¯¯ç”¨print(pairs)print(paris) -- è¿è¡Œæ—¶è¿™é‡Œä¼šæŠ¥é”™ï¼Œå› ä¸ºè¢«è§£é‡Šä¸ºäº† `_ENV['paris']`ï¼Œè€Œæ­¤æ—¶çš„ `_ENV` ä¸º `nil`\n\nåƒåœ¾å›æ”¶  ç›®å‰ä¸»æµçš„åƒåœ¾å›æ”¶æœ‰ 2 ç§ï¼Œåˆ†åˆ«æ˜¯å¼•ç”¨è®¡æ•°ä¸æ ‡è®°æ¸…ç†ã€‚\nå¼•ç”¨è®¡æ•°çš„åŸç†å¾ˆæœ´ç´ ï¼Œæ¯å½“å¯¹è±¡è¢«æŒæœ‰æ—¶è®¡æ•° +1ï¼Œå½“æŒæœ‰è¢«è§£é™¤å -1ï¼Œå½’ 0 å³é‡Šæ”¾ã€‚è¿™ç§æœ´ç´ çš„æ€æƒ³è‡ªç„¶ä¼šäº§ç”Ÿå¾ˆå¤šé—®é¢˜ï¼ŒåŒ…æ‹¬éš¾ä»¥è§£å†³å¾ªç¯å¼•ç”¨ä»¥åŠå¯¹äºåŠ¨æ€è¯­è¨€æ¥è¯´æµªè´¹æ€§èƒ½ç­‰ã€‚ä½† Lua æ²¡æœ‰ä½¿ç”¨è¿™ç§æ–¹å¼çš„ä¸»è¦åŸå› æ˜¯ Lua è®¾è®¡ä¸ºéœ€è¦é¢‘ç¹å’Œ C äº¤äº’ï¼Œè€Œå¼•ç”¨è®¡æ•°åŠ¿å¿…ä¼šä¾µå…¥ CAPI çš„éƒ¨åˆ†ï¼Œä¼šç»™ C çš„ä»£ç å¸¦æ¥é¢å¤–çš„å¿ƒæ™ºè´Ÿæ‹…ã€‚\næ ‡è®°æ¸…ç†åˆ™æ˜¯ä»ç›®çš„å‡ºå‘ï¼šæ—¢ç„¶åƒåœ¾å›æ”¶çš„ç›®çš„æ˜¯ä¸ºäº†æ¸…ç†æ‰æ— æ³•å†è®¿é—®åˆ°çš„å†…å­˜ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªè¦è¿›è¡Œä¸€æ¬¡å¯è¾¾æ€§æµ‹è¯•ï¼Œå³å¯æ‰¾å‡ºè¦æ”¶é›†çš„åƒåœ¾ï¼Œå¦‚å›¾æ‰€ç¤ºï¼š\n\n    \n\n\næˆ‘ä»¬åªéœ€è¦ä»æ ¹é›†ï¼ˆæ³¨å†Œè¡¨ï¼‰å‡ºå‘ï¼Œé¡ºç€åº”ç”¨é“¾å¾€ä¸‹é€’å½’ï¼Œå°†è®¿é—®åˆ°çš„å¯¹è±¡å…¨éƒ¨æ ‡è®°ä¸ºé»‘è‰²ã€‚å½“é€’å½’ç»“æŸåï¼Œé‚£äº›æ²¡æœ‰è¢«æ ‡è®°åˆ°çš„å¯¹è±¡ä¾¿æˆä¸ºäº†åƒåœ¾å¯ä»¥é‡Šæ”¾æ‰äº†ã€‚è¿™ä¸ªæµç¨‹å®ç°èµ·æ¥å¾ˆç®€å•ï¼Œå› ä¸º Lua çš„ç»“æ„ç®€å•ï¼Œå¹¶ä¸”æä¾›äº†å®Œå–„çš„è°ƒè¯•ä¸åå°„åŠŸèƒ½ï¼Œç”šè‡³ä½¿ç”¨çº¯ Lua ä¹Ÿèƒ½å®ç°æ‰«æï¼Œå¯ä»¥ç”¨äºå†…å­˜åˆ†æç­‰åŠŸèƒ½\nå¢é‡å›æ”¶  æ ‡è®°æ¸…ç†æœ‰ä¸ªæ˜¾è€Œæ˜“è§çš„é—®é¢˜ï¼Œé‚£å°±æ˜¯ç”±äºå•æ¬¡å›æ”¶éœ€è¦æ‰«ææ•´ä¸ªå†…å­˜ç©ºé—´ï¼Œä¼šäº§ç”Ÿä¸¥é‡çš„åœé¡¿ã€‚å› æ­¤éœ€è¦å°†è¿™ä¸ªå›æ”¶å°½é‡åˆ‡æˆå°ç‰‡ï¼Œå¹¶åˆ†æ•£åœ¨è¿è¡Œæ—¶çš„å„ä¸ªæ—¶æœºä¸­\næ ‡è®°è¿‡ç¨‹æ˜¾ç„¶æ˜¯ä¸€ä¸ªå¯ä»¥æ‹†åˆ†çš„æµç¨‹ï¼Œå› ä¸ºä»–çš„æœ¬è´¨æ˜¯é€’å½’ï¼Œå¯ä»¥å°†é€’å½’è§£ä¸ºä¸€ä¸ªå¾ªç¯ï¼Œè€Œå¾ªç¯åªè¦ä¿å­˜ä¸€ä¸‹é˜Ÿåˆ—ä¸å½“å‰çŠ¶æ€å³å¯éšæ—¶æš‚åœä¸æ¢å¤\nä¸ºäº†æ–¹ä¾¿ç†è§£ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥ä¸€ä¸ªä¸­é—´é‡ç°è‰²ï¼Œè¡¨ç¤ºé‚£äº›æ”¾åœ¨é˜Ÿåˆ—ä¸­ç­‰å¾…æ‰«æçš„å¯¹è±¡ï¼ˆå³å·²ç»ç¡®å®šè¢«æ ¹é›†å¼•ç”¨åˆ°ï¼Œä½†è¿˜ä¸çŸ¥é“å®ƒå¼•ç”¨äº†å“ªäº›åˆ«çš„å¯¹è±¡ï¼‰ã€‚æ•´ä¸ªæµç¨‹å¤§æ¦‚å°±æ˜¯ï¼š\n\nå°†æ ¹é›†ï¼ˆæ³¨å†Œè¡¨ï¼‰æ ‡è®°ä¸ºé»‘è‰²ï¼Œå¹¶å°†é™„è¿‘çš„èŠ‚ç‚¹ï¼ˆå…¨å±€å˜é‡è¡¨ã€è¿è¡Œæ ˆç­‰ï¼‰æŸ“ä¸ºç°è‰²\néšä¾¿æŒ‘ä¸€ä¸ªç°è‰²ï¼Œå°†å…¶æ ‡è®°ä¸ºé»‘è‰²ï¼Œå¹¶å°†é™„è¿‘çš„ç™½è‰²èŠ‚ç‚¹æŸ“ä¸ºç°è‰²\né‡å¤ç¬¬ 2 æ­¥ï¼Œç›´åˆ°æ²¡æœ‰ä»»ä½•ç°è‰²èŠ‚ç‚¹ä¸ºæ­¢\n\nå› ä¸ºç¬¬ 2 æ­¥å¯ä»¥éšæ—¶æ‰“æ–­ï¼Œæˆ‘ä»¬å¯ä»¥å°†å…¶åˆ†æ•£åˆ°ä»£ç çš„å„ä¸ªè¿‡ç¨‹ä¸­ï¼ŒLua çš„é»˜è®¤è®¾ç½®ä¸ºä¼šä»¥å†…å­˜å¢é•¿é€Ÿåº¦çš„ 2 å€è¿›è¡Œæ‰«æï¼Œæ„æ€æ˜¯æ¯åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡ï¼Œæˆ‘å°±ä¼šæ‰«æ 2 ä¸ªç°è‰²å¯¹è±¡ï¼ˆè¿™é‡Œå‡è®¾å¯¹è±¡å¤§å°éƒ½ä¸€æ ·ï¼‰\nå¢é‡å›æ”¶çš„åŠ å…¥ä½¿å¾— Lua çš„åœ°ä½å‘ç”Ÿäº†æ ¹æœ¬æ€§çš„æ”¹å˜ï¼Œå›é¡¾å†å²ï¼ŒLua æ­£æ˜¯åœ¨æ­¤æ—¶ä»ä¸€ä¸ªçº¯ç²¹çš„èƒ¶æ°´è¯­è¨€å˜ä¸ºäº†ç¼–ç¨‹è¯­è¨€\nä¸€äº›ä½¿ç”¨è€ç‰ˆæœ¬ Unity çš„æ¸¸æˆé¡¹ç›®æœ‰æ—¶ä¼šå› ä¸ºä½¿ç”¨çš„ C# ç‰ˆæœ¬è¾ƒè€ä¸æ”¯æŒå¢é‡å›æ”¶ï¼Œä¸ºäº†é¿å…åƒåœ¾å›æ”¶å¸¦æ¥çš„åœé¡¿ï¼Œå°†å¯¹è±¡å…¨éƒ¨æ‰˜ç®¡åˆ°äº† Lua ä¸­\nå¦å¤–è¿˜éœ€è¦è¯´æ˜ä¸€ç‚¹ï¼Œå¢é‡å›æ”¶å¤§å¤§å¢åŠ äº†åƒåœ¾å›æ”¶å®ç°çš„å¤æ‚åº¦ï¼Œå¹¶ä¸”äº§ç”Ÿäº†é¢å¤–çš„å¼€é”€ã€‚ä¸€èˆ¬æˆ‘ä»¬é€šè¿‡â€œååé‡â€æ¥æè¿°åƒåœ¾å›æ”¶å™¨çš„æ€§èƒ½ï¼Œè€Œå¢é‡å›æ”¶åŠ¿å¿…ä¼šè®©ååé‡ä¸‹é™ã€‚å› æ­¤ Lua æä¾›äº† collectgarbage æ¥å£å¯ä»¥é€šè¿‡å‚æ•°è°ƒæ•´ç­–ç•¥ï¼Œè‡ªå·±å¯»æ‰¾ä¸€ä¸ªååé‡ä¸æš‚åœæ—¶é—´çš„å¹³è¡¡ç‚¹\nç¨‹åºå¼€å‘ä¸­ä¸€ç›´æœ‰æ‰€è°“çš„â€œäºŒå…«åŸåˆ™â€ï¼Œåƒåœ¾å›æ”¶ä¹Ÿä¸ä¾‹å¤–ã€‚åˆ°ç›®å‰ä¸ºæ­¢æˆ‘æè¿°çš„éƒ½æ˜¯åƒåœ¾å›æ”¶ä¸­æœ€åŸºç¡€çš„æ€æƒ³å’Œæœ€ä¸»è¦çš„å®ç°ï¼Œå®ƒä»¬å æ®äº† 80% çš„æƒ…å†µï¼Œåªéœ€è¦ä»˜å‡º 20% çš„ç»å†ä¸ä»£ç é‡å³å¯å®Œæˆã€‚åœ¨è¿™ä¹‹åæˆ‘ä»¬ä¼šé‡åˆ° 20% çš„è¾¹ç•Œæƒ…å†µï¼Œä¸ºäº†å¯¹ä»˜ä»–ä»¬ï¼Œæˆ‘ä»¬éœ€è¦å¼•å…¥å¤§é‡å¤æ‚çš„è®¾è®¡ï¼Œä»˜å‡º 80% çš„ç²¾åŠ›ä¸ä»£ç é‡\nå†™å±éšœ  åœ¨ä¸Šé¢çš„å¢é‡å›æ”¶æµç¨‹ä¸­ï¼Œæˆ‘ä»¬çœ‹åˆ°äº†ä¸€ä¸ªç†æƒ³çš„æ¨¡å‹ï¼šåœ¨çº¯ç™½çš„åœ°å›¾ä¸Šï¼Œä¸€ä¸ªé»‘è‰²å‡ºç°ï¼Œä¹‹åç°è‰²è¾¹ç•Œäº§ç”Ÿå¹¶æ…¢æ…¢æ‰©æ•£ï¼Œå¹¶ä¸”ç°è‰²æ…¢æ…¢è½¬æ¢ä¸ºé»‘è‰²ï¼Œæœ€ç»ˆå°†åœ°å›¾åˆ†å‰²ä¸ºéé»‘å³ç™½çš„ä¸–ç•Œã€‚å…¶ä¸­ç°è‰²ä½œä¸ºç¼“å†²å¸¦åˆ†å‰²äº†é»‘è‰²ä¸ç™½è‰²ï¼Œé»‘è‰²å¯¹è±¡ä¸ä¼šæŒ‡å‘ç™½è‰²å¯¹è±¡\nä½†å®é™…è¿è¡Œä¸­ï¼Œæˆ‘ä»¬å®Œå…¨æœ‰å¯èƒ½åœ¨åƒåœ¾å›æ”¶æš‚åœçš„è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡èµ‹å€¼æ“ä½œç›´æ¥å°†é»‘è‰²å¯¹è±¡æŒ‡å‘ç™½è‰²å¯¹è±¡ï¼Œä¾‹å¦‚\n_G['X'] = {} -- _G è¡¨ä½œä¸ºæ ¹é›†ä¹‹ä¸€ï¼Œå¾ˆå¯èƒ½æ˜¯é»‘è‰²çš„ï¼›è€Œæ–°å»ºçš„ç©ºè¡¨ä¸€å®šæ˜¯ç™½è‰²çš„\n\nå› æ­¤æˆ‘ä»¬éœ€è¦å¼•å…¥å†™å±éšœæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚å†™å±éšœè¿™ä¸ªåå­—å¬ç€å¾ˆå‰å®³ï¼Œå®é™…ä¸Šå°±æ˜¯åœ¨èµ‹å€¼æ“ä½œé‡Œé¢åŠ äº†ä¸ªåˆ¤æ–­ï¼Œå‘ç°ç™½è‰²å¯¹è±¡è¢«èµ‹å€¼åˆ°äº†é»‘è‰²å¯¹è±¡çš„å¼•ç”¨ä¸­æ—¶ï¼Œå°†å…¶ä¸­ä¸€ä¸ªå¯¹è±¡æ”¹ä¸ºç°è‰²ã€‚åˆ°åº•æŠŠè°æ”¹ä¸ºç°è‰²ï¼Œè¿™ä¸ªä¸€èˆ¬æ˜¯æ ¹æ®æ¦‚ç‡ç»Ÿè®¡å‡ºæ¥çš„ç»éªŒï¼ˆåˆ†æ”¯é¢„æµ‹ï¼‰ï¼Œå› æ­¤è¿™é‡Œä¸å†å±•å¼€è¯´äº†ï¼Œç†è®ºä¸Šæ”¹è°éƒ½å¯ä»¥\nå†æ¬¡ç°è‰²  å¦‚æœä¸€ä¸ªå¯¹è±¡è¢«åå¤æ”¹ä¸ºç°è‰²ï¼ˆæ¯æ¬¡ä»é»‘æ”¹ç°éƒ½æ„å‘³ç€éœ€è¦é‡æ–°æ‰«æè¿™ä¸ªå¯¹è±¡ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡ä¼šè¢«æ ‡è®°ä¸ºä¸€ä¸ªç‰¹æ®Šçš„ç°è‰²ï¼Œä¹‹åå¢é‡é˜¶æ®µä¸å†æ‰«ææ­¤å¯¹è±¡ï¼ˆé¿å…åå¤æ‰«æè¿™ä¸ªå¯¹è±¡ï¼‰ï¼Œæ”¹ä¸ºå¢é‡é˜¶æ®µç»“æŸåä½¿ç”¨ä¸€ä¸ªåŸå­é˜¶æ®µä¸€æ¬¡æ€§æ‰«æ\nå¼±å¼•ç”¨Lua ä½¿ç”¨å¼±è¡¨å®ç°äº†å¼±å¼•ç”¨ï¼Œä½†å¼±è¡¨æœ¬èº«ä¹Ÿæ˜¯éœ€è¦æ‰«æçš„ï¼Œå› ä¸ºå­—ç¬¦ä¸²æœ¬èº«è™½ç„¶æ˜¯ä¸ªå¯å›æ”¶å¯¹è±¡ï¼Œä½†æ˜¯åœ¨ä½œä¸ºå¼±è¡¨çš„é”®å€¼æ—¶æ€»æ˜¯å¼ºå¼•ç”¨ã€‚æ­¤å¤–å¼±è¡¨è¿˜æœ‰ä¸ªç‰¹æ®Šçš„æƒ…å†µï¼Œè€ƒè™‘ä»¥ä¸‹æƒ…å†µï¼š\nlocal t = setmetatable({}, { __mode = 'k' }) -- æ„é€ ä¸€ä¸ªå¼±é”®è¡¨t[X] = Yt[Y] = X\n\nåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œè¡¨çš„é”®ä¸ºå¼±å¼•ç”¨ï¼Œå€¼ä¸ºå¼ºå¼•ç”¨ã€‚å½“æ‰«ææ­¤è¡¨æ—¶ï¼Œå‘ç° X ä¸ Yéƒ½ä½œä¸ºå€¼ï¼Œè€Œè¯¥è¡¨çš„å€¼ä¸ºå¼ºå¼•ç”¨ï¼Œäºæ˜¯è®¤ä¸ºä»–ä»¬è¢«å¼•ç”¨ä½äº†ï¼Œå› æ­¤ä¸ä¼šå›æ”¶è¿™ 2 ä¸ªå¯¹è±¡ã€‚ä½†å®é™…ä¸Šè¿™æ˜¯ä¸€ä¸ªå¼±å¾ªç¯å¼•ç”¨ï¼Œåº”å½“è¢«å›æ”¶ã€‚\nä¸ºæ­¤ï¼ŒLua å¼•å…¥äº†ä¸€ä¸ªå«åšâ€œèœ‰è£è¡¨â€çš„æ¦‚å¿µï¼Œå¯ä»¥æ­£ç¡®å‘ç°å¹¶å›æ”¶è¿™ç§å¼±å¾ªç¯å¼•ç”¨ã€‚ä½ é—®æˆ‘è¿™ä¸ªâ€œèœ‰è£è¡¨â€çš„åŸç†ï¼Ÿè¯·è‡ªå·±å»å•ƒ è®ºæ–‡ å§ï¼Œè¿™ç©æ„å„¿æ²¡äººç¿»è¯‘ï¼Œæˆ‘çœ‹äº†ä¸€çœ¼å°±ç¡ç€äº†\n\nå€¼å¾—æ³¨æ„çš„æ˜¯è®ºæ–‡ä¸­æåˆ°èœ‰è£è¡¨å­˜åœ¨ä¸€äº›â€œæœ€åæƒ…å†µâ€ï¼Œä¾‹å¦‚è¿™ä¸ªä¾‹å­ï¼š\ncollectgarbage 'stop'local oo = {}for i = 1, 5000 do    oo[i] = {}endlocal t = setmetatable({}, { __mode = 'k' })for i = 1, #oo do    local k = oo[i]    local v = oo[i+1]    t[k] = v -- t[o1] = o2, t[o2] = o3, t[o3] = o4 ...endlocal ref = oo[1] -- ç¡®ä¿ o1 æœ‰ä¸ªå¼ºå¼•ç”¨oo = nil -- ç¡®ä¿å…¶ä»–å¯¹è±¡éƒ½æ²¡æœ‰å¤–éƒ¨å¼•ç”¨local clock = os.clock()collectgarbage()print(os.clock() - clock)\n\nåœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œæˆ‘æ„é€ äº†ä¸€ä¸ªèœ‰è£è¡¨ï¼Œè¡¨ä¸­æ‰€æœ‰çš„æ‰€æœ‰çš„é”®å€¼å¯¹å½¢æˆä¸€ä¸ªé“¾ï¼Œå¹¶ç¡®ä¿åªæœ‰ç¬¬ä¸€ä¸ªå¯¹è±¡æœ‰å¤–éƒ¨çš„å¼ºå¼•ç”¨ã€‚åˆ†åˆ«å¯¹èœ‰è£è¡¨ä¸æ­£å¸¸è¡¨è¿›è¡Œäº†åƒåœ¾å›æ”¶æµ‹è¯•ï¼š\n\n\n\nå¯¹è±¡æ•°é‡\næ­£å¸¸è¡¨è€—æ—¶\nèœ‰è£è¡¨è€—æ—¶\n\n\n\n5000\n0.001\n0.064\n\n\n10000\n0.001\n0.36\n\n\n15000\n0.001\n0.607\n\n\n20000\n0.001\n1.368\n\n\n25000\n0.001\n1.764\n\n\n30000\n0.002\n2.172\n\n\n35000\n0.002\n4.369\n\n\n40000\n0.003\n4.981\n\n\n45000\n0.003\n5.868\n\n\n50000\n0.005\n7.293\n\n\nèœ‰è£è¡¨æ˜¯åœ¨ Lua 5.2 ä¸­è¢«å¼•å…¥çš„ï¼ŒLua 5.1 ä¸­å¦‚æœæ²¡æœ‰å¤–éƒ¨å¼ºå¼•ç”¨çš„è¯ä¼šäº§ç”Ÿå†…å­˜æ³„æ¼\n\næ¸…ç†å¼±è¡¨  å¼±è¡¨è§„å®šäº†å½“é”®æˆ–å€¼è¢«å›æ”¶åï¼Œè¿™ä¸ªé”®å€¼å¯¹ä¼šä»å¼±è¡¨ä¸­ç§»é™¤ã€‚è€Œ Lua ä½œä¸ºå¼•ç”¨å®‰å…¨çš„è¯­è¨€ï¼Œä¸å…è®¸å¼•ç”¨æ‚¬ç©ºï¼Œå› æ­¤åœ¨å›æ”¶ä¸€ä¸ªå¯¹è±¡åå¿…é¡»å³æ—¶æŠŠä»–ä»¬ä»å¼±è¡¨ä¸­ç§»é™¤ã€‚åœ¨è¿™é‡Œ Lua ä½¿ç”¨äº†ä¸€ä¸ªåŸå­é˜¶æ®µï¼Œä¼šä¸€æ¬¡æ€§éå†è™šæ‹Ÿæœºä¸­æ‰€æœ‰çš„å¼±è¡¨ï¼Œæ¸…ç†æ‰å¤±æ•ˆçš„é”®å€¼å¯¹ã€‚å› æ­¤å¦‚æœä½ çš„ç¯å¢ƒä¸­å­˜åœ¨å¤§é‡å·¨å¤§çš„å¼±è¡¨ï¼Œè¿™ä¸ªæ¸…ç†é˜¶æ®µå¯èƒ½ä¼šé€ æˆé•¿æ—¶é—´çš„åœé¡¿ã€‚ï¼ˆå…¸å‹çš„ä¾‹å­æ˜¯ï¼Œä¸ºäº†è¿½è¸ªæ‰€æœ‰å¯¹è±¡çš„å­˜æ´»æƒ…å†µï¼Œä½¿ç”¨ä¸€ä¸ªå·¨å¤§çš„å¼±è¡¨ä¿å­˜äº†æ‰€æœ‰çš„å¯¹è±¡ï¼‰\nç»ˆç»“å™¨ï¼ˆè§£æå™¨ï¼‰Lua å…è®¸ä½ é€šè¿‡å…ƒæ–¹æ³• __gc ç»™å¯¹è±¡æ·»åŠ ä¸€ä¸ªç»ˆç»“å™¨ï¼Œå½“å¯¹è±¡è¢«å›æ”¶åå°±ä¼šè°ƒç”¨æ­¤ç»ˆç»“å™¨ï¼Œç”¨äºé‡Šæ”¾å¯¹è±¡èƒŒåå¼•ç”¨çš„èµ„æºï¼ˆæ¯”å¦‚åœ¨æ–‡ä»¶å¯¹è±¡é‡Šæ”¾åå…³é—­æ–‡ä»¶å¥æŸ„ï¼‰\nä¸ºäº†ä¿è¯ä¸€è‡´æ€§ï¼Œæ‰€æœ‰å¸¦æœ‰ç»ˆç»“å™¨çš„çš„å¯¹è±¡ä¼šåœ¨ä¸€ä¸ªåŸå­é˜¶æ®µä¾æ¬¡è°ƒç”¨ï¼ˆæŒ‰ç…§åˆ›å»ºé¡ºåºçš„ååºï¼‰ã€‚ç”±äºè°ƒç”¨ç»ˆç»“å™¨æ—¶éœ€è¦ä¼ å…¥è¢«å›æ”¶çš„å¯¹è±¡ï¼Œå› æ­¤ä¼šè®©è¿™ä¸ªå¯¹è±¡æ´»è¿‡è¿™è½®ã€‚åœ¨ä¸‹ä¸€è½®åƒåœ¾å›æ”¶æ—¶ï¼Œå¦‚æœå‘ç°è¯¥å¯¹è±¡ä¾ç„¶æ²¡æœ‰å¼•ç”¨å°±ä¼šæ­£å¼åˆ é™¤ï¼ˆå½“ç„¶ä¸ä¼šå†è°ƒç”¨ç»ˆç»“å™¨äº†ï¼‰ï¼Œä½†å¦‚æœå‘ç°è¯¥å¯¹è±¡é‡æ–°æœ‰äº†å¼•ç”¨ï¼ˆä½ åœ¨ç»ˆç»“å™¨ä¸­å°†å…¶é‡æ–°å¼•ç”¨ä½äº†ï¼Œä¾‹å¦‚å°†å…¶ä¿å­˜åˆ°äº†å…¨å±€å˜é‡ä¸­ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå¯¹è±¡å°±ä¼šè¢«æ­£å¼å¤æ´»ï¼Œä»¥åå†è¢«å›æ”¶çš„è¯ä¼šé‡æ–°è§¦å‘ç»ˆç»“å™¨\nç”±äºè°ƒç”¨ç»ˆç»“å™¨æ˜¯åŸå­æ“ä½œï¼Œå› æ­¤æˆ‘ä»¬å¿…é¡»è¦ä¿è¯ç»ˆç»“å™¨å†…çš„è¿è¡Œå°½é‡ç®€å•ä»¥å‡å°‘åœé¡¿ã€‚å¦å¤–ä¸ºäº†é¿å…åƒåœ¾å›æ”¶é‡å…¥ï¼Œæ­¤æ—¶çš„åƒåœ¾å›æ”¶æ˜¯æš‚åœçŠ¶æ€ï¼Œå› æ­¤ä¸è¦åˆ›å»ºå¤ªå¤šçš„ä¸´æ—¶å†…å­˜ã€‚è¯´åˆ°åº•è¿˜æ˜¯è¦è®©ç»ˆç»“å™¨å†…çš„æ“ä½œå°½é‡ç®€å•ï¼Œå¤æ‚çš„äº‹æƒ…è¦åŠ å…¥åˆ°é˜Ÿåˆ—ä¸­ä»¥åå†åš\n","categories":["Lua"],"tags":["lua"]},{"title":"æ¸¸æˆä½“ç³»","url":"/2022/08/13/43/","content":"\n             è‹±æ–‡ç®€å†\n          \n\n             åŠ¨ç”»ç³»ç»Ÿ\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n             å››å…ƒæ•°ä¸ä¸‰ç»´æ—‹è½¬\n           goto\n\n            AI\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n             çŠ¶æ€æœº\n          &nbsp;&nbsp;&nbsp;&nbsp;\n            Behavior Tree\n          \n\n            OpenGL\n          \n\n            RL\n          \n\n             å¯»è·¯\n          \n\n            3D è¿ç®—\n          \n\n             å‘é‡è¿ç®—åŠå«ä¹‰\n          \n&nbsp;&nbsp;&nbsp;&nbsp;\n            Geometric Tests\n           goto\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["GamePlay","æ¸¸æˆ","TODO"]},{"title":"Unity æŠ€æœ¯ç¾æœ¯ - Shader ç¯‡","url":"/2023/04/03/47/","content":"ç‰‡æ®µç€è‰²å™¨  å›¾å…ƒã€ç‰‡å…ƒå’Œåƒç´   ç”Ÿæˆçš„å…ˆåé¡ºåºï¼šé¡¶ç‚¹ â†’ å›¾å…ƒ â†’ ç‰‡å…ƒ â†’ åƒç´ \nShaderLab æ¨¡æ¿\nStandard Surface Shader è¡¨é¢ç€è‰²å™¨\nUnlit Shader ä¸å—å…‰ç…§ï¼ˆUnLightï¼‰\nImage Effect Shader åå¤„ç†\nCompute Shader\nRay Tracing Shader\n\nSubShaderGPU ä¼šæ£€æŸ¥ç¬¬ä¸€ä¸ª SubShaderï¼Œå¦‚æœ SubShader ä¸æ”¯æŒï¼ˆæ˜¾å¡ç‰¹æ€§ç­‰ï¼‰ï¼Œä¼šæ£€æŸ¥ç¬¬äºŒä¸ª SubShaderï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„ SubShader å°±ä¼šæ‰§è¡Œ FallBack ä¸­çš„ Shader ä»£ç \nå¸¸ç”¨çš„ cginc\nHLSLSupport.cginc ç¼–è¯‘ CGRPOGRAM æ—¶è‡ªåŠ¨åŒ…å«æ­¤æ–‡ä»¶ï¼Œå…¶ä¸­å£°æ˜äº†å¾ˆå¤šé¢„å¤„ç†å™¨å®å¸®åŠ©å¤šå¹³å°å¼€å‘\nUnityShaderVariables.cginc ç¼–è¯‘ CGRPOGRAM æ—¶è‡ªåŠ¨åŒ…å«æ­¤æ–‡ä»¶ï¼Œå…¶ä¸­å£°æ˜äº†å¾ˆå¤šå„ç§å†…ç½®çš„å…¨å±€å˜é‡\nUnityCG.cginc éœ€è¦æ‰‹åŠ¨æ·»åŠ ï¼Œå…¶ä¸­å£°æ˜äº†å¾ˆå¤šå†…ç½®çš„å¸®åŠ©å‡½æ•°ä¸ç»“æ„\n\næè´¨å±æ€§ Propertiesè¯­æ³•æ ¼å¼// Attribute ä¸ºå±æ€§// _Name ä¸ºå˜é‡å// Dispaly_Name ä¸ºå±•ç¤ºåœ¨æè´¨é¢æ¿ä¸Šçš„åå­—// Type ä¸ºå˜é‡ç±»å‹/********************* *   &#123; *       color, *       int, *       float, *       vector, *       2D, *       3D, *       cube *   &#125;**********************/// Default_Value ä¸ºé»˜è®¤å€¼[Attribute]_Name(&quot;Display_Name&quot;, Type) = Default_Value\n\nProperties&#123;    [HDR]_Color(&quot; é¢œè‰² &quot;, color) = (1, 1, 0, 1)    _Int(&quot; æ•´æ•° &quot;, int) = 0.5    [PowerSlider(3)]_Float(&quot; æµ®ç‚¹æ•° &quot;, range(0, 10)) = 0.5    _Vector(&quot; å››ç»´å‘é‡ &quot;, vector) = (0.5, 2, -1, 1)    _2DTex(&quot;2D çº¹ç† &quot;, 2D) = &quot;black&quot;&#123;&#125;&#125;\n\næ··åˆæ“ä½œ  ç‰‡æ®µç€è‰²å™¨ï¼ˆæºé¢œè‰² * SrcFactorï¼‰ BlendOp å¸§ç¼“å†²åŒº Frame Bufferï¼ˆç›®æ ‡é¢œè‰² * DstFactorï¼‰\nShader ä¸­çš„æ—¶é—´_Time_Time.xyzw\n\n_Time.x (t / 20)\n_Time.y (t)\n_Time.z (t * 2)\n_Time.w (t * 3)\n\nç›¸å…³æœ¯è¯­  è²æ¶…å°”æ•ˆåº”  åœ¨çœŸå®ä¸–ç•Œä¸­ï¼Œé™¤äº†é‡‘å±ä¹‹å¤–ï¼Œå…¶å®ƒç‰©è´¨å‡æœ‰ä¸åŒç¨‹åº¦çš„â€œè²æ¶…å°”æ•ˆåº”â€ã€‚ç®€å•çš„è®²ï¼Œå°±æ˜¯è§†çº¿å‚ç›´äºè¡¨é¢æ—¶ï¼Œåå°„è¾ƒå¼±ï¼Œè€Œå½“è§†çº¿éå‚ç›´è¡¨é¢æ—¶ï¼Œå¤¹è§’è¶Šå°ï¼Œåå°„è¶Šæ˜æ˜¾ã€‚å¦‚æœä½ çœ‹å‘ä¸€ä¸ªåœ†çƒï¼Œé‚£åœ†çƒä¸­å¿ƒçš„åå°„è¾ƒå¼±ï¼Œé è¿‘è¾¹ç¼˜è¾ƒå¼ºã€‚ä¸è¿‡è¿™ç§è¿‡åº¦å…³ç³»è¢«æŠ˜å°„ç‡å½±å“ã€‚å¦‚æœä½ ç«™åœ¨æ¹–è¾¹ï¼Œä½å¤´çœ‹è„šä¸‹çš„æ°´ï¼Œä½ ä¼šå‘ç°æ°´æ˜¯é€æ˜çš„ï¼Œåå°„ä¸æ˜¯ç‰¹åˆ«å¼ºçƒˆï¼›å¦‚æœä½ çœ‹è¿œå¤„çš„æ¹–é¢ï¼Œä½ ä¼šå‘ç°æ°´å¹¶ä¸æ˜¯é€æ˜çš„ï¼Œä½†åå°„éå¸¸å¼ºçƒˆã€‚è¿™å°±æ˜¯â€œè²æ¶…å°”æ•ˆåº”â€\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Shader","Unity","è¯¾ç¨‹"]},{"title":"Unity Shader","url":"/2022/11/25/46/","content":"é›¶æ•£çš„çŸ¥è¯†  æ™®é€šçº¹ç†ç»˜åˆ¶  åœ¨ CG è¯­æ³•ä¸­ï¼Œå½“å±æ€§ä¸­å®šä¹‰äº†ä¸€ä¸ªçº¹ç†ç±»å‹çš„å˜é‡\nProperties &#123;    _MainTex(&quot;Main Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;&#125;\næƒ³è¦åœ¨ CGPROGRAM ä¸­å¼•ç”¨è¿™ä¸ªçº¹ç†ï¼Œå°±éœ€è¦å£°æ˜ä¸€ä¸ªé‡‡æ ·å™¨ï¼š\nsampler2D _MainTex;\n\nè€Œåœ¨ HLSL ä¸­ï¼Œsampler2Dè¿™ä¸ªå¯¹è±¡è¢«æ‹†åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œå³çº¹ç†å¯¹è±¡å’Œé‡‡æ ·å™¨ï¼Œéœ€è¦åŒæ—¶å£°æ˜ä¸¤ä¸ªå˜é‡æ¥ä¿å­˜å®ƒä»¬ï¼š\n/*å£°æ˜ä¸»çº¹ç†å¹¶ä¸”ä¸ºä¸»çº¹ç†è®¾ç½®ä¸€ä¸ªé‡‡æ ·å™¨ï¼ˆè¿™æ˜¯ä¸€ç§å›ºå®šçš„æ ¼å¼ï¼‰ä¸»çº¹ç†çš„å£°æ˜åŒå±æ€§çš„å£°æ˜ï¼Œæ³¨æ„ç±»å‹ä¸º TEXTURE2Dï¼Œé‡‡æ ·é€šè¿‡ SAMPLER æ¥å®šä¹‰ï¼Œæ‹¬å·ä¸­çš„åå­—ä¸ºé‡‡æ ·å™¨çš„å˜é‡åï¼Œå˜é‡åä¸º &lt;sampler_çº¹ç†å &gt;ï¼Œç”±äºè¿™é‡Œçš„çº¹ç†åä¸º MainTexï¼Œæ‰€ä»¥é‡‡æ ·å™¨ä¸º sampler_MainTex*/TEXTURE2D(_MainTex);SAMPLER(sampler_MainTex);\n\nä¹‹åéœ€è¦é€šè¿‡é‡‡æ ·å™¨å‡½æ•° SAMPLE_TEXTURE2D æ¥å¯¹å®ƒä»¬è¿›è¡Œé‡‡æ ·ï¼š\nhalf4 albedo = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, i.uv);\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Graphics","Shader","Unity"]},{"title":"Unity é¢è¯•","url":"/2022/08/19/45/","content":"ä¸šåŠ¡Unity çš„è¿è¡Œæ—¶åº\n    \n\n\nUnity åƒåœ¾å›æ”¶æœºåˆ¶  ç®€å•æ¥çœ‹ä¸‹ BDWGCï¼ˆå…¨ç§°ï¼šBoehm-Demers-Weiser conservative garbage collectorï¼‰ï¼Œä¹Ÿå°±æ˜¯å¸¸è¯´çš„ Boehm å›æ”¶å™¨ã€‚å…¶å®å®ƒé™¤äº†å›æ”¶ä¹‹å¤–è¿˜åšäº†å¾ˆå¤šåˆ†é…çš„å·¥ä½œï¼Œç”šè‡³è¿˜å¯ä»¥ç”¨æ¥æ£€æŸ¥å†…å­˜æ³„æ¼ã€‚\nè€Œ Unity ç”¨çš„æ˜¯æ”¹è‰¯è¿‡çš„ BDWGCï¼Œå®ƒå±äºä¿å®ˆå¼å†…å­˜å›æ”¶ã€‚ç›®å‰ä¸»æµçš„å›æ”¶å™¨æœ‰å¦‚ä¸‹ä¸‰ç§ï¼š\n\nä¿å®ˆå¼å›æ”¶ï¼ˆConservative GCï¼‰ï¼Œä»¥ Boehm ä¸ºä»£è¡¨ã€‚\nåˆ†ä»£å¼å›æ”¶ï¼ˆGenerational GCï¼‰ï¼Œä»¥ SGenï¼ˆSimple Generational GCï¼‰ä¸ºä»£è¡¨ã€‚\nå¼•ç”¨ï¼ˆè®¡æ•°ï¼‰å¼å†…å­˜å›æ”¶ï¼ˆReference Counting GCï¼‰ï¼Œä¾‹å¦‚ Java å°±æ˜¯ä½¿ç”¨çš„è¿™ç§ï¼Œä½†æ˜¯å®ƒæ˜¯ç»“åˆäº†ä¿å®ˆå¼çš„å¼•ç”¨å¼å†…å­˜å›æ”¶ã€‚é‚£ä¹ˆä¸ºä»€ä¹ˆ Unity ä¸ç”¨åˆ†ä»£å¼çš„å‘¢ï¼Ÿåˆ†ä»£å¼çš„æ˜¯å¦æ›´å¥½å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ï¼Œè™½ç„¶åˆ†ä»£å¼ç¡®å®æœ‰å¾ˆå¤šçš„ä¼˜ç‚¹ï¼Œä½†æ˜¯å®ƒä»¬éƒ½è¦ä»˜å‡ºé¢å¤–çš„ä»£ä»·ã€‚ä¾‹å¦‚åˆ†ä»£å¼çš„ GCï¼Œå®ƒè¦è¿›è¡Œå†…å­˜å—çš„ç§»åŠ¨ï¼Œä¸€å—å†…å­˜åœ¨é¢‘ç¹åˆ†é…åŒºé•¿æ—¶é—´ä¸åŠ¨çš„è¯ï¼Œä¼šè¢«ç§»åŠ¨åˆ°é•¿æ—¶åˆ†é…åŒºï¼Œé€ æˆé¢å¤–æ¶ˆè€—ã€‚å¦å¤–æ¯æ¬¡å›æ”¶çš„æ—¶å€™è¿˜è¦è¿›è¡Œä¸€ä¸ªè¯„ä¼°ï¼Œåˆ¤æ–­å½“å‰å†…å­˜æ˜¯å¦æ˜¯ä¸€ä¸ªæ´»è·ƒå†…å­˜ï¼Œè¿™äº›ä¸œè¥¿éƒ½ä¸æ˜¯å…è´¹çš„ï¼Œè€Œæ˜¯è¦æ¶ˆè€—é¢å¤–çš„ CPU æ€§èƒ½ã€‚å½“ç„¶ sGen ä¹Ÿæœ‰å®ƒçš„ä¼˜åŠ¿ï¼Œä¾‹å¦‚å®ƒæ˜¯å¯ç§»åŠ¨çš„ï¼Œå¯ä»¥è¿›è¡Œåˆå¹¶çš„ï¼ˆå¯ä»¥å‡å°‘å†…å­˜ç¢ç‰‡ï¼‰ç­‰ç­‰ã€‚ä½†æ˜¯åœ¨è®¡ç®—åŠ›æœ¬èº«å°±å¾ˆç´§å¼ çš„ç§»åŠ¨å¹³å°ä¸Šï¼Œå†èŠ±è´¹ CPU å»è®¡ç®—å†…å­˜çš„æ¬è¿å’Œç§»åŠ¨å®é™…ä¸Šæ˜¯ä¸åˆç®—çš„ï¼Œå¼•ç”¨è®¡æ•°ä¹Ÿæœ‰ç±»ä¼¼çš„é—®é¢˜ï¼Œæ‰€ä»¥ unity è¿˜æ˜¯ä½¿ç”¨ç›¸å¯¹æ¯”è¾ƒä¿å®ˆçš„ Boehm å›æ”¶ã€‚\n\nUnity æ•°æ®æŒä¹…åŒ–ä½ ä½¿ç”¨è¿‡å“ªäº›ã€è¯´è¯´å®ƒä»¬ä¹‹é—´çš„ä¼˜ç¼ºç‚¹ PlayerPrefs è¿™æ˜¯ Unity è‡ªå¸¦çš„è§£å†³æ–¹æ¡ˆï¼Œä¼šè‡ªåŠ¨ç”Ÿæˆæ–‡ä»¶å­˜å‚¨äºæœ¬åœ°ï¼ŒAPI ç®€å•ï¼Œå°è£…äº†ç¹ççš„åºåˆ—åŒ–ååºåˆ—åŒ–è¿‡ç¨‹ï¼Œä½†ä»–åªæ”¯æŒå‡ ç§åŸºæœ¬æ•°æ®ç±»å‹ï¼Œstringã€intã€floatï¼Œæ¯”è¾ƒç®€å•çš„æ•°æ®å­˜è¯»å–åŠŸèƒ½çš„è¯ï¼Œç”¨è¿™ä¸ªä¼šæ¯”è¾ƒæ–¹ä¾¿ã€‚\nScriptableObjectScriptableObject å¹¶ä¸ä¾èµ–äºæ¸¸æˆå¯¹è±¡ï¼ˆGameObjectï¼‰ï¼Œä¹Ÿä¸å—åœºæ™¯åŠ è½½å’Œå¸è½½çš„å½±å“ã€‚å®ƒçš„ç”Ÿå‘½å‘¨æœŸç”± Unity å¼•æ“ç®¡ç†\nåºåˆ—åŒ–ï¼šJsonã€XMLã€äºŒè¿›åˆ¶  å…³äºåºåˆ—åŒ–ï¼š\n\nå¿…é¡»æ˜¯ public ç±»ï¼Œå…¶ä¸­çš„å­—æ®µæˆ–å±æ€§å¿…é¡»æ˜¯å¯åºåˆ—åŒ–çš„\nç±»ä¸­çš„æ–¹æ³•ä¸ä¼šè¢«åºåˆ—åŒ–\næ„é€ å‡½æ•°ä¸å¯è¢«åºåˆ—åŒ–\nä¸å¯è¢«åºåˆ—åŒ–çš„æ•°æ®ç±»å‹ï¼š\né™æ€ç±»æˆ–é™æ€æˆå‘˜\nå§”æ‰˜\näº‹ä»¶\næŒ‡é’ˆ\nç´¢å¼•å™¨\n\n\n\nJson æ˜¯å­—ç¬¦ä¸²æ–‡æœ¬ï¼Œå¯ä»¥å­˜å‚¨å¤æ‚ä¸€ç‚¹çš„å¯¹è±¡ï¼›XML ä¸€æ ·å¯ä»¥å­˜å‚¨å¤æ‚æ•°æ®å¯¹è±¡ï¼Œç›¸è¾ƒäº Json ä¼˜ç‚¹æ˜¯å¯è¯»æ€§è‰¯å¥½ï¼Œä½†æ•ˆç‡è¾ƒä½ï¼Œé€‚åˆå¤§é‡çš„æ•°æ®é…ç½®ï¼›äºŒè¿›åˆ¶å°±æ˜¯ 01 åºåˆ—ï¼Œåœ¨æ•°æ®å­˜å‚¨å’Œä¼ è¾“æ•ˆç‡ã€ç´§å‡‘æ€§å’Œé€Ÿåº¦ä¸Šå æœ‰ä¼˜åŠ¿ï¼ˆProtoBufã€MessagePackï¼‰\nå‡ ä¸ªå« Serialize çš„ç›¸å…³å±æ€§\nSerializableæ˜¯ä¸€ä¸ª C# ä¸­çš„ç‰¹æ€§ï¼Œå®ƒå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªç±»æ˜¯å¯ä»¥è¢«åºåˆ—åŒ–\nSerializeReferenceæ˜¯ Unity 2019.3 å¼•å…¥çš„æ–°ç‰¹æ€§ï¼Œç”¨äºå¤„ç†å¤šæ€å¯¹è±¡çš„åºåˆ—åŒ–ï¼Œä½¿å¾—å¯ä»¥åœ¨ Inspector çª—å£ä¸­ä¸ºè¯¥å­—æ®µåˆ†é…ä»»æ„ç»§æ‰¿è‡ªåŒæ„çˆ¶ç±»çš„å¯¹è±¡\nSerializeFieldè¿™ä¸ªæ˜¯æŠŠ private å˜é‡æš´éœ²åˆ° Inspector ä¸­\n\nC#List çš„åº•å±‚åŸç†ã€Dictionary çš„åº•å±‚åŸç† List åº•å±‚å®ç°æµ…æAdd åœ¨Addå‰ï¼Œéƒ½ä¼šè°ƒç”¨ EnsureCapacity æ¥ä¿è¯æœ‰å……è¶³çš„ç©ºé—´å­˜æ”¾å…ƒç´ ï¼Œå¦‚æœå®¹é‡ä¸è¶³ï¼Œå°±ä¼šè¿›è¡Œæ‰©å®¹ï¼Œæ¯æ¬¡å®¹é‡ä¸å¤Ÿçš„æ—¶å€™ï¼Œæ•´ä¸ªæ•°ç»„çš„å®¹é‡éƒ½ä¼šæ‰©å……ä¸€å€ï¼Œ_defaultCapacityæ˜¯å®¹é‡çš„é»˜è®¤å€¼ä¸º 4ã€‚å› æ­¤æ•´ä¸ªæ‰©å……çš„è·¯çº¿ä¸º 4ï¼Œ8ï¼Œ16ï¼Œ32ï¼Œ64ï¼Œ128ï¼Œ256ï¼Œ512ï¼Œ1024ï¼Œâ€¦â€¦ä»¥æ­¤ç±»æ¨\n\nList ä½¿ç”¨æ•°ç»„å½¢å¼ä½œä¸ºåº•å±‚æ•°æ®ç»“æ„ï¼Œå¥½å¤„æ˜¯ä½¿ç”¨ç´¢å¼•æ–¹å¼æå–å…ƒç´ å¾ˆå¿«ï¼Œä½†åœ¨æ‰©å®¹çš„æ—¶å€™å°±ä¼šå¾ˆç³Ÿç³•ï¼Œæ¯æ¬¡ new æ•°ç»„éƒ½ä¼šé€ æˆå†…å­˜åƒåœ¾ï¼Œè¿™ç»™åƒåœ¾å›æ”¶ GC å¸¦æ¥äº†å¾ˆå¤šè´Ÿæ‹…\n\nInsertpublic void Insert(int index, T item) {    // Note that insertions at the end are legal.    if ((uint) index &gt; (uint)_size) {        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.index, ExceptionResource.ArgumentOutOfRange_ListInsert);    }    Contract.EndContractBlock();    if (_size == _items.Length) EnsureCapacity(_size + 1);    if (index &lt; _size) {        Array.Copy(_items, index, _items, index + 1, _size - index);    }    _items[index] = item;    _size++;                _version++;}\n\næ’å…¥çš„å…³é”®å°±æ˜¯ Array.Copy(_items, index, _items, index +1, _size - index)ï¼ŒæŠŠæŒ‡å®šç´¢å¼•åŠ  1 åˆ°æ•°ç»„æœ«å°¾çš„å…ƒç´ å‘åç§»åŠ¨ï¼Œç„¶åèµ‹å€¼ï¼Œè¿™ä¸ªè·Ÿæ•°ç»„çš„æ’å…¥åˆ é™¤ä¸€æ ·ï¼Œéƒ½è¦èŠ±è´¹ çš„æ—¶é—´å»æŒªåŠ¨æ•°ç»„\nRemovepublic bool Remove(T item) {    int index = IndexOf(item);    if (index &gt;= 0) {        RemoveAt(index);        return true;    }    return false;}public void RemoveAt(int index) {    if ((uint)index &gt;= (uint)_size) {        ThrowHelper.ThrowArgumentOutOfRangeException();    }    Contract.EndContractBlock();    _size--;    if (index &lt; _size) {        Array.Copy(_items, index + 1, _items, index, _size - index);    }    _items[_size] = default(T);    _version++;}\n\nåˆ é™¤è·Ÿæ’å…¥ç›¸åï¼ŒArray.Copy(_items, index +1, _items, index, _size - index)ï¼Œç”¨IndexOfï¼ˆéå†ï¼‰æ‰¾åˆ°æŒ‡å®šå…ƒç´ åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ï¼Œç„¶åç”¨æŒ‡å®šç´¢å¼•åŠ  1 åˆ°æ•°ç»„æœ«å°¾çš„å…ƒç´ å‘å‰ç§»åŠ¨ï¼Œè¦†ç›–ã€‚è¿™ä¸ªæ­¥éª¤ï¼Œè¢«åˆ é™¤å…ƒç´ åé¢çš„æ•°éƒ½è¦å¾€å‰ç§»åŠ¨ï¼Œæ—¶é—´å¤æ‚åº¦\n\nåœ¨ä½¿ç”¨ List çš„æ—¶å€™ï¼Œè¦æ³¨æ„ï¼Œå¦‚æœè¿‡äºé¢‘ç¹ä½¿ç”¨çš„è¯ï¼Œä¼šå¯¼è‡´æ•ˆç‡é™ä½ï¼Œä¹Ÿä¼šé€ æˆä¸å°‘å†…å­˜çš„å†—ä½™ï¼Œä½¿å¾—åƒåœ¾å›æ”¶ (GC) æ—¶æ‰¿æ‹…äº†æ›´å¤šçš„å‹åŠ›\n\nç´¢å¼•public T this[int index] {    get {        // Following trick can reduce the range check by one        if ((uint) index &gt;= (uint)_size) {            ThrowHelper.ThrowArgumentOutOfRangeException();        }        Contract.EndContractBlock();        return _items[index];     }    set {        if ((uint) index &gt;= (uint)_size) {            ThrowHelper.ThrowArgumentOutOfRangeException();        }        Contract.EndContractBlock();        _items[index] = value;        _version++;    }}\n\nClearpublic void Clear() {    if (_size &gt; 0)    {        Array.Clear(_items, 0, _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references.        _size = 0;    }    _version++;}\n\nClearæ¥å£åœ¨è°ƒç”¨æ—¶å¹¶ä¸ä¼šåˆ é™¤æ•°ç»„ï¼Œè€Œåªæ˜¯å°†æ•°ç»„ä¸­çš„å…ƒç´ æ¸…é›¶ï¼Œå¹¶è®¾ç½® _size ä¸º 0 è€Œå·²ï¼Œç”¨äºè™šæ‹Ÿåœ°è¡¨æ˜å½“å‰å®¹é‡ä¸º 0\nforeachå·²ç»åœ¨ unity5.5 è§£å†³ä¹‹å‰ï¼Œforeachæ¯æ¬¡è·å–è¿­ä»£å™¨æ—¶ï¼Œä¼šæ–°å»ºä¸€ä¸ªEnumeratorï¼Œå¦‚æœå¤§é‡ä½¿ç”¨è¿­ä»£å™¨çš„è¯å°±ä¼šé€ æˆå¤§é‡çš„åƒåœ¾å¯¹è±¡ï¼Œåœ¨ unity5.5 è§£å†³ä¹‹åå°±ä¸ä¼šäº§ç”Ÿé¢å¤–çš„ GC äº†\nSortArray.Sortä½¿ç”¨çš„æ˜¯å¿«é€Ÿæ’åºæ–¹å¼è¿›è¡Œæ’åºï¼ŒList çš„ Sort æ’åºçš„æ•ˆç‡ä¸ºã€‚\nDictionary åº•å±‚å®ç°æµ…æ Entry ç»“æ„ä½“ Dictionary ç§å­˜æ”¾æ•°æ®çš„æœ€å°å•ä½ï¼Œè°ƒç”¨Add(Key, Value) æ–¹æ³•æ·»åŠ çš„å…ƒç´ éƒ½ä¼šè¢«å°è£…åœ¨è¿™æ ·çš„ä¸€ä¸ªç»“æ„ä½“ä¸­\nprivate struct Entry {    public int hashCode;    // é™¤ç¬¦å·ä½ä»¥å¤–çš„ 31 ä½ hashCode å€¼ï¼Œå¦‚æœè¯¥ Entry æ²¡æœ‰è¢«ä½¿ç”¨ï¼Œé‚£ä¹ˆä¸º -1    public int next;        // ä¸‹ä¸€ä¸ªå…ƒç´ çš„ä¸‹æ ‡ç´¢å¼•ï¼Œå¦‚æœæ²¡æœ‰ä¸‹ä¸€ä¸ªå°±ä¸º -1    public TKey key;        // å­˜æ”¾å…ƒç´ çš„é”®    public TValue value;    // å­˜æ”¾å…ƒç´ çš„å€¼}\n\né™¤äº† Entry ç»“æ„ä½“å¤–ï¼Œè¿˜æœ‰å‡ ä¸ªå…³é”®çš„ç§æœ‰å˜é‡\nprivate int[] buckets;\t\t// Hash æ¡¶private Entry[] entries;\t// Entry æ•°ç»„ï¼Œå­˜æ”¾å…ƒç´ private int count;\t\t\t// å½“å‰ entries çš„ index ä½ç½®private int version;\t\t// å½“å‰ç‰ˆæœ¬ï¼Œé˜²æ­¢è¿­ä»£è¿‡ç¨‹ä¸­é›†åˆè¢«æ›´æ”¹private int freeList;\t\t// è¢«åˆ é™¤ Entry åœ¨ entries ä¸­çš„ä¸‹æ ‡ indexï¼Œè¿™ä¸ªä½ç½®æ˜¯ç©ºé—²çš„private int freeCount;\t\t// æœ‰å¤šå°‘ä¸ªè¢«åˆ é™¤çš„ Entryï¼Œæœ‰å¤šå°‘ä¸ªç©ºé—²çš„ä½ç½®private IEqualityComparer&lt;TKey&gt; comparer;\t// æ¯”è¾ƒå™¨private KeyCollection keys;\t\t// å­˜æ”¾ Key çš„é›†åˆprivate ValueCollection values;\t\t// å­˜æ”¾ Value çš„é›†åˆ\n\nAdd æ“ä½œpublic void Add(TKey key, TValue value) {    Insert(key, value, true);}private void Insert(TKey key, TValue value, bool add){        if(key == null ) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets == null) Initialize(0);    // é€šè¿‡ key è·å– hashCode    int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;    // è®¡ç®—å‡ºç›®æ ‡ bucket ä¸‹æ ‡    int targetBucket = hashCode % buckets.Length;\t// ç¢°æ’æ¬¡æ•°    int collisionCount = 0;    for (int i = buckets[targetBucket]; i &gt;= 0; i = entries[i].next) {        if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {            // å¦‚æœæ˜¯å¢åŠ æ“ä½œï¼Œéå†åˆ°äº†ç›¸åŒçš„å…ƒç´ ï¼Œé‚£ä¹ˆæŠ›å‡ºå¼‚å¸¸            if (add) {\t\t\t\tThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);            }            // å¦‚æœä¸æ˜¯å¢åŠ æ“ä½œï¼Œé‚£å¯èƒ½æ˜¯ç´¢å¼•èµ‹å€¼æ“ä½œ dictionary[\"foo\"] = \"foo\"            // é‚£ä¹ˆèµ‹å€¼åç‰ˆæœ¬ ++ï¼Œé€€å‡º            entries[i].value = value;            version++;            return;        }        // æ¯éå†ä¸€ä¸ªå…ƒç´ ï¼Œéƒ½æ˜¯ä¸€æ¬¡ç¢°æ’        collisionCount++;    }    int index;    // å¦‚æœæœ‰è¢«åˆ é™¤çš„å…ƒç´ ï¼Œé‚£ä¹ˆå°†å…ƒç´ æ”¾åˆ°è¢«åˆ é™¤å…ƒç´ çš„ç©ºé—²ä½ç½®    if (freeCount &gt; 0) {        index = freeList;        freeList = entries[index].next;        freeCount--;    }    else {        // å¦‚æœå½“å‰ entries å·²æ»¡ï¼Œé‚£ä¹ˆè§¦å‘æ‰©å®¹        if (count == entries.Length)        {            Resize();            targetBucket = hashCode % buckets.Length;        }        index = count;        count++;    }    // ç»™ entry èµ‹å€¼    entries[index].hashCode = hashCode;    entries[index].next = buckets[targetBucket];    entries[index].key = key;    entries[index].value = value;    buckets[targetBucket] = index;    // ç‰ˆæœ¬å· ++    version++;    // å¦‚æœç¢°æ’æ¬¡æ•°å¤§äºè®¾ç½®çš„æœ€å¤§ç¢°æ’æ¬¡æ•°ï¼Œé‚£ä¹ˆè§¦å‘ Hash ç¢°æ’æ‰©å®¹    if(collisionCount &gt; HashHelpers.HashCollisionThreshold &amp;&amp; HashHelpers.IsWellKnownEqualityComparer(comparer))     {        comparer = (IEqualityComparer&lt;TKey&gt;) HashHelpers.GetRandomizedEqualityComparer(comparer);        Resize(entries.Length, true);    }}\n\nFind æ“ä½œ// å¯»æ‰¾ Entry å…ƒç´ çš„ä½ç½®private int FindEntry(TKey key) {    if(key == null) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets != null) {        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF; // è·å– HashCodeï¼Œå¿½ç•¥ç¬¦å·ä½        // int i = buckets[hashCode % buckets.Length] æ‰¾åˆ°å¯¹åº”æ¡¶ï¼Œç„¶åè·å– entry åœ¨ entries ä¸­ä½ç½®        // i &gt;= 0; i = entries[i].next éå†å•é“¾è¡¨        for (int i = buckets[hashCode % buckets.Length]; i &gt;= 0; i = entries[i].next) {            // æ‰¾åˆ°å°±è¿”å›äº†            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) return i;        }    }    return -1;}internal TValue GetValueOrDefault(TKey key) {    int i = FindEntry(key);    // å¤§äºç­‰äº 0 ä»£è¡¨æ‰¾åˆ°äº†å…ƒç´ ä½ç½®ï¼Œç›´æ¥è¿”å› value    // å¦åˆ™è¿”å›è¯¥ç±»å‹çš„é»˜è®¤å€¼    if (i &gt;= 0) {        return entries[i].value;    }    return default(TValue);} public bool TryGetValue(TKey key, out TValue value) {    int i = FindEntry(key);    if (i &gt;= 0) {        value = entries[i].value;        return true;    }    value = default(TValue);    return false;}\n\nRemove æ“ä½œpublic bool Remove(TKey key) {    if(key == null) {        ThrowHelper.ThrowArgumentNullException(ExceptionArgument.key);    }    if (buckets != null) {        // 1. é€šè¿‡ key è·å– hashCode        int hashCode = comparer.GetHashCode(key) &amp; 0x7FFFFFFF;        // 2. å–ä½™è·å– bucket ä½ç½®        int bucket = hashCode % buckets.Length;        // last ç”¨äºç¡®å®šæ˜¯å¦å½“å‰ bucket çš„å•é“¾è¡¨ä¸­æœ€åä¸€ä¸ªå…ƒç´         int last = -1;        // 3. éå† bucket å¯¹åº”çš„å•é“¾è¡¨        for (int i = buckets[bucket]; i &gt;= 0; last = i, i = entries[i].next) {            if (entries[i].hashCode == hashCode &amp;&amp; comparer.Equals(entries[i].key, key)) {                // 4. æ‰¾åˆ°å…ƒç´ åï¼Œå¦‚æœ last&lt; 0ï¼Œä»£è¡¨å½“å‰æ˜¯ bucket ä¸­æœ€åä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆç›´æ¥è®© bucket å†…ä¸‹æ ‡èµ‹å€¼ä¸º entries[i].next å³å¯                if (last &lt; 0) {                    buckets[bucket] = entries[i].next;                }                else {                    // 4.1 last ä¸å°äº 0ï¼Œä»£è¡¨å½“å‰å…ƒç´ å¤„äº bucket å•é“¾è¡¨ä¸­é—´ä½ç½®ï¼Œéœ€è¦å°†è¯¥å…ƒç´ çš„å¤´ç»“ç‚¹å’Œå°¾èŠ‚ç‚¹ç›¸è¿èµ·æ¥ï¼Œé˜²æ­¢é“¾è¡¨ä¸­æ–­                    entries[last].next = entries[i].next;                }                // 5. å°† Entry ç»“æ„ä½“å†…æ•°æ®åˆå§‹åŒ–                entries[i].hashCode = -1;                // 5.1 å»ºç«‹ freeList å•é“¾è¡¨                entries[i].next = freeList;                entries[i].key = default(TKey);                entries[i].value = default(TValue);                // *6. å…³é”®çš„ä»£ç ï¼ŒfreeList ç­‰äºå½“å‰çš„ entry ä½ç½®ï¼Œä¸‹ä¸€æ¬¡ Add å…ƒç´ ä¼šä¼˜å…ˆ Add åˆ°è¯¥ä½ç½®                freeList = i;                freeCount++;                // 7. ç‰ˆæœ¬å· +1                version++;                return true;            }        }    }    return false;}\n\nResize æ“ä½œï¼ˆæ‰©å®¹ï¼‰ä¸¤ç§æƒ…å†µä¼šå‘ç”Ÿæ‰©å®¹æ“ä½œï¼š\n\nentriesæ•°ç»„æ»¡äº†ï¼Œæ²¡æœ‰åŠæ³•ç»§ç»­å­˜æ”¾æ–°çš„å…ƒç´ \nDictionary ä¸­å‘ç”Ÿçš„ç¢°æ’æ¬¡æ•°å¤ªå¤šï¼Œä¼šä¸¥é‡å½±å“æ€§èƒ½ï¼Œä¹Ÿä¼šè§¦å‘æ‰©å®¹æ“ä½œ\n\n\nç›®å‰ .Net Framwork 4.7 ä¸­è®¾ç½®çš„ç¢°æ’æ¬¡æ•°é˜ˆå€¼ä¸º 100\n\nprivate void Resize() {    Resize(HashHelpers.ExpandPrime(count), false);}private void Resize(int newSize, bool forceNewHashCodes) {    Contract.Assert(newSize &gt;= entries.Length);    // 1. ç”³è¯·æ–°çš„ Buckets å’Œ entries    int[] newBuckets = new int[newSize];    for (int i = 0; i &lt; newBuckets.Length; i++) newBuckets[i] = -1;    Entry[] newEntries = new Entry[newSize];    // 2. å°† entries å†…å…ƒç´ æ‹·è´åˆ°æ–°çš„ entries æ€»    Array.Copy(entries, 0, newEntries, 0, count);    // 3. å¦‚æœæ˜¯ Hash ç¢°æ’æ‰©å®¹ï¼Œä½¿ç”¨æ–° HashCode å‡½æ•°é‡æ–°è®¡ç®— Hash å€¼    if(forceNewHashCodes) {        for (int i = 0; i &lt; count; i++) {            if(newEntries[i].hashCode != -1) {                newEntries[i].hashCode = (comparer.GetHashCode(newEntries[i].key) &amp; 0x7FFFFFFF);            }        }    }    // 4. ç¡®å®šæ–°çš„ bucket ä½ç½®    // 5. é‡å»º Hahs å•é“¾è¡¨    for (int i = 0; i &lt; count; i++) {        if (newEntries[i].hashCode &gt;= 0) {            int bucket = newEntries[i].hashCode % newSize;            newEntries[i].next = newBuckets[bucket];            newBuckets[bucket] = i;        }    }    buckets = newBuckets;    entries = newEntries;}\n\nCollection ç‰ˆæœ¬æ§åˆ¶  è¿­ä»£è¿‡ç¨‹ä¸­ä¸å…è®¸é›†åˆå‡ºç°å˜åŒ–ï¼Œå¦åˆ™ä¼šæŠ›å‡º System.InvalidOperationException:â€Collection was modified; enumeration operation may not execute.â€ è¿™æ ·çš„å¼‚å¸¸\ninternal Enumerator(Dictionary&lt;TKey,TValue&gt; dictionary, int getEnumeratorRetType) {    this.dictionary = dictionary;    version = dictionary.version;    index = 0;    this.getEnumeratorRetType = getEnumeratorRetType;    current = new KeyValuePair&lt;TKey, TValue&gt;();} public bool MoveNext() {    if (version != dictionary.version) {        ThrowHelper.ThrowInvalidOperationException(ExceptionResource.InvalidOperation_EnumFailedVersion);    }    // Use unsigned comparison since we set index to dictionary.count+1 when the enumeration ends.    // dictionary.count+1 could be negative if dictionary.count is Int32.MaxValue    while ((uint)index &lt; (uint)dictionary.count) {        if (dictionary.entries[index].hashCode &gt;= 0) {            current = new KeyValuePair&lt;TKey, TValue&gt;(dictionary.entries[index].key, dictionary.entries[index].value);            index++;            return true;        }        index++;    }    index = dictionary.count + 1;    current = new KeyValuePair&lt;TKey, TValue&gt;();    return false;}\n\nåœ¨è¿­ä»£å™¨åˆå§‹åŒ–æ—¶ï¼Œå°±ä¼šè®°å½• dictionary.version ç‰ˆæœ¬å·ï¼Œä¹‹åæ¯ä¸€æ¬¡è¿­ä»£è¿‡ç¨‹éƒ½ä¼šæ£€æŸ¥ç‰ˆæœ¬å·æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æœä¸ä¸€è‡´å°†æŠ›å‡ºå¼‚å¸¸ã€‚è¿™æ ·å°±é¿å…äº†åœ¨è¿­ä»£è¿‡ç¨‹ä¸­ä¿®æ”¹äº†é›†åˆï¼Œé€ æˆå¾ˆå¤šè¯¡å¼‚çš„é—®é¢˜\nè£…ä¿®æ‹†ç®±int x = 1023;object o = x; // è£…ç®±int y = (int) o; // æ‹†ç®±\nè£…ç®±ï¼šå€¼ç±»å‹è½¬æ¢ä¸ºå¼•ç”¨å¯¹è±¡ï¼Œä¸€èˆ¬æ˜¯è½¬æ¢ä¸º System.Object ç±»å‹æˆ–å€¼ç±»å‹å®ç°çš„æ¥å£å¼•ç”¨ç±»å‹\n\nåœ¨å †ä¸­ç”³è¯·å†…å­˜ï¼Œå†…å­˜å¤§å°ä¸ºå€¼ç±»å‹çš„å¤§å°ï¼Œå†åŠ ä¸Šé¢å¤–å›ºå®šç©ºé—´ï¼ˆå¼•ç”¨ç±»å‹çš„æ ‡é…ï¼šTypeHandleå’ŒåŒæ­¥ç´¢å¼•å—ï¼‰\nå°†å€¼ç±»å‹çš„å­—æ®µå€¼ï¼ˆx = 1023ï¼‰æ‹·è´æ–°åˆ†é…çš„å†…å­˜ä¸­\nè¿”å›æ–°å¼•ç”¨å¯¹è±¡çš„åœ°å€ï¼ˆç»™å¼•ç”¨å˜é‡object oï¼‰\n\næ‹†ç®±ï¼šå¼•ç”¨ç±»å‹è½¬æ¢ä¸ºå€¼ç±»å‹ï¼Œæ³¨æ„ï¼Œè¿™é‡Œçš„å¼•ç”¨ç±»å‹åªèƒ½æ˜¯è¢«è£…ç®±çš„å¼•ç”¨ç±»å‹å¯¹è±¡\n\næ£€æŸ¥å®ä¾‹å¯¹è±¡ï¼ˆobject oï¼‰æ˜¯å¦æœ‰æ•ˆï¼Œå¦‚æ˜¯å¦ä¸ºnullï¼Œåˆ¤æ–­å…¶è£…ç®±çš„ç±»å‹ä¸æ‹†ç®±çš„ç±»å‹ï¼ˆintï¼‰æ˜¯å¦ä¸€è‡´ï¼Œå¦‚æ£€æµ‹ä¸åˆæ³•ï¼ŒæŠ›å‡ºå¼‚å¸¸\næŒ‡é’ˆè¿”å›ï¼Œå°±æ˜¯è·å–è£…ç®±å¯¹è±¡ï¼ˆobject oï¼‰ä¸­å€¼ç±»å‹å­—æ®µå€¼çš„åœ°å€\nå­—æ®µæ‹·è´ï¼ŒæŠŠè£…ç®±å¯¹è±¡ï¼ˆobject oï¼‰ä¸­å€¼ç±»å‹å­—æ®µå€¼æ‹·è´åˆ°æ ˆä¸Šï¼Œæ„æ€å°±æ˜¯åˆ›å»ºä¸€ä¸ªæ–°çš„å€¼ç±»å‹å˜é‡æ¥å­˜å‚¨æ‹†ç®±åçš„å€¼\n\n\n\nåªæœ‰å€¼ç±»å‹æ‰æœ‰è£…ç®±ã€æ‹†ç®±ä¸¤ä¸ªçŠ¶æ€ï¼Œè€Œå¼•ç”¨ç±»å‹ä¸€ç›´éƒ½åœ¨ç®±å­é‡Œ\nä¸€èˆ¬æ¥è¯´ï¼Œè£…ç®±çš„æ€§èƒ½å¼€é”€æ›´å¤§ï¼Œå› ä¸ºå¼•ç”¨å¯¹è±¡çš„åˆ†é…æ›´åŠ å¤æ‚ï¼Œæˆæœ¬ä¹Ÿæ›´é«˜ï¼Œå€¼ç±»å‹åˆ†é…åœ¨æ ˆä¸Šï¼Œåˆ†é…å’Œé‡Šæ”¾çš„æ•ˆç‡éƒ½å¾ˆé«˜ã€‚è£…ç®±è¿‡ç¨‹æ˜¯éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„å¼•ç”¨ç±»å‹å¯¹è±¡å®ä¾‹ï¼Œæ‹†ç®±è¿‡ç¨‹éœ€è¦åˆ›å»ºä¸€ä¸ªå€¼ç±»å‹å­—æ®µï¼Œå¼€é”€æ›´ä½\n\n\näº‹ä»¶å§”æ‰˜  å§”æ‰˜æ˜¯ä¸€ä¸ªç±»ï¼Œå®ƒå®šä¹‰äº†æ–¹æ³•çš„ç±»å‹ï¼Œä½¿å¾—å¯ä»¥å°†æ–¹æ³•å½“ä½œå¦ä¸€ä¸ªæ–¹æ³•çš„å‚æ•°æ¥è¿›è¡Œä¼ é€’ï¼Œäº‹ä»¶æ˜¯ä¸€ç§ç‰¹æ®Šçš„å§”æ‰˜\nå§”æ‰˜  å§”æ‰˜ï¼Œæ˜¯ä¸€ç§å­˜å‚¨å‡½æ•°å¼•ç”¨çš„ç±»å‹ã€‚å£°æ˜ä¸€ä¸ªå§”æ‰˜ä¸å£°æ˜å‡½æ•°ç±»ä¼¼ï¼ŒåŒºåˆ«åœ¨äºä¸åŒ…å«å‡½æ•°ä½“ï¼Œéœ€è¦ä½¿ç”¨å…³é”®å­—delegateã€‚ä¸€ä¸ªå§”æ‰˜åŒ…å«å…¶å¯ä»¥å¼•ç”¨çš„å‡½æ•°ç­¾åï¼ˆè¿”å›ç±»å‹å’Œå‚æ•°åˆ—è¡¨ï¼‰\nå¯¹äºå§”æ‰˜çš„åˆå§‹åŒ–èµ‹å€¼ï¼Œå¯ä»¥ä½¿ç”¨ä¸¤ç§è¯­æ³•ï¼š\n// æ–¹æ³•ä¸€delegate double ProcessDelegate(double arg1, double arg2);ProcessDelegate process;// æ–¹æ³•äºŒprocess = new ProcessDelegate(Multiply) // double Multiply(double arg1, double arg2)process = Divide; // double Divide(double arg1, double arg2)\n\nå§”æ‰˜å¯¹è±¡å¯ä½¿ç”¨ + è¿ç®—ç¬¦è¿›è¡Œåˆå¹¶ã€‚ä¸€ä¸ªåˆå¹¶å§”æ‰˜è°ƒç”¨å®ƒæ‰€åˆå¹¶çš„ä¸¤ä¸ªå§”æ‰˜ã€‚åªæœ‰ç›¸åŒç±»å‹çš„å§”æ‰˜å¯è¢«åˆå¹¶ã€‚-è¿ç®—ç¬¦å¯ç”¨äºä»åˆå¹¶çš„å§”æ‰˜ä¸­ç§»é™¤ç»„ä»¶å§”æ‰˜ã€‚è¿™æ ·å°±å¯ä»¥åˆ›å»ºä¸€ä¸ªå§”æ‰˜è¢«è°ƒç”¨æ—¶è¦è°ƒç”¨çš„æ–¹æ³•çš„è°ƒç”¨åˆ—è¡¨ã€‚ä½†æ˜¯å¤šæ’­å§”æ‰˜çš„è°ƒç”¨é¡ºåºæ— æ³•ä¿è¯\nå§”æ‰˜çš„ç±»å‹ï¼šdelegateã€Actionã€Funcã€predicate\ndelegateï¼šè‡³å°‘ 0 ä¸ªå‚æ•°ï¼Œè‡³å¤š 32 ä¸ªå‚æ•°ï¼Œå¯ä»¥æ— è¿”å›å€¼ï¼Œä¹Ÿå¯ä»¥æŒ‡å®šè¿”å›å€¼ç±»å‹\nActionï¼šæ˜¯æ— è¿”å›å€¼çš„æ³›å‹å§”æ‰˜\nFuncï¼šæ˜¯æœ‰è¿”å›å€¼çš„æ³›å‹å§”æ‰˜\npredicateï¼šæ˜¯è¿”å› bool å‹çš„æ³›å‹å§”æ‰˜\n\näº‹ä»¶  äº‹ä»¶ç±»ä¼¼äºå¼‚å¸¸ï¼Œéƒ½ç”±å¯¹è±¡å¼•å‘ï¼ˆæˆ–æŠ›å‡ºï¼‰ï¼Œç„¶åé€šè¿‡æä¾›çš„ä»£ç è¿›è¡Œå¤„ç†ã€‚äº‹ä»¶éœ€è¦åœ¨å¤„ç†ä¹‹å‰è¿›è¡Œè®¢é˜…ï¼ˆ subscribe ï¼‰ï¼Œè¡¨ç¤ºæä¾›äº†åœ¨äº‹ä»¶å‘ç”Ÿæ—¶éœ€è¦æ‰§è¡Œçš„ä»£ç ï¼Œå³äº‹ä»¶å¤„ç†ç¨‹åºã€‚C# ä¸­çš„äº‹ä»¶ event å…³é”®å­—æ˜¯è¯­è¨€å±‚é¢çš„  è§‚å¯Ÿè€…æ¨¡å¼  çš„å®ç°ï¼Œå°†äº‹ä»¶çš„å‘èµ·è€…ï¼ˆè¢«è§‚å¯Ÿè€…ï¼‰ä¸å¤„ç†è€…ï¼ˆè§‚å¯Ÿè€…ï¼‰çš„ä»£ç è§£è€¦ã€‚äº‹ä»¶å¤„ç†ç¨‹åºéœ€è¦è¢«åŒ¹é…äº‹ä»¶æ‰€è¦æ±‚çš„è¿”å›å€¼å’Œå‚æ•°ï¼Œè¿™ä¸ªé™åˆ¶ç”±å§”æ‰˜æ¥æŒ‡å®š\nåœ¨ C# ä¸­ï¼Œäº‹ä»¶å°±åƒæ˜¯ä¸€ç§æœºåˆ¶ï¼Œåœ¨ç¨‹åºè¿è¡Œåˆ°ä¸€å®šé˜¶æ®µçš„æ—¶å€™æˆ–è€…é‡åˆ°æŸäº›çŠ¶å†µçš„æ—¶å€™ï¼Œå°±ä¼šè§¦å‘ä¸€ä¸ªäº‹ä»¶ã€‚ç„¶åå¦‚æœæœ‰å…¶ä»–ä»£ç è®¢é˜…äº†è¿™ä¸ªäº‹ä»¶ï¼Œå°±ä¼šè‡ªåŠ¨æ‰§è¡Œè®¢é˜…çš„ä»£ç ã€‚æè¿°èµ·æ¥å¾ˆæŠ½è±¡ï¼Œç®€å•æ¥è®²å°±æ˜¯åœ¨ç±»å£°æ˜ä¸€ä¸ªå§”æ‰˜ï¼Œå¹¶æ ‡è®°è¿™ä¸ªå§”æ‰˜æ˜¯ä¸€ä¸ªäº‹ä»¶ï¼Œåœ¨å¦ä¸€ä¸ªæ–¹æ³•ä¸­æ‰§è¡Œè¿™ä¸ªäº‹ä»¶ã€‚å…¶ä¸­ï¼Œè§¦å‘è¿™ä¸ªäº‹ä»¶çš„ç±»ç§°ä¸ºå‘å¸ƒè€…ï¼Œæ¥å—æˆ–è€…æ³¨å†Œäº†å¤„ç†æ–¹æ³•çš„ç±»ç§°ä¸ºè®¢é˜…è€…\nå£°æ˜ä¸€ä¸ªäº‹ä»¶æœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯ç›´æ¥ä½¿ç”¨EventHandlerï¼Œå¦ä¸€ç§æ˜¯è‡ªå·±å…ˆå®šä¹‰ä¸€ä¸ªå§”æ‰˜ï¼Œç„¶åç”¨è¿™ä¸ªå§”æ‰˜å®šä¹‰äº‹ä»¶\n\nä½¿ç”¨ EventHandler\n\npublic class EventDemo{    public event EventHandler HandlerEvent;}\n\n\nä½¿ç”¨è‡ªå®šä¹‰å§”æ‰˜\n\npublic class EventDemo{    public delegate void EventDelegate(object sender, EventArgs e);    public event EventDelegate DelegateEvent;}\n\nä¸€èˆ¬äº‹ä»¶çš„å®šä¹‰çº¦å®šä¿—ç§°æ˜¯ä¸€ä¸ª void æ–¹æ³•ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯ sender è¡¨ç¤ºäº‹ä»¶çš„å‘å¸ƒè€…ï¼Œé»˜è®¤æ˜¯ object ç±»å‹ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯ EventArgs ç±»å‹çš„äº‹ä»¶å˜é‡ï¼Œè¡¨ç¤ºè§¦å‘äº‹ä»¶æ—¶éœ€è¦è®¢é˜…è€…æ³¨æ„çš„å†…å®¹ï¼Œä¸€èˆ¬ç”¨æ¥ä¼ ä¸€äº›å‚æ•°ï¼›EventArgsåªæœ‰ä¸€ä¸ªé»˜è®¤æ„é€ æ–¹æ³•å’Œå‡ ä¸ªç»§æ‰¿è‡ª Object çš„æ–¹æ³•ã€‚æ‰€ä»¥åœ¨å¼€å‘ä¸­ï¼Œä¼šå®šä¹‰ä¸€ä¸ªäº‹ä»¶å˜é‡ç±»å‹ï¼Œä¸ºäº†ä¿æŒä¸€è‡´ä¼šç»§æ‰¿EventArgs\nDemopublic class EventDemo{    public delegate void EventDelegate(object sender, EventArgs e);    public event EventDelegate DelegateEvent;    public void Trigger()    {        if (DelegateEvent != null)// è§¦å‘äº‹ä»¶ï¼ŒæŒ‰éœ€åˆ¤æ–­äº‹ä»¶çš„è®¢é˜…è€…åˆ—è¡¨æ˜¯å¦ä¸ºç©º        {            DelegateEvent(this, new EventArgs());        }    }}EventDemo demo = new EventDemo(); demo.DelegateEvent += (sender, eventArgs) =&gt;{    // çœç•¥è®¢é˜…è€…çš„æ–¹æ³•å†…å®¹}demo.Trigger();// è§¦å‘äº‹ä»¶\n\nå°†å…¶ä¸­çš„ event å»æ‰ï¼Œç¨‹åºä¾ç„¶æ­£å¸¸è¿è¡Œï¼Œä¸ä¼šå‡ºç°ä»»ä½•é—®é¢˜ã€‚äº‹ä»¶å®é™…ä¸Šæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å§”æ‰˜å®ä¾‹ï¼Œä¸ç”¨äº‹ä»¶ä¹Ÿæ²¡æœ‰å…³ç³»ã€‚å®é™…ä¸Šäº‹ä»¶åªæ˜¯å‰Šå¼±äº†å§”æ‰˜çš„åŠŸèƒ½ï¼Œeventåœ¨ç¼–è¯‘å™¨è§’åº¦ä¿æŠ¤äº†ç¨‹åºçš„å®‰å…¨ï¼Œå› ä¸ºåªèƒ½ä½¿ç”¨ +=ã€-= æ¥æ³¨å†Œäº‹ä»¶äº†ï¼Œè€Œä¸èƒ½ä½¿ç”¨ = ä¸ºäº‹ä»¶å…³è”æ–¹æ³•ã€‚ï¼ˆåœ¨å§”æ‰˜ä¸­è¿˜å¯ä»¥ä½¿ç”¨ = æ¥ç»‘å®šæ–¹æ³•ï¼Œä¸è¿‡ = æ˜¯ä¸€ç§ç ´åæ€§ä»£ç ï¼Œä¸ç®¡ä¹‹å‰æ˜¯å¦å·²ç»ç»‘å®šçš„æœ‰æ–¹æ³•äº†ï¼Œéƒ½ä¼šå°†å…¶æ¸…é™¤ï¼‰\nC# çš„å¼‚æ­¥å’Œ Unity çš„åç¨‹  åç¨‹ Coroutine â€”â€” ä¼ªå¼‚æ­¥ Unity å¼•æ“æ˜¯å•çº¿ç¨‹çš„ï¼ˆä¹Ÿå°±æ˜¯æœ‰ä¸€ä¸ªä¸»çº¿ç¨‹ï¼‰ã€‚ä¸ºäº†æ»¡è¶³å¼€å‘è€…çš„ç‰¹å®šçš„ å¼‚æ­¥ ã€ å¤šçº¿ç¨‹  çš„å¼€å‘éœ€æ±‚ï¼ŒUnity ä¹Ÿæä¾›äº†ä¸€ä¸ª  ä¼ªå¼‚æ­¥  çš„è§£å†³æ€æƒ³â€”â€”åç¨‹ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œåç¨‹ä¸æ˜¯çº¿ç¨‹ï¼Œä¹Ÿä¸æ˜¯å¼‚æ­¥æ‰§è¡Œçš„ï¼Œæœ¬è´¨ä¸Šå…¶å®è¿˜æ˜¯åœ¨ç”Ÿå‘½å‘¨æœŸçš„ Update ä¸­æ‰§è¡Œçš„\nä½¿ç”¨åç¨‹çš„å¥½å¤„å°±åœ¨äºï¼š\n\nå¤§å¤§å‡å°‘äº† Update å‡½æ•°çš„è‡ƒè‚¿\næ–¹ä¾¿å¼€å‘è€…å¯¹ä»£ç çš„é˜…è¯»å’Œç»´æŠ¤\n\nå¼Šç«¯ï¼š\n\nè¿è¡Œæ•ˆç‡æ²¡æœ‰å˜åŒ–\nä¸èƒ½è¿”å›å€¼ï¼Œåªèƒ½æ³¨å…¥å§”æ‰˜è°ƒç”¨\n\nçº¿ç¨‹ Thread â€”â€” çœŸå¼‚æ­¥  å¤šçº¿ç¨‹ï¼ˆThreadï¼‰æ˜¯ C# å¸¦æ¥çš„ç‰¹æ€§ã€‚åœ¨ Unity ä¸­æ°å½“çš„ä½¿ç”¨å¤šçº¿ç¨‹ä¼šæé«˜ä¸€å®šçš„ç¨‹åºæ•ˆç‡ï¼Œä½¿ç”¨å¤šçº¿ç¨‹çš„åœºæ™¯ä¸€èˆ¬æ˜¯æ¶‰åŠåˆ°æ•°æ®çš„åŠ è½½å’Œé€»è¾‘å¤„ç†ï¼Œä¸å¦‚æ–‡ä»¶è¯»å†™ï¼Œç½‘ç»œé€šä¿¡ç­‰ã€‚\nnote\nå­çº¿ç¨‹å†…ä¸å¯è®¿é—®æ¸¸æˆå¯¹è±¡æˆ–è€…ç»„ä»¶ä»¥åŠç›¸å…³çš„ Unity APIï¼Œå¦‚æœéœ€è¦ä¸ä¸»çº¿ç¨‹æ²Ÿé€šçš„è¯éœ€è¦è¿›è¡Œå›è°ƒ\n\n\nåˆ©ç”¨ async å’Œawaitç®€åŒ–å¤šçº¿ç¨‹å¼‚æ­¥è°ƒç”¨\n    \n\n\nå®˜æ–¹å»ºè®®\nä¸¤è€…çš„åŠŸèƒ½æ˜¯æœ‰åŒºåˆ«çš„ï¼Œä½†æ˜¯ä¸€èˆ¬éƒ½æ˜¯è¢«æ­é…ä¸€èµ·ä½¿ç”¨\nawaitè¿ç®—ç¬¦é€šçŸ¥ç¼–è¯‘å™¨å¼‚æ­¥æ–¹æ³•ï¼šåœ¨ç­‰å¾…çš„å¼‚æ­¥è¿‡ç¨‹å®Œæˆåæ‰èƒ½ç»§ç»­é€šè¿‡è¯¥ç‚¹ã€‚ åŒæ—¶ï¼Œæ§åˆ¶è¿”å›è‡³å¼‚æ­¥æ–¹æ³•çš„è°ƒç”¨æ–¹ã€‚\nasyncå…³é”®å­—ä»…ç”¨äºä¿®é¥°æ–¹æ³•ä½“ï¼Œå¹¶ä¸”æ–¹æ³•ä½“ä¸­ä¸€å®šè¦æœ‰ await å…³é”®å­—å­˜åœ¨ï¼Œå¦åˆ™å®ƒä»¬å°†æ°¸ä¸æš‚åœ\nå¯¹ Task&lt;TResult&gt; ç±»å‹å‰ä½¿ç”¨ await å…³é”®å­—ï¼Œä»£è¡¨å¯¹è¯¥ Task è¿›è¡Œå¼‚æ­¥ç­‰å¾…è¿”å›ç»“æœï¼Œå±Šæ—¶ä¼šè¢«æŒ‚èµ·ç›´åˆ°å¼‚æ­¥æ“ä½œå®Œæˆ\n\nCoroutine çš„åŸç†ã€Coroutine åœ¨å“ªäº›åœºæ™¯ä¼šè¢«ç”¨åˆ°A coroutine is a function that is executed partially and, presuming suitable conditions are met, will be resumed at some point in the future until its work is done.\nå³åç¨‹æ˜¯ä¸€ä¸ªåˆ†éƒ¨æ‰§è¡Œï¼Œé‡åˆ°æ¡ä»¶ï¼ˆyield return è¯­å¥ï¼‰ä¼šæŒ‚èµ·ï¼Œç›´åˆ°æ¡ä»¶æ»¡è¶³æ‰ä¼šè¢«å”¤é†’ç»§ç»­æ‰§è¡Œåé¢çš„ä»£ç \né€šè¿‡è®¾ç½® MonoBehaviour è„šæœ¬çš„ enabled å¯¹åç¨‹æ˜¯æ²¡æœ‰å½±å“çš„ï¼Œä½†å¦‚æœ gameObject.SetActive(false) åˆ™å·²ç»å¯åŠ¨çš„åç¨‹åˆ™å®Œå…¨åœæ­¢äº†ï¼Œå³ä½¿åœ¨ Inspector æŠŠ gameObject æ¿€æ´»è¿˜æ˜¯æ²¡æœ‰ç»§ç»­æ‰§è¡Œã€‚ä¹Ÿå°±è¯´åç¨‹è™½ç„¶æ˜¯åœ¨ MonoBehvaviour å¯åŠ¨çš„ï¼ˆStartCoroutineï¼‰ä½†æ˜¯åç¨‹å‡½æ•°çš„åœ°ä½å®Œå…¨æ˜¯è·Ÿ MonoBehaviour æ˜¯ä¸€ä¸ªå±‚æ¬¡çš„ï¼Œä¸å— MonoBehaviour çš„çŠ¶æ€å½±å“ï¼Œä½†è·Ÿ MonoBehaviour è„šæœ¬ä¸€æ ·å— gameObject æ§åˆ¶ï¼Œä¹Ÿåº”è¯¥æ˜¯å’Œ MonoBehaviour è„šæœ¬ä¸€æ ·æ¯å¸§â€œè½®è¯¢â€yieldçš„æ¡ä»¶æ˜¯å¦æ»¡è¶³\nå€¼ç±»å‹å’Œå¼•ç”¨ç±»å‹\nå€¼ç±»å‹å°†æ•°æ®å’Œå†…å­˜éƒ½ä¿å­˜åœ¨åŒä¸€ä½ç½®ï¼Œè€Œå¼•ç”¨ç±»å‹åˆ™ä¼šæœ‰ä¸€ä¸ªæŒ‡å‘å®é™…å†…å­˜åŒºåŸŸçš„æŒ‡é’ˆ\n\n\nå€¼ç±»å‹ ï¼šå½“å°†ä¸€ä¸ªint ç±»å‹çš„å€¼èµ‹å€¼åˆ°å¦ä¸€ä¸ª int ç±»å‹çš„å€¼æ—¶ï¼Œå®ƒå®é™…ä¸Šæ˜¯åˆ›å»ºäº†ä¸€ä¸ªå®Œå…¨ä¸åŒçš„å‰¯æœ¬ã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæ”¹å˜äº†å…¶ä¸­æŸä¸€ä¸ªçš„å€¼ï¼Œå¦ä¸€ä¸ªä¸ä¼šå‘ç”Ÿæ”¹å˜ã€‚C# çš„æ‰€æœ‰å€¼ç±»å‹å‡éšå¼æ´¾ç”Ÿè‡ªSystem.ValueType\nå¼•ç”¨ç±»å‹ ï¼šå½“åˆ›å»ºä¸€ä¸ªå¯¹è±¡å¹¶ä¸”å°†æ­¤å¯¹è±¡èµ‹å€¼ç»™å¦å¤–ä¸€ä¸ªå¯¹è±¡æ—¶ï¼Œä»–ä»¬å½¼æ­¤éƒ½æŒ‡å‘äº†å†…å­˜ä¸­åŒä¸€å—åŒºåŸŸã€‚å› æ­¤ï¼Œå½“å°†obj èµ‹å€¼ç»™ obj1 æ—¶ï¼Œä»–ä»¬éƒ½æŒ‡å‘äº†å †ä¸­çš„åŒä¸€å—åŒºåŸŸã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœæ­¤æ—¶æ”¹å˜äº†å…¶ä¸­ä»»ä½•ä¸€ä¸ªï¼Œå¦ä¸€ä¸ªéƒ½ä¼šå—åˆ°å½±å“\n\nå“ªäº›æ˜¯å€¼ç±»å‹ï¼Œå“ªäº›æ˜¯å¼•ç”¨ç±»å‹\nC# çš„å€¼ç±»å‹åŒ…æ‹¬ï¼šæ•°å€¼ç±»å‹ã€boolã€ç”¨æˆ·å®šä¹‰çš„structï¼Œenumï¼Œå¯ç©ºç±»å‹\nC# çš„å¼•ç”¨ç±»å‹åŒ…æ‹¬ï¼šæ•°ç»„ï¼Œclassã€interfaceã€delegateï¼Œobjectï¼Œstring\n\nC# ä¸­ struct å’Œclassçš„åŒºåˆ«ï¼Œåˆ†åˆ«å­˜æ”¾åœ¨å“ªä¸ªå†…å­˜åŒº\nstructæ˜¯å€¼ç±»å‹ï¼Œclassæ˜¯å¯¹è±¡ç±»å‹\nstructä¸èƒ½è¢«ç»§æ‰¿ï¼Œclasså¯ä»¥è¢«ç»§æ‰¿\nstructé»˜è®¤çš„è®¿é—®æƒé™æ˜¯ publicï¼Œè€Œclass é»˜è®¤çš„è®¿é—®æƒé™æ˜¯private\nstructæ€»æ˜¯æœ‰é»˜è®¤çš„æ„é€ å‡½æ•°ï¼Œå³ä½¿æ˜¯é‡è½½é»˜è®¤æ„é€ å‡½æ•°ä»ç„¶ä¼šä¿ç•™ã€‚è¿™æ˜¯å› ä¸º struct çš„æ„é€ å‡½æ•°æ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„ï¼Œä½†æ˜¯å¦‚æœé‡è½½æ„é€ å‡½æ•°ï¼Œå¿…éœ€å¯¹ struct ä¸­çš„å˜é‡å…¨éƒ¨åˆå§‹åŒ–ã€‚å¹¶ä¸” struct çš„ç”¨é€”æ˜¯é‚£äº›æè¿°è½»é‡çº§çš„å¯¹è±¡ï¼Œä¾‹å¦‚ Lineï¼ŒPoint ç­‰ï¼Œå¹¶ä¸”æ•ˆç‡æ¯”è¾ƒé«˜ã€‚classåœ¨æ²¡æœ‰é‡è½½æ„é€ å‡½æ•°æ—¶æœ‰é»˜è®¤çš„æ— å‚æ•°æ„é€ å‡½æ•°ï¼Œä½†æ˜¯ä¸€è¢«é‡è½½ï¼Œé»˜è®¤æ„é€ å‡½æ•°å°†è¢«è¦†ç›–\nstructçš„ new å’Œ class çš„ new æ˜¯ä¸åŒçš„ã€‚structçš„ new å°±æ˜¯æ‰§è¡Œä¸€ä¸‹æ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªæ–°å®ä¾‹å†å¯¹æ‰€æœ‰çš„å­—æ®µè¿›è¡Œæ‹·è´ã€‚è€Œ class åˆ™æ˜¯åœ¨å †ä¸Šåˆ†é…ä¸€å—å†…å­˜ç„¶åå†æ‰§è¡Œæ„é€ å‡½æ•°ï¼Œstructçš„å†…å­˜å¹¶ä¸æ˜¯åœ¨ new çš„æ—¶å€™åˆ†é…çš„ï¼Œè€Œæ˜¯åœ¨å®šä¹‰çš„æ—¶å€™åˆ†é…\n\nåœ¨ C# ä¸­ï¼Œç”¨ struct æˆ–classæ¥å£°æ˜ä¸€ä¸ªç±»å‹ä¸ºå€¼ç±»å‹ / å¼•ç”¨ç±»å‹ã€‚è€ƒè™‘ä¸‹é¢çš„ä¾‹å­ï¼š\nSomeType[] oneTypes = new SomeType[100];\n\n\nå¦‚æœ SomeType æ˜¯å€¼ç±»å‹ï¼Œåˆ™åªéœ€è¦ä¸€æ¬¡åˆ†é…ï¼Œå¤§å°ä¸º SomeType çš„ 100 å€\nå¦‚æœ SomeType æ˜¯å¼•ç”¨ç±»å‹ï¼Œåˆšå¼€å§‹éœ€è¦ 100 æ¬¡åˆ†é…ï¼Œåˆ†é…åæ•°ç»„çš„å„å…ƒç´ å€¼ä¸ºnullï¼Œç„¶åå†åˆå§‹åŒ– 100 ä¸ªå…ƒç´ ï¼Œç»“æœæ€»å…±éœ€è¦è¿›è¡Œ 101 æ¬¡åˆ†é…ã€‚è¿™å°†æ¶ˆè€—æ›´å¤šçš„æ—¶é—´ï¼Œé€ æˆæ›´å¤šçš„å†…å­˜ç¢ç‰‡ã€‚æ‰€ä»¥ï¼Œå¦‚æœç±»å‹çš„èŒè´£ä¸»è¦æ˜¯å­˜å‚¨æ•°æ®ï¼Œå€¼ç±»å‹æ¯”è¾ƒåˆé€‚\n\nstructå’Œ class åº”ç”¨ä¸Šçš„åŒºåˆ«\nå€¼ç±»å‹é€‚åˆå­˜å‚¨ä¾› C# åº”ç”¨ç¨‹åºæ“ä½œçš„æ•°æ®\nå¼•ç”¨ç±»å‹åº”è¯¥ç”¨äºå®šä¹‰åº”ç”¨ç¨‹åºçš„è¡Œä¸º\n\nåˆ›å»ºå€¼ç±»å‹çš„å‰æ\nè¯¥ç±»å‹çš„ä¸»è¦èŒè´£ç”¨äºæ•°æ®å­˜å‚¨\nè¯¥ç±»å‹çš„å…±æœ‰æ¥å£å®Œå…¨ç”±ä¸€äº›æ•°æ®æˆå‘˜å­˜å–å±æ€§å®šä¹‰\nè¯¥ç±»å‹æ°¸è¿œä¸å¯èƒ½æœ‰å­ç±»\nè¯¥ç±»å‹ä¸å…·æœ‰å¤šæ€è¡Œä¸º\n\nå¯¹è±¡æ± é‡å¤ä¾èµ–å’Œå¾ªç¯ä¾èµ–çš„è¯æ€ä¹ˆå¤„ç†.Net ä¸ Mono çš„å…³ç³».Net.Net æ‹¥æœ‰è·¨è¯­è¨€ï¼Œè·¨å¹³å°æ€§\n\nè·¨è¯­è¨€ï¼šå°±æ˜¯åªè¦æ˜¯é¢å‘ .Net å¹³å°çš„ç¼–ç¨‹è¯­è¨€ï¼Œç”¨å…¶ä¸­ä¸€ç§è¯­è¨€ç¼–å†™çš„ç±»å‹å°±å¯ä»¥æ— ç¼çš„åœ¨å¦å¤–ä¸€ç§è¯­è¨€ç¼–å†™çš„åº”ç”¨ç¨‹åºä¸­äº’æ“ä½œã€‚\nè·¨å¹³å°ï¼šä¸€æ¬¡ç¼–è¯‘ï¼Œä¸éœ€è¦ä»»ä½•ä»£ç ä¿®æ”¹ï¼Œåº”ç”¨ç¨‹åºå°±å¯ä»¥è¿è¡Œåœ¨ä»»æ„åœ¨ .Net å®ç°çš„å¹³å°ä¸Šè·‘ï¼Œå³ä»£ç ä¸ä¾èµ–äºæ“ä½œç³»ç»Ÿï¼Œä¹Ÿä¸ä¾èµ–ç¡¬ä»¶ç¯å¢ƒã€‚ä¸€ä¸ª .Net ç¨‹åºè¿è¡Œçš„æ ¸å¿ƒåœ¨äº .Net\n\nCLRï¼ˆå…¬å…±è¯­è¨€è¿è¡Œæ—¶ï¼Œæˆ–è€…ç§°ä¸º .Net è™šæ‹Ÿæœºï¼Œç±»ä¼¼ Java è™šæ‹Ÿæœºçš„æ¦‚å¿µï¼‰ï¼Œä¸ºäº†è®© .Net ç¨‹åºåœ¨å…¶ä»–å¹³å°ï¼ˆç›®å‰åªèƒ½åœ¨ .Net å¹³å°ï¼Œwindows ç³»ç»Ÿï¼‰ä¸Šè·‘ï¼Œå¾®è½¯å®˜æ–¹è¿˜æ¨å‡ºäº†åœ¨å…¶ä»–å¹³å°ä¸Š (MacOs,Linux) è·‘çš„.Net çš„å®ç°ï¼Œå°±æ¨å‡ºäº† .Net Coreã€‚ç„¶è€Œï¼ŒUnity å¼•æ“éœ€æ±‚ä¹Ÿæ˜¯éœ€è¦è·¨å¹³å°ï¼Œæ”¯æŒå¤šè¯­è¨€ï¼ˆC#ï¼ŒJsï¼ŒBooï¼‰ã€‚å°±å‚è€ƒå¾®è½¯å¼€å‘ .Net Core çš„æ¦‚å¿µï¼Œäºæ˜¯ï¼Œæ¨å‡ºäº† Mono\n\n    \n\n\nMono\n    \n\n\n\nmcs ç¼–è¯‘å™¨ï¼šC#ç¼–è¯‘å™¨ï¼ŒC# ç¼–è¯‘ä¸º IL ä¸­é—´æŒ‡ä»¤\nUnity è·¨å¹³å°çš„åŸç†ï¼šå°±æ˜¯ Mono è¿è¡Œæ—¶ç¼–è¯‘å™¨æ”¯æŒå°† IL ä»£ç è½¬ä¸ºå¯¹åº”å¹³å°åŸç”Ÿç ï¼ŒIL å¯ä»¥åœ¨ä»»ä½•æ”¯æŒ CLI(Common Language Insfrastructure, é€šç”¨è¯­è¨€ç¯å¢ƒç»“æ„ï¼‰ä¸­è¿è¡Œï¼ŒIL çš„è¿è¡Œæ˜¯ä¾æ‰˜äº Mono è¿è¡Œæ—¶\nIOS ä¸æ”¯æŒ jit ç¼–è¯‘åŸå› ï¼šæœºå™¨ç è¢«ç¦æ­¢æ˜ å°„åˆ°å†…å­˜ï¼Œå³å°å­˜äº†å†…å­˜çš„å¯æ‰§è¡Œæƒé™ï¼Œå˜ç›¸çš„å°é”äº† jit ç¼–è¯‘æ–¹å¼ï¼Œè¯¦æƒ…å‚è€ƒ\nJIT ç¼–è¯‘ï¼šå°† IL ä»£ç è½¬ä¸ºå¯¹åº”å¹³å°åŸç”Ÿç å¹¶ä¸”å°†åŸç”Ÿç æ˜ å°„åˆ°è™šæ‹Ÿå†…å­˜ä¸­æ‰§è¡Œã€‚JIT ç¼–è¯‘çš„æ—¶å€™ IL æ˜¯åœ¨ä¾æ‰˜ Mono è¿è¡Œæ—¶ï¼Œè½¬ä¸ºå¯¹åº”çš„åŸç”Ÿç ååœ¨ä¾æ‰˜æœ¬åœ°è¿è¡Œã€‚\nAOTï¼ŒJITï¼ŒFull-AOt ä¸‰è€…å…³ç³»ï¼šæ³¨æ„ JITï¼ŒAOT ç¼–è¯‘å¹¶ä¸æ˜¯äº’æ–¥å…³ç³»ï¼Œä»–ä»¬å¯ä»¥å…±å­˜ã€‚Mono çš„ AOT æ¨¡å¼ä»ç„¶ä¼šä¿ç•™éƒ¨åˆ†ä»£ç åœ¨ç¨‹åºè¿è¡Œæ—¶é‡‡ç”¨ jit ç¼–è¯‘ï¼Œå› ä¸º ios è¢«ç¦æ­¢äº† jitï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒMono æä¾›äº†ä¸€ä¸ªè¢«ç§°ä¸º Full-AOT çš„æ¨¡å¼ã€‚å³é¢„å…ˆå¯¹ç¨‹åºé›†ä¸­æ‰€æœ‰ IL ä»£ç è¿›è¡Œ AOT ç¼–è¯‘ç”Ÿæˆä¸€ä¸ªæœ¬åœ°ä»£ç æ˜ åƒï¼Œç„¶ååœ¨è¿è¡Œæ—¶ç›´æ¥åŠ è½½è¿™ä¸ªæ˜ åƒè€Œä¸å†ä½¿ç”¨ jit\n\nC# ä¸­æŠ½è±¡ç±» abstract å’Œæ¥å£ interface çš„ç›¸åŒç‚¹ä¸åŒºåˆ«  ç›¸åŒç‚¹\néƒ½å¯ä»¥è¢«ç»§æ‰¿\néƒ½ä¸èƒ½è¢«å®ä¾‹åŒ–\néƒ½å¯ä»¥åŒ…å«æ–¹æ³•å£°æ˜\næ´¾ç”Ÿç±»å¿…é¡»å®ç°æœªå®ç°çš„æ–¹æ³•\n\nåŒºåˆ«\næŠ½è±¡åŸºç±»å¯ä»¥å®šä¹‰å­—æ®µã€å±æ€§ã€æ–¹æ³•å®ç°ã€‚æ¥å£åªèƒ½å®šä¹‰å±æ€§ã€ç´¢å¼•å™¨ã€äº‹ä»¶ã€å’Œæ–¹æ³•å£°æ˜ï¼Œä¸èƒ½åŒ…å«å­—æ®µã€‚\næŠ½è±¡ç±»æ˜¯ä¸€ä¸ªä¸å®Œæ•´çš„ç±»ï¼Œéœ€è¦è¿›ä¸€æ­¥ç»†åŒ–ï¼Œè€Œæ¥å£æ˜¯ä¸€ä¸ªè¡Œä¸ºè§„èŒƒã€‚å¾®è½¯çš„è‡ªå®šä¹‰æ¥å£æ€»æ˜¯åå¸¦ able å­—æ®µï¼Œè¯æ˜å…¶æ˜¯è¡¨è¿°ä¸€ç±»â€œæˆ‘èƒ½åšã€‚ã€‚ã€‚â€\næ¥å£å¯ä»¥è¢«å¤šé‡å®ç°ï¼ŒæŠ½è±¡ç±»åªèƒ½è¢«å•ä¸€ç»§æ‰¿\næŠ½è±¡ç±»æ›´å¤šçš„æ˜¯å®šä¹‰åœ¨ä¸€ç³»åˆ—ç´§å¯†ç›¸å…³çš„ç±»é—´ï¼Œè€Œæ¥å£å¤§å¤šæ•°æ˜¯å…³ç³»ç–æ¾ä½†éƒ½å®ç°æŸä¸€åŠŸèƒ½çš„ç±»ä¸­\næŠ½è±¡ç±»æ˜¯ä»ä¸€ç³»åˆ—ç›¸å…³å¯¹è±¡ä¸­æŠ½è±¡å‡ºæ¥çš„æ¦‚å¿µï¼Œå› æ­¤åæ˜ çš„æ˜¯äº‹ç‰©çš„å†…éƒ¨å…±æ€§ï¼›æ¥å£æ˜¯ä¸ºäº†æ»¡è¶³å¤–éƒ¨è°ƒç”¨è€Œå®šä¹‰çš„ä¸€ä¸ªåŠŸèƒ½çº¦å®šï¼Œ å› æ­¤åæ˜ çš„æ˜¯äº‹ç‰©çš„å¤–éƒ¨ç‰¹æ€§\næ¥å£åŸºæœ¬ä¸Šä¸å…·å¤‡ç»§æ‰¿çš„ä»»ä½•å…·ä½“ç‰¹ç‚¹, å®ƒä»…ä»…æ‰¿è¯ºäº†èƒ½å¤Ÿè°ƒç”¨çš„æ–¹æ³•\næ¥å£å¯ä»¥ç”¨äºæ”¯æŒå›è°ƒ, è€Œç»§æ‰¿å¹¶ä¸å…·å¤‡è¿™ä¸ªç‰¹ç‚¹\næŠ½è±¡ç±»å®ç°çš„å…·ä½“æ–¹æ³•é»˜è®¤ä¸ºè™šçš„ï¼Œä½†å®ç°æ¥å£çš„ç±»ä¸­çš„æ¥å£æ–¹æ³•å´é»˜è®¤ä¸ºéè™šçš„ï¼Œå½“ç„¶æ‚¨ä¹Ÿå¯ä»¥å£°æ˜ä¸ºè™šçš„\nå¦‚æœæŠ½è±¡ç±»å®ç°æ¥å£ï¼Œåˆ™å¯ä»¥æŠŠæ¥å£ä¸­æ–¹æ³•æ˜ å°„åˆ°æŠ½è±¡ç±»ä¸­ä½œä¸ºæŠ½è±¡æ–¹æ³•è€Œä¸å¿…å®ç°ï¼Œè€Œåœ¨æŠ½è±¡ç±»çš„å­ç±»ä¸­å®ç°æ¥å£ä¸­æ–¹æ³•\n\næ¸²æŸ“  æ¸²æŸ“æµç¨‹\n    \n\n\nDrawCall æ˜¯ä»€ä¹ˆã€DrawCall è¿‡é«˜ä¼šæœ‰ä»€ä¹ˆå½±å“  ä»€ä¹ˆæ˜¯ DrawCallDrawCall æœ¬èº«çš„å«ä¹‰å¾ˆç®€å•ï¼Œå°±æ˜¯ CPU è°ƒç”¨å›¾åƒç¼–ç¨‹æ¥å£ï¼Œå¦‚ OpenGL ä¸­çš„ glDrawElements å‘½ä»¤æˆ–è€… DirectX ä¸­çš„ DrawlndexedPrimitive å‘½ä»¤ï¼Œä»¥å‘½ä»¤ GPU è¿›è¡Œæ¸²æŸ“çš„æ“ä½œ\nä¸ºä»€ä¹ˆ DrawCall è¿‡é«˜ä¼šå½±å“å¸§ç‡  åœ¨æ¯æ¬¡è°ƒç”¨ DrawCall ä¹‹å‰ï¼Œ CPU éœ€è¦å‘ GPU å‘é€å¾ˆå¤šå†…å®¹ï¼ŒåŒ…æ‹¬æ•°æ®ã€çŠ¶æ€å’Œå‘½ä»¤ç­‰ã€‚åœ¨è¿™ä¸€é˜¶æ®µï¼Œ CPU éœ€è¦å®Œæˆå¾ˆå¤šå·¥ä½œï¼Œä¾‹å¦‚æ£€æŸ¥æ¸²æŸ“çŠ¶æ€ç­‰ã€‚è€Œä¸€æ—¦ CPU å®Œæˆäº†è¿™äº›å‡†å¤‡å·¥ä½œï¼Œ GPU å°±å¯ä»¥å¼€å§‹æœ¬æ¬¡çš„æ¸²æŸ“ã€‚GPU çš„æ¸²æŸ“èƒ½åŠ›æ˜¯å¾ˆå¼ºçš„ï¼Œæ¸²æŸ“ 200 ä¸ªè¿˜æ˜¯ 2000 ä¸ªä¸‰è§’ç½‘æ ¼é€šå¸¸æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œå› æ­¤æ¸²æŸ“é€Ÿåº¦å¾€å¾€å¿«äº CPU æäº¤å‘½ä»¤çš„é€Ÿåº¦ã€‚å¦‚æœ DrawCall çš„æ•°é‡å¤ªå¤šï¼Œ CPU å°±ä¼šæŠŠå¤§é‡æ—¶é—´èŠ±è´¹åœ¨æäº¤ DrawCall ä¸Šï¼Œé€ æˆ CPU çš„è¿‡è½½\nDrawCall ä¼˜åŒ–æ–¹æ¡ˆ\né™æ€åˆå¹¶\nåŠ¨æ€åˆå¹¶\nGPU Instancing\nSRP Batcherï¼ˆæœ¬è´¨ä¸Š DrawCall ä¸ä¼šå‡å°‘ï¼Œå‡å°‘çš„æ˜¯ DrawCall æ•°æ®æ‹·è´ï¼‰\n\n\n â€œå…³äº DrawCall ç›¸å…³è¿˜éœ€è¦æ³¨æ„çš„é—®é¢˜â€\n\nå¦‚æœé™æ€æ‰¹å¤„ç†å‰æœ‰ä¸€äº›ç‰©ä½“å…±äº«äº†ç›¸åŒçš„ç½‘æ ¼ï¼Œé‚£ä¹ˆæ¯ä¸€ä¸ªç‰©ä½“éƒ½ä¼šæœ‰ä¸€ä¸ªè¯¥ç½‘æ ¼çš„å¤åˆ¶å“ï¼ˆæœ¬æ¥ Unity åªä¼šä¿ç•™ä¸€ä»½ï¼Œä½†æ˜¯é™æ€æ‰¹å¤„ç†ä¼šç”Ÿæˆæ–°çš„ä¸€ä¸ªå¤§ç½‘æ ¼ï¼Œæ‰€ä»¥ä¼šä¿ç•™æ‰€æœ‰ç‰©ä½“çš„ç½‘æ ¼ï¼Œæœ€ååˆå¹¶ï¼‰ï¼Œå³ä¸€ä¸ªç½‘æ ¼ä¼šå˜æˆå¤šä¸ªç½‘æ ¼è¢«å‘é€ç»™ GPUï¼Œè¿™å›å¯¼è‡´ä¸€æ¬¡æ€§æäº¤è¿‡å¤§çš„æ•°æ®ï¼Œè™½ç„¶å¼•æ“æ˜¯æœ‰é™åˆ¶çš„ï¼Œä¸€èˆ¬æ˜¯ 65535 ä¸ªé¡¶ç‚¹\nå¯¹äºé‚£äº› shader ç›¸åŒï¼Œçº¹ç†ä¸åŒå¯¼è‡´çš„ä¸åŒæè´¨æ— æ³•è¿›è¡Œæ‰¹å¤„ç†çš„ç‰©ä½“ï¼ˆæ¯”å¦‚é¡¹ç›®ä¸­çš„åœºæ™¯ç¯å¢ƒï¼Œåœ°é¢ï¼Œå¦‚æœéƒ½ä½¿ç”¨äº†æ¯”è¾ƒå¤æ‚çš„ Shaderï¼‰é€šè¿‡çº¹ç†åˆå¹¶çš„æ–¹æ³•æ¥ä½¿å¾—å®ƒä»¬å¯ä»¥è¢«é™æ€æ‰¹å¤„ç†ã€‚ä½†è¿™ä¼šå¼•å‘å¸¦å®½é—®é¢˜ï¼Œè¯¦ç»†åŸå› å…³ç³»åˆ° Bus æ€»çº¿å¸¦å®½çš„é—®é¢˜\nä¸€ä¸‹å­æäº¤å¤§é‡çš„ DrawCall å¯¼è‡´çš„å¡é¡¿é—®é¢˜ï¼Œè¿™ä¸ªå¯ä»¥é˜…è¯»ä¸‹ å¤šçº¿ç¨‹æ¸²æŸ“ ç›¸å…³çš„ã€‚ä¸»è¦æ˜¯å¯èƒ½æ˜¯å› ä¸ºï¼Œæäº¤æ¸²æŸ“ (eglSwapBuffers) ä¼šå¯¼è‡´é©±åŠ¨å±‚ä¸­ç¼“å­˜çš„æ¸²æŸ“æŒ‡ä»¤ç«‹å³æ‰§è¡Œï¼Œæ­¤æ—¶ CPU è¢«é˜»å¡ã€‚å¦‚æœåœ¨æäº¤æ¸²æŸ“æ—¶é©±åŠ¨å±‚ç¼“å­˜äº†å¤§é‡çš„æŒ‡ä»¤ï¼ŒCPU å°±ä¼šè¢«é˜»å¡å¾ˆé•¿æ—¶é—´ï¼›ä¹Ÿå¯èƒ½æ˜¯å› ä¸ºæäº¤å¤§é‡ DrawCall çš„æ—¶å€™å­˜åœ¨çº¹ç†çš„ Upload\nCPU å®Œæˆä¸€æ¬¡ DrawCallï¼Œé™¤äº†éœ€è¦å‘ä¸€ä¸ª DrawCall çš„å‘½ä»¤ä¹‹å¤–ï¼Œè¿˜éœ€è¦æŠŠå†…å­˜ä¸­é¡¶ç‚¹æ•°æ®ã€çº¹ç†è´´å›¾ã€Shader å‚æ•°é€šè¿‡ Bus æ€»çº¿æ‹·è´åˆ°å†…å­˜åˆ†é…ç»™ GPU çš„æ˜¾å­˜ä¹‹ä¸­ï¼Œæ³¨æ„è¿™æ˜¯æ‹·è´ï¼Œä¸æ˜¯æŒ‡é’ˆä¼ é€’ï¼Œé€Ÿåº¦ä¸å¿«ã€‚å¦‚æœä¸€æ¬¡ DrawCall ä¼ é€’çš„æ•°æ®è¿‡å¤§ï¼Œå¸¦å®½æˆä¸ºäº†ç“¶é¢ˆï¼Œé‚£å°±ä¼šå¤§å¤§å½±å“æ•ˆç‡ï¼ˆå…¶å®ƒçš„ DrawCall æ— æ³•å‡ºå‘ï¼ŒGPU åˆå¤„äºé—²ç½®ï¼‰ã€‚è¿™ç§æƒ…å†µæœ€æœ‰å¯èƒ½å‡ºç°åœ¨ä¸ºäº†å‡å°‘ DrawCallï¼Œç–¯ç‹‚çš„åˆå¹¶çº¹ç†ä¸Šã€‚åœ¨é¡¹ç›®ä¸­ï¼ŒUI çš„ DrawCall è°ƒç”¨å äº†å¾ˆå¤§ä¸€éƒ¨åˆ†ï¼Œä¹Ÿä¼šæœ€éš¾ä¼˜åŒ–çš„ã€‚ä¸ºäº†å‡å°‘ DrawCall , æŠŠ UI åˆå¹¶æˆå¤§çš„è´´å›¾ï¼ŒDrawCall ä¸‹é™äº†ï¼Œä½†æ˜¯å¸§ç‡å´ä¹Ÿä¸‹é™äº†ï¼Œå†…å­˜ä½¿ç”¨ä¹Ÿå¢åŠ äº†ï¼ŒåŸå› å°±æ˜¯è¿™ä¸ªã€‚åœ¨é¡¹ç›®ä¸­ï¼Œä¸ä¼šåŒæ—¶å‡ºç°çš„å…ƒç´ ä¸è¦æ‰“åŒ…åˆ°ä¸€èµ·ï¼Œä¿è¯å•å¼ åˆå¹¶çº¹ç†ä¸å¤§äº 1024 ä¸€èˆ¬å°±ä¸ä¼šæœ‰é—®é¢˜äº†ï¼Œæœ€å¤§å°½é‡ä¸è¦è¶…è¿‡ 2048\n\n\nLOD æ˜¯ä»€ä¹ˆï¼Œä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆLOD æŠ€æœ¯å³ Levels of Detail çš„ç®€ç§°ï¼Œæ„ä¸ºå¤šç»†èŠ‚å±‚æ¬¡ã€‚LOD æŠ€æœ¯æŒ‡æ ¹æ®ç‰©ä½“æ¨¡å‹çš„èŠ‚ç‚¹åœ¨ç°å®ç¯å¢ƒä¸­æ‰€å¤„çš„ä½ç½®å’Œé‡è¦åº¦ï¼Œå†³å®šç‰©ä½“æ¸²æŸ“çš„èµ„æºåˆ†é…ï¼Œé™ä½éé‡è¦ç‰©ä½“çš„é¢ç†Ÿå’Œç»†èŠ‚çš„ï¼Œä»è€Œè·å¾—é«˜æ•ˆç‡çš„æ¸²æŸ“è¿ç®—\n\nä¼˜ç‚¹ï¼šå¯æ ¹æ®å…·ä½“åŠ¨æ€åœ°æ¸²æŸ“ä¸åŒç»†èŠ‚çš„æ¨¡å‹\nç¼ºç‚¹ï¼šåŠ é‡ç¾æœ¯çš„è´Ÿæ‹…ï¼Œè¦å‡†å¤‡ä¸åŒç»†èŠ‚çš„åŒä¸€æ¨¡å‹ï¼ŒåŒæ ·çš„ä¼šç¨å¾®å¢åŠ åŒ…ä½“å¤§å°\n\nMipMap æ˜¯ä»€ä¹ˆï¼Œä¼˜ç¼ºç‚¹æ˜¯ä»€ä¹ˆMipMapï¼Œåˆå«å¤šçº§æ¸è¿›è´´å›¾çº¹ç†æ˜ å°„ï¼Œæ ¹æ®æ¸²æŸ“ç‰©ä½“è·ç¦»ç›¸æœºçš„è¿œè¿‘ï¼Œé€‰ç”¨ä¸åŒå¤§å°çš„çº¹ç†è´´å›¾\n\nå¯ä»¥ä½¿å¾—è¿œå¤„çš„åƒç´ ä¸å‘ç”Ÿé—ªçƒ\nå‡å°å¸¦å®½ï¼šå› ä¸ºåœ¨è¯»å–è´´å›¾çš„æ—¶å€™ï¼Œæ­£å¸¸çš„ UV åœ¨ 0~1 çš„åŒºé—´è¿ç»­è¯»å–ï¼ŒGPU ä¼šå°½é‡å°†è¿™ä¸ª Shader ä¸­è¯»å–è¿™å¼ è´´å›¾çš„æŒ‡ä»¤æ‹¼æ¥åœ¨ä¸€èµ·ï¼ŒGPU ä¼šå°†è´´å›¾ä¸­ç¬¬ä¸€ä¸ªè¯»å–æŒ‡ä»¤çš„ UV å€¼çš„å‘¨å›´çš„ä¸€å—åƒç´ è¯»å–åˆ° L2ï¼ŒL1 ç¼“å­˜ä¸­ï¼Œè¿™å°±æ˜¯è´´å›¾è¯»å–çš„é¢„æµ‹ç­–ç•¥ã€‚è¿™æ ·åšçš„å¥½å¤„å°±æ˜¯ï¼šç”±äº UV è¿ç»­ï¼Œè¿™æ ·ä¼šæœ‰é«˜å‘½ä¸­ç‡ç›´æ¥è·å–æ‰€éœ€è¦ UV å€¼çš„é¢œè‰²ï¼Œè¦é‡‡æ ·çš„ä¸¤ä¸ª UV è·ç¦»å¾ˆè¿œæ—¶ï¼Œå½“å†…å­˜ä¸­ä¸å­˜åœ¨è¿™ä¸ªè´´å›¾çš„ UV ä½ç½®çš„å†…å­˜æ•°æ®ï¼Œé‚£ä¹ˆä¹…èŒèƒ½æ¸…ç©ºå½“å‰å·²ç»è¿›å…¥ç¼“å­˜çš„æ•°æ®ï¼Œé‡æ–°é‡‡æ ·å¯¹åº” UV çš„å‘¨å›´ä¸€å—åƒç´ å€¼ï¼Œå†æ¬¡æ”¾å…¥ L2ï¼ŒL1 ç¼“å­˜ä¸­ï¼Œè¿™å°±æ˜¯  ç¼“å­˜å‘½ä¸­ç‡é™ä½  é€ æˆçš„å¸¦å®½ä¸Šå‡\n\nç¼ºç‚¹ï¼šä¼šå ç”¨å†…å­˜ï¼ˆå¤§çº¦ä¸º 1/3ï¼‰\nOverDraw æ˜¯ä»€ä¹ˆï¼Œè¿‡é«˜ä¼šæœ‰ä»€ä¹ˆå½±å“ï¼Œæ€ä¹ˆä¼˜åŒ– OverDrawOverdraw æ˜¯æŒ‡åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ï¼ŒåŒä¸€åƒç´ è¢«å¤šæ¬¡ç»˜åˆ¶çš„ç°è±¡ã€‚å½“æ¸¸æˆä¸­æœ‰å¤§é‡çš„é€æ˜ç‰©ä½“å åŠ åœ¨ä¸€èµ·æ—¶ï¼ŒOverdraw å°±ä¼šå‘ç”Ÿã€‚è¿™æ˜¯å› ä¸ºåœ¨æ¸²æŸ“ç®¡çº¿ä¸­ï¼Œåƒç´ çš„é¢œè‰²è®¡ç®—æ˜¯åŸºäºèƒŒååƒç´ çš„é¢œè‰²è®¡ç®—çš„ã€‚å½“å¤šä¸ªé€æ˜ç‰©ä½“é‡å åœ¨ä¸€èµ·æ—¶ï¼Œæ¯ä¸ªåƒç´ éƒ½éœ€è¦è®¡ç®—å¤šæ¬¡ï¼Œå¯¼è‡´æ€§èƒ½ä¸‹é™ã€‚\né€ æˆ Overdraw çš„åŸå› æœ‰å¾ˆå¤šï¼Œå…¶ä¸­ä¹‹ä¸€æ˜¯ä½¿ç”¨äº†è¿‡å¤šçš„é€æ˜æè´¨ã€‚é€æ˜æè´¨åœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­éœ€è¦é¢å¤–çš„è®¡ç®—èµ„æºï¼Œå› æ­¤ä½¿ç”¨è¿‡å¤šçš„é€æ˜æè´¨ä¼šå¢åŠ  Overdraw çš„å‘ç”Ÿæ¦‚ç‡ã€‚å¦ä¸€ä¸ªåŸå› æ˜¯è¿‡åº¦ä½¿ç”¨ç²’å­ç³»ç»Ÿã€‚ç²’å­ç³»ç»Ÿåœ¨æ¸²æŸ“è¿‡ç¨‹ä¸­ä¼šäº§ç”Ÿå¤§é‡çš„é€æ˜åƒç´ ï¼Œå› æ­¤è¿‡åº¦ä½¿ç”¨ç²’å­ç³»ç»Ÿä¹Ÿä¼šå¢åŠ  Overdraw çš„å‘ç”Ÿã€‚\nä¸ºäº†å‡å°‘ Overdraw å¯¹æ¸¸æˆæ€§èƒ½çš„å½±å“ï¼Œæˆ‘ä»¬å¯ä»¥é‡‡å–ä¸€äº›ä¼˜åŒ–æªæ–½ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬å¯ä»¥åˆå¹¶å¤šä¸ªé€æ˜ç‰©ä½“ä¸ºä¸€ä¸ªç‰©ä½“ã€‚é€šè¿‡å°†å¤šä¸ªé€æ˜ç‰©ä½“åˆå¹¶ä¸ºä¸€ä¸ªç‰©ä½“ï¼Œå¯ä»¥å‡å°‘ Overdraw çš„å‘ç”Ÿã€‚å…¶æ¬¡ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸é€æ˜çš„æè´¨æ›¿ä»£é€æ˜æè´¨ã€‚ä¸é€æ˜æè´¨ä¸éœ€è¦é¢å¤–çš„è®¡ç®—èµ„æºï¼Œå› æ­¤å¯ä»¥å‡å°‘ Overdraw çš„å‘ç”Ÿã€‚æ­¤å¤–ï¼Œæˆ‘ä»¬è¿˜å¯ä»¥é€šè¿‡å‡å°‘ç²’å­ç³»ç»Ÿçš„ä½¿ç”¨æ¥å‡å°‘ Overdraw çš„å‘ç”Ÿã€‚\nå·¥å…· TextMeshProUGUI çš„Text çš„æ–‡å­—æ˜¯å¦‚ä½•æ¸²æŸ“å‡ºæ¥ Text ç»§æ‰¿äº†MaskableGraphic, ILayoutElement\nprotected override void OnPopulateMesh(VertexHelper toFill){    if (font == null)        return;     // We don't care if we the font Texture changes while we are doing our Update.    // The end result of cachedTextGenerator will be valid for this instance.    // Otherwise we can get issues like Case 619238.    m_DisableFontTextureRebuiltCallback = true;     Vector2 extents = rectTransform.rect.size;     var settings = GetGenerationSettings(extents);    cachedTextGenerator.PopulateWithErrors(text, settings, gameObject);     // Apply the offset to the vertices    IList&lt;UIVertex&gt; verts = cachedTextGenerator.verts;    float unitsPerPixel = 1 / pixelsPerUnit;    int vertCount = verts.Count;     // We have no verts to process just return (case 1037923)    if (vertCount &lt;= 0)    {        toFill.Clear();        return;    }     Vector2 roundingOffset = new Vector2(verts[0].position.x, verts[0].position.y) * unitsPerPixel;    roundingOffset = PixelAdjustPoint(roundingOffset) - roundingOffset;    toFill.Clear();    if (roundingOffset != Vector2.zero)    {        for (int i = 0; i &lt; vertCount; ++i)        {            int tempVertsIndex = i &amp; 3;            m_TempVerts[tempVertsIndex] = verts[i];            m_TempVerts[tempVertsIndex].position *= unitsPerPixel;            m_TempVerts[tempVertsIndex].position.x += roundingOffset.x;            m_TempVerts[tempVertsIndex].position.y += roundingOffset.y;            if (tempVertsIndex == 3)                toFill.AddUIVertexQuad(m_TempVerts);        }    }    else    {        for (int i = 0; i &lt; vertCount; ++i)        {            int tempVertsIndex = i &amp; 3;            m_TempVerts[tempVertsIndex] = verts[i];            m_TempVerts[tempVertsIndex].position *= unitsPerPixel;            if (tempVertsIndex == 3)                toFill.AddUIVertexQuad(m_TempVerts);        }    }     m_DisableFontTextureRebuiltCal\n\n\né‡å†™ Graphic çš„OnPopulateMeshæ–¹æ³•ï¼Œä¼šåœ¨ Graphic çš„Rebuildæ–¹æ³•è¢«è°ƒç”¨ï¼Œä¸º CanvasRenderer çš„ Mesh æä¾›äº†é¡¶ç‚¹ä½ç½®ã€é¡¶ç‚¹é¢œè‰²ã€UV å’Œä¸‰è§’å½¢ä¿¡æ¯\næ ¹æ®ç”¨æˆ·è®¾ç½®ç”Ÿæˆäº†ä¸€ä¸ª TextGenerationSettings æ–‡æœ¬ç”Ÿæˆè®¾ç½®ï¼Œç„¶åè°ƒç”¨ TextGenerator.PopulateWithErrors ç”Ÿæˆ Mesh çš„é¡¶ç‚¹ã€é¡¶ç‚¹é¢œè‰²ã€UV å’Œä¸‰è§’å½¢ä¿¡æ¯\nè®¡ç®—åç§»é‡ï¼ˆä¾‹å¦‚å·¦å¯¹é½éœ€è¦ç´§é å·¦è¾¹ï¼‰ï¼Œæœ€åéå† TextGenerator çš„é¡¶ç‚¹æ•°ç»„ï¼Œå°†å®ƒä»¬çš„ä½ç½®é™¤ä»¥pixelsPerUnitï¼ˆæ¯å•å…ƒåƒç´ ï¼‰å¹¶åŠ ä¸Šåç§»é‡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œå¾—åˆ°çš„ç»“æœå¡«åˆ°VertexHelper\n\nUI æ·»åŠ æ–‡æœ¬\n\næ–‡æœ¬å­—å½¢æ˜¯ä½œä¸ºç‹¬ç«‹çš„é¢ç‰‡ (quad) è¿›è¡Œæ¸²æŸ“çš„ï¼Œæ¯ä¸ªå­—ç¬¦éƒ½æ˜¯ä¸€ä¸ªé¢ç‰‡ã€‚è¿™äº›é¢ç‰‡é€šå¸¸éƒ½å«æœ‰å¤§é‡çš„ç©ºç™½åŒºåŸŸå›´ç»•ç€å­—å½¢ï¼Œç©ºç™½åŒºåŸŸçš„å¤§å°å–å†³äºå­—å½¢çš„å½¢çŠ¶ï¼Œåœ¨æ”¾ç½®æ–‡æœ¬æ—¶å¾ˆå®¹æ˜“å°±ä¼šæ— æ„ä¸­ç ´åå…¶ä»– UI å…ƒç´ çš„æ‰¹å¤„ç†\nUI æ–‡æœ¬çš„ç½‘æ ¼é‡å»ºæ˜¯ä¸ªé‡ç‚¹é—®é¢˜ã€‚å½“ Text ç»„ä»¶å‘ç”Ÿå˜åŒ–æ—¶ï¼Œå¿…é¡»é‡æ–°è®¡ç®—ç”¨äºæ˜¾ç¤ºå®é™…æ–‡æœ¬çš„å¤šè¾¹å½¢ã€‚å½“ Text ç»„ä»¶æˆ–å®ƒçš„ä»»æ„çº§åˆ«çš„çˆ¶èŠ‚ç‚¹è¢«ç¦ç”¨æˆ–å¯ç”¨æ—¶ï¼Œä¹Ÿéœ€è¦è¿›è¡Œé‡æ–°è®¡ç®—\n\n\n\næ¸¸æˆä¸­çš„ Text RenderingBitmap font ä½å›¾å­—ä½“  æœ€ç®€å•ç›´æ¥çš„æ–¹å¼ï¼Œå°±æ˜¯æ¯ä¸ªå­—ç¬¦ä½¿ç”¨ä¸€å¼ å›¾ç‰‡æ¥è¡¨ç¤ºï¼Œæ‰“åŒ…æˆä¸€ä¸ªå›¾é›†ï¼Œç„¶åç”¨ä¸€ç§æ–¹å¼æ¥æè¿°å­—ç¬¦çš„ä½ç½®ã€‚ç”¨æ¥åšä¸€äº›å½©è‰² UI å­—ä½“ç›¸å½“æ–¹ä¾¿ï¼Œè¿™ç§æ–¹å¼æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯åªèƒ½æ”¯æŒå›ºå®šå¤§å°çš„å­—ä½“ï¼Œæ”¾å¤§åä¼šå‡ºç°æ¨¡ç³Š\nTTF OTF å­—ä½“  ä¸åŒäºä½å›¾çš„å›¾ç‰‡æè¿°ï¼ŒTTF/OTF å­—ä½“ä½¿ç”¨è´å¡å°”æ›²çº¿æ¥æè¿°å­—å½¢ (glyph)ï¼Œè¿™æ ·å°±å¯ä»¥ä¿è¯ç¼©æ”¾å­—ä½“æ—¶ä¸ä¼šå¤±çœŸã€‚åœ¨æ¸²æŸ“æ—¶ï¼Œä¼šåŠ¨æ€ç”Ÿæˆéœ€è¦ç”¨åˆ°çš„å­—ç¬¦çš„å­—å½¢ä½å›¾å¹¶ç¼“å­˜èµ·æ¥ï¼Œä¸åŒå­—å·çš„å­—ç¬¦éœ€è¦ä¸åŒçš„ä½å›¾ã€‚ä»è´å¡å°”æ›²çº¿ç”Ÿæˆä½å›¾ï¼Œä¸€èˆ¬æ˜¯ç”¨ CPU æ¥è®¡ç®—ç”Ÿæˆï¼Œç°åœ¨ä¹Ÿæœ‰ä½¿ç”¨ GPU çš„ Computer Shader ç­‰æ¥ç”Ÿæˆçš„æ–¹å¼ã€‚è¿™ç§æ–¹å¼æ˜¯ç»å¤§å¤šæ•°æ–‡æ¡£ç­‰å„ç±»ç³»ç»Ÿä¸­çš„æ–‡æœ¬æ¸²æŸ“æ–¹å¼ï¼Œä¹Ÿæ˜¯æ¸¸æˆ UI ä¸­çš„é»˜è®¤é€‰é¡¹\nä½†æ˜¯åœ¨æ¸¸æˆçš„ 3D å¹³é¢ä¸­æ¸²æŸ“ä¸€äº›æ–‡å­—çš„æ—¶å€™ï¼Œä¼šå‡ºç°ä¸€äº›é—®é¢˜ã€‚å› ä¸ºç”Ÿæˆçš„ä½å›¾æ˜¯æŒ‰ç…§å±å¹•åƒç´ æ¥ç”Ÿæˆçš„ï¼ŒTexture ä¸­çš„ä¸€ä¸ªçº¹ç´  (texel) å¯¹åº”ä¸€ä¸ªåƒç´  (pixel)ã€‚åœ¨ 3D ç©ºé—´æ¸²æŸ“æ–‡å­—æ—¶ï¼Œå¯èƒ½ä¼šåœ¨ä¸åŒçš„è§’åº¦å’Œä¸åŒçš„è·ç¦»è§‚å¯Ÿæ–‡å­—ï¼Œå°±ä¼šå‡ºç°å¤±çœŸæŠ–åŠ¨çš„é—®é¢˜\nåŸºäº SDF ç»˜åˆ¶  åœ¨å­—ä½“ä½å›¾å›¾é›†çš„åŸºç¡€ä¸Šï¼Œè®¡ç®—æ¯ä¸ªåƒç´ ç‚¹åˆ°å‘¨å›´åƒç´ ç‚¹çš„è·ç¦»ï¼Œå¾—åˆ° SDF çš„å€¼ï¼Œç„¶åæ˜ å°„åˆ° 0~1 çš„èŒƒå›´ï¼Œç”Ÿæˆä¸€å¼  Alpha è´´å›¾ï¼Œ0.5 çš„å€¼ä»£è¡¨æ­£å¥½æ˜¯è¾¹ç¼˜ã€‚æ¸²æŸ“æ–‡æœ¬çš„æ—¶å€™ï¼Œå¯¹ Alpha=0.5 è¿›è¡Œ AlphaTestï¼Œå°±å¯ä»¥æ¸²æŸ“å‡ºæ–‡æœ¬ã€‚å¾—ç›Šäº Texture çš„åŒçº¿æ€§æ’å€¼ï¼Œå¯ä»¥å¾—åˆ°å¹³æ»‘è¾¹ç¼˜çš„æ–‡æœ¬\nSDF æ¸²æŸ“æ–‡æœ¬çš„å¦ä¸€ä¸ªå·¨å¤§ä¼˜åŠ¿æ˜¯ï¼Œ, å¯ä»¥å¾ˆæ–¹ä¾¿åœ°è°ƒæ•´æ¸²æŸ“çš„ shaderï¼Œå¾—åˆ°ä¸€äº›ç‰¹æ®Šçš„æ•ˆæœã€‚æ¯”å¦‚ï¼š\n\nAAï¼Œåœ¨æ–‡æœ¬è¾¹ç¼˜å¤„æ’å€¼ä¸€äº›é€æ˜åº¦è¿‡æ¸¡\nOutlineï¼Œåˆ¤æ–­ alpha å€¼ï¼Œ0.51 æ­£å¸¸æ¸²æŸ“æ–‡æœ¬ï¼Œ 0.5-delta0.5 æ¸²æŸ“æè¾¹è‰²\nGlowï¼Œåˆ¤æ–­ alpha å€¼ï¼Œåœ¨ 0~0.5 å¤„æ’å€¼ä¸€ä¸ªå‘å…‰è‰²\nDrop Shadowï¼Œ åœ¨ Pixel Shader ä¸­è¿›è¡Œ UV åç§»ï¼ŒäºŒæ¬¡æŸ¥æ‰¾ SDF Textureï¼Œå¾—åˆ°é˜´å½±\n\nGPU ç»˜åˆ¶å­—å½¢TextMeshProTextMeshPro æ–‡å­—æ¸²æŸ“æ’ä»¶æ˜¯åŸºäº SDFï¼ˆSigned Distance Functionï¼‰å®ç°çš„ã€‚ä½¿å…¶å¯ä»¥åœ¨ä»»æ„å°ºå¯¸å’Œåˆ†è¾¨ç‡ä¸‹æ¸…æ™°çš„æ¸²æŸ“æ–‡æœ¬ã€‚ä½¿ç”¨ä¸€ç³»åˆ—è‡ªå®šä¹‰çš„ç€è‰²å™¨æ¥æå‡ SDF æ–‡æœ¬æ¸²æŸ“çš„èƒ½åŠ›åï¼ŒTextMeshPro å¯ä»¥ç®€å•çš„é€šè¿‡ä¿®æ”¹æè´¨å±æ€§æ¥åŠ¨æ€åœ°æ”¹å˜è§†è§‰æ•ˆæœï¼Œä¾‹å¦‚ï¼Œæ”¾å¤§ã€å¤–è¾¹æ¡†ã€è½¯é˜´å½±ç­‰ï¼Œå¹¶ä¸”å¯ä»¥é€šè¿‡åˆ›å»ºæè´¨é¢„è®¾æ¥ä¿å­˜è¿™äº›æ•ˆæœï¼Œåœ¨ä»¥åé‡æ–°è°ƒç”¨\nSDF Signed Distance FunctionIn mathematics and its applications, the signed distance function (or oriented distance function) is the orthogonal distance of a given point  to the boundary of a set  in a metric space, with the sign determined by whether or not  is in the interior of . The function has positive values at points  inside , it decreases in value as  approaches the boundary of  where the signed distance function is zero, and it takes negative values outside of . \nSDFï¼Œåˆå¯ä»¥ç§°ä¸ºå®šå‘è·ç¦»å‡½æ•°ï¼ˆoriented distance functionï¼‰ï¼Œåœ¨åº¦é‡ç©ºé—´ä¸­çš„ä¸€ä¸ªæœ‰é™åŒºåŸŸ  å†…ç»™å®šä¸€ä¸ªç‚¹ ï¼Œç¡®å®š åˆ°è¾¹ç•Œçš„è·ç¦»ï¼Œå¹¶æ ¹æ®  æ˜¯å¦åœ¨  å†…éƒ¨ç¡®å®šè·ç¦»çš„ç¬¦å·ï¼šåœ¨  å†…éƒ¨ä¸ºæ­£ï¼Œä½äºå¤–éƒ¨ä¸ºè´Ÿï¼Œä½äºè¾¹ç•Œä¸Š SDF ä¸º 0\nå¯¹åº”æ–‡æœ¬æ¸²æŸ“\nSDF è®°å½•ç€å½“å‰åƒç´ ç‚¹è·ç¦»æŸä¸€ä¸ªåŒºåŸŸçš„æœ€å°è·ç¦»ï¼Œè¿™ä¸ªåŒºåŸŸ  å¯ä»¥ç†è§£ä¸ºæ–‡å­—ï¼Œå°±æ˜¯è¯´å¯ä»¥å‡è®¾åƒç´ å€¼ä¸º 0 çš„ç‚¹åœ¨åŒºåŸŸå†…ï¼Œåƒç´ å€¼ä¸º 255 çš„ç‚¹åœ¨åŒºåŸŸå¤–\n\n\nSDF ç”Ÿæˆç®—æ³• Saito çš„ç®—æ³• æ¬§å‡ é‡Œå¾—è·ç¦»è½¬æ¢ (Euclidean Distance Transform, EDT) ç®€å•çš„è¯´å³æ˜¯ä»¥æœ€å¸¸ç”¨çš„æ¬§å‡ é‡Œå¾—è·ç¦»ä½œä¸º  è·ç¦»åº¦é‡ï¼Œæ‰¾åˆ°æ¯ä¸€ä¸ªå‰æ™¯ç‚¹åˆ°æœ€è¿‘çš„èƒŒæ™¯ç‚¹ä¹‹é—´çš„è·ç¦»ï¼Œæ˜¯å°†äºŒç»´å›¾ç‰‡è½¬ä¸ºä¸¤ä¸ªä¸€ç»´å‘é‡\nä¸€äº›åŸºæœ¬å®šä¹‰ï¼š\n\nèƒŒæ™¯ç‚¹ä¸º 0ï¼Œé»‘è‰²\nå‰æ™¯ç‚¹ä¸º 1ï¼Œç™½è‰²\n\nstep1ï¼š1-D Transformation\nä»ä¸Šåˆ°ä¸‹ï¼Œè®¡ç®—æ¯ä¸€è¡Œä¸­å‰æ™¯ç‚¹åˆ°æœ¬è¡ŒèƒŒæ™¯ç‚¹è·ç¦»æœ€è¿‘çš„å¹³æ–¹ï¼Œå¾—åˆ°ä¸­é—´ç»“æœ\n\n    \n\n\nå¦‚ä¸‹å›¾ï¼Œï¼ˆaï¼‰ä¸ºåŸå›¾ï¼ˆbï¼‰ä¸ºåŒä¸€è¡Œçš„è·ç¦»å¹³æ–¹å›¾ï¼Œå³ï¼Œå…¬å¼å¦‚ä¸‹ï¼š\nMissing or unrecognized delimiter for \\left G(i, j) = \\mathop{min}\\limits_y \\left{(j - y)^2 | F(i, y) = 0 \\right} \nstep2ï¼š2-D Transformation\nä»å·¦åˆ°å³ï¼Œå¯¹æ¯ä¸€åˆ—ï¼Œå¯¹ä¸­é—´ç»“æœ  è¿›è¡Œæ“ä½œï¼Œè®¡ç®—æœ¬åˆ—èƒŒæ™¯ç‚¹ä¸æœ¬è¡ŒèƒŒæ™¯ç‚¹è·ç¦»å¹³æ–¹å’Œçš„æœ€å°å€¼ï¼Œå¾—åˆ°è·ç¦»å›¾ï¼ˆDistance Mapï¼‰\n\n    \n\n\nå¦‚ä¸‹å›¾ï¼ˆ4 å³ä½¿æœ€è¿‘è·ç¦»çš„å¹³æ–¹ï¼‰\n8ssedtè®¾å®šåƒç´ ç‚¹å€¼ä¸º 0 è¡¨ç¤ºç©ºï¼Œ1 è¡¨ç¤ºä¸ºç‰©ä½“ï¼Œé‚£ä¹ˆå¯¹äºä»»ä½•ä¸€ä¸ªåƒç´ ç‚¹ï¼Œæˆ‘ä»¬è¦æ‰¾è·ç¦»å®ƒæœ€è¿‘çš„ç›®æ ‡åƒç´ ç‚¹ï¼Œå°±æœ‰ä»¥ä¸‹å‡ ç§æƒ…å†µï¼š\n\nåƒç´ ç‚¹å€¼ä¸º 1ï¼šè‡ªèº«å°±æ˜¯ç›®æ ‡ç‚¹ï¼Œæ‰€ä»¥è·ç¦»ä¸º 0ã€‚\nåƒç´ ç‚¹å€¼ä¸º 0ï¼šç›®æ ‡ç‚¹åº”è¯¥åœ¨è‡ªå·±çš„å››å‘¨ï¼Œä½†å¯èƒ½æ˜¯ä¸Šä¸‹å·¦å³ä»»æ„ä¸€æ–¹å‘\nå‡å¦‚å½“å‰åƒç´ ç‚¹å‘¨å›´æœ€è¿‘çš„æŸä¸ªåƒç´ ï¼ˆä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘è·ç¦»ä¸º 1 çš„åƒç´ ï¼‰æ­£å¥½ä¸º 1ï¼Œé‚£è¿™ä¸ªåƒç´ ç‚¹çš„ SDF å°±åº”è¯¥ä¸º 1ï¼Œå› ä¸ºä¸ä¼šæœ‰æ›´è¿‘çš„æƒ…å†µäº†ï¼Œå…¶æ¬¡å°±æ˜¯å·¦ä¸Šã€å·¦ä¸‹ã€å³ä¸Šã€å³ä¸‹å››ä¸ªç‚¹ï¼Œå¦‚æœæœ‰ä¸º 1 çš„ç‚¹ï¼Œé‚£è¯¥åƒç´ ç‚¹çš„ SDF å€¼å°±åº”è¯¥ä¸ºã€‚ä»¥æ­¤ç±»æ¨ï¼Œå¦‚æœçŸ¥é“äº†å½“å‰åƒç´ ç‚¹å‘¨å›´æ‰€æœ‰åƒç´ çš„ SDF å€¼ï¼Œé‚£ä¹ˆè¯¥åƒç´ ç‚¹çš„ SDF å€¼ä¸€å®šä¸ºï¼š\n\n// near è¡¨ç¤ºé™„è¿‘åƒç´ ç‚¹// cur è¡¨ç¤ºå½“å‰åƒç´ // near.SDF è¡¨ç¤º near çš„ SDF å€¼// Distance è¡¨ç¤ºä¸¤ç‚¹ä¹‹é—´è·ç¦»min(near.SDF + Distance(cur, near))\n\næºç \næºç ç¼–è¯‘ä¼˜åŒ–\nåŠ¨ç”»ç³»ç»Ÿ  éª¨éª¼åŠ¨ç”»çš„åŸç†  åŸºç¡€æ¦‚å¿µ  ç»™ä¸€ä¸ªæ¨¡å‹åŠ ä¸Šéª¨éª¼å‰ï¼Œä¸€èˆ¬è¦æ±‚è¿™ä¸ªæ¨¡å‹æ‘†æˆ T å­—å‹ï¼Œæ‰æ–¹ä¾¿åŠ¨ä½œå¸ˆåŠ éª¨éª¼å’ŒåšåŠ¨ä½œã€‚æ­¤æ—¶ï¼ŒåŠ éª¨éª¼æ“ä½œè¢«ç§°ä¸ºéª¨éª¼ç»‘å®š (Skeleton Binding)ï¼›æˆ–è€…ä»æ¨¡å‹è§’åº¦è®²å«åšï¼Œæ¨¡å‹è’™çš® (Model Skinning) åˆ°éª¨éª¼\nè¿™ä¸ªåˆå§‹éª¨éª¼æ‘†ä½ï¼Œå°±æ˜¯ç»‘å®šå§¿åŠ¿ (Bind Poses)ã€‚ä½†è¦æ³¨æ„ï¼Œç»‘å®šå§¿åŠ¿æœ¬èº«åªè®°å½•äº†éª¨éª¼å„ä¸ªå…³èŠ‚çš„å§¿åŠ¿ä¿¡æ¯ï¼Œå¹¶ä¸åŒ…æ‹¬è’™çš®ä¿¡æ¯ã€‚è’™çš®ä¿¡æ¯æ˜¯å­˜å‚¨äºæ¨¡å‹æ•°æ®é‡Œçš„ï¼Œå› ä¸ºæ‰€è°“è’™çš®ï¼Œå³æ˜¯è®©æ¯ä¸€ä¸ªé¡¶ç‚¹ç»‘å®šè‡³  ä¸ªå…³èŠ‚ï¼Œè¿™  ä¸ªå…³èŠ‚è¿åŠ¨çš„æ—¶å€™ï¼Œä¼šå½±å“åˆ°è¯¥é¡¶ç‚¹çš„å½“å‰ä½ç½®\nå±€éƒ¨å…³èŠ‚å§¿åŠ¿ Local Joint Poseså…³èŠ‚å§¿åŠ¿åˆ†ä¸ºå±€éƒ¨å…³èŠ‚å§¿åŠ¿å’Œå…¨å±€å…³èŠ‚å§¿åŠ¿ï¼Œå±€éƒ¨å…³èŠ‚å§¿åŠ¿æ˜¯ç›¸å¯¹ç›´å±çˆ¶å…³èŠ‚è€Œè¨€çš„ï¼Œå¯ä»¥ç”¨ä¸€ä¸ªç»“æ„ä½“è¡¨ç¤ºï¼š\nstruct JointPose {    Quaternion rot; // R å…³èŠ‚æ—‹è½¬ä¿¡æ¯    Vector3 trans; // T å…³èŠ‚ä½ç§»ä¿¡æ¯    Vector3 scale; // S å…³èŠ‚ç¼©æ”¾ä¿¡æ¯}\n\nä¸€ä¸ªå…³èŠ‚åªéœ€è¦å­˜ä¸€ç»„ RTS ä¿¡æ¯ã€‚è¿™ 3 ä¸ªä¿¡æ¯å¯åˆ†åˆ«è½¬æ¢æˆ 3 ä¸ªçŸ©é˜µï¼Œå¹¶ä¸”å¯ä»¥åˆå¹¶æˆä¸€ä¸ªçŸ©é˜µã€‚åˆå¹¶åçš„çŸ©é˜µå°±è¢«ç§°ä¸ºå…³èŠ‚ä»¿å°„å˜æ¢çŸ©é˜µ ï¼š ä¸€ä¸ªéª¨éª¼ï¼Œå°±æ˜¯æ‰€æœ‰å…³èŠ‚ä»¿å°„å˜æ¢çš„é›†åˆï¼šå³ï¼š\nstruct Skeleton {    size_t jointCount; // å…³èŠ‚æ•°é‡    JointPose* local Poses; // å¤šä¸ªå±€éƒ¨å…³èŠ‚å§¿åŠ¿}\n\næŠŠ  åº”ç”¨åˆ°å…³èŠ‚  çš„å±€éƒ¨åæ ‡ç³»çš„æŸä¸ªç‚¹æˆ–å‘é‡ ï¼Œå°±èƒ½æŠŠå®ƒå˜æ¢åˆ°çˆ¶å…³èŠ‚ çš„åæ ‡ç³»ï¼š\n\nå‡è®¾æœ‰ ï¼Œè¡¨ç¤ºå…³èŠ‚ çš„å±€éƒ¨åæ ‡ç³»çš„åœ†ç‚¹ï¼Œæ˜¯ä¸€ä¸ªå¹³ç§»çŸ©é˜µ ï¼Œé‚£ä¹ˆ çš„ç»“æœå°±æ˜¯ ï¼Œå³ è¡¨ç¤ºçˆ¶å…³èŠ‚  åæ ‡ç³»ä¸‹çš„åæ ‡\nå¯ä»¥å®šä¹‰å­å…³èŠ‚  åˆ°çˆ¶å…³èŠ‚çš„å˜æ¢ä¸º $(P_{C \\rightarrow P})jã€‚è¿™  æ ·å½¢  å¼ä¸  å¤ªå¥½  çœ‹ï¼Œå¯  ä»¥æ¢  ä¸€ç§ ï¼Œ å…ˆå®š  ä¹‰ä¸€  ä¸ªå‡½  æ•°p(j)ï¼Œp(j)è¿”  å›å…³  èŠ‚jçš„  çˆ¶å…³  èŠ‚ç´¢  å¼•ã€‚é‚£  ä¹ˆ(P{C \\rightarrow P})jå¯  ä»¥å†™  æˆP{j \\rightarrow p(j)}$\n\nå…¨å±€å…³èŠ‚å§¿åŠ¿ Global Joint Poseså±€éƒ¨å…³èŠ‚å§¿åŠ¿æ˜¯ä¸€ç§åŸå§‹ä¿¡æ¯ï¼Œå®é™…ä¸Šå†æ¸²æŸ“è’™çš®åŠ¨ç”»å‰ï¼Œéœ€è¦åšé¢„å¤„ç†ï¼ŒæŠŠå±€éƒ¨å…³èŠ‚å§¿åŠ¿è½¬æ¢æˆå…¨å±€å…³èŠ‚å§¿åŠ¿ã€‚å…¨å±€å…³èŠ‚å§¿åŠ¿å˜æ¢ï¼ŒæŒ‡çš„æ˜¯æŠŠå…³èŠ‚å§¿åŠ¿ï¼Œç”¨æ¨¡å‹ç©ºé—´åæ ‡ç³»è¡¨ç¤ºã€‚é¦–å…ˆå®šä¹‰ï¼Œå³æ ¹å…³èŠ‚çš„çˆ¶èŠ‚ç‚¹ä¸ºæ¨¡å‹ç©ºé—´\næ¯ä¸ªå…³èŠ‚  çš„å…¨å±€å…³èŠ‚å§¿åŠ¿å˜æ¢ ï¼Œå¯ä»¥ç”¨åˆšæ‰çš„ æ¥è¡¨ç¤ºï¼š\n\n\n\n\nå¯¹æ¯ä¸ªå…³èŠ‚éƒ½åšä¸€éè¿™ä¸ªå…¬å¼ï¼Œå°±èƒ½å¾—åˆ°ä¸€ä¸ªå…¨å±€å…³èŠ‚å§¿åŠ¿æ•°ç»„ã€‚ç„¶åå¯ä»¥å†™å…¥SkeletonPoseï¼š\nstruct SkeletonPose {    size_t jointCount; // å…³èŠ‚æ•°é‡    JointPose* localPoses; // å¤šä¸ªå±€éƒ¨å…³èŠ‚å§¿åŠ¿    Matrix4x4* globalPoses; // å¤šä¸ªå…¨å±€å…³èŠ‚å§¿åŠ¿}\n\nå…¨å±€å…³èŠ‚å§¿åŠ¿çš„å­˜å‚¨ï¼Œå¹¶ä¸åªé™å®šäºç”¨ RTSï¼Œè€Œæ˜¯æ—¢å¯ä»¥ç”¨ RTS ä¹Ÿå¯ä»¥ç”¨çŸ©é˜µã€‚å› ä¸ºå®æ—¶æ¸²æŸ“é‡ŒçŸ©é˜µæ›´é€šç”¨å¿«é€Ÿï¼Œæ‰€ä»¥å¾—å­˜æˆçŸ©é˜µ\nç»‘å®šå§¿åŠ¿çŸ©é˜µï¼ˆBind Poses Matrixï¼‰ã€ç»‘å®šå§¿åŠ¿é€†çŸ©é˜µï¼ˆInversed Bind Poses Matrixï¼‰å®šä¹‰çŸ©é˜µ  ä¸ºå…³èŠ‚  åœ¨æ¨¡å‹ç©ºé—´çš„å…¨å±€ç»‘å®šå§¿åŠ¿çŸ©é˜µã€‚æ ¹æ®ä¸Šæ–‡ï¼Œå¯ä»¥æŠŠ  ä»å…³èŠ‚  çš„å±€éƒ¨ç©ºé—´å˜æ¢åˆ°æ¨¡å‹ç©ºé—´\nåè¿‡æ¥ï¼Œè¦æŠŠä¸€ä¸ªç‚¹ï¼ˆæ¨¡å‹çš„ä»»æ„ä¸€ä¸ªé¡¶ç‚¹ï¼‰æˆ–å‘é‡ï¼Œå˜æ¢åˆ°å…³èŠ‚  çš„ç©ºé—´ï¼Œå°±æ˜¯ï¼šå°±æ˜¯ç»‘å®šå§¿åŠ¿é€†çŸ©é˜µï¼Œä¹Ÿå¯ä»¥å†™æˆï¼šå†å®šä¹‰  ä¸ºæ¨¡å‹ä»»æ„é¡¶ç‚¹  åœ¨ç»‘å®šå§¿åŠ¿çš„æ¨¡å‹ç©ºé—´åæ ‡ï¼Œè€Œ  ä¸ºå½“å‰å§¿åŠ¿çš„æ¨¡å‹ç©ºé—´åæ ‡ã€‚å¦‚æœè¦æ±‚  åœ¨å…³èŠ‚  çš„å±€éƒ¨ç©ºé—´åæ ‡ ï¼Œåˆ™å…¬å¼ä¸ºï¼š ç„¶åå†ä¹˜ä»¥å½“å‰å§¿åŠ¿çš„å§¿åŠ¿çŸ©é˜µï¼ˆä¸æ˜¯ç»‘å®šå§¿åŠ¿ï¼‰ï¼Œå¾—åˆ°å½“å‰å§¿åŠ¿çš„æ¨¡å‹ç©ºé—´åæ ‡ï¼š\nè’™çš®çŸ©é˜µ Skinning Matrix\nå°±æ˜¯å…³èŠ‚  çš„è’™çš®çŸ©é˜µäº†ï¼šæŠŠç»‘å®šå§¿åŠ¿æ¨¡å‹ç©ºé—´ä¸‹çš„é¡¶ç‚¹ï¼Œå…ˆè½¬æ¢åˆ°ç»‘å®šå§¿åŠ¿å…³èŠ‚ç©ºé—´ï¼Œç„¶åå†è½¬æ¢åˆ°å½“å‰å§¿åŠ¿æ¨¡å‹ç©ºé—´\nozz-animation ä¸­ç®—  çŸ©é˜µçš„ä»£ç ç‰‡æ®µï¼š\nfor (size_t j = 0; j &lt; models.Count(); ++j) {    skinning_matirces[j] = models[j] * mesh.inverse_bind_poses[j];}\n\nmodels[j]å°±æ˜¯å½“å‰å§¿åŠ¿å½“å‰æ—¶åˆ»ç¬¬  çš„å…³èŠ‚çš„ ï¼›mesh.inverse_bind_poses[j] å°±æ˜¯ï¼Œè¿™ä¸ªé€†çŸ©é˜µæ˜¯é¢„å…ˆç®—å¥½çš„ï¼Œæ¯”è¿è¡Œæ—¶å†ç®—é€†çŸ©é˜µè¦å¿«å¾—å¤šï¼Œä¸€èˆ¬çš„è’™çš®åŠ¨ç”»å¼•æ“éƒ½æ˜¯è¿™æ ·åš\nAnimation å’Œ Animator\nAnimatorï¼šåŠ¨ç”»æ§åˆ¶å™¨ï¼Œæ§åˆ¶ Mecanim åŠ¨ç”»ç³»ç»Ÿçš„æ¥å£ï¼Œç”¨æ¥ç®¡ç†å¤šä¸ªåŠ¨ç”»ï¼›\nAnimationï¼šç”¨äºæ’­æ”¾åŠ¨ç”»ï¼Œè€ç‰ˆä¸­å•ç‹¬çš„ä¸€ä¸ª Animation ä¹Ÿå¯ä»¥å®ŒæˆåŠ¨ç”»çš„æ’­æ”¾å’Œåˆ‡æ¢ï¼Œä¸è¿‡çŠ¶æ€åˆ‡æ¢ä¹‹ç±»çš„éœ€è¦ç¨‹åºä»£ç æ§åˆ¶ã€‚åœ¨æ–°ç‰ˆä¸­ï¼ŒçŠ¶æ€ç®¡ç†éƒ¨åˆ†äº¤ç»™äº† Animatorï¼›\nAnimationClipï¼šåŠ¨ç”»å‰ªè¾‘ç‰‡æ®µï¼Œå‚¨å­˜åŸºäºå…³é”®å¸§çš„åŠ¨ç”»ï¼Œæ˜¯ç”¨äº Animation æ¥æ’­æ”¾åŠ¨ç”»ï¼›\nAnimationStateï¼šåŠ¨ç”»çŠ¶æ€ï¼Œç”¨æ¥æ”¹å˜å•ä¸€åŠ¨ç”»çš„æ’­æ”¾é€Ÿåº¦ã€æƒé‡ã€æ—¶é—´ã€å±‚çº§ã€æ’­æ”¾ Modeï¼Œä»¥åŠæ··åˆæ¨¡å¼ï¼›\nAnimationEventï¼šåŠ¨ç”»äº‹ä»¶ï¼Œç”¨äºæŸç§æ¡ä»¶ä¸‹è§¦å‘è‡ªå®šä¹‰å‡½æ•°ï¼›\nStateMachineBehaviourï¼š åŠ¨ç”»çŠ¶æ€æœºç®¡ç†å™¨æ‹“å±•ç±»ï¼Œè„šæœ¬ç»§æ‰¿äº†è¯¥ç±»ä¹‹åï¼Œç»‘å®šåˆ° Animator ä¸ŠæŸ State ä¸Šé¢ã€‚å½“çŠ¶æ€å‘ç”Ÿå˜åŒ–ï¼Œå¯ä»¥é‡è½½å“åº”å‡½æ•°ã€‚ç±»ä¼¼ è§¦å‘å™¨çš„å“åº”å‡½æ•°ï¼›\n\nAnimator çš„æ€§èƒ½ç¼ºé™·  ä»€ä¹ˆæ˜¯ Animator Overrideã€‚å‡è®¾æˆ‘ä»¬æœ‰ä¸ªå¤šä¸ªä¸åŒçš„è§’è‰²ï¼Œä»–ä»¬éƒ½æœ‰ç›¸åŒçš„åŠ¨ä½œï¼Œä¾‹å¦‚å¾…æœºï¼Œè·‘æ­¥ï¼Œæ”»å‡»ç­‰ç­‰ï¼Œå¹¶ä¸”è§¦å‘æ¡ä»¶ä¹Ÿéƒ½ç›¸åŒã€‚ä½†æ˜¯ä¸ºäº†åŒºåˆ†è§’è‰²ï¼Œä»–ä»¬ç›¸åŒçš„åŠ¨ä½œå¯¹åº”çš„åŠ¨ç”»å¾€å¾€éƒ½ä¸ç›¸åŒï¼Œä¾‹å¦‚ä¸‹å›¾ä¸åŒçš„è·‘æ­¥åŠ¨ç”»ï¼š\n\n    \n\n\nUnity ä¼šå°è¯•æŠŠ AnimatorController é‡Œæ‰€æœ‰çš„ State åˆå¹¶åˆ°ä¸€ä¸ªåä¸º Animationset çš„æ•°æ®ç»“æ„ä¸­ã€‚è¿™æ„å‘³ç€æ‰€æœ‰çš„ AnimationClip å†ä¹˜ä¸Šæ‰€æœ‰ Clip é‡Œæ‰€ç”¨çš„æ›²çº¿éƒ½è¦ç»è¿‡ä¸€ç³»åˆ—çš„è¿ç®—ã€‚å› æ­¤æˆ‘ä»¬çš„ State å’Œ AnimationClip è¶Šå¤šè¶Šå¤æ‚ï¼Œè¿™ä¸ªè¿ç®—çš„è€—æ—¶ä¹Ÿä¼šå¢åŠ ï¼Œå¯¼è‡´æ€§èƒ½é—®é¢˜\nLuaLua å¦‚ä½•å®ç°é¢å‘å¯¹è±¡çš„ä¸‰å¤§ç‰¹æ€§  é¢å‘å¯¹è±¡çš„å®ç°\nç±» ï¼šè¿™æ˜¯å¯¹è±¡çš„å…ƒè¡¨ï¼Œåœ¨è®¿é—®ä¸åˆ°å¯¹è±¡çš„å­—æ®µæ—¶ï¼Œä¼šè§¦å‘ç±»çš„indexï¼Œè€Œindex å¯ä»¥è®¾ä¸ºç±»è‡ªå·±ï¼Œè¿™æ ·å°±å˜æˆè®¿é—®ç±»çš„å­—æ®µã€‚é€šå¸¸æˆ‘ä»¬æŠŠå¯¹è±¡çš„åŠŸèƒ½å‡½æ•°æ”¾åœ¨ç±»ä¸­ï¼Œè®©è¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡éƒ½å…±äº«ä¸€å¥—å‡½æ•°\nç±»çš„å…ƒè¡¨ï¼šè¿™ä¸ªè¡¨æ˜¯ä¸ºäº†å®ç°ç»§æ‰¿ï¼Œç±»ä¹Ÿæ‰¾ä¸åˆ°å­—æ®µæ—¶ï¼Œä¼šè§¦å‘ç±»çš„å…ƒè¡¨çš„__indexï¼Œè¿™é‡Œä¼šå–å‡ºçˆ¶ç±»å¹¶ç»§ç»­è®¿é—®ï¼Œå¦‚æ­¤å¾ªç¯ï¼Œä¸€ç›´åˆ°çˆ¶ç±»ä¸ºç©ºä¸ºæ­¢ã€‚\nå¯¹è±¡ï¼šè¿™å°±æ˜¯ä¸€ä¸ªæ™®é€šçš„tableï¼ŒæŠŠå®ƒçš„å…ƒè¡¨è®¾ä¸ºæŒ‡å®šçš„ç±»ï¼Œé‚£ä¹ˆå®ƒå°±è¢«ç§°ä¸ºè¯¥ç±»çš„å¯¹è±¡\n\n-- rtl.lualocal rtl = {}local ksuper = {}   -- ä½œä¸ºæŸ¥æ‰¾çˆ¶ç±»çš„ key-- å®šä¹‰ä¸€ä¸ªç±»ï¼Œsuper æ˜¯çˆ¶ç±»ï¼Œä¸º nil è¡¨ç¤ºæ²¡æœ‰çˆ¶ç±»function rtl.class(super)    local klass = {}        -- è¿™å°±æ˜¯ä»£è¡¨ç±»çš„ table    klass[ksuper] = super   -- æŠŠçˆ¶ç±» table ä¿å­˜èµ·æ¥    klass.__index = klass   -- __index è®¾ä¸ºè‡ªå·±    local _class_metatable = rtl._class_metatable   -- è¿™æ˜¯ç±»çš„å…ƒè¡¨ï¼Œæ‰€æœ‰ç±»éƒ½è®¾ç½®åŒä¸€ä¸ªå…ƒè¡¨    if not _class_metatable then        _class_metatable = {            __index = function (t, k)                -- å–å¾—ç±»çš„çˆ¶ç±»                local super = rawget(t, ksuper)                if super then                    -- ç„¶åç»§ç»­è®¿é—® kï¼Œå¦‚æœæ‰¾ä¸åˆ°è¿˜ä¼šè§¦å‘è¿™ä¸ª__indexï¼Œä¸€ç›´å¾€ä¸Šè¿½æº¯                    return super[k]                else                    return nil                end            end,            __call = function (cls, ...)                -- åˆ›å»ºç±»çš„å¯¹è±¡ï¼Œcls å°±æ˜¯ç±»                local obj = {}                -- å°† cls è®¾ä¸º obj çš„å…ƒè¡¨ï¼Œæ‰¾ä¸åˆ° obj çš„å­—æ®µæ—¶ï¼Œå°±ä¼šè§¦å‘ klass.__index                -- è€Œ__index æŒ‡å‘ kclass è‡ªå·±ï¼Œæ‰€ä»¥ç›¸å½“äºåœ¨ kclass ä¸Šè®¿é—®å­—æ®µã€‚                setmetatable(obj, cls)                -- çº¦å®š_init ä¸ºç±»çš„æ„é€ å‡½æ•°ï¼Œæ‰€ä»¥è¿™é‡Œä¼šè°ƒç”¨æ„é€ å‡½æ•°                local _init = cls._init                if _init then                    _init(obj, ...)                end                -- æœ€åè¿”å›è¿™ä¸ªå¯¹è±¡                return obj            end          }        rtl._class_metatable = _class_metatable    end    -- è®¾ç½®ç±»çš„å…ƒè¡¨    setmetatable(klass, _class_metatable)     -- æœ€åè¿”å›ç±»    return klassendreturn rtl\n\né¡¹ç›®ä¸­çš„å¤šç»§æ‰¿å®ç°function class(classname, ...)    local cls = {__cname = classname}    local supers = {...}    for _, super in ipairs(supers) do        local superType = type(super)        assert(superType == \"nil\" or superType == \"table\" or superType == \"function\",            string.format(\"class() - create class \\\"%s\\\"with invalid super class type \\\"%s\\\"\",                classname, superType))        if superType == \"function\" then            assert(cls.__create == nil,                string.format(\"class() - create class \\\"%s\\\" with more than one creating function\",                    classname));            -- if super is function, set it to __create            cls.__create = super        elseif superType == \"table\" then            if super[\".isclass\"] then                -- super is native class                assert(cls.__create == nil,                    string.format(\"class() - create class \\\"%s\\\" with more than one creating function or native class\",                        classname));                cls.__create = function() return super:create() end            else                -- super is pure lua class                cls.__supers = cls.__supers or {}                cls.__supers[#cls.__supers + 1] = super                if not cls.super then                    -- set first super pure lua class as class.super                    cls.super = super                end            end        else            error(string.format(\"class() - create class \\\"%s\\\" with invalid super type\",                        classname), 0)        end    end    cls.__index = cls    if not cls.__supers or #cls.__supers == 1 then        setmetatable(cls, {__index = cls.super})    else        setmetatable(cls, {__index = function(_, key)            local supers = cls.__supers            for i = 1, #supers do                local super = supers[i]                if super[key] then return super[key] end            end        end})    end    if not cls.ctor then        -- add default constructor        cls.ctor = function() end    end    cls.new = function(...)        local instance        if cls.__create then            instance = cls.__create(...)        else            instance = {}        end        setmetatableindex(instance, cls)        instance.class = cls        instance:ctor(...)        return instance    end    cls.create = function(_, ...)        return cls.new(...)    end    return clsendlocal setmetatableindex_setmetatableindex_ = function(t, index)    if type(t) == \"userdata\" then        local peer = tolua.getpeer(t)        if not peer then            peer = {}            tolua.setpeer(t, peer)        end        setmetatableindex_(peer, index)    else        local mt = getmetatable(t)        if not mt then mt = {} end        if not mt.__index then            mt.__index = index            setmetatable(t, mt)        elseif mt.__index ~= index then            setmetatableindex_(mt, index)        end    endendsetmetatableindex = setmetatableindex_\n\nUIä»€ä¹ˆæ˜¯å›¾é›†ã€å›¾é›†çš„ä½œç”¨\næ‰€è°“å›¾é›†å°±æ˜¯å°†å¾ˆå¤šé›¶ç¢çš„ 2 ç»´å°å›¾æ•´åˆæˆä¸€å¼ å¤§å›¾\n\nå›¾é›†çš„ä½œç”¨\n\næå‡æ•ˆç‡ï¼šå›¾ç‰‡å°ºå¯¸ä¸º 2 çš„æ¬¡å¹‚æ—¶ï¼ŒGPU å¤„ç†èµ·æ¥ä¼šå¿«å¾ˆå¤šï¼Œå°å›¾è‡ªå·±æ˜¯åšä¸åˆ°æ¯å¼ å›¾éƒ½æ˜¯ 2 çš„æ¬¡å¹‚çš„ï¼Œä½†æ‰“æˆä¸€å¼ å¤§å›¾å°±å¯ä»¥\n\nUI çš„åˆæ‰¹ç†å‡å°‘ DrawCallï¼šæ‰“æˆå›¾é›†åï¼ŒCPU åœ¨ä¼ é€èµ„æºä¿¡æ¯ç»™ GPU æ—¶ï¼Œåªéœ€è¦ä¼ ä¸€å¼ å¤§å›¾å°±å¯ä»¥äº†ï¼Œå› ä¸º GPU å¯ä»¥åœ¨è¿™å¼ å›¾ä¸­çš„ä¸åŒåŒºåŸŸè¿›è¡Œé‡‡æ ·ï¼Œç„¶åæ‹¼å‡ºå¯¹åº”çš„ç•Œé¢\n\nè¿™å°±æ˜¯ä¸ºä»€ä¹ˆä¸€ä¸ª UI ç•Œé¢éœ€è¦ç”¨åŒä¸€ä¸ªå›¾é›†çš„åŸå› \n\n\né¿å…æµªè´¹èµ„æºï¼šæ‰“æˆå›¾é›†åæŠŠå›¾ç‰‡ä¸Šçš„ç©ºé—´å°½é‡åˆ©ç”¨å¾—å……å®ä¸€ç‚¹\n\n\n\n\nè€ç‰ˆçš„ Sprite Packer å’Œæ–°ç‰ˆçš„ Sprite Altas çš„åŒºåˆ«\nSprite Packerï¼š2017.3 åŠä¹‹å‰ä½¿ç”¨çš„å›¾é›†æ–¹æ¡ˆï¼Œé€šè¿‡å¯¹ Sprite æ‰“ Tag çš„æ–¹å¼ï¼Œæ¥è‡ªåŠ¨ç”Ÿæˆå›¾é›†ã€‚å¯ä»¥è‡ªå®šä¹‰æ‰“å›¾é›†çš„ç­–ç•¥\nSprite Altasï¼š2017.4 æ–°å‡ºçš„å›¾é›†æ–¹æ¡ˆï¼Œç”¨æ¥æ›¿ä»£ Sprite Packerã€‚Sprite Packer å’Œ Sprite Atlas ä¸èƒ½å…±å­˜ï¼ŒUnity çš„ Sprite Packer Mode ä¸­çš„å•é€‰æ€§å†³å®šäº†è¿™ä¸ªä¸èƒ½å…±å­˜çš„æ€§è´¨\nSprite Atlas é’ˆå¯¹ Sprite Packer å›¾é›†æ‰“åŒ…ç³»ç»Ÿåœ¨æ€§èƒ½å’Œæ˜“ç”¨æ€§ä¸Šçš„ä¸è¶³ï¼Œè¿›è¡Œäº†å…¨é¢æ”¹å–„\n\nUGUI çš„ä¼˜åŒ–ã€å®ç°è¿‡æœ€å¤æ‚çš„ UI é¢æ¿æ˜¯ä»€ä¹ˆã€ç®€è¿°ä¸€ä¸‹è‡ªå·±é¡¹ç›®ä¸­å®ç°çš„ UI æ¡†æ¶  æ€§èƒ½æ¶ˆè€—çš„å…³é”®ç‚¹unity å°† UI çš„æ¸²æŸ“åˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼Œå¯¹ mesh çš„æ“ä½œç§°ä¸º Rebatchï¼Œå¯¹ material å’Œ layout çš„æ“ä½œç§°ä¸º Rebuildï¼Œæ‰€ä»¥æ€§èƒ½æ¶ˆè€—ä¹Ÿæ˜¯åœ¨è¿™ä¸¤ä¸ªéƒ¨åˆ†ã€‚\nRebatch çš„å†…éƒ¨å®ç°Rebatch å‘ç”Ÿåœ¨ C++ å±‚é¢ï¼Œæ˜¯æŒ‡ Canvas åˆ†æ UI èŠ‚ç‚¹ç”Ÿæˆæœ€ä¼˜æ‰¹æ¬¡çš„è¿‡ç¨‹ï¼ŒèŠ‚ç‚¹æ•°é‡è¿‡å¤šä¼šå¯¼è‡´ç®—æ³•ï¼ˆè´ªå¿ƒç­–ç•¥ï¼‰è€—æ—¶è¾ƒé•¿ã€‚å¯¹åº” SetVerticesDirtyï¼Œå½“ä¸€ä¸ª canvas ä¸­åŒ…å«çš„ mesh å‘ç”Ÿæ”¹å˜æ—¶å°±è§¦å‘ï¼Œä¾‹å¦‚ SetActiveã€transform çš„æ”¹å˜ã€ é¢œè‰²æ”¹å˜ã€æ–‡æœ¬å†…å®¹æ”¹å˜ç­‰ç­‰ï¼Œcanvas ç‹¬ç«‹å¤„ç†ï¼Œäº’ç›¸ä¸å½±å“ã€‚æ¶ˆè€—åœ¨å¯¹ meshes æŒ‰ç…§æ·±åº¦å’Œé‡å æƒ…å†µæ’åºã€å…±äº«æè´¨çš„æ£€æµ‹ç­‰ã€‚\nBatch ä»¥ Canvas ä¸ºå•ä½ï¼ŒåŒä¸€ä¸ª Canvas ä¸‹çš„ UI å…ƒç´ æœ€ç»ˆéƒ½ä¼šè¢« Batch åˆ°ä¸€ä¸ª Mesh ä¸­ã€‚Batch å‰ï¼ŒUGUI æ ¹æ® UI æè´¨ä»¥åŠæ¸²æŸ“é¡ºåºé‡æ’ï¼Œåœ¨ä¸æ”¹å˜æ¸²æŸ“ç»“æœçš„å‰æä¸‹ï¼Œå°½å¯èƒ½å°†ç›¸åŒæè´¨çš„ UI å…ƒç´ åˆå¹¶åœ¨åŒä¸€ä¸ª SubMesh ä¸­ï¼Œä»¥å‡å°‘ DCã€‚Batch åªåœ¨ UI å…ƒç´ å‘ç”Ÿå˜åŒ–æ—¶è¿›è¡Œï¼Œåˆæˆçš„ Mesh è¶Šå¤§ï¼Œè€—æ—¶è¶Šå¤§ã€‚é‡å»ºå¯¹ Canvas ä¸‹æ‰€æœ‰ ui å…ƒç´ ç”Ÿæ•ˆï¼Œä¸è®ºæ˜¯å¦ä¿®æ”¹è¿‡ã€‚\n5.2 ä¹‹ååº•å±‚æ˜¯å¤šçº¿ç¨‹çš„ï¼Œè€ƒè™‘åˆ°ç°åœ¨æ‰‹æœºä¸Šéƒ½æ˜¯å¤šæ ¸ï¼Œè¿™éƒ¨åˆ†æ¶ˆè€—å¯èƒ½ä¼šå°å¾ˆå¤šã€‚ä¸è¿‡å¯¹äºå¤æ‚çš„ UIï¼Œè¿˜æ˜¯å¤šæ³¨æ„ä¸€äº›æ›´å¥½ã€‚\né’ˆå¯¹ Rebatch çš„ä¼˜åŒ–æ–¹æ³•\nCanvas åŠ¨é™åˆ†ç¦»ï¼Œåˆç†åˆ’åˆ†ï¼ŒæŒ‰æ¸¸æˆç±»å‹å’Œ UI æ•°é‡åˆ’åˆ†ï¼Œå¤ªå¤šä¹Ÿæœ‰é¢å¤–æ¶ˆè€—ã€‚\nå‡å°‘èŠ‚ç‚¹å±‚æ¬¡å’Œæ•°é‡ï¼Œåˆæ‰¹è®¡ç®—é‡å°ï¼Œé€Ÿåº¦å¿«ã€‚\nä½¿ç”¨ç›¸åŒæè´¨è´´å›¾çš„ UI å°½é‡ä¿æŒæ·±åº¦ç›¸åŒï¼Œè¿™æ ·å¯¹åˆæ‰¹ç®—æ³•å‹å¥½ï¼Œé€Ÿåº¦å¿«ã€‚\nä¿®æ”¹ Image çš„ Color å±æ€§ï¼ŒåŸç†æ˜¯ä¿®æ”¹é¡¶ç‚¹è‰²ï¼Œä¼šå¼•èµ·ç½‘æ ¼ Rebatchï¼ŒåŒæ—¶è§¦å‘ Canvas.SendWillRenderCanvasesã€‚å¥½å¤„åœ¨äºä¿®æ”¹é¡¶ç‚¹è‰²æè´¨ä¸å˜ï¼Œæ²¡æœ‰é¢å¤– DCã€‚ä¿®æ”¹ shader é¢œè‰²ä¸ä¼šé‡ç»˜ï¼Œæè´¨ä¸å˜ï¼Œæ²¡æœ‰ Rebatchã€‚\n\nRebuild çš„è§¦å‘åŸå› Rebuild å‘ç”Ÿåœ¨ C# å±‚é¢ï¼Œæ˜¯æŒ‡ UGUI åº“ä¸­ layout ç»„ä»¶è°ƒæ•´ RectTransform å°ºå¯¸ã€Graphic ç»„ä»¶æ›´æ–° Materialï¼Œä»¥åŠ Mask æ‰§è¡Œ Cull çš„è¿‡ç¨‹ï¼Œè€—æ—¶å’Œå‘ç”Ÿå˜åŒ–çš„èŠ‚ç‚¹æ•°é‡åŸºæœ¬å‘ˆçº¿æ€§ç›¸å…³ã€‚\nåªæœ‰ LayoutGroup çš„ç›´æ¥å­èŠ‚ç‚¹ï¼Œå¹¶ä¸”æ˜¯ Graphic ç±»å‹çš„ï¼ˆæ¯”å¦‚ Image å’Œ Textï¼‰ä¼šè§¦å‘ SetLayoutDirtyã€‚\nGraphic æ”¹å˜çš„åŸå› åŒ…æ‹¬ï¼ŒåŸºæœ¬çš„å¤§å°ã€æ—‹è½¬ä»¥åŠæ–‡å­—çš„å˜åŒ–ã€å›¾ç‰‡çš„ä¿®æ”¹ç­‰ç­‰ï¼Œå¯¹åº” SetMaterialDirtyã€‚\né’ˆå¯¹ Rebuild çš„ä¼˜åŒ–æ–¹æ³•\nå°‘ç”¨ layoutï¼Œç®€å•çš„å¸ƒå±€ RectTransform ä»£æ›¿\nCanvas åŠ¨é™åˆ†ç¦»ï¼ŒæŒ‰é¡¹ç›®ç±»å‹å»è§„åˆ’ã€‚\n\né’ˆå¯¹ç»„ä»¶çš„ä¼˜åŒ–\nä¸è¦ç”¨ç©ºçš„ Imageï¼Œåªæ¥æ”¶äº‹ä»¶ä¸æ˜¾ç¤ºçš„å¯¹è±¡ï¼Œç»§æ‰¿ Graphicï¼Œå¡«å……æ•°æ®å‡½æ•°å†™æˆç©ºçš„ã€‚\nä¸æ˜¾ç¤ºçš„å¯¹è±¡ï¼Œä¸è¦ SetActiveï¼Œè®¾ç½® Canvas Group çš„ alpha ä¸º 0ï¼Œscale ä¸º 0ï¼Œè¿™æ · vbo ä¸ä¼šè¢«æ¸…é™¤ã€‚æˆ–æ˜¯ canvasRenderer.cull ä¸º trueã€‚\nä¸éœ€è¦å“åº”äº‹ä»¶çš„ï¼Œå–æ¶ˆ RaycastTargetã€‚æ·»åŠ å·¥å…·ï¼Œä»£ç è®¾ç½® Image å’Œ text é»˜è®¤å–æ¶ˆã€‚\nCanvas æ¸²æŸ“æ¨¡å¼ä¸º World Space æˆ– Screen Space Cameraï¼Œå§‹ç»ˆåˆ†åˆ«è®¾ç½®äº‹ä»¶æ‘„åƒæœºå’Œæ¸²æŸ“æ‘„åƒæœºéå¸¸é‡è¦ï¼Œæ²¡æœ‰è®¾ç½®ä¼šé€šè¿‡ FindWithTag æŸ¥æ‰¾ä¸»æ‘„åƒæœºã€‚\nå°‘ç”¨ Maskï¼Œç”¨ RectMask2D ä»£æ›¿ã€‚\nTextMeshPro ä»£æ›¿åŸç”Ÿ textã€‚\nå­—ä½“ OutLine å¤šç»˜åˆ¶ 4 æ¬¡ã€‚PixelPerfect æœ‰æ¶ˆè€—ï¼Œæ»‘åŠ¨æ¶ˆè€—æ›´å¤§ã€‚\nFont.CacheFontForTextï¼šç”ŸæˆåŠ¨æ€å­—ä½“ Font Textureï¼Œä¸€æ¬¡æ€§æ‰“å¼€ UI ç•Œé¢ä¸­çš„æ–‡å­—è¶Šå¤šï¼Œå¼€é”€è¶Šå¤§ã€‚å¦‚æœå½“å‰ Font Texture ä¸èƒ½å®¹ä¸‹æ¥ä¸‹æ¥çš„æ–‡å­—ï¼Œæ‰©å¤§ textureï¼Œæ€§èƒ½å½±å“å¤§ã€‚\n\né€šç”¨ç­–ç•¥\nå‹ç¼©å›¾ç‰‡ï¼Œé™ä½å†…å­˜ï¼ŒåŠ¨æ€åŠ è½½é‡Šæ”¾å’Œç¼“å­˜ã€‚\nå›¾é›†ç®¡ç†ï¼Œå‡å°‘ DrawCallï¼ŒåŠ è½½å‹åŠ›ï¼Œè¿™éƒ¨åˆ†æŒ‰æ¸¸æˆç±»å‹ä¸åŒç­–ç•¥ä¸åŒã€‚ä¸€ä¸ªç®€å•çš„è§„åˆ™æ˜¯ä¸€ä¸ª UI åªä¾èµ–è‡ªèº«ä¸€ä¸ªå›¾é›†ï¼ŒåŠ ä¸Šé€šç”¨å›¾é›†ï¼Œå®é™…åšçš„æ—¶å€™å›¾é›†è¿˜è¦å¤šèŠ±æ—¶é—´æ£€æµ‹ï¼Œæ˜¯ä¸ªæŒç»­è°ƒä¼˜çš„äº‹ã€‚\nç‰¹å®šæ¡ä»¶ä¸‹ç”¨å¤§å›¾ç‰‡ä»£æ›¿å¤šä¸ªå°å›¾ç»„åˆï¼Œå‡å°‘ OverDrawã€‚\nè¡€æ¡ã€é£˜å­—ç­‰å®æ—¶åˆ·æ–°çš„æ³¨æ„æ€§èƒ½ï¼Œå®¹æ˜“å‡ºç°ç“¶é¢ˆã€‚å¯ä»¥å‡å°‘å¯è§æ•°é‡ï¼Œé™ä½è¿œå¤„åˆ·æ–°é¢‘ç‡ç­‰ã€‚\ngameobject éšè—æ–¹æ³•ï¼Œenable æœ‰å¾ˆå¤§æ¶ˆè€—ï¼Œåº•å±‚å¤„ç†å¾ˆå¤šä¸œè¥¿ï¼Œç§»åŠ¨åæ ‡æˆ–æ˜¯è®¾ç½® layerã€‚\nç®€åŒ– UI ç»“æ„ï¼Œç©ºçš„èŠ‚ç‚¹è¶Šå°‘è¶Šå¥½ï¼Œå±‚çº§è¶Šå°‘è¶Šå¥½ï¼Œä¸ç”¨çš„èŠ‚ç‚¹åŠæ—¶åˆ é™¤ã€‚å› ä¸º UI ä¸€èˆ¬ä¿®æ”¹è¾ƒå¤šï¼Œå¾ˆå®¹æ˜“æŠŠä¸æ˜¾ç¤ºçš„éšè—ï¼Œä¾ç„¶æœ‰ä¸€å®šæ¶ˆè€—ã€‚\nåŠ¨æ€å›¾é›†ï¼Œç”¨åœ¨å›¾ç‰‡æ•°é‡å¤šï¼Œä¸èƒ½åˆæˆä¸€ä¸ªå¤§å›¾é›†çš„æƒ…å†µã€‚\nç•Œé¢ä¸Šå°‘æŒ‚ç²’å­ç‰¹æ•ˆï¼ŒåŠ¨æ€åŠ è½½ã€‚\nå…¨å± UI æ—¶å…³é—­åœºæ™¯ç›¸æœºã€‚\n\nUGUI çš„ç†è§£ï¼Œç®€å•èŠèŠä½ å¯¹ Image å’Œ RawImage çš„ç†è§£\nImageï¼š ä½¿ç”¨çº¹ç†ï¼ˆTextureï¼‰ä½œä¸ºå›¾åƒæºï¼Œæ”¯æŒç€è‰²å’Œ alpha æ··åˆç­‰é«˜çº§åŠŸèƒ½\nMaskï¼š å¯ä»¥ä½¿ç”¨å¦ä¸€ä¸ª Image æˆ– Shape æ§ä»¶ä½œä¸ºé®ç½©ï¼Œåˆ›å»ºæ›´å¤æ‚çš„å›¾åƒå½¢çŠ¶ã€‚\nAlpha æ··åˆï¼š å¯ä»¥è®¾ç½®å›¾åƒçš„é€æ˜åº¦ï¼Œä½¿å®ƒä¸èƒŒæ™¯æ··åˆæˆ–å åŠ ã€‚\nè£å‰ªï¼š å¯ä»¥è£å‰ªå›¾åƒï¼Œåªæ˜¾ç¤ºçº¹ç†çš„ä¸€éƒ¨åˆ†ã€‚\n\n\nRawImageï¼š ä½¿ç”¨åŸå§‹åƒç´ æ•°æ®ä½œä¸ºå›¾åƒæºï¼Œä¸æä¾›ç€è‰²æˆ– alpha æ··åˆåŠŸèƒ½ï¼Œä½†æ€§èƒ½æ›´ä½³\næ€§èƒ½ä¼˜åŒ–ï¼š ç”±äºä¸è¿›è¡Œç€è‰²æˆ–æ··åˆï¼Œå› æ­¤ RawImage æ§ä»¶æ€§èƒ½æ›´å¥½ï¼Œéå¸¸é€‚åˆå¤„ç†å¤§é‡å›¾åƒæˆ–é«˜åˆ†è¾¨ç‡çº¹ç†\nåƒç´ å®Œç¾ï¼š RawImage æ§ä»¶æ˜¾ç¤ºå›¾åƒçš„åŸå§‹åƒç´ ï¼Œæ²¡æœ‰ä»»ä½•å¹³æ»‘æˆ–æŠ—é”¯é½¿ï¼Œå› æ­¤éå¸¸é€‚åˆåƒç´ è‰ºæœ¯æˆ–å¤å¤æ¸¸æˆ\n\n\n\né®æŒ¡ MaskRectMask2Dåªèƒ½é®æŒ¡çŸ©å½¢èŒƒå›´ï¼Œç±»ä¼¼ NGUIpanel çš„è£å‰ªæ–¹å¼ã€‚è¿™ç§æ–¹å¼ä¸å¢åŠ  DrawCallï¼Œæ¯” Mask æ€§èƒ½é«˜äº›ï¼Œä½†æ˜¯åªèƒ½é®æŒ¡çŸ©å½¢åŒºåŸŸã€‚\nShader éƒ¨åˆ†ï¼Œå®šä¹‰ UNITY_UI_CLIP_RECTï¼Œcolor.a *= UnityGet2DClipping(IN.worldPosition.xy, _ClipRect); å®ç°è£å‰ªï¼›ä»£ç éƒ¨åˆ†ï¼Œè°ƒç”¨ CanvasRenderer çš„EnableRectClippingæ–¹æ³•ï¼Œä¼ é®æŒ¡åŒºåŸŸï¼Œåº•å±‚è®¾ç½®ç»™_ClipRect\nRectMask2D èŠ‚ç‚¹ä¸‹çš„ Maskable ç»„ä»¶ï¼Œæ³¨å†Œåˆ° ClipperRegistry ç±»ï¼Œåº•å±‚æ§åˆ¶å¯¹åº”çš„ Shader æ‰“å¼€å®å®šä¹‰\nMaskåŸç†è®¾ç½®æ¨¡æ¿ç¼“å†²å€¼ï¼Œé€šè¿‡æµ‹è¯•çš„åƒç´ æ˜¾ç¤ºï¼Œä»è€Œåªåœ¨æŒ‡å®šèŒƒå›´å†…æ˜¾ç¤ºå›¾åƒã€‚é€æ˜åº¦ä¸º 0 çš„åŒºåŸŸä¸æ˜¾ç¤ºã€‚å°†æ¸²æŸ“åˆ† 3 ä¸ªæ­¥éª¤ï¼Œ* æ¸²æŸ“ Maskï¼Œè®¾ç½®æ¨¡æ¿ç¼“å†²çš„å€¼\n\næ¸²æŸ“æ¨¡æ¿ä¸‹çš„å¯¹è±¡ï¼Œåˆ¤æ–­æ¨¡æ¿ç¼“å†²å€¼ï¼Œç›¸åŒæ‰æ¸²æŸ“ï¼Œä¹Ÿå°±æ˜¯åœ¨æ ¹èŠ‚ç‚¹å®šä¹‰çš„åŒºåŸŸå†…æ¸²æŸ“\næœ€åå°†æ¨¡æ¿ç¼“å†²åŒºè®¾ç½®ä¸º 0\n\nç¼ºç‚¹\n\næ‰“ä¹±åˆæ‰¹\nåœ†å½¢è¾¹ç¼˜é”¯é½¿æ˜æ˜¾ï¼ŒåŸå› æ˜¯å¹¶ä¸æ”¯æŒè¾¹ç¼˜æ¸å˜ï¼Œåªæœ‰æ˜¾ç¤ºå’Œä¸æ˜¾ç¤ºä¸¤ä¸ªçŠ¶æ€\né®æŒ¡æ•ˆæœåªæ˜¯æ˜¾ç¤ºï¼Œç‚¹å‡»é€»è¾‘è¿˜æ˜¯å®Œæ•´çš„åŒºåŸŸï¼Œä¸€èˆ¬å¸¸ç”¨çš„ï¼Œæ‰©å±•ä¸€ä¸ªå›¾å½¢æ›´å¥½ï¼Œæ¯”å¦‚åœ†å½¢\n\nUGUI çš„é‡ç»˜é¡ºåºæ˜¯æ€æ ·çš„CanvasUpdateRegistry è´Ÿè´£é©±åŠ¨ï¼Œä¹Ÿå°±æ˜¯é€šçŸ¥éœ€è¦æ¸²æŸ“çš„ UI ç»„ä»¶ï¼Œä¸ºä»€ä¹ˆç”¨é€šçŸ¥çš„æ–¹å¼è€Œä¸æ˜¯ UI è‡ªå·±å¤„ç†å‘¢ï¼ŒUGUI çš„å¤„ç†æµç¨‹æ˜¯è¿™æ ·çš„ï¼ŒUI è‡ªå·±è®°å½•æ˜¯å¦éœ€è¦é‡æ–°æ¸²æŸ“ï¼Œæ³¨å†Œäº‹ä»¶ç»™ registryï¼Œregistry åœ¨è¦æ¸²æŸ“çš„æ—¶å€™è§¦å‘äº‹ä»¶ï¼ŒUI å†å»æäº¤æ•°æ®ã€‚è¿™æ ·çš„å¥½å¤„æ˜¯ï¼Œé¦–å…ˆ UI å„ç§æ•°æ®ä¼šåœ¨ä¸€å¸§å†…å¤šæ¬¡æ”¹å˜ï¼Œè‚¯å®šä¸èƒ½æ¯æ¬¡æ”¹å˜éƒ½å‘æ¸²æŸ“äº‹ä»¶ï¼Œä¸€å¸§å¤„ç†ä¸€æ¬¡æ•ˆç‡æ¯”è¾ƒé«˜ã€‚å†ä¸€ä¸ªå¦‚æœä¸å‘äº‹ä»¶ï¼Œé‚£å°±å¿…ç„¶è¦åœ¨ update é‡Œå†™é€»è¾‘ï¼Œæ¯”ç»Ÿä¸€äº‹ä»¶è¦éº»çƒ¦äº›ã€‚\nUI ç»„ä»¶çš„åŸºç±»æ˜¯ Graphicï¼ŒGraphic æ ¸å¿ƒåŠŸèƒ½æ˜¯ç»„ç»‡ mesh å’Œ material ç„¶åä¼ ç»™åº•å±‚ï¼Œä¹Ÿå°±æ˜¯ CanvasRenderer ç±»ã€‚\nCanvasRenderer è¿æ¥ç”»å¸ƒå’Œæ¸²æŸ“ç»„ä»¶ï¼Œé€šè¿‡ CanvasRenderer æŠŠç½‘æ ¼ç»˜åˆ¶åˆ° Canvas ä¸Šï¼ŒCR å¹¶ä¸æ˜¯ç›´æ¥æ¸²æŸ“ï¼Œè€Œæ˜¯äº¤ç»™ Canvasï¼ŒCanvas è¿˜è¦åšåˆæ‰¹ç­‰æ“ä½œ\nCanvasRenderer è¿™ä¸ªåå­—æœ‰ç‚¹è¯¯å¯¼ï¼Œå¹¶ä¸æ˜¯å¯¹åº” Canvasï¼Œè€Œæ˜¯å¯¹åº” Graphicã€‚é‡è¦çš„æ¥å£æœ‰ä¸¤ä¸ªï¼ŒSetMesh å’Œ SetMaterialã€‚ä¸€æ¬¡è®¾ç½®åï¼Œå¦‚æœæ²¡æœ‰æ”¹å˜ï¼Œä¸éœ€è¦é‡å¤è®¾ç½®ï¼Œåº•å±‚æœ‰ç¼“å­˜ï¼Œmesh å’Œ material å¯ä»¥åˆ†å¼€è®¾ç½®ã€‚\næ¯ä¸ª Graphic çš„ CanvasRenderer ä¿å­˜äº†å½“å‰å…ƒç´ çš„ mesh å’Œ materialï¼Œä½†å¹¶ä¸ä¼šæ¯ä¸ª Graphic ä¸€ä¸ª drawcallï¼Œcanvas ä¼šå¯¹èŠ‚ç‚¹ä¸‹çš„ Graphic è¿›è¡Œåˆæ‰¹ï¼Œæ‰€ä»¥ä¸€ä¸ª Graphic è®¾ç½® dirtyï¼Œæ•´ä¸ª canvas éƒ½éœ€è¦é‡æ–°è®¡ç®—åˆæ‰¹ï¼Œè¿™ä¸ªæ¶ˆè€—æ˜¯æ¯”è¾ƒå¤§çš„ï¼Œåˆç†åˆ†é… canvasï¼Œå¯¹æ€§èƒ½å½±å“è¾ƒå¤§ï¼Œè¿™æ˜¯ç•Œé¢æ¸²æŸ“æ€§èƒ½è¦æ³¨æ„çš„åœ°æ–¹ã€‚\n\n    \n\n\né‡ç»˜è§¦å‘æ¡ä»¶\nenableï¼Œdisableï¼Œvalidateéƒ½ä¼šè§¦å‘\nSetVerticesDirty\nMeshEffect æœ‰å˜åŒ–\nshadow å±æ€§æ”¹ç‰ˆ\ntransform å¤§å°æ”¹å˜\nimage ç±»å‹æ”¹å˜ï¼Œå±‚çº§æ”¹å˜ï¼Œå¡«å……æ–¹å¼æ”¹å˜\nRawImageï¼štexture æ”¹å˜ï¼ŒuvRect æ”¹å˜ï¼Œè§¦å‘åŠ¨ç”»æ•ˆæœ\ntext å†…å®¹æ”¹å˜ï¼Œå¼€å…³ richtexï¼Œç­‰ç­‰å¾ˆå¤šï¼Œtext æ˜¯æœ€é¢‘ç¹ dirty çš„\nSetMaterialDirty\nmaterial æ›¿æ¢\nImage è§¦å‘åŠ¨ç”»\næ˜¾ç¤º maskï¼Œè®¾ç½®æ˜¯å¦å¼€å¯ mask\ntransform å±‚çº§å˜åŒ–\ncanvas å±‚çº§å˜åŒ–\né‡æ–°è®¡ç®— mask\nRawImage æ›¿æ¢ textureï¼Œä½¿è§¦å‘åŠ¨ç”»\nåŒæ—¶ dirtyï¼ŒåŒ…æ‹¬ layoutã€transform å±‚çº§æ”¹å˜\nSprite æ›¿æ¢ï¼Œæ”¹å˜å›¾ç‰‡å¤§å°ï¼Œæ›¿æ¢å›¾é›†\nå­—ä½“æ”¹å˜ï¼Œå­—ä½“å›¾é›†å˜åŒ–\n\nNGUI å’Œ UGUI åŒºåˆ«\nUGUI åœ¨éœ€è¦é‡ç»˜æ—¶è§¦å‘äº‹ä»¶ï¼ŒNGUI åœ¨ update æ¯å¸§æ£€æµ‹ï¼Œç•Œé¢å¤æ‚çš„æƒ…å†µä¸‹ä¼šæœ‰ä¸€å®šé¢å¤–æ¶ˆè€—\nåˆæ‰¹ï¼ŒNGUI å¼€æºï¼Œä¿®æ”¹æ–¹ä¾¿ï¼Œä¹Ÿæ›´å¥½æŸ¥é—®é¢˜ã€‚UGUI åªæ˜¯ä¼ æ•°æ®åˆ°åº•å±‚ï¼Œè§„åˆ™åªèƒ½æ˜¯æµ‹è¯•å’ŒçŒœã€‚ä¸è¿‡åˆæ‰¹çš„åŸç†åŸºæœ¬ç›¸åŒï¼Œæ€§èƒ½ä¸Š UGUI æ›´å¥½ï¼Œåº•å±‚ä¸ç”¨ C#ï¼Œåœ¨è¯­è¨€å±‚é¢æ•ˆç‡å°±æ›´é«˜äº›ã€‚\né‡ç»˜ï¼Œåœ¨ NGUI å’Œ UGUI éƒ½æ˜¯ä¸ªæ€§èƒ½æ¶ˆè€—ç‚¹ï¼Œè¦æ³¨æ„ã€‚\nå±‚çº§ï¼ŒUGUI æŒ‰èŠ‚ç‚¹é¡ºåºï¼Œè°ƒæ•´èµ·æ¥å®¹æ˜“ä¸€ç‚¹ï¼ŒNGUI è¦ç‚¹å¼€æ‰èƒ½çœ‹åˆ° depthï¼Œæœ‰ç‚¹éº»çƒ¦\nè£å‰ªï¼ŒNGUI é€šè¿‡åˆ‡æ¢ shaderï¼Œå¤šåˆ›å»ºä¸€ä¸ª material å®ç°çš„ï¼Œè¦å¤šä¸€ä¸ª shaderï¼Œæ²¡æœ‰ UGUI æ–¹ä¾¿ï¼Œè€Œä¸” UGUI2D çš„æ–¹å¼æ›´é«˜æ•ˆï¼Œä¸è¿‡ NGUI æ”¯æŒè£å‰ªè¾¹ç¼˜æ¨¡ç³Šï¼ŒUGUI è¦è‡ªå·±å®ç°ã€‚\nå›¾é›†ï¼ŒNGUI çš„å›¾é›†æ¯”è¾ƒå¯æ§ï¼ŒUGUI é»˜è®¤çš„å›¾é›†ä¸å¯æ§ï¼Œä¸€èˆ¬è¿˜è¦ç”¨å…¶ä»–æ–¹æ¡ˆå®ç°\n\nå¯¹ UI è¿›è¡Œ SetActive è¿™ä¸ªæ“ä½œä¸ºä»€ä¹ˆè¦é¿å…é¢‘ç¹è¿›è¡Œï¼Œå…·ä½“åšäº†äº›ä»€ä¹ˆå†…å®¹ï¼Œæœ‰ä»€ä¹ˆæ–¹æ³•å¯ä»¥ä»£æ›¿å®ƒ\nC# å±‚åˆ° Native å±‚çš„ç©¿æ¢­è°ƒç”¨é€Ÿåº¦æ¯” C# å±‚å†…çš„é€Ÿåº¦æ…¢ã€‚\nUI å…ƒç´ çš„å˜åŒ–å¯¼è‡´æ‰€åœ¨çš„ Canvas å˜åŒ–ï¼Œè§¦å‘å‡½æ•° Canvas.SendWillRenderCanvases() ä¸Canvas.BuildBatch()é€ æˆé«˜è€—æ—¶\nUI å…ƒç´ çš„ç½‘æ ¼é¡¶ç‚¹æ•°ç»„æ”¹å˜ä¼šé€ æˆå †å†…å­˜åˆ†é…ï¼Œè§¦å‘ GCï¼Œå¯¼è‡´è€—æ—¶ï¼ˆä¸è¿‡å¯¹ UI å…ƒç´ è¿›è¡Œä½ç½®ç§»åŠ¨ä¸ä¼šé€ æˆå †å†…å­˜åˆ†é…ï¼‰\n\nå› æ­¤ï¼Œä¼˜åŒ–ä¹Ÿå¯ä»¥ä»ä»¥ä¸‹å‡ ç‚¹è€ƒè™‘ï¼š\n\nåœ¨ C# å±‚è®¾ç½®å˜é‡æ¥æ ‡è¯†ç›¸åº”çš„ GO å¤„äº Active è¿˜æ˜¯é Active çŠ¶æ€ï¼Œé¿å…å¯¹ Active çš„å¯¹è±¡è¿›è¡Œ SetActive(true)ï¼Œé¿å…å¯¹é Active çš„å¯¹è±¡è¿›è¡Œ SetActive(false)ã€‚å¯¹ Active è¿›è¡Œ SetActive(true) æ—¶ï¼Œâ€œåº•å±‚â€ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä½†è°ƒç”¨çš„æ—¶å€™ï¼Œå°±å·²ç»æ˜¯ä» C# å±‚è°ƒç”¨åº•å±‚ï¼Œå¯¼è‡´å¼€é”€è¾ƒé«˜ã€‚åœ¨ C# å±‚åˆ¤æ–­å¥½ï¼Œå°±é¿å…äº†è®©åº•å±‚åˆ¤æ–­ã€‚\nå°†è¦é¢‘ç¹å˜åŒ–çš„ UI å…ƒç´ ä¸ä¸é¢‘ç¹å˜åŒ–çš„ UI å…ƒç´ æ”¾åœ¨ä¸åŒçš„ Canvas ä¸­ï¼Œå‡å°‘ UI å…ƒç´ å˜åŒ–æ—¶çš„è€—æ—¶ã€‚\né€šè¿‡å°† UI å…ƒç´ çš„åæ ‡ç§»åŠ¨åˆ° Canvas çš„èŒƒå›´ä¹‹å¤–çš„æ–¹æ³•æ¥æ˜¾ç¤ºä¸éšè—ï¼Œé¿å… SetActive çš„è€—æ—¶ä»¥åŠ SendWillRenderCanvases çš„è€—æ—¶ã€‚\nç»æµ‹è¯•ï¼Œå¯¹ Component è¿›è¡Œ enabled = false çš„æ“ä½œæ¯”å¯¹ GO è¿›è¡Œ SetActive(false) çš„æ“ä½œè€—æ—¶ä½ã€‚\né€šè¿‡æ·»åŠ  CanvasGroup ç»„ä»¶è®¾ç½®é€æ˜åº¦çš„æ–¹å¼æ¥è¿›è¡Œæ˜¾ç¤ºä¸éš\n\nCanvas çš„ä¸‰ç§æ¨¡å¼  æ¸²æŸ“æ¨¡å¼  åœ¨ Unity3D ä¸­ï¼ŒCanvas ç»„ä»¶æœ‰ä¸‰ç§ä¸åŒçš„æ¸²æŸ“æ¨¡å¼ï¼šScreen Space - Overlayã€Screen Space - Camera å’Œ World Spaceã€‚ä¸åŒçš„æ¸²æŸ“æ¨¡å¼é€‚ç”¨äºä¸åŒçš„åœºæ™¯å’Œéœ€æ±‚ã€‚\n\nScreen Space - Overlay æ˜¯æœ€å¸¸ç”¨çš„æ¸²æŸ“æ¨¡å¼ï¼Œå®ƒå°† UI å…ƒç´ æ¸²æŸ“åœ¨å±å¹•ä¸Šï¼Œå¹¶ä¸”æ€»æ˜¯ä½äºæ‰€æœ‰å…¶ä»–å¯¹è±¡çš„å‰é¢ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼ŒUI å…ƒç´ çš„ä½ç½®æ˜¯ä»¥å±å¹•åˆ†è¾¨ç‡ä¸ºåŸºå‡†çš„ï¼Œä¸å—ç›¸æœºçš„å½±å“ã€‚è¿™ç§æ¨¡å¼é€‚ç”¨äºæ¸¸æˆä¸­çš„å¸¸é©» UIï¼Œä¾‹å¦‚èœå•ã€è¡€æ¡ç­‰\nScreen Space - Camera æ¨¡å¼å°† UI å…ƒç´ æ¸²æŸ“åœ¨ç›¸æœºçš„å‰é¢ï¼Œå¹¶ä¸”ä¼šå—ç›¸æœºçš„è§†é‡å’Œä½ç½®çš„å½±å“ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼ŒUI å…ƒç´ çš„ä½ç½®æ˜¯ä»¥ç›¸æœºä¸ºåŸºå‡†çš„ï¼Œå¯ä»¥éšç€ç›¸æœºçš„ç§»åŠ¨è€Œç§»åŠ¨ã€‚è¿™ç§æ¨¡å¼é€‚ç”¨äºéœ€è¦ UI å…ƒç´ éšç€ç›¸æœºç§»åŠ¨çš„åœºæ™¯ï¼Œä¾‹å¦‚ç¬¬ä¸€äººç§°å°„å‡»æ¸¸æˆä¸­çš„å‡†å¿ƒ\nWorld Space æ¨¡å¼å°† UI å…ƒç´ æ¸²æŸ“åœ¨ 3D ä¸–ç•Œä¸­çš„æŸä¸ªä½ç½®ï¼Œå¹¶ä¸”ä¼šå—åˆ°åœºæ™¯ä¸­å…¶ä»– 3D å¯¹è±¡çš„é®æŒ¡å’Œå…‰ç…§çš„å½±å“ã€‚åœ¨è¿™ç§æ¨¡å¼ä¸‹ï¼ŒUI å…ƒç´ çš„ä½ç½®æ˜¯ä»¥åœºæ™¯ä¸­çš„ 3D åæ ‡ä¸ºåŸºå‡†çš„ã€‚è¿™ç§æ¨¡å¼é€‚ç”¨äºéœ€è¦å°† UI å…ƒç´ ä¸åœºæ™¯ä¸­çš„ 3D å¯¹è±¡è¿›è¡Œäº¤äº’çš„åœºæ™¯ï¼Œä¾‹å¦‚åœ¨æ¸¸æˆä¸­æ˜¾ç¤º NPC çš„å¯¹è¯æ¡†\n\nå±å¹•é€‚é…  åœ¨ç§»åŠ¨è®¾å¤‡ä¸Šï¼Œå±å¹•çš„å°ºå¯¸å’Œåˆ†è¾¨ç‡å„ä¸ç›¸åŒï¼Œä¸ºäº†èƒ½å¤Ÿåœ¨ä¸åŒè®¾å¤‡ä¸Šæ­£ç¡®æ˜¾ç¤º UI å…ƒç´ ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œå±å¹•é€‚é…ã€‚åœ¨ Canvas ç»„ä»¶ä¸­ï¼Œæœ‰ä¸¤ç§å¸¸ç”¨çš„å±å¹•é€‚é…æ–¹å¼ï¼šConstant Pixel Size å’Œ Scale With Screen Size\n\nConstant Pixel Size æ˜¯ä¸€ç§å›ºå®šåƒç´ å¤§å°çš„é€‚é…æ–¹å¼ï¼Œå³ UI å…ƒç´ çš„å¤§å°ä¸ä¼šéšç€å±å¹•å°ºå¯¸çš„å˜åŒ–è€Œå˜åŒ–ã€‚åœ¨è¿™ç§é€‚é…æ–¹å¼ä¸‹ï¼ŒUI å…ƒç´ çš„å¤§å°æ˜¯ä»¥åƒç´ ä¸ºå•ä½çš„ï¼Œå¯¹äºä¸åŒçš„å±å¹•å°ºå¯¸ï¼ŒUI å…ƒç´ çš„å¤§å°ä¼šæœ‰æ‰€å˜åŒ–ã€‚è¿™ç§é€‚é…æ–¹å¼é€‚ç”¨äºéœ€è¦ä¿æŒ UI å…ƒç´ å¤§å°ä¸å˜çš„åœºæ™¯ï¼Œä¾‹å¦‚æ¸¸æˆä¸­çš„æŒ‰é’®\nScale With Screen Size æ˜¯ä¸€ç§æ ¹æ®å±å¹•å°ºå¯¸è¿›è¡Œç¼©æ”¾çš„é€‚é…æ–¹å¼ï¼Œå³ UI å…ƒç´ çš„å¤§å°ä¼šéšç€å±å¹•å°ºå¯¸çš„å˜åŒ–è€Œå˜åŒ–ã€‚åœ¨è¿™ç§é€‚é…æ–¹å¼ä¸‹ï¼ŒUI å…ƒç´ çš„å¤§å°æ˜¯ä»¥ç™¾åˆ†æ¯”ä¸ºå•ä½çš„ï¼Œå¯¹äºä¸åŒçš„å±å¹•å°ºå¯¸ï¼ŒUI å…ƒç´ çš„å¤§å°ä¼šæŒ‰ç…§æ¯”ä¾‹è¿›è¡Œç¼©æ”¾ã€‚è¿™ç§é€‚é…æ–¹å¼é€‚ç”¨äºéœ€è¦æ ¹æ®å±å¹•å°ºå¯¸è¿›è¡Œè‡ªé€‚åº”çš„åœºæ™¯ï¼Œä¾‹å¦‚æ¸¸æˆä¸­çš„èƒŒæ™¯å›¾åƒ\n\nèµ„æºç®¡ç†  èµ„æºç®¡ç†æ¨¡å— AssetBundle çš„åŸç† å¦‚ä½•ä» Bundle åŠ è½½ä¸€ä»½èµ„æºåˆ° Game é‡Œé¢ï¼Œéœ€è¦ç»è¿‡å‡ æ¬¡æˆ–è€…å‡ ä¸ªå†…å­˜åŒº  å¦‚ä½•ç®¡ç† AB åŒ…  å¦‚ä½•å®‰å…¨å¸è½½ AB åŒ…æˆ–è€… Assetå¦‚ä½•è§£å†³ä¾èµ–Unity ä¼šè‡ªåŠ¨æ”¶é›†å¹¶åˆ†æå…¶ä¾èµ–çš„èµ„æºï¼Œå¦‚æœè¯¥èµ„æºä¾èµ–çš„æŸä¸ªèµ„æºæ²¡æœ‰è¢«æ˜¾å¼æŒ‡å®šæ‰“åŒ…åˆ° ab ä¸­ï¼Œå°±å°†å…¶ä¾èµ–çš„è¿™ä¸ªèµ„æºæ‰“åŒ…è¿›è¯¥èµ„æºæ‰€åœ¨çš„ ab é‡Œï¼›å¦‚æœå·²ç»è¢«æŒ‡å®šæ‰“åŒ…è¿›å…¶ä»– ab é‡Œï¼Œé‚£ä¹ˆè¿™ä¸¤ä¸ª ab ä¹‹é—´å°±ä¼šæ„æˆä¾èµ–å…³ç³»ï¼ŒåŠ è½½ ab æ—¶ï¼Œå…ˆåŠ è½½å…¶ä¾èµ–çš„ ab å³å¯ã€‚\nè¿™ä¸€å¥—ä¾èµ–ç®¡ç†æœºåˆ¶ä½¿ç”¨æ–¹ä¾¿çš„åŒæ—¶ä¹Ÿä¼šå¸¦æ¥ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœä¸¤ä¸ª ab A å’Œ B ä¸­çš„ä¸€äº›èµ„æºéƒ½ä¾èµ–äº†ä¸€ä¸ªæ²¡æœ‰è¢«æŒ‡å®šè¦æ‰“åŒ…çš„èµ„æº Cï¼Œé‚£ä¹ˆ C å°±ä¼šåŒæ—¶è¢«æ‰“è¿› ab A å’Œ B ä¸­ï¼Œé€ æˆèµ„æºçš„å†—ä½™ï¼Œå¢å¤§ ab å’Œå®‰è£…åŒ…çš„ä½“ç§¯ã€‚è€Œè¿™ä¸ªè¢« Aï¼ŒB ä¾èµ–çš„èµ„æº C åˆå¯ä»¥åˆ†ä¸ºä¸¤ç§ç±»å‹ï¼Œä¸€ç§æ˜¯ Assets ä¸‹å¤–éƒ¨å¯¼å…¥çš„èµ„æºï¼Œå³å¼€å‘è€…å¯¼å…¥æˆ–åˆ›å»ºçš„èµ„æºï¼›å¦ä¸€ç§åˆ™æ˜¯ Unity å†…ç½®çš„èµ„æºï¼Œä¾‹å¦‚å†…ç½®çš„ Shaderï¼ŒDefault-Material å’Œ UGUI ä¸€äº›ç»„ä»¶å¦‚ Image ç”¨çš„ä¸€äº›çº¹ç†èµ„æºç­‰ç­‰ã€‚å› æ­¤è¦è§£å†³èµ„æºå†—ä½™çš„é—®é¢˜ï¼Œå°±è¦åˆ†åˆ«å¯¹è¿™ä¸¤ç§è¢«ä¾èµ–çš„èµ„æºè¿›è¡Œå¤„ç†ã€‚\nå¤„ç†è¢«ä¾èµ–çš„å¤–éƒ¨èµ„æº  å¯¹äºæ²¡æœ‰è¢«æŒ‡å®šæ‰“åŒ…çš„å¤–éƒ¨èµ„æºï¼Œå¦‚æœå¤šä¸ª ab åŒ…ä¾èµ–äº†å®ƒï¼Œæ‰“åŒ…æ—¶è¯¥èµ„æºå°±ä¼šè¢«å¤šæ¬¡æ‰“åŒ…è¿›ä¾èµ–å®ƒçš„ ab åŒ…ä¸­ï¼Œé€ æˆå†—ä½™ã€‚è§£å†³æ–¹æ¡ˆå°±æ˜¯å°†è¿™äº›è¢«å¤šä¸ª ab åŒ…ä¾èµ–çš„èµ„æºæ‰“åŒ…åˆ°ä¸€ä¸ªå…¬å…± ab åŒ…ä¸­ã€‚å¤„ç†è¿‡ç¨‹å¦‚ä¸‹ï¼š\n\nä½¿ç”¨ EditorUtility.CollectDependencies() å¾—åˆ° ab ä¾èµ–çš„æ‰€æœ‰èµ„æºçš„è·¯å¾„\nç»Ÿè®¡èµ„æºè¢«æ‰€æœ‰ ab å¼•ç”¨çš„æ¬¡æ•°ï¼Œå°†è¢«å¤šä¸ª ab å¼•ç”¨çš„èµ„æºæ‰“åŒ…ä¸ºå…¬å…± ab åŒ…\n\n\nEditorUtility.CollectDependencies()æ”¶é›†åˆ°çš„èµ„æºåŒ…å«äº†è„šæœ¬ï¼Œdll å’Œç¼–è¾‘å™¨èµ„æºï¼Œè¿™äº›èµ„æºæ— éœ€æ‰“è¿› ab ä¸­\n\nå¤„ç†è¢«ä¾èµ–çš„å†…éƒ¨èµ„æº  æ€§èƒ½ä¼˜åŒ–  ä½¿ç”¨è¿‡å“ªäº›æ€§èƒ½åˆ†æå·¥å…·ã€æ€§èƒ½ä¸»è¦æ˜¯åœ¨è€ƒè™‘å“ªæ–¹é¢çš„å› ç´ å½±å“Unity ProfilerUnity Profiler æ˜¯ Unity ä¸­æœ€å¸¸ç”¨çš„å®˜æ–¹æ€§èƒ½åˆ†æå·¥å…·ï¼Œåœ¨ä½¿ç”¨ Unity å¼€å‘æ¸¸æˆçš„è¿‡ç¨‹ä¸­ï¼Œå€ŸåŠ© Profiler æ¥åˆ†æ CPUã€GPU åŠå†…å­˜ä½¿ç”¨çŠ¶å†µæ˜¯è‡³å…³é‡è¦çš„\n\nåˆæ‰¹çš„åŸç†ï¼Œåˆæ‰¹æœ‰å“ªäº›ï¼ŒåŒºåˆ«æ˜¯ä»€ä¹ˆ  åˆæ‰¹ï¼Œä¹Ÿå¯ä»¥å«åšæ‰¹é‡æ¸²æŸ“ã€‚åˆæ‰¹å°±æ˜¯é€šè¿‡å‡å°‘ CPU å‘ GPU å‘é€æ¸²æŸ“å‘½ä»¤ï¼ˆDrawCallï¼‰çš„æ¬¡æ•°ï¼Œä»¥åŠå‡å°‘ GPU åˆ‡æ¢æ¸²æŸ“çŠ¶æ€çš„æ¬¡æ•°ï¼Œå°½é‡è®© GPU ä¸€æ¬¡å¤šåšä¸€äº›äº‹æƒ…ï¼Œæ¥æå‡é€»è¾‘çº¿å’Œæ¸²æŸ“çº¿çš„æ•´ä½“æ•ˆç‡ã€‚ä½†å‚ä¸åˆæ‰¹æœ‰ä¸ªå‰æï¼Œå°±æ˜¯å‚ä¸åˆæ‰¹çš„æè´¨å¿…é¡»ç›¸åŒ\né™æ€åˆæ‰¹  å¯¹æ ‡è®°ä¸º static çš„ Mesh è‡ªåŠ¨åˆæ‰¹ã€‚ä»¥ç©ºé—´æ¢æ—¶é—´çš„ç­–ç•¥æ¥æå‡æ¸²æŸ“æ•ˆç‡ã€‚ä»¥å­˜å‚¨æ›´å¤šç½‘æ ¼æ•°æ®ä¸ºä»£ä»·çš„\nå¦‚æœåœ¨ä½¿ç”¨ç›¸åŒæè´¨çƒçš„æ¡ä»¶ä¸‹ï¼Œåœ¨ Build çš„æ—¶å€™ Unity ä¼šè‡ªåŠ¨åœ°æå–è¿™äº›å…±äº«æè´¨çš„é™æ€æ¨¡å‹çš„ Vertex Buffer å’Œ Index Bufferã€‚æ ¹æ®å…¶æ‘†æ”¾åœ¨åœºæ™¯ä¸­çš„ä½ç½®ç­‰æœ€ç»ˆçŠ¶æ€ä¿¡æ¯ï¼Œå°†è¿™äº›æ¨¡å‹çš„é¡¶ç‚¹æ•°æ®å˜æ¢åˆ°ä¸–ç•Œç©ºé—´ä¸‹ï¼Œå­˜å‚¨åœ¨æ–°æ„å»ºçš„å¤§ Vertex Buffer å’Œ Index Buffer ä¸­ï¼Œå¹¶ä¸”è®°å½•æ¯ä¸€ä¸ªå­æ¨¡å‹çš„ Index Buffer æ•°æ®åœ¨æ„å»ºçš„å¤§ Index Buffer ä¸­çš„èµ·å§‹ (start0) åŠç»“æŸ (end0) ä½ç½®\n\n    \n\n\nåœ¨åç»­çš„ç»˜åˆ¶è¿‡ç¨‹ä¸­ï¼Œä¸€æ¬¡æ€§æäº¤æ•´ä¸ªåˆå¹¶æ¨¡å‹çš„é¡¶ç‚¹æ•°æ®ï¼Œæ ¹æ®å¼•æ“çš„åœºæ™¯ç®¡ç†ç³»ç»Ÿåˆ¤æ–­å„ä¸ªå­æ¨¡å‹çš„å¯è§æ€§ã€‚ç„¶åè®¾ç½®ä¸€æ¬¡æ¸²æŸ“çŠ¶æ€ï¼Œè°ƒç”¨å¤šæ¬¡ DrawCall åˆ†åˆ«ç»˜åˆ¶æ¯ä¸€ä¸ªå­æ¨¡å‹ã€‚æ‰€ä»¥å…¶å® Static Batching æ˜¯ä¸å‡å°‘ DrawCall çš„æ•°é‡ï¼ˆä½†æ˜¯åœ¨ç¼–è¾‘å™¨æ—¶ç”±äºè®¡ç®—æ–¹æ³•åŒºåˆ« DrawCall æ•°é‡æ˜¯ä¼šæ˜¾ç¤ºå‡å°‘äº†çš„ï¼‰ï¼Œä½†æ˜¯ç”±äºæˆ‘ä»¬é¢„å…ˆæŠŠæ‰€æœ‰çš„å­æ¨¡å‹çš„é¡¶ç‚¹å˜æ¢åˆ°äº†ä¸–ç•Œç©ºé—´ä¸‹ï¼Œæ‰€ä»¥åœ¨è¿è¡Œæ—¶ CPU ä¸éœ€è¦å†æ¬¡æ‰§è¡Œé¡¶ç‚¹å˜æ¢æ“ä½œï¼ŒèŠ‚çº¦äº†å°‘é‡çš„è®¡ç®—èµ„æºï¼Œå¹¶ä¸”è¿™äº›å­æ¨¡å‹å…±äº«æè´¨ï¼Œæ‰€ä»¥åœ¨å¤šæ¬¡ DrawCall è°ƒç”¨ä¹‹é—´å¹¶æ²¡æœ‰æ¸²æŸ“çŠ¶æ€çš„åˆ‡æ¢ï¼Œæ¸²æŸ“ APIï¼ˆCommand Bufferï¼‰ä¼šç¼“å­˜ç»˜åˆ¶å‘½ä»¤ï¼Œèµ·åˆ°äº†æ¸²æŸ“ä¼˜åŒ–çš„ç›®çš„ ã€‚\nä½†é™æ€åˆå¹¶æœ‰ä¸ªå¾ˆå¤§çš„ç¼ºç‚¹å°±æ˜¯æ‰“åŒ…ä¹‹åä¼šå¯¼è‡´åº”ç”¨ä½“ç§¯å¢å¤§ï¼Œåº”ç”¨è¿è¡Œæ—¶æ‰€å ç”¨çš„å†…å­˜ä½“ç§¯ä¹Ÿä¼šå¢å¤§ã€‚ä¾‹å¦‚ï¼Œåœ¨èŒ‚å¯†çš„æ£®æ—çº§åˆ«å°†æ ‘æ ‡è®°ä¸ºé™æ€ä¼šä¸¥é‡å½±å“å†…å­˜ï¼Œå› ä¸ºåœºæ™¯ä¸­æ‰€æœ‰å¼•ç”¨ç›¸åŒæ¨¡å‹çš„ GameObject éƒ½å¿…é¡»å°†æ¨¡å‹é¡¶ç‚¹ä¿¡æ¯å¤åˆ¶ï¼Œå¹¶ç»è¿‡è®¡ç®—å˜åŒ–åˆ°æœ€ç»ˆåœ¨ä¸–ç•Œç©ºé—´ä¸­ï¼Œå­˜å‚¨åœ¨æœ€ç»ˆç”Ÿæˆçš„ Vertex Buffer ä¸­ï¼Œè¿™ä¸ªæ—¶å€™çš„ vertex Buffer ä¼šç‰¹åˆ«å¤§\n\n    \n\n\nåŠ¨æ€åˆæ‰¹  å°†æ•°ä»½ Mesh çš„æ•°æ®å¤åˆ¶ç²˜è´´åˆ°ä¸€èµ·ï¼Œä¹Ÿå°±æ˜¯å®æ—¶çš„ï¼Œæ¯ä¸€å¸§éƒ½åˆå¹¶ï¼Œä½†ä¸é€‚ç”¨äºç½‘æ ¼æ•°æ®å¤ªå¤šçš„ç‰©ä½“ï¼ˆæ¯”å¦‚çƒï¼‰\nåœ¨è¿›è¡Œåœºæ™¯ç»˜åˆ¶ä¹‹å‰å°†æ‰€æœ‰çš„å…±äº«åŒä¸€æè´¨çš„æ¨¡å‹çš„é¡¶ç‚¹ä¿¡æ¯å˜æ¢åˆ°ä¸–ç•Œç©ºé—´ä¸­ï¼Œç„¶åé€šè¿‡ä¸€æ¬¡ DrawCall ç»˜åˆ¶å¤šä¸ªæ¨¡å‹ï¼Œè¾¾åˆ°åˆæ‰¹çš„ç›®çš„ã€‚æ¨¡å‹é¡¶ç‚¹å˜æ¢çš„æ“ä½œæ˜¯ç”± CPU å®Œæˆçš„ï¼Œæ‰€ä»¥è¿™ä¼šå¸¦æ¥ä¸€äº› CPU çš„æ€§èƒ½æ¶ˆè€—ã€‚å¹¶ä¸”è®¡ç®—çš„æ¨¡å‹é¡¶ç‚¹æ•°é‡ä¸å®œå¤ªå¤šï¼Œå¦åˆ™ CPU ä¸²è¡Œè®¡ç®—è€—è´¹çš„æ—¶é—´å¤ªé•¿ä¼šé€ æˆåœºæ™¯æ¸²æŸ“å¡é¡¿ï¼Œæ‰€ä»¥ Dynamic Batching åªèƒ½å¤„ç†ä¸€äº›å°æ¨¡å‹ã€‚æ‰€ä»¥ä»…ä»…åœ¨åˆæ‰¹æ“ä½œçš„æ€§èƒ½æ¶ˆè€—å°äºä¸åˆæ‰¹ï¼ŒDynamic Batching æ‰ä¼šæœ‰æ„ä¹‰ï¼Œè™½ç„¶åœ¨å†…å­˜å ç”¨å’Œå‘å¸ƒçš„ç¨‹åºä½“ç§¯æ–¹é¢è¦ä¼˜äº Static Batchingã€‚\næ— æ³•å‚åŠ  Dynamic Batching çš„æƒ…å†µï¼š\n\nç‰©ä»¶ Mesh å¤§äºç­‰äº 900 ä¸ªé¢\nä»£ç åŠ¨æ€æ”¹å˜æè´¨å˜é‡åä¸ç®—åŒä¸€ä¸ªæè´¨ï¼Œä¼šä¸å‚ä¸åˆæ‰¹\nå¦‚æœä½ çš„ç€è‰²å™¨ä½¿ç”¨é¡¶ç‚¹ä½ç½®ï¼Œæ³•çº¿å’Œ UV å€¼ä¸‰ç§å±æ€§ï¼Œé‚£ä¹ˆä½ åªèƒ½æ‰¹å¤„ç† 300 é¡¶ç‚¹ä»¥ä¸‹çš„ç‰©ä½“ï¼›å¦‚æœä½ çš„ç€è‰²å™¨éœ€è¦ä½¿ç”¨é¡¶ç‚¹ä½ç½®ï¼Œæ³•çº¿ï¼ŒUV0ï¼ŒUV1 å’Œåˆ‡å‘é‡ï¼Œé‚£ä½ åªèƒ½æ‰¹å¤„ç† 180 é¡¶ç‚¹ä»¥ä¸‹çš„ç‰©ä½“ï¼Œå¦åˆ™éƒ½æ— æ³•å‚ä¸åˆæ‰¹\n\n\n    \n\n\nåŠ¨æ€åˆæ‰¹ä¸é™æ€åˆæ‰¹çš„åŒºåˆ«\nåŠ¨æ€åˆæ‰¹ä¸ä¼šåˆ›å»ºå¸¸é©»å†…å­˜çš„â€œåˆå¹¶åç½‘æ ¼â€ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¸ä¼šåœ¨è¿è¡Œæ—¶é€ æˆå†…å­˜çš„æ˜¾è‘—å¢é•¿ï¼Œä¹Ÿä¸ä¼šå½±å“æ‰“åŒ…æ—¶çš„åŒ…ä½“å¤§å°ï¼›\nåŠ¨æ€åˆæ‰¹åœ¨ç»˜åˆ¶å‰ä¼šå…ˆå°†é¡¶ç‚¹è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»ä¸‹ï¼Œç„¶åå†å¡«å……è¿›é¡¶ç‚¹ã€ç´¢å¼•ç¼“å†²åŒºï¼›é™æ€åˆæ‰¹åå­ç½‘æ ¼ä¸æ¥å—ä»»ä½•å˜æ¢æ“ä½œï¼Œä»…æ‰‹åŠ¨åˆæ‰¹åçš„ Root èŠ‚ç‚¹å¯è¢«æ“ä½œï¼Œå› æ­¤é™æ€åˆæ‰¹çš„é¡¶ç‚¹ã€ç´¢å¼•ç¼“å†²åŒºä¸­çš„ä¿¡æ¯ä¸ä¼šè¢«ä¿®æ”¹ï¼ˆRoot çš„å˜æ¢ä¿¡æ¯åˆ™ä¼šé€šè¿‡ Constant Buffer ä¼ å…¥ï¼‰ï¼›\nå› ä¸º 2 çš„åŸå› ï¼ŒåŠ¨æ€åˆæ‰¹çš„ä¸»è¦å¼€é”€åœ¨äºéå†é¡¶ç‚¹è¿›è¡Œç©ºé—´å˜æ¢æ—¶çš„å¯¹ CPU æ€§èƒ½çš„å¼€é”€ï¼›é™æ€åˆæ‰¹æ²¡æœ‰è¿™ä¸ªæ“ä½œï¼Œæ‰€ä»¥ä¹Ÿæ²¡æœ‰è¿™ä¸ªå¼€é”€ï¼›\nåŠ¨æ€åˆæ‰¹ä½¿ç”¨æ ¹æ®æ¸²æŸ“å™¨ç±»å‹åˆ†é…çš„å…¬å…±ç¼“å†²åŒºï¼Œè€Œé™æ€åˆæ‰¹ä½¿ç”¨è‡ªå·±ä¸“ç”¨çš„ç¼“å†²åŒºã€‚\n\nURPSetPassCall å’Œ DrawCallè¦æƒ³ CPU å’Œ GPU æ—¢å¯ä»¥å¹¶è¡Œåˆå¯ä»¥ç‹¬ç«‹å·¥ä½œï¼Œè¦ä½¿ç”¨ä¸€ä¸ªå‘½ä»¤ç¼“å†²åŒºï¼ˆCommand Bufferï¼‰ã€‚å‘½ä»¤ç¼“å†²åŒºåŒ…å«äº†ä¸€ä¸ªå‘½ä»¤é˜Ÿåˆ—ï¼Œå½“ CPU éœ€è¦æ¸²æŸ“ä¸€äº›å¯¹è±¡æ—¶ï¼Œå®ƒä¼šé€šè¿‡å›¾åƒç¼–ç¨‹æ¥å£å‘å‘½ä»¤ç¼“å†²åŒºæ·»åŠ å‘½ä»¤ï¼Œå½“ GPU å®Œæˆä¸Šæ¬¡çš„æ¸²æŸ“ä»»åŠ¡åï¼Œå®ƒä¼šä»å‘½ä»¤é˜Ÿåˆ—è¯»å–ä¸€ä¸ªå‘½ä»¤å¹¶æ‰§è¡Œå®ƒï¼Œæ·»åŠ å’Œè¯»å–çš„è¿‡ç¨‹æ˜¯ç›¸äº’ç‹¬ç«‹çš„\nå‘½ä»¤ç¼“å†²åŒºæœ‰å¾ˆå¤šç§ç±»å‹ï¼Œè€Œ Draw Call å°±æ˜¯å…¶ä¸­ä¸€ç§ï¼Œå…¶å®ƒå‘½ä»¤è¿˜æœ‰ Set Pass Call ç­‰ç­‰ã€‚Set Pass Call ä»£è¡¨äº†å¸¸è¯´çš„æ”¹å˜æ¸²æŸ“çŠ¶æ€ï¼Œå½“åˆ‡æ¢æè´¨æˆ–è€…åˆ‡æ¢åŒä¸€æè´¨ä¸­ Shader çš„ä¸åŒ Pass è¿›è¡Œæ¸²æŸ“æ—¶éƒ½ä¼šè§¦å‘ä¸€æ¬¡ Set Pass Callã€‚æ¯”å¦‚æ¸²æŸ“ 1000 ä¸ªç›¸åŒçš„ç‰©ä½“å’Œæ¸²æŸ“ 1000 ä¸ªä¸åŒçš„ç‰©ä½“ï¼Œè™½ç„¶ä¸¤è€… Draw Call éƒ½æ˜¯ 1000ï¼Œä½†æ˜¯å‰è€…çš„ Set Pass Call ä¸º 1ï¼Œåè€…è¿˜æ˜¯ 1000ã€‚åˆ‡æ¢æ¸²æŸ“çŠ¶æ€å¾€å¾€æ¯” Draw Call æ›´è€—æ—¶ï¼Œæ‰€ä»¥è¿™ä¹Ÿæ˜¯ URP ä¸å†æ”¯æŒå¤š Pass çš„åŸå› \næ¯æ¬¡è°ƒç”¨ Draw Call ä¹‹å‰ï¼ŒCPU éƒ½è¦å‘ GPU å‘é€å¾ˆå¤šå†…å®¹ï¼ŒåŒ…æ‹¬æ•°æ®ã€çŠ¶æ€å’Œå‘½ä»¤ç­‰ã€‚åœ¨è¿™ä¸€é˜¶æ®µ CPU éœ€è¦å®Œæˆå¾ˆå¤šå·¥ä½œï¼Œä¾‹å¦‚æ£€æŸ¥æ¸²æŸ“çŠ¶æ€ç­‰ã€‚ä¸€æ—¦ CPU å®Œæˆäº†è¿™äº›å‡†å¤‡å·¥ä½œï¼ŒGPU å°±å¯ä»¥å¼€å§‹æœ¬æ¬¡æ¸²æŸ“ï¼ŒGPU çš„æ¸²æŸ“èƒ½åŠ›å¾ˆå¼ºï¼Œæ¸²æŸ“é€Ÿåº¦å¾€å¾€æ¯” CPU çš„æäº¤å‘½ä»¤é€Ÿåº¦å¿«ï¼Œå¦‚æœ Draw Call æ•°é‡è¿‡å¤šï¼ŒCPU å°±ä¼šæŠŠæœºä¼šæŠŠå¤§é‡æ—¶é—´èŠ±è´¹åœ¨æäº¤ Draw Call ä¸Šï¼Œé€ æˆ CPU è¿‡è½½ï¼Œæ¸¸æˆå¸§ç‡å˜ä½\næ—©æœŸ Unity åªæ”¯æŒåŠ¨æ€æ‰¹å¤„ç†å’Œé™æ€æ‰¹å¤„ç†ï¼Œåæ¥æœ‰æ”¯æŒäº† GPU Instancingï¼Œæœ€å SRP å‡ºç°æ—¶æ”¯æŒäº†ä¸€ç§æ–°çš„æ‰¹å¤„ç†æ–¹å¼â€”â€”SRP Batcher\nSRP BatcherSRP Batcher ä¸­å°† CPU æ”¶é›†ä¸æäº¤ GPU éƒ¨åˆ†çœç•¥ï¼Œå¹¶ä¸æ˜¯å®Œå…¨çœç•¥è€Œæ˜¯ä¸éœ€è¦æ¯å¸§éƒ½ç»™ GPU ä¼ é€’æ•°æ®ï¼Œå¦‚æœæ•°æ®æ²¡æœ‰å‘ç”Ÿå˜åŒ–å®ƒä»¬å°†è¢«ä¿å­˜åœ¨ GPU å†…å­˜ä¸­ï¼Œè¿™æ ·æ¯å¸§åªéœ€è¦æƒŠé†’ç»‘å®šæ•°æ®å°±è¡Œï¼Œä»è€ŒèŠ‚çœäº†æ•ˆç‡ã€‚\n\nSRP Batcher æ˜¯å¦å‘ç”Ÿæ‰“æ–­åˆä¼ ç»Ÿæ–¹å¼æ˜¯ä¸åŒçš„ï¼šä¼ ç»Ÿæ–¹å¼å³ä½¿ä¸¤ä¸ªæè´¨ä½¿ç”¨äº†  ç›¸åŒçš„ç€è‰²å™¨  ä¹Ÿä¼šäº§ç”Ÿ Set Pass Callï¼Œè€Œ SRP Batcher å´ä¸ä¼šï¼Œå®ƒåˆ¤æ–­æ‰“æ–­å¹¶ä¸æ˜¯æŒ‰æè´¨æ˜¯å¦å˜åŒ–ï¼ŒäºŒåç€è‰²å™¨å˜ç§æ˜¯å¦å‘ç”Ÿå˜åŒ–ï¼Œåªè¦å˜ç§ç›¸åŒå³ä½¿æ˜¯ç”¨äº†ä¸åŒçš„æè´¨ä¹Ÿèƒ½æœ‰æ•ˆ SRP Batcher\n\nConstant BufferUnity æ²¡æœ‰ç›´æ¥æä¾› MVP çŸ©é˜µï¼Œè€Œæ˜¯æ‹†å¼€æˆä¸¤ä¸ªä¸¾è¯ M å’Œ VPï¼Œå› ä¸º VP çŸ©é˜µ  åœ¨ä¸€å¸§ä¸­ä¸ä¼šæ”¹å˜ï¼Œå¯ä»¥é‡å¤åˆ©ç”¨ã€‚Unity å°† M çŸ©é˜µå’Œ VP çŸ©é˜µå­˜å…¥ Constant Buffer ä¸­ä»¥æé«˜è¿ç®—æ•ˆç‡ï¼ŒM çŸ©é˜µå­˜å…¥çš„ Buffer ä¸ºUnityPerDraw Bufferï¼Œä¹Ÿå°±æ˜¯é’ˆå¯¹æ¯ä¸ªç‰©ä½“çš„ç»˜åˆ¶ä¸ä¼šæ”¹å˜ã€‚VP çŸ©é˜µåˆ™å­˜å…¥çš„æ˜¯UnityPerFrame Bufferï¼Œå³æ¯ä¸€å¸§ VP çŸ©é˜µå¹¶ä¸ä¼šæ”¹å˜ã€‚Constant Buffer å¹¶ä¸æ˜¯æ‰€æœ‰å¹³å°éƒ½æ”¯æŒï¼Œç›®å‰ OpenGL å°±ä¸æ”¯æŒ\nä½¿ç”¨ cbuffer å…³é”®å­—æ¥å¼•å…¥ Constant Bufferï¼ŒConstant Buffer ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æ•°æ®\ncbuffer UnityPerFrame {    float4x4 unity_MatirxVP;};cbuffer UnityPerDraw {    float4x4 unity_ObjectToWorld;};cbuffer UnityPerMaterial {        }\n\nUnityPerMaterialæ‰€æœ‰æè´¨ç›¸å…³æ•°æ®éƒ½åº”è¯¥åœ¨åä¸º UnityPerMaterial çš„å•ä¸ª CBUFFER ä¸­å£°æ˜\n\nä»€ä¹ˆæ˜¯ ** Per Material**\né€šå¸¸æ˜¯åœ¨ç€è‰²å™¨å±æ€§éƒ¨åˆ†å£°æ˜çš„æ‰€æœ‰å˜é‡ï¼Œä¸èƒ½æŠŠè¿™äº›æ•°æ®æ¼å†™æˆ–è€…å†™é“åˆ«çš„ CBUFFER ä¸­\n\nUnityPerDrawè¯¥ CBUFFER åº”è¯¥åŒ…å«æ‰€æœ‰ Unity çš„å†…ç½®å¼•æ“å˜é‡ã€‚UnityPerDrawçš„ CBUFFER å†…éƒ¨å˜é‡å£°æ˜é¡ºåºä¹Ÿå¾ˆé‡è¦ï¼Œæ‰€æœ‰å˜é‡éƒ½åº”è¯¥éµé¡¼åä¸º Block Feature çš„å¸ƒå±€â€”â€”å¦‚æœä¸éœ€è¦ï¼Œåˆ™ä¸å¿…å£°æ˜éƒ¨åˆ†å—åŠŸèƒ½ã€‚UnityPerDrawä¸­çš„æ‰€æœ‰å†…ç½®å¼•æ“å˜é‡éƒ½åº”è¯¥ä¸º float4 æˆ–float4x4ç±»å‹\n\nåœ¨ç§»åŠ¨å¹³å°ä¸Šï¼Œå¼€å‘è€…å¯èƒ½æƒ³ä½¿ç”¨ real4 ç±»å‹ï¼Œä»¥èŠ‚çœéƒ¨åˆ† GPU å¸¦å®½ã€‚ä¸æ˜¯æ‰€æœ‰ UnityPerDraw å˜é‡éƒ½å¯ä»¥ä½¿ç”¨ real4 ç±»å‹\n\nSRP Batcher åŸç† SRP Batcher ä¼šåœ¨ä¸»å­˜ä¸­å°†æ¨¡å‹çš„åæ ‡ä¿¡æ¯ã€æè´¨ä¿¡æ¯ã€ä¸»å…‰é˜´å½±å‚æ•°ã€éä¸»å…‰é˜´å½±å‚æ•°åˆ†åˆ«ä¿å­˜æˆä¸åŒçš„CBUFFER ä¸­ï¼Œåªæœ‰ CBUFFEER äº§ç”Ÿå˜åŒ–æ‰ä¼šé‡æ–°æäº¤åˆ° GPU ä¸­ã€‚å¦‚ä¸‹å›¾æ‰€ç¤ºï¼Œå°†æ¨¡å‹ä¿¡æ¯ã€ä½ç½®ä¿¡æ¯ã€å˜æ¢ä¿¡æ¯ä¸æè´¨ä¿¡æ¯åˆ†å¼€ï¼Œæ¨¡å‹å¯èƒ½æ¯å¸§éƒ½ä¼šç§»åŠ¨åæ ‡ï¼Œä½†ä¸ä¼šæ¯å¸§éƒ½ä¿®æ”¹æè´¨å‚æ•°ä¿¡æ¯ï¼Œæè´¨ä¿¡æ¯æ¯æ¬¡å˜åŒ–åéƒ½é€šè¿‡ CBUFFER ä¼ åˆ° GPU ä¸­å¹¶ä¸”ä¿å­˜ï¼ˆåªè¦æ²¡æœ‰å˜åŒ–å°±ä¸éœ€è¦é‡æ–°æäº¤ï¼‰ï¼Œæœ€ç»ˆ Shader åœ¨æ˜¾å­˜ä¸­é€šè¿‡æ¯å¸§å˜åŒ–çš„åæ ‡ä¿¡æ¯å’Œä¸ä¸€å®šæ¯å¸§å˜åŒ–çš„æè´¨ä¿¡æ¯æ¸²æŸ“å‡ºæ¨¡å‹æ¥\n\n    \n\n\n\nCBUFFER_START(UnityPerDraw)ï¼šæ¯ä¸ªç‰©ä½“ç»˜åˆ¶å…±äº«çš„ CBUFFERï¼ŒåŒ…æ‹¬æ¨¡å‹æ§ä»¶è½¬ä¸–ç•Œç©ºé—´çŸ©é˜µã€ä¸–ç•Œç©ºé—´è½¬æ¨¡å‹ç©ºé—´çŸ©é˜µã€LOD å‚æ•°ã€ ä¸–ç•Œå˜æ¢å‚æ•°ã€ç¯å…‰å‚æ•°ã€ç¯å¢ƒè´´å›¾å‚æ•°ã€çƒ˜ç„™å‚æ•°ã€çƒè°å…‰ç…§ä¿¡æ¯\nCBUFFER_START(UnityPerMaterial)ï¼šåŒä¸€æè´¨åªèƒ½äº›ä¸€ä¸ª CBUFFER_START(UnityPerMaterial)ï¼Œå¦‚æœå†™å¤šä¸ªä¼šæŠ¥é”™ã€‚ç”±äºè¿™ä¸ªCBUFFER æ˜¯è‡ªå·±å†™çš„ï¼Œæ‰€ä»¥æ‰€ä»¥æ•°æ®çš„èµ‹å€¼åœ¨ Shader ä»£ç çš„å±æ€§æ¡†æ¶ä¸­ï¼Œåœ¨æè´¨é¢æ¿ä¸­å°±å¯ä»¥è®¾ç½®å‚æ•°äº†\næ¯ä¸ªæè´¨çš„å†…å®¹æŒä¹…åŒ–åœ¨ GPU çš„å†…å­˜ä¸Š\nä¸€ä¸ªä¸“ç”¨çš„ä»£ç è·¯å¾„æ¥ç®¡ç†ä¸€ä¸ªå¤§çš„â€œPer Objectâ€çš„CBUFFER\n\n\n\nç€è‰²å™¨æ ‡è¯† Shader.PropertyToIDè·å–ç€è‰²å™¨  å±æ€§åç§°  çš„å”¯ä¸€æ ‡è¯†ç¬¦ã€‚ä½¿ç”¨å±æ€§æ ‡è¯†ç¬¦æ¯”å°†å­—ç¬¦ä¸²ä¼ é€’åˆ°æ‰€æœ‰æè´¨å±æ€§å‡½æ•°æ›´æœ‰æ•ˆã€‚ä¾‹å¦‚ï¼Œå¦‚æœè¦å¤šæ¬¡è°ƒç”¨ Material.SetColor æˆ–è€…ä½¿ç”¨ MaterialPropertyBlockï¼Œåˆ™æœ€å¥½åªè·å–ä¸€æ¬¡æ‰€éœ€å±æ€§çš„æ ‡è¯†ç¬¦ã€‚åœ¨ Unity ä¸­ï¼Œç€è‰²å™¨å±æ€§çš„æ¯ä¸ªåç§°ï¼ˆä¾‹å¦‚ _MainTex æˆ– _Colorï¼‰å‡åˆ†é…æœ‰å”¯ä¸€ æ•´æ•°ï¼Œåœ¨æ•´ä¸ªæ¸¸æˆä¸­ï¼Œè¯¥æ•´æ•°å‡ä¿æŒç›¸åŒã€‚åœ¨æ¸¸æˆçš„ä¸åŒæ¬¡è¿è¡Œä¹‹é—´æˆ–åœ¨ä¸åŒæœºå™¨ä¹‹é—´ï¼Œè¿™äº›æ•°å­—ä¸åŒï¼Œå› æ­¤ä¸è¦å­˜å‚¨æˆ–é€šè¿‡ç½‘ç»œå‘é€è¿™äº›æ•°å­—\n","categories":["é¢è¯•"],"tags":["unity","é¢è¯•","2022"]},{"title":"Life of a triangle","url":"/2023/04/20/49/","content":"Life of a triangle\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","ç¿»è¯‘","GPU"]},{"title":"C++ çŸ¥è¯†","url":"/2021/11/08/5/","content":"C++ è™šå‡½æ•°C++ è™šå‡½æ•°æ˜¯å®šä¹‰åœ¨åŸºç±»ä¸­çš„å‡½æ•°ï¼Œå­ç±»å¿…é¡»å¯¹å…¶è¿›è¡Œè¦†ç›–ã€‚\nè™šå‡½æ•°çš„ä½œç”¨\nå®šä¹‰å­ç±»å¯¹è±¡ï¼Œå¹¶è°ƒç”¨å¯¹è±¡ä¸­æœªè¢«å­ç±»é‡å†™çš„åŸºç±»å‡½æ•° Aã€‚åŒæ—¶åœ¨è¯¥å‡½æ•°A ä¸­ï¼Œåˆè°ƒç”¨äº†å·²è¢«å­ç±»é‡å†™çš„åŸºç±»å‡½æ•°Bã€‚é‚£æ­¤æ—¶å°†ä¼šè°ƒç”¨åŸºç±»ä¸­çš„å‡½æ•°Bï¼Œå¯æˆ‘ä»¬æœ¬åº”è¯¥è°ƒç”¨çš„æ˜¯å­ç±»ä¸­çš„å‡½æ•°Bã€‚è™šå‡½æ•°å³èƒ½è§£å†³è¿™ä¸ªé—®é¢˜ã€‚#include&lt;iostream&gt;using namespace std;// åŸºç±» Fatherclass Father &#123;public:    void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;    // åœ¨å‡½æ•°ä¸­è°ƒç”¨äº†ï¼Œå­ç±»é‡å†™åŸºç±»çš„å‡½æ•° display()    void fatherShowDisplay() &#123;        display();    &#125;&#125;;// å­ç±» Sonclass Son:public Father &#123;public:    // é‡å†™åŸºç±»ä¸­çš„ display() å‡½æ•°    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Son son;                    // å­ç±»å¯¹è±¡    son.fatherShowDisplay();    // é€šè¿‡åŸºç±»ä¸­æœªè¢«é‡å†™çš„å‡½æ•°ï¼Œæƒ³è°ƒç”¨å­ç±»ä¸­é‡å†™çš„ display å‡½æ•°&#125;\n\n Father::display()ç”¨è™šå‡½æ•°ï¼š\n\n#include&lt;iostream&gt;using namespace std;// åŸºç±» Fatherclass Father &#123;public:    virtual void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;    // åœ¨å‡½æ•°ä¸­è°ƒç”¨äº†ï¼Œå­ç±»é‡å†™åŸºç±»çš„å‡½æ•° display()    void fatherShowDisplay() &#123;        display();    &#125;&#125;;// å­ç±» Sonclass Son:public Father &#123;public:    // é‡å†™åŸºç±»ä¸­çš„ display() å‡½æ•°    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Son son;                    // å­ç±»å¯¹è±¡    son.fatherShowDisplay();    // é€šè¿‡åŸºç±»ä¸­æœªè¢«è¦†ç›–çš„å‡½æ•°ï¼Œæƒ³è°ƒç”¨å­ç±»ä¸­é‡å†™çš„ display å‡½æ•°&#125;\n\n Son::display()\n\n\nåœ¨ä½¿ç”¨  æŒ‡å‘å­ç±»å¯¹è±¡çš„åŸºç±»æŒ‡é’ˆï¼Œå¹¶è°ƒç”¨å­ç±»ä¸­çš„é‡å†™å‡½æ•°  æ—¶ï¼Œå¦‚æœè¯¥å‡½æ•°ä¸æ˜¯è™šå‡½æ•°ï¼Œé‚£ä¹ˆå°†è°ƒç”¨åŸºç±»ä¸­çš„è¯¥å‡½æ•°ï¼›å¦‚æœè¯¥å‡½æ•°æ˜¯è™šå‡½æ•°ï¼Œåˆ™ä¼šè°ƒç”¨å­ç±»ä¸­çš„è¯¥å‡½æ•°ã€‚#include&lt;iostream&gt;using namespace std;// åŸºç±» Fatherclass Father &#123;public:    void display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;&#125;;// å­ç±» Sonclass Son:public Father &#123;public:    // é‡å†™åŸºç±»ä¸­çš„ display å‡½æ•°    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Father *fp;     // å®šä¹‰åŸºç±»æŒ‡é’ˆ    Son son;        // å­ç±»å¯¹è±¡    fp = &amp;son;        // ä½¿åŸºç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡    fp-&gt;display();  // é€šè¿‡åŸºç±»æŒ‡é’ˆæƒ³è°ƒç”¨å­ç±»ä¸­é‡å†™çš„ display å‡½æ•°&#125;\n\n Father::display()\n\n#include&lt;iostream&gt;using namespace std;// åŸºç±» Fatherclass Father &#123;public:    // å®šä¹‰äº†è™šå‡½æ•°    void virtual display() &#123;        cout&lt;&lt;&quot;Father::display()\\n&quot;;    &#125;&#125;;// å­ç±» Sonclass Son:public Father &#123;public:    // è¦†ç›–åŸºç±»ä¸­çš„ display å‡½æ•°    void display() &#123;        cout&lt;&lt;&quot;Son::display()\\n&quot;;    &#125;&#125;;int main() &#123;    Father *fp;     // å®šä¹‰åŸºç±»æŒ‡é’ˆ    Son son;        // å­ç±»å¯¹è±¡    fp = &amp;son;        // ä½¿åŸºç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡    fp-&gt;display();  // é€šè¿‡åŸºç±»æŒ‡é’ˆæƒ³è°ƒç”¨å­ç±»ä¸­è¦†ç›–çš„ display å‡½æ•°&#125;\n\n Son::display()\n\n\n\nâ€‹    \nè™šå‡½æ•°çš„åŸç†  è™šå‡½æ•°çš„æœ¬è´¨æ˜¯ä¸€ä¸ªç®€å•çš„  è™šå‡½æ•°è¡¨ ã€‚å½“ä¸€ä¸ªç±»å­˜åœ¨è™šå‡½æ•°æ—¶ï¼Œé€šè¿‡è¯¥ç±»åˆ›å»ºçš„å¯¹è±¡å®ä¾‹ï¼Œä¼šåœ¨å†…å­˜ç©ºé—´çš„å‰ 4 ä¸ªå­—èŠ‚ä¿å­˜ä¸€ä¸ªæŒ‡å‘è™šå‡½æ•°è¡¨çš„æŒ‡é’ˆ__vfptrã€‚__vfptr æŒ‡å‘çš„è™šå‡½æ•°è¡¨æ˜¯ç±»ç‹¬æœ‰çš„ï¼Œè€Œä¸”è¯¥ç±»çš„æ‰€æœ‰å¯¹è±¡å…±äº«ã€‚è™šå‡½æ•°è¡¨çš„å®è´¨æ˜¯ä¸€ä¸ªè™šå‡½æ•°åœ°å€çš„æ•°ç»„ï¼Œå®ƒåŒ…å«äº†ç±»ä¸­æ¯ä¸ªè™šå‡½æ•°çš„åœ°å€ï¼Œæ—¢æœ‰å½“å‰ç±»å®šä¹‰çš„è™šå‡½æ•°ï¼Œä¹Ÿæœ‰é‡å†™çˆ¶ç±»çš„è™šå‡½æ•°ï¼Œä¹Ÿæœ‰ç»§æ‰¿è€Œæ¥çš„è™šå‡½æ•°ã€‚å½“å­ç±»é‡å†™äº†çˆ¶ç±»çš„è™šå‡½æ•°æ—¶ï¼Œå­ç±»è™šå‡½æ•°è¡¨å°†åŒ…å«å­ç±»è™šå‡½æ•°çš„åœ°å€ï¼Œè€Œä¸ä¼šæœ‰çˆ¶ç±»è™šå‡½æ•°çš„åœ°å€ã€‚åŒæ—¶ï¼Œå½“ç”¨åŸºç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡æ—¶ï¼ŒåŸºç±»æŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ç©ºé—´ä¸­çš„ __vfptr ä¾æ—§æŒ‡å‘äº†å­ç±»çš„è™šå‡½æ•°è¡¨ã€‚æ‰€ä»¥ï¼ŒåŸºç±»æŒ‡é’ˆä¾æ—§ä¼šè°ƒç”¨å­ç±»çš„è™šå‡½æ•°ã€‚\nå®šä¹‰ä¸€ä¸ªæœ‰è™šå‡½æ•°çš„ç±»class Base1 &#123;public:    int base1_1;    int base1_2;        virtual void base1_func1() &#123;&#125;    virtual void base1_func2() &#123;&#125;&#125;;\nå®šä¹‰ä¸¤ä¸ªå¯¹è±¡ï¼š\nBase1 b1;Base1 b2;\nä¸¤ä¸ªå¯¹è±¡çš„å†…å­˜ç©ºé—´åˆ†é…å¦‚ä¸‹ï¼š\nå®šä¹‰ä¸€ä¸ªå­ç±»class Base1 &#123;public:    int base1_1;    int base1_2;    virtual void base1_fun1() &#123;&#125;    virtual void base1_fun2() &#123;&#125;    &#125;;class Derive1 : public Base1 &#123;public:    int derive1_1;    int derive1_2;    // è¦†ç›–åŸºç±»å‡½æ•°    virtual void base1_fun1() &#123;&#125;&#125;;\nå®šä¹‰ä¸€ä¸ªå­ç±»å¯¹è±¡ï¼š\nDerive1 d1;\nå…¶å†…å­˜ç©ºé—´å¦‚ä¸‹ï¼š\nc++ ä¸­çš„çº¯è™šå‡½æ•°  çº¯è™šå‡½æ•°æ˜¯åœ¨åŸºç±»ä¸­å£°æ˜çš„è™šå‡½æ•°ï¼Œå®ƒåœ¨åŸºç±»ä¸­æ²¡æœ‰å®šä¹‰ï¼Œä½†è¦æ±‚ä»»ä½•æ´¾ç”Ÿç±»éƒ½è¦å®šä¹‰è‡ªå·±çš„å®ç°æ–¹æ³•ã€‚åœ¨åŸºç±»ä¸­å®ç°çº¯è™šå‡½æ•°çš„æ–¹æ³•æ˜¯åœ¨å‡½æ•°åŸå‹ååŠ =0\nclass A&#123;public:    virtual void foo() = 0;&#125;;\n\nåœ¨å¾ˆå¤šæƒ…å†µä¸‹ï¼ŒåŸºç±»æœ¬èº«ç”Ÿæˆå¯¹è±¡æ˜¯ä¸åˆæƒ…ç†çš„ã€‚ä¾‹å¦‚ï¼ŒåŠ¨ç‰©ä½œä¸ºä¸€ä¸ªåŸºç±»å¯ä»¥æ´¾ç”Ÿå‡ºè€è™ã€å­”é›€ç­‰å­ç±»ï¼Œä½†åŠ¨ç‰©æœ¬èº«ç”Ÿæˆå¯¹è±¡æ˜æ˜¾ä¸åˆå¸¸ç†ã€‚è€Œé’ˆå¯¹æ¯ç§åŠ¨ç‰©çš„æ–¹æ³•åˆæœ‰æ‰€ä¸åŒï¼Œæ­¤æ—¶éœ€è¦ä½¿ç”¨å¤šæ€ç‰¹æ€§ï¼Œä¹Ÿå°±éœ€è¦åœ¨åŸºç±»ä¸­å®šä¹‰è™šå‡½æ•°ã€‚\nçº¯è™šå‡½æ•°æ˜¯åœ¨åŸºç±»ä¸­å£°æ˜çš„è™šå‡½æ•°ï¼Œå®ƒè¦æ±‚ä»»ä½•æ´¾ç”Ÿç±»éƒ½è¦å®šä¹‰è‡ªå·±çš„å®ç°æ–¹æ³•ï¼Œä»¥å®ç°å¤šæ€æ€§ã€‚å®ç°äº†çº¯è™šå‡½æ•°çš„å­ç±»ï¼Œè¯¥çº¯è™šå‡½æ•°åœ¨å­ç±»ä¸­å°±å˜æˆäº†è™šå‡½æ•°ã€‚\nå®šä¹‰çº¯è™šå‡½æ•°æ˜¯ä¸ºäº†å®ç°ä¸€ä¸ªæ¥å£ï¼Œç”¨æ¥è§„èŒƒæ´¾ç”Ÿç±»çš„è¡Œä¸ºï¼Œä¹Ÿå³è§„èŒƒç»§æ‰¿è¿™ä¸ªç±»çš„ç¨‹åºå‘˜å¿…é¡»å®ç°è¿™ä¸ªå‡½æ•°ã€‚æ´¾ç”Ÿç±»ä»…ä»…åªæ˜¯ç»§æ‰¿å‡½æ•°çš„æ¥å£ã€‚çº¯è™šå‡½æ•°çš„æ„ä¹‰åœ¨äºï¼Œè®©æ‰€æœ‰çš„ç±»å¯¹è±¡ï¼ˆä¸»è¦æ˜¯æ´¾ç”Ÿç±»å¯¹è±¡ï¼‰éƒ½å¯ä»¥æ‰§è¡Œçº¯è™šå‡½æ•°çš„åŠ¨ä½œï¼Œä½†åŸºç±»æ— æ³•ä¸ºçº¯è™šå‡½æ•°æä¾›ä¸€ä¸ªåˆç†çš„ç¼ºçœå®ç°ã€‚æ‰€ä»¥ç±»çº¯è™šå‡½æ•°çš„å£°æ˜å°±æ˜¯åœ¨å‘Šè¯‰å­ç±»çš„è®¾è®¡è€…ï¼Œâ€œä½ å¿…é¡»æä¾›ä¸€ä¸ªçº¯è™šå‡½æ•°çš„å®ç°ï¼Œä½†æˆ‘ä¸çŸ¥é“ä½ ä¼šæ€æ ·å®ç°å®ƒâ€ã€‚\nå«æœ‰çº¯è™šå‡½æ•°çš„ç±»ç§°ä¹‹ä¸ºæŠ½è±¡ç±»ï¼Œå®ƒä¸èƒ½ç”Ÿæˆå¯¹è±¡ï¼ˆåˆ›å»ºå®ä¾‹ï¼‰ï¼Œåªèƒ½åˆ›å»ºå®ƒçš„æ´¾ç”Ÿç±»çš„å®ä¾‹ã€‚æŠ½è±¡ç±»æ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»ï¼Œå®ƒæ˜¯ä¸ºäº†æŠ½è±¡å’Œè®¾è®¡çš„ç›®çš„ä¸ºå»ºç«‹çš„ï¼Œå®ƒå¤„äºç»§æ‰¿å±‚æ¬¡ç»“æ„çš„è¾ƒä¸Šå±‚ã€‚æŠ½è±¡ç±»çš„ä¸»è¦ä½œç”¨æ˜¯å°†æœ‰å…³çš„æ“ä½œä½œä¸ºç»“æœæ¥å£ç»„ç»‡åœ¨ä¸€ä¸ªç»§æ‰¿å±‚æ¬¡ç»“æ„ä¸­ï¼Œç”±å®ƒæ¥ä¸ºæ´¾ç”Ÿç±»æä¾›ä¸€ä¸ªå…¬å…±çš„æ ¹ï¼Œæ´¾ç”Ÿç±»å°†å…·ä½“å®ç°åœ¨å…¶åŸºç±»ä¸­ä½œä¸ºæ¥å£çš„æ“ä½œã€‚\næŠ½è±¡ç±»åªèƒ½ä½œä¸ºåŸºç±»æ¥ä½¿ç”¨ï¼Œå…¶çº¯è™šå‡½æ•°çš„å®ç°ç”±æ´¾ç”Ÿç±»ç»™å‡ºã€‚å¦‚æœæ´¾ç”Ÿç±»ä¸­æ²¡æœ‰é‡æ–°å®šä¹‰çº¯è™šå‡½æ•°ï¼Œè€Œåªæ˜¯ç»§æ‰¿åŸºç±»çš„çº¯è™šå‡½æ•°ï¼Œåˆ™è¿™ä¸ªæ´¾ç”Ÿç±»ä»ç„¶è¿˜æ˜¯ä¸€ä¸ªæŠ½è±¡ç±»ã€‚å¦‚æœæ´¾ç”Ÿç±»ä¸­ç»™å‡ºäº†åŸºç±»çº¯è™šå‡½æ•°çš„å®ç°ï¼Œåˆ™è¯¥æ´¾ç”Ÿç±»å°±ä¸å†æ˜¯æŠ½è±¡ç±»äº†ï¼Œå®ƒæ˜¯ä¸€ä¸ªå¯ä»¥å»ºç«‹å¯¹è±¡çš„å…·ä½“çš„ç±»ã€‚\nè™šææ„å‡½æ•°  ä¸»è¦åŠŸèƒ½å°±æ˜¯ç¡®ä¿ç»§æ‰¿ä½“ç³»ä¸­çš„å¯¹è±¡æ­£ç¡®é‡Šæ”¾ã€‚\nclass Base&#123;public:    virtual ~Base()&#123;&#125;&#125;;class Derived :public Base&#123;public:    Derived() &#123;        pointer = new int[10];    &#125;    ~Derived() &#123;        delete []pointer;    &#125;    int *pointer;&#125;;void main()&#123;    Derived *d = new Derived();    Base *b = d;    delete b;&#125;\nå¦‚æœæ²¡æœ‰è™šææ„å‡½æ•°ï¼Œåˆ™åªä¼šè°ƒç”¨åŸºç±»çš„ææ„å‡½æ•°ï¼Œé‚£ä¹ˆæ´¾ç”Ÿç±»ä¸­åˆ†é…çš„å†…å­˜å°±æ²¡åŠæ³•é‡Šæ”¾ï¼Œé€ æˆæ³„éœ²ã€‚æ‰€ä»¥ï¼Œå¦‚æœå‘ç”Ÿç»§æ‰¿ï¼Œä¸€å®šè¦æŠŠåŸºç±»ææ„å‡½æ•°å®šä¹‰ä¸ºè™šå‡½æ•°ã€‚\nC++ ä¸­å‡½æ•°é‡è½½ã€é‡å†™å’Œé‡å®šä¹‰\né‡è½½ï¼ˆoverloadï¼‰ï¼šå‡½æ•°åç›¸åŒï¼Œå‚æ•°åˆ—è¡¨ä¸åŒï¼Œé‡è½½åªå­˜åœ¨ç±»çš„å†…éƒ¨\n\né‡å†™ï¼ˆoverrideï¼‰ï¼šå­ç±»é‡æ–°å®šä¹‰çˆ¶ç±»ä¸­æœ‰ç›¸åŒåç§°å’Œå‚æ•°çš„è™šå‡½æ•°ï¼Œå­˜åœ¨äºç»§æ‰¿å…³ç³»ä¹‹é—´\n\nè¢«é‡å†™çš„å‡½æ•°ä¸èƒ½æ˜¯ static çš„ï¼Œå¿…é¡»æ˜¯ virtual çš„\né‡å†™å‡½æ•°å¿…é¡»æœ‰ç›¸åŒçš„è¿”å›å€¼ç±»å‹ã€åç§°å’Œå‚æ•°åˆ—è¡¨\né‡å†™å‡½æ•°çš„è®¿é—®ä¿®é¥°ç¬¦å¯ä»¥ä¸åŒ\n\n\né‡å®šä¹‰ï¼ˆredefiningï¼‰ï¼šå­ç±»é‡æ–°å®šä¹‰çˆ¶ç±»æœ‰ç›¸åŒåç§°çš„éè™šå‡½æ•°\n\n\nç¼–è¯‘å™¨å¦‚ä½•è§£å†³å‘½åå†²çª\nç¼–è¯‘åï¼Œé‡è½½çš„å‡½æ•°åå„ä¸ç›¸åŒã€‚å˜åçš„æœºåˆ¶ï¼šä½œç”¨åŸŸ + è¿”å›ç±»å‹ + å‡½æ•°å + å‚æ•°åˆ—è¡¨ï¼Œæ¥è§£å†³å‘½åå†²çªçš„é—®é¢˜\næ™ºèƒ½æŒ‡é’ˆ shared_ptrã€weak_ptrã€unique_ptrshared_ptr åªæœ‰æŒ‡å‘åŠ¨æ€åˆ†é…çš„å¯¹è±¡çš„æŒ‡é’ˆæ‰èƒ½äº¤ç»™ shared_ptr å¯¹è±¡æ‰˜ç®¡ã€‚\nä¸èƒ½ç”¨ä¸‹é¢çš„æ–¹å¼ä½¿å¾—ä¸¤ä¸ª shared_ptr å¯¹è±¡æ‰˜ç®¡åŒä¸€ä¸ªæŒ‡é’ˆï¼š\nA* p = new A(10);shared_ptr&lt;A&gt; sp1(p), sp2(p);\nsp1å’Œ sp2 å¹¶ä¸ä¼šå…±äº«åŒä¸€ä¸ª p çš„æ‰˜ç®¡æŠ€æœ¯ï¼Œè€Œæ˜¯å„è‡ªå°†å¯¹ p çš„çš„æ‰˜ç®¡è®¡æ•°éƒ½è®°ä¸º 1ã€‚è¿™æ ·ï¼Œå½“ sp1 æ¶ˆäº¡æ—¶è¦ææ„ pï¼Œsp2 æ¶ˆäº¡æ—¶è¦å†æ¬¡ææ„pï¼Œè¿™ä¼šå¯¼è‡´ç¨‹åºå´©æºƒã€‚\nweak_ptrweak_ptræ˜¯ä¸€ç§ç”¨äºè§£å†³ shared_ptr ç›¸äº’å¼•ç”¨æ—¶äº§ç”Ÿæ­»é”é—®é¢˜çš„æ™ºèƒ½æŒ‡é’ˆã€‚weak_ptræ—¶å¯¹å¯¹è±¡çš„ä¸€ç§å¼±å¼•ç”¨ï¼Œå®ƒä¸ä¼šå¢åŠ å¯¹è±¡çš„å¼•ç”¨è®¡æ•°ï¼Œweak_ptrå’Œ shared_ptr å¯ä»¥ç›¸äº’è½¬åŒ–ï¼Œshared_ptrå¯ä»¥ç›´æ¥èµ‹å€¼ç»™ weak_ptrï¼Œweak_ptr ä¹Ÿå¯ä»¥é€šè¿‡ lock å‡½æ•°æ¥è·å¾—shared_ptrã€‚\n\nweak_ptræŒ‡é’ˆé€šå¸¸ä¸å•ç‹¬ä½¿ç”¨ï¼Œåªèƒ½å’Œ shared_ptr ç±»å‹æŒ‡é’ˆæ­é…ä½¿ç”¨ã€‚å°†ä¸€ä¸ª weak_ptr ç»‘å®šåˆ°ä¸€ä¸ª shared_ptr ä¸ä¼šæ”¹å˜ shared_ptr çš„å¼•ç”¨è®¡æ•°ã€‚ä¸€æ—¦æœ€åä¸€ä¸ªæŒ‡å‘å¯¹è±¡çš„ shared_ptr è¢«é”€æ¯ï¼Œå¯¹è±¡å°±ä¼šè¢«é‡Šæ”¾ã€‚å³ä½¿æœ‰ weak_ptr æŒ‡å‘å¯¹è±¡ï¼Œå¯¹è±¡ä¹Ÿè¿˜æ˜¯ä¼šè¢«é‡Šæ”¾ã€‚\nweak_ptrå¹¶æ²¡æœ‰é‡è½½ operator -&gt; å’Œoperator *æ“ä½œç¬¦ï¼Œå› æ­¤ä¸å¯ç›´æ¥é€šè¿‡ weak_ptr ä½¿ç”¨å¯¹è±¡ï¼Œå…¸å‹çš„ç”¨æ³•æ—¶è°ƒç”¨å…¶ lock å‡½æ•°æ¥è·å¾— shared_ptr å®ä¾‹ï¼Œè¿›è€Œè®¿é—®åŸå§‹å¯¹è±¡ã€‚\n\nunique_ptrunique_ptræ˜¯ä¸€ä¸ªç‹¬äº«æ‰€æœ‰æƒçš„æ™ºèƒ½æŒ‡é’ˆï¼Œunique_ptrå¯¹è±¡åŒ…è£…ä¸€ä¸ªåŸå§‹æŒ‡é’ˆï¼Œå¹¶è´Ÿè´£å…¶ç”Ÿå‘½å‘¨æœŸã€‚å½“è¯¥å¯¹è±¡è¢«é”€æ¯æ—¶ï¼Œä¼šåœ¨å…¶ææ„å‡½æ•°ä¸­åˆ é™¤å…³è”çš„åŸå§‹æŒ‡é’ˆã€‚unique_ptré‡è½½äº† -&gt; å’Œ*è¿ç®—ç¬¦ï¼Œå› æ­¤å¯ä»¥åƒå…¶ä»–æ™®é€šæŒ‡é’ˆä¸€æ ·ä½¿ç”¨ã€‚\nå¼•ç”¨è®¡æ•°æ˜¯åœ¨å¯¹ä¸Šè¿˜æ˜¯æ ˆä¸Š  å¤šä¸ª shared_ptr æˆ–weak_ptrå¯ä»¥æŒ‡å‘åŒä¸€ä¸ªè¢«å¼•ç”¨è®¡æ•°çš„å¯¹è±¡ã€‚è€Œå…¶ä¸­ä¸€ä¸ªæˆ–å‡ ä¸ªç¦»å¼€ä½œç”¨åŸŸè¢«ææ„ï¼Œå¼ºå¼•ç”¨è®¡æ•°æœªå½’ 0ï¼ŒæŒ‡å‘çš„å¯¹è±¡ä¸èƒ½é‡Šæ”¾ã€‚å› æ­¤ä¸èƒ½æ”¾åˆ°æ ˆä¸Šã€‚\n","categories":["C++"],"tags":["c++"]},{"title":"Lua è§£é‡Šå™¨æ„å»ºï¼šä»è™šæ‹Ÿæœºåˆ°ç¼–è¯‘å™¨","url":"/2023/04/03/48/","content":"å¢é‡å¼æ ‡è®°æ¸…é™¤ç®—æ³•  æ•´ä¸ª GC æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œå¤§è‡´ç»å†ä»¥ä¸‹å‡ ä¸ªé˜¶æ®µ\n\npause é˜¶æ®µ\nmainthread å’Œ global table åŒ…å« GC èµ·å§‹ç‚¹ï¼Œå› æ­¤è¦å°†å®ƒä»¬æ’å…¥åˆ° gray é“¾è¡¨ä¸­ï¼Œå¹¶å°†å®ƒä»¬æ ‡è®°ä¸ºç°è‰²ï¼Œè¿›å…¥åˆ° propagate é˜¶æ®µ\n\npropagate é˜¶æ®µ\n\nä¸æ–­ä» gray é“¾è¡¨ä¸­å–å‡ºå¯¹è±¡ï¼Œç„¶åæŠŠå®ƒä»ç°è‰²å˜ä¸ºé»‘è‰²ï¼Œå†éå†å®ƒæ‰€å¼•ç”¨çš„å¯¹è±¡ï¼Œå¹¶å°†å…¶æ’å…¥åˆ° gray é“¾è¡¨ä¸­\npropagate é˜¶æ®µç´¯ç§¯éå†çš„å¯¹è±¡å¤§å°è¶…è¿‡ä¸€å®šçš„å­—èŠ‚æ•°ï¼Œæœ¬è½® GC ä¼šè¢«ç»ˆæ­¢ï¼Œç­‰å¾…ä¸‹ä¸€æ¬¡ GC æ­¥éª¤å¼€å§‹åç»§ç»­æ‰«æ gray é“¾è¡¨ä¸­çš„å¯¹è±¡\nå½“ gray é“¾è¡¨ä¸ºç©ºæ—¶ï¼Œè¿›å…¥ atomic é˜¶æ®µ\n\n\natomic é˜¶æ®µ\n\nGC æ­¥éª¤åœ¨ pause é˜¶æ®µæ˜¯å¯ä»¥è¢«ä¸­æ–­çš„ï¼Œå‡å¦‚æ–°å»ºçš„å¯¹è±¡è¢«æ ‡è®°ä¸ºé»‘è‰²çš„å¯¹è±¡å¼•ç”¨ï¼Œæœ¬è½® GC å°±ä¸ä¼šå¯¹å…¶è¿›è¡Œéå†å’Œæ ‡è®°ï¼Œåˆ° sweep é˜¶æ®µå°±ä¼šè¢«å½“ä½œä¸å¯è¾¾çš„å¯¹è±¡è€Œæ¸…é™¤æ‰\néœ€è¦ä¸ºæ–°å»ºå¯¹è±¡è®¾ç½®å±éšœï¼ˆbarrierï¼‰\nå‘å‰è®¾ç½®å±éšœï¼šç›´æ¥å°†æ–°åˆ›å»ºçš„å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼Œæ”¾å…¥åˆ° gray é“¾è¡¨ä¸­\nå‘åè®¾ç½®å±éšœï¼šå°†é»‘è‰²å¯¹è±¡æ ‡è®°ä¸ºç°è‰²ï¼Œ grayagain é“¾è¡¨ä¸­\n\n\nåŸå­æ‰§è¡Œ atomic é˜¶æ®µ\n\n\nsweep é˜¶æ®µ\nä» allgc é“¾è¡¨ä¸­å»é™¤è‹¥å¹²ä¸ªå¯¹è±¡ï¼›å¦‚æœå·²ç»æ˜¯æœ¬è½® GC è¦è¢«æ¸…é™¤çš„  ç™½è‰² ï¼Œé‚£ä¹ˆå®ƒä¼šè¢«æ¸…é™¤ï¼›å¦‚æœä¸æ˜¯ï¼Œåˆ™æ ‡è®°ä¸º å¦ä¸€ç§ç™½ï¼Œä»¥ä¾›ä¸‹ä¸€è½® GC ä½¿ç”¨\n\n\nLua è™šæ‹Ÿæœºçš„å­—ç¬¦ä¸²\nä» Lua-5.2.1 å¼€å§‹ï¼Œå­—ç¬¦ä¸²å°±åˆ†ä¸ºé•¿å­—ç¬¦ä¸²åˆçŸ­å­—ç¬¦ä¸²ã€‚å…¶ä¸­çŸ­å­—ç¬¦ä¸²ä¼šè¿›è¡Œå……åˆ†çš„å“ˆå¸Œè¿ç®—ï¼Œå¹¶è¿›è¡Œå†…éƒ¨ä¼˜åŒ–å¤„ç†ï¼›é•¿å­—ç¬¦ä¸²ä¸ä¼šè¿›è¡Œå“ˆå¸Œè¿ç®—å’Œå†…éƒ¨åŒ–\nå­—ç¬¦ä¸²å†…éƒ¨åŒ–çš„æœ¬è´¨å°±æ˜¯ä¸ºæ¯ä¸ªå­—ç¬¦ä¸²åˆ›å»ºå”¯ä¸€çš„å®ä¾‹\nåœ¨ Lua ä¸­ï¼Œå­—ç¬¦ä¸² Body é•¿åº¦å°äºæˆ–ç­‰äº 40B çš„æ˜¯çŸ­å­—ç¬¦ä¸²ï¼Œå¤§äº 40B çš„æ˜¯é•¿å­—ç¬¦ä¸²ï¼›åœ¨ Lua-5.3 ä¸­ï¼ŒçŸ­å­—ç¬¦ä¸²çš„å¤§å°é™åˆ¶ç”± LUAI_MAXSHORTLEN å†³å®šï¼Œè¿™ä¸ªå®å®šä¹‰åœ¨ llimits.h ä¸­å®šä¹‰\n\nLua è™šæ‹Ÿæœºçš„è¡¨Lua è¡¨çš„åŸºæœ¬æ•°æ®ç»“æ„// luaobject.htypedef union lua_Value &#123;    struct GCObject* gc;    void* p;    int b;    lua_Interger i;    lua_Number n;    lua_CFunction f;&#125; Value;typedef struct lua_TValue &#123;    Value value_;    int tt_;&#125; TValue;// lua Tabletypedef union TKey &#123;    struct &#123;        Value value_;        int tt; // ç”¨æ¥æ ‡è®° value_æ˜¯ä»€ä¹ˆç±»å‹        int next;    &#125; nk;    TValue tvk;&#125; TKey;typedef struct Node &#123;    TKey key;    TValue value;&#125; Node;struct Table &#123;    CommonHeader;               // GC éƒ¨åˆ†    TValue* array;              // æ•°ç»„éƒ¨åˆ†    unsigned int arraysize;     // æ•°ç»„å¤§å°    Node* node;                 // hash éƒ¨åˆ†    unsigned int lsizenode;     // hash å¤§å°ï¼Œå®é™…å¤§å°ä¸º 2&lt;sup&gt;lsizenode    Node* lastfree;             // ç©ºé—²æŒ‡é’ˆ    struct GCObject* gclist;    // GC éƒ¨åˆ†&#125;\n\né”®å€¼çš„å“ˆå¸Œè¿ç®— Node ç»“æ„çš„ key å¯ä»¥æ˜¯ä»»æ„ Lua ç±»å‹ã€‚keyå€¼æ˜¯å¦‚ä½•å’Œå“ˆå¸Œè¡¨çš„ç´¢å¼•å¯¹åº”èµ·æ¥\n\nå¯¹ key è¿›è¡Œå“ˆå¸Œè¿ç®—\næ ¹æ®å¾—åˆ°çš„å“ˆå¸Œå€¼ï¼Œæ¢ç®—æˆè¡¨ç»“æ„ node æ•°ç»„çš„ç´¢å¼•å€¼\nindex = hash_value &amp; (2^lsizenode - 1)\n\n\næŸ¥æ‰¾å…ƒç´ \nè¢«æŸ¥æ‰¾çš„å…ƒç´  key æ˜¯ int ç±»å‹ï¼š\nkey åœ¨æ•°ç»„èŒƒå›´ä¹‹å†…ï¼ˆåœ¨ array ä¸­æŸ¥æ‰¾ï¼‰ï¼Œè¿”å›array[k - 1]\nkey ä¸åœ¨æ•°ç»„èŒƒå›´ä¹‹å†…ï¼Œè®¡ç®—å“ˆå¸Œå€¼ï¼ˆåœ¨ node é“¾è¡¨ä¸­æŸ¥æ‰¾ï¼‰\n\n\nè¢«æŸ¥æ‰¾çš„å…ƒç´  key ä¸æ˜¯ int ç±»å‹ï¼škey ä¸åœ¨æ•°ç»„èŒƒå›´ä¹‹å†…ï¼Œè®¡ç®—å“ˆå¸Œå€¼ï¼ˆåœ¨ node é“¾è¡¨ä¸­æŸ¥æ‰¾ï¼‰\n\n\n\nè°ƒæ•´è¡¨çš„å¤§å°\nnums[i]çš„å«ä¹‰ï¼šç»Ÿè®¡ $(2^{i - 1}, 2^i]$ åŒºé—´å†…ï¼Œæ‰€æœ‰æ•°ç»„ç´¢å¼•å€¼ã€å“ˆå¸Œè¡¨keyï¼ˆç±»å‹ä¸ºintï¼‰çš„å“ˆå¸Œå€¼ä½äºè¿™ä¸ªåŒºé—´çš„å…ƒç´ æ€»æ•°n\n\nåˆ¤æ–­æ–°æ’å…¥çš„å…ƒç´ çš„ key å€¼æ˜¯å¦ä¸ºæ•´æ•°ç±»å‹ï¼Œå¦‚æœæ˜¯åˆ™å¯¹åº”åŒºé—´æ€»æ•°å¢åŠ  1ï¼šnums[i]++\n\nå®Œæˆ nums çš„ç»Ÿè®¡åï¼Œæ ¹æ® nums è®¡ç®—æ–°çš„æ•°ç»„å¤§å°ã€‚åœ¨æ•°ç»„å¤§å°èŒƒå›´å†…ï¼Œå€¼ä¸ä¸º nil çš„å…ƒç´ è¦è¶…è¿‡æ•°ç»„å¤§å°çš„ä¸€åŠï¼š\n  int i = 0;int asize = 0;for (; i &lt; 32; i++) &#123;    asize += nums[i];    if (asize &gt; pow(2, i) / 2) &#123;        arraysize = pow(2, i)    &#125;&#125;\nè®¡ç®—åœ¨æ•°ç»„å¤§å°èŒƒå›´å†…æœ‰æ•ˆå…ƒç´ çš„ä¸ªæ•°ï¼Œè®°ä¸ºarray_used_num\n\nå½“æ•°ç»„æ¯”åŸæ¥å¤§æ—¶ï¼Œæ‰©å±•  åŸæ¥çš„æ•°ç»„åˆ°æ–°çš„å¤§å°ï¼Œå¹¶å°†å“ˆå¸Œè¡¨ä¸­ key å€¼å°äºç­‰äº arraysizeï¼Œä¸”å¤§äº 0 çš„å…ƒç´ è½¬ç§»åˆ°æ•°ç»„ä¸­ï¼Œå¹¶å°†å“ˆå¸Œè¡¨å¤§å°è°ƒæ•´ä¸º $\\lceil \\log_2^{total - array_used_num} \\rceil$ï¼ŒåŒæ—¶å¯¹æ¯ä¸ªnode é‡æ–°å®šä½\n\nå½“æ•°ç»„æ¯”åŸæ¥å°æ—¶ï¼Œç¼©å°  åŸæ¥çš„æ•°ç»„åˆ°æ–°çš„å¤§å°ï¼Œå¹¶å°†æ•°ç»„ä¸­ key å€¼è¶…è¿‡æ•°ç»„å¤§å°çš„å…ƒç´ è½¬ç§»åˆ°å“ˆå¸Œè¡¨ä¸­ï¼Œå¹¶å°†å“ˆå¸Œè¡¨å¤§å°è°ƒæ•´ä¸º $\\lceil \\log_2^{total - array_used_num} \\rceil$ï¼ŒåŒæ—¶å¯¹æ¯ä¸ª node é‡æ–°å®šä½\n\n\nLua ä¸­çš„ä¸‰ç§å‡½æ•°ç±»åˆ« Light C Function å¯ä»¥ç†è§£ä¸ºæ™®é€šçš„ C å‡½æ•°ï¼Œå¦‚\nstatic int test_main(struct lua_State* L)&#123;    int arg1 = (int)luaL_tointeger(L, 1);    int arg2 = (int)luaL_tointeger(L, 2);    printf(&quot;test main arg1:%d arg2%d \\n&quot;, arg1, arg2);    lua_pushinteger(L, arg1 + arg2);    return 1;&#125;\n\nè¦åœ¨ Lua è™šæ‹Ÿæœºä¸­è¿è¡Œ test_main å‡½æ•°ï¼Œéœ€è¦è°ƒç”¨lua_pcallï¼Œå…¶å£°æ˜å¦‚ä¸‹\n// L è¡¨ç¤º Lua çº¿ç¨‹// narg è¡¨ç¤ºåœ¨ Lua çº¿ç¨‹é‡Œæ‰§è¡Œçš„å‡½æ•°æœ‰å¤šå°‘ä¸ªå‚æ•°// nresult è¡¨ç¤ºåœ¨ Lua çº¿ç¨‹é‡Œæ‰§è¡Œçš„å‡½æ•°æœ‰å¤šå°‘ä¸ªè¿”å›å€¼int lua_pcall(struct lau_State* L, int narg, int nresult);\n\nC é—­åŒ…#define ClosureHeader \\   CommonHeader; lu_byte nupvalues; GCObject* gclisttypedef struct CClosure &#123;    ClosureHeader;    lua_Function f;    TValue upvalue[1]; // upvalue åˆ—è¡¨&#125; CClosure;\n\nä¸€ä¸ª C é—­åŒ…å’Œ Light C Function å‡½æ•°ç›¸æ¯”ï¼Œé™¤äº†å— GC æ‰˜ç®¡å¹¶ä¸”æ‹¥æœ‰ä¸Šå€¼åˆ—è¡¨å¤–ï¼Œå…¶ä»–åŠŸèƒ½å’Œ Light C Function å‡½æ•°å·®ä¸å¤š\nLua é—­åŒ… Lua é—­åŒ…æ˜¯å— Lua è™šæ‹Ÿæœºçš„ GC æ‰˜ç®¡çš„ï¼ŒLua è„šæœ¬ä»£ç ç»è¿‡ç¼–è¯‘ç”Ÿæˆçš„è™šæ‹ŸæŒ‡ä»¤ï¼Œä»¥åŠå…¶ä»–ä¸€äº›ç¼–è¯‘ç›¸å…³çš„ä¿¡æ¯ä¼šå­˜æ”¾åœ¨ LClosure ä¸­çš„Proto ç±»å‹å˜é‡ä¸­\ntypedef struct LClosure &#123;    ClosureHeader;    struct Proto* p;    UpVal* upvals[1];&#125; LClosure;\n\nProtoç»“æ„// common/luaobject.htypedef struct Proto &#123;    CommonHeader;    int is_vararg;          // æ ‡è®° Lua å‡½æ•°å‚æ•°åˆ—è¡¨æ˜¯å¦ä¸ºå¯å˜å‚ï¼Œ0 è¡¨ç¤ºå¦ï¼Œ1 è¡¨ç¤ºæ˜¯    int nparam;             // å½“ is_varrag ä¸º 0 æ—¶ç”Ÿæ•ˆï¼Œå®ƒè¡¨ç¤ºè¯¥å‡½æ•°å‚æ•°çš„æ•°é‡    Instruction* code;      // Lua å‡½æ•°ç»è¿‡ç¼–è¯‘åï¼Œç”Ÿæˆçš„è™šæ‹ŸæœºæŒ‡ä»¤åˆ—è¡¨    int sizecode;           // æŒ‡æ˜ code åˆ—è¡¨çš„å¤§å°    TValue* k               // å¸¸é‡åˆ—è¡¨ï¼Œå¦‚æ•°å€¼ã€å­—ç¬¦ä¸²ç­‰    int sizek;              // å¸¸é‡åˆ—è¡¨å¤§å°    LocVar* localvars;      // local å˜é‡åˆ—è¡¨    int sizelocvar;         // local å˜é‡åˆ—è¡¨å¤§å°    Upvaldesc* upvalues;    // upvalue ä¿¡æ¯åˆ—è¡¨ï¼Œä¸»è¦è®°å½• upvalue çš„åç§°ï¼Œä»¥åŠå…¶æ‰€åœ¨çš„åœ°å€ï¼Œå¹¶ä¸æ˜¯ upvalue å®é™…å€¼çš„åˆ—è¡¨    int sizeupvalues;       // upvalue åˆ—è¡¨å¤§å°    struct Proto** p;       // å†…åµŒå®šä¹‰çš„å‡½æ•°åˆ—è¡¨    int sizep;              // proto åˆ—è¡¨é•¿åº¦    TString* source;        // è„šæœ¬è·¯å¾„    struct GCObjects* gclist;    int maxstacksize;       // Proto æ‰€å¯¹åº”çš„ Lua å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œå‡½æ•°æ ˆçš„æœ€å¤§å°ºå¯¸&#125; Proto;\n\nä¸Šå€¼ç”Ÿæˆè¿‡ç¨‹  ä¸Šå€¼å®é™…ä¸Šæ˜¯å†ç¼–è¯‘æ—¶ç¡®å®šï¼ˆä½ç½®ä¿¡æ¯å’Œå¤–å±‚å‡½æ•°çš„å…³è”ç­‰ï¼‰ã€åœ¨è¿è¡Œæ—¶ç”Ÿæˆçš„ã€‚ç”¨æ¥è¡¨ç¤ºä¸Šå€¼çš„æ•°æ®ç»“æ„æœ‰ä¸¤ä¸ªï¼Œä¸€ä¸ªæ˜¯ç¼–è¯‘æ—¶æœŸå­˜å‚¨ä¸Šå€¼ä¿¡æ¯çš„ Upvaldescï¼ˆè¿™ä¸ªç»“æ„å¹¶ä¸å­˜å‚¨ä¸Šå€¼çš„å®é™…å€¼ï¼Œåªæ˜¯ç”¨æ¥æ ‡è®°ä¸Šå€¼çš„ä½ç½®ä¿¡æ¯ï¼‰ï¼Œå¦ä¸€ä¸ªæ˜¯åœ¨è¿è¡Œæ—¶å®é™…å­˜å‚¨ä¸Šå€¼çš„UpVal ç»“æ„\n// luaobject.htypedef struct Upvaldesc &#123;    // æœ¬å‡½æ•°çš„ä¸Šå€¼æ˜¯å¦æŒ‡å‘å¤–å±‚å‡½æ•°çš„æ ˆï¼ˆå¦‚æœä¸æ˜¯åˆ™æŒ‡å‘å¤–å±‚å‡½æ•°çš„æŸä¸ªä¸Šå€¼ï¼‰    int in_stack;    // ä¸Šå€¼åœ¨å¤–å±‚å‡½æ•°ä¸­çš„ä½ç½®ï¼ˆæ ˆçš„ä½ç½®æˆ– upval åˆ—è¡¨ä¸­çš„ä½ç½®ï¼Œæ ¹æ® in_stack ç¡®å®šï¼‰    int idx;    // ä¸Šå€¼çš„åç§°    TString* name; &#125; Upvaldescï¼›\n\n// luafunc.hstruct Upval &#123;    // æŒ‡å‘å¤–å±‚å‡½æ•°çš„ local å˜é‡ï¼ˆå¼€æ”¾ä¸Šå€¼ï¼‰ï¼Œæˆ–è€…æŒ‡å‘è‡ªå·±ï¼ˆä¸Šå€¼å…³é—­æ—¶ï¼‰    TValue* v;    // Upval å®ä¾‹è¢«å¼•ç”¨çš„æ¬¡æ•°    int refcount;    union &#123;        struct &#123;            struct UpVal* next; .. ä¸‹ä¸€ä¸ªå¼€æ”¾ä¸Šå€¼            int touched;        &#125; open;        Tvalue value;    &#125; u;&#125;\n\nLua è„šæœ¬çš„ç¼–è¯‘ä¿¡æ¯ä¼šè¢«å­˜å‚¨åˆ° Proto ç»“æ„å®ä¾‹ä¸­ï¼Œå½“ä¸€ä¸ª Lua å‡½æ•°çš„æŸä¸ªå˜é‡ä¸æ˜¯ local å˜é‡æ—¶ï¼Œå¦‚æœå¸Œæœ›è·å¾—å®ƒçš„å€¼ï¼Œå®é™…ä¸Šå°±è¦æŸ¥æ‰¾è¿™ä¸ªå˜é‡çš„ä½ç½®ï¼Œå¦‚æœåœ¨ local åˆ—è¡¨ä¸­æ‰¾ä¸åˆ°ï¼Œåˆ™è¿›å…¥ä¸€ä¸‹æµç¨‹ï¼š\n\nåˆ°è‡ªå·±çš„ Upvaldesc åˆ—è¡¨ä¸­ï¼Œæ ¹æ®å˜é‡åæŸ¥æ‰¾ï¼Œå¦‚æœå­˜åœ¨åˆ™ä½¿ç”¨å®ƒï¼Œå¦åˆ™è¿›è¡Œä¸‹ä¸€æ­¥ï¼›\nåˆ°å¤–å±‚å‡½æ•°æŸ¥æ‰¾ local å˜é‡ï¼Œå¦‚æœæ‰¾åˆ°å®ƒå°±å°†å®ƒä½œä¸ºè‡ªå·±çš„ä¸Šå€¼ï¼Œå¦åˆ™æŸ¥æ‰¾å®ƒçš„ Upvaldesc è¡¨ï¼Œæ‰¾åˆ°å°±å°†å…¶ç”Ÿæˆä¸ºè‡ªå·±çš„ä¸Šå€¼ï¼Œå¦åˆ™è¿›å…¥æ›´å¤–å±‚å‡½æ•°ï¼Œé‡å¤è¿™ä¸€æ­¥ï¼›\nå¦‚æœä¸€ç›´åˆ°é¡¶çº§å‡½æ•°éƒ½æ‰¾ä¸åˆ°ï¼Œé‚£ä¹ˆè¡¨ç¤ºè¿™ä¸ªä¸Šå€¼ä¸å­˜åœ¨ï¼Œæ­¤æ—¶éœ€è¦å» _ENV ä¸­æŸ¥æ‰¾\n\n","categories":["è¯»ä¹¦ç¬”è®°"],"tags":["lua","æºç "]},{"title":"RO é¡¹ç›®ç›¸å…³","url":"/2024/05/09/50/","content":"å®¢æˆ·ç«¯è‡ªåŠ¨æˆ˜æ–— AIBehaviour Designer è¡Œä¸ºæ ‘æ’ä»¶AI çš„è§£å†³æ–¹æ¡ˆ\nç¼–ç ï¼šååº”å‹ AI\nçŠ¶æ€æœº\nè¡Œä¸ºæ ‘\nåŸºäºè§„åˆ™çš„ç³»ç»Ÿ\n\n\næ±‚è§£ï¼šåå•†è¡Œ AI\nA*\nç›®æ ‡å¯¼å‘å‹è¡ŒåŠ¨è®¡åˆ’ï¼ˆGOAPï¼‰\nå±‚æ¬¡äººç‰©ç½‘è§„åˆ’ï¼ˆHTNï¼‰\nè§„åˆ’å™¨\n\n\nå­¦ä¹ ï¼šæœºå™¨å­¦ä¹ \næ¨¡ä»¿å­¦ä¹ \nå¼ºåŒ–å­¦ä¹ \n\n\n\næ¸¸æˆä¸­å¸¸è§çš„ AI è§£å†³æ–¹æ¡ˆéƒ½æ˜¯ååº”å‹ AIï¼ŒRO ä¸­å¤§é‡ç”¨åˆ°ååº”å‹ AI çš„è¡Œä¸ºæ ‘ä½œä¸ºè§£å†³æ–¹æ¡ˆï¼Œè¿™ä¸ªè¡Œä¸ºæ ‘æ’ä»¶å°±æ˜¯ Behaviour Designer\nBehaviour Designer ä¸­çš„ Taskç®€å•è¡Œä¸ºæ ‘å®é™…ä¸Šå°±æ˜¯ Task çš„é›†åˆï¼ŒTask æœ‰å››ç§ä¸åŒçš„ç±»å‹ï¼š\n\nAction åŠ¨ä½œâ€”â€”ä»£è¡¨äº†æŸç§çŠ¶æ€ï¼Œæœ€åŸºæœ¬çš„ä»»åŠ¡\nConditional æ¡ä»¶â€”â€”ç”¨æ¥æ£€æµ‹æ˜¯å¦è¾¾åˆ°æŸç§æ¡ä»¶\nComposite å¤åˆâ€”â€”åŒ…å«äº†ä¸€ç³»åˆ—å­ä»»åŠ¡åˆ—è¡¨çš„çˆ¶ä»»åŠ¡\nDecorator ä¿®é¥°ç¬¦â€”â€”ä¹Ÿæ˜¯ä¸€ä¸ªçˆ¶ä»»åŠ¡ï¼Œå¹¶ä¸”åªèƒ½åŒ…å«ä¸€ä¸ªå­ä»»åŠ¡ï¼Œæ˜¯ç”¨æ¥ä¿®æ”¹å­ä»»åŠ¡çš„è¡Œä¸ºã€‚ä¾‹å¦‚å°†ä¸€ä¸ªå­ä»»åŠ¡è¿è¡Œ 10 æ¬¡ï¼ˆRepeaterï¼‰ï¼Œæˆ–è€…å¯¹å­ä»»åŠ¡çš„ç»“æœå–åï¼ˆInverterï¼‰\n\nAction å’Œ Conditional è‡ªå®šä¹‰ Taskä¸€èˆ¬æƒ…å†µä¸‹åªä¼šåœ¨ Behaviour Designer ä¸­å®šä¹‰ Action å’Œ Conditionalï¼ŒComposite å’Œ Decorator ä½¿ç”¨æä¾›çš„å°±å¯ä»¥ï¼Œä¸‹é¢çš„ Action ä»£ç ç”±å·¥å…·è‡ªåŠ¨ç”Ÿæˆ\n[BehaviorDesigner.Runtime.Tasks.TaskDescriptionAttribute(\"è¡€é‡å±æ€§æ¯”è¾ƒ\")]public class MAISelfCompareByHP : BehaviorDesigner.Runtime.Tasks.Action{    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"æ˜¯å¦è‡ªå·±\")]    public BehaviorDesigner.Runtime.SharedBool is_self;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"ç›®æ ‡\")]    public BehaviorDesigner.Runtime.SharedTransform target;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"å€¼ç±»å‹ (hp è¡€é‡ ã€hp ç™¾åˆ†æ¯”ï¼‰\")]    public MoonClient.MAISelfCompareByHP.MHPValueType hp_value_type;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"æ¯”è¾ƒç±»å‹\")]    public MoonClient.MNumberComparisonType hp_cmp_type;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"å³å€¼\")]    public BehaviorDesigner.Runtime.SharedFloat right_value;    [BehaviorDesigner.Runtime.Tasks.TooltipAttribute(\"ä¿å­˜å·¦å€¼ç»“æœ\")]    public BehaviorDesigner.Runtime.SharedFloat store_left_value;    private MoonClient.MAISelfCompareByHP node;    private MEntity entity;    private MoonClient.MAISelfCompareByHP.MNodeArgs args;       public override void OnAwake()    {     entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.gameObject.name));     if(entity == null) return;     node = new MoonClient.MAISelfCompareByHP();     args = new MoonClient.MAISelfCompareByHP.MNodeArgs();      args.is_self = is_self.swigValue;      args.hp_value_type = hp_value_type;      args.hp_cmp_type = hp_cmp_type;      args.right_value = right_value.swigValue;      args.store_left_value = store_left_value.swigValue;     node.SetNodeArgs(args);    }        public override TaskStatus OnUpdate()    {     if(entity == null) return TaskStatus.Failure;     return node.Update(entity) ? TaskStatus.Success : TaskStatus.Failure;    }}\n\nå¸¸ç”¨çš„ Parent Tasks\nComposite å¤åˆç±»å‹\nSequence å°†å…¶æ‰€æœ‰å­èŠ‚ç‚¹ä¾æ¬¡æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´å½“å‰ä¸€ä¸ªè¿”å›â€œå®Œæˆâ€çŠ¶æ€åï¼Œå†è¿è¡Œå…ˆä¸€ä¸ªå­èŠ‚ç‚¹ [Image]The sequence task is similar to an â€œandâ€ operation. It will return failure as soon as one of its child tasks return failure. If a child task returns success then it will sequentially run the next task. If all child tasks return success then it will return success. å’Œâ€œandâ€æ“ä½œç¬¦é€»è¾‘ç±»ä¼¼ï¼Œä¸‹é¢çš„å­ä»»åŠ¡æŒ‰ç…§ä»å·¦åˆ°å³çš„é¡ºåºæ‰§è¡Œï¼Œå¦‚æœæœ‰ä¸€ä¸ªå­ä»»åŠ¡è¿”å› falseï¼Œåç»­å­ä»»åŠ¡éƒ½ä¸æ‰§è¡Œï¼Œå¹¶ä¸”è¯¥ä»»åŠ¡ç›´æ¥è¿”å› false\nSelector é€‰æ‹©å…¶å­èŠ‚ç‚¹çš„æŸä¸€ä¸ªæ‰§è¡Œ [Image]The selector task is similar to an â€œorâ€ operation. It will return success as soon as one of its child tasks return success. If a child task returns failure then it will sequentially run the next task. If no child task returns success then it will return failure. å’Œâ€œorâ€æ“ä½œç¬¦é€»è¾‘ç±»ä¼¼ï¼Œè®©å­ä»»åŠ¡ä»å·¦åˆ°å³ä¾æ¬¡æ‰§è¡Œï¼Œå¦‚æœæœ‰ä¸€ä¸ªäººç‰©è¿”å› trueï¼Œåç»­æ‰€æœ‰äººç‰©å°±ä¸æ‰§è¡Œï¼Œè¯¥ä»»åŠ¡ç›´æ¥è¿”å› true\nParallel å°†å…¶æ‰€æœ‰å­èŠ‚ç‚¹éƒ½è¿è¡Œä¸€é\n\n\nDecorator è£…é¥°å™¨ç±»å‹\nInverter\nRepeater\nReturn Failure å’Œ Return Success// ReturnFailure.cspublic override TaskStatus Decorate(TaskStatus status){    // Return failure even if the child task returned success.    if (status == TaskStatus.Success) {        return TaskStatus.Failure;    }    return status;}// ReturnSuccess.cspublic override TaskStatus Decorate(TaskStatus status){    // Return success even if the child task returned failure.    if (status == TaskStatus.Failure) {        return TaskStatus.Success;    }    return status;}\næ— è®ºè¿”å›æˆåŠŸè¿˜æ˜¯å¤±è´¥ï¼Œéƒ½æ˜¯è¿”å›ç›¸åº”ä»»åŠ¡å¯¹åº”çš„ç»“æœ\nUntil Failure å’Œ Until Success\nRandom Probability\n\n\n\nå˜é‡ç›¸å…³  è¡Œä¸ºæ ‘çš„ä¼˜ç‚¹æ˜¯éå¸¸çµæ´»ï¼Œå› ä¸ºæ‰€æœ‰ä»»åŠ¡éƒ½æ˜¯è§£è€¦åˆçš„ï¼Œä»»åŠ¡ä¹‹é—´æ˜¯ä¸äº’ç›¸ä¾èµ–çš„ã€‚ä½†æ˜¯æœ‰æ—¶å€™éœ€è¦æä¾›å½¼æ­¤å…±äº«çš„ä¿¡æ¯ï¼Œè¿™æ˜¯ä¼šç”¨åˆ°è¡Œä¸ºæ ‘æä¾›çš„å…±äº«å˜é‡ç±»å‹ã€‚åœ¨éœ€è¦çš„ Task ä¸­å®šä¹‰äº†æŸä¸ªç±»å‹ï¼Œéœ€è¦åœ¨è¡Œä¸ºæ ‘ä¸­åˆ›å»ºè¯¥ç±»å‹ï¼Œå¹¶åœ¨ Task ä¸­å¼•ç”¨è¯¥ç±»å‹\nå±€éƒ¨å˜é‡å°±æ˜¯å½“å‰è¡Œä¸ºæ ‘å¯ä»¥å…±äº«çš„å˜é‡ï¼Œå…¨å±€å˜é‡å°±æ˜¯æ‰€æœ‰è¡Œä¸ºæ ‘éƒ½å¯ä»¥å…±äº«çš„å˜é‡ï¼ŒBehaviour Designer å†…ç½®çš„å…±äº«å˜é‡ç±»å‹æœ‰ä»¥ä¸‹å‡ ç§ï¼š\nSharedAnimationCurveSharedBoolSharedColorSharedFloatSharedGameObjectSharedGameObjectListSharedIntSharedMaterialSharedObjectSharedObjectListSharedQuaternionSharedRectSharedStringSharedTransformSharedTransformListSharedVector2SharedVector3IntSharedVector3SharedVector3IntSharedVector4\n\nBehaviour Designer ä¸­çš„å…±äº«å˜é‡çš„ç†è§£ Behaviour Designer çš„å…±äº«å˜é‡æ˜¯ä¸€ç§é»‘æ¿ï¼ˆBlackboardï¼‰è®¾è®¡æ¨¡å¼ è¾“å…¥å†…å®¹çš„æ¥æºå–å†³äºè¡Œä¸ºæ ‘ç”¨åœ¨æ•´ä¸ª AI æ¶æ„çš„å“ªä¸€å±‚ï¼Œå¯ä»¥æ˜¯æ¸¸æˆä¸–ç•Œçš„ä¿¡æ¯ï¼Œæˆ–è€…æ˜¯ä¸Šå±‚æ¨¡å—çš„è¾“å‡ºã€‚è¾“å…¥çš„å½¢å¼ï¼Œå¯ä»¥æ˜¯åˆ†æ•£çš„ï¼ˆDecentralizedï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯é›†ä¸­çš„ï¼ˆCentralizedï¼‰ã€‚ä¸¾ä¸ªä¾‹å­æ¥è¯´ï¼Œå¦‚æœæˆ‘ä»¬åšä¸€ä¸ªæˆ˜å£«æ˜¯ç§»åŠ¨ï¼Œè¿˜æ˜¯æ”»å‡»çš„å†³ç­–ï¼Œè¿™æ˜¯å†³ç­–å±‚çš„è¡Œä¸ºï¼Œæ‰€ä»¥è¾“å…¥å†…å®¹å°±æ˜¯æ¸¸æˆä¸–ç•Œçš„ä¿¡æ¯ï¼Œå®ƒå¯èƒ½åŒ…æ‹¬æˆ˜å£«è‡ªèº«çŠ¶æ€ï¼ˆåœ¨æ¨¡å— A ä¸­ï¼‰ï¼Œæ•ŒäººçŠ¶æ€ï¼ˆåœ¨æ¨¡å— B ä¸­ï¼‰ï¼Œè£…å¤‡ç‰©å“æƒ…å†µï¼ˆåœ¨æ¨¡å— Cï¼‰ï¼Œåœ°å›¾åœºæ™¯æƒ…å†µï¼ˆåœ¨æ¨¡å— D ä¸­ï¼‰ç­‰ç­‰ï¼Œæ‰€ä»¥ï¼Œå½“æˆ‘ä»¬æœç´¢å’Œæ‰§è¡Œè¡Œä¸ºæ ‘æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ä» 4 ä¸ªæ¨¡å—ä¸­è·å–ä¿¡æ¯æ¥å¸®åŠ©å†³ç­–ï¼Œè¿™æ ·çš„æ–¹å¼å°±æ˜¯æˆ‘ä¸Šé¢è¯´çš„åˆ†æ•£çš„æ–¹å¼ï¼Œå®ƒçš„å¥½å¤„æ˜¯è°ƒç”¨éå¸¸ç›´æ¥ï¼ˆå¯èƒ½æ˜¯ç”¨å¤šä¸ª Singleton æä¾›çš„æ¥å£ï¼‰ï¼Œæ²¡æœ‰æ•°æ®å†—ä½™ï¼Œç¼ºç‚¹æ˜¯ä½¿å¾—è¡Œä¸ºæ ‘å¯¹äºæ•°æ®çš„ä¾èµ–åº¦å¤ªåˆ†æ•£ã€‚\né›†ä¸­çš„æ–¹å¼çš„è¯ï¼Œå°±æ˜¯æˆ‘ä»¬å¯ä»¥å®šä¹‰ä¸€ä¸ªæ•°æ®ç»“æ„ä¸“é—¨ç”¨äºè¡Œä¸ºæ ‘çš„è¾“å…¥ï¼Œå°†ä¸Šé¢æåˆ°çš„éœ€è¦ç”¨åˆ°çš„æ•°æ®ï¼Œåœ¨è¿›è¡Œè¡Œä¸ºæ ‘å†³ç­–å‰ï¼Œå…ˆä»å„ä¸ªæ¨¡å—ä¸­æ”¶é›†åˆ°è¿™ä¸ªæ•°æ®ç»“æ„é‡Œï¼Œç„¶åå†é€’äº¤ç»™è¡Œä¸ºæ ‘ä½¿ç”¨ã€‚é›†ä¸­å¼çš„è¾“å…¥å‡å°‘äº†è¾“å…¥å’Œè¡Œä¸ºæ ‘ä¹‹é—´çš„æ¥å£æ•°é‡ï¼ˆåªå’Œé¢„å®šä¹‰çš„æ•°æ®ç»“æ„é€šä¿¡ï¼‰ï¼Œä½†ç¼ºç‚¹æ˜¯ï¼Œå­˜åœ¨æ•°æ®å†—ä½™ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°é›†ä¸­å¼çš„æ•°æ®è¾“å…¥ä½¿å¾—è¡Œä¸ºæ ‘çš„è¡¨ç°æ›´åƒä¸€ä¸ªé»‘ç›’äº†ï¼ˆå¯ä»¥ä¼ªé€ æ•°æ®æ¥æµ‹è¯•è¡Œä¸ºæ ‘ï¼‰ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»¬ä¸€ç›´ä»¥æ¥æƒ³è¦çš„ã€‚å¯ä»¥å‚çœ‹ä¸‹é¢å¯¹äºä¸¤ç§æ–¹å¼çš„ç¤ºæ„å›¾ï¼šåœ¨è¡Œä¸ºæ ‘çš„ä½¿ç”¨è¿‡ç¨‹ä¸­ï¼Œå‘ç°æœ‰æ—¶å€™èŠ‚ç‚¹å’ŒèŠ‚ç‚¹é—´ï¼Œè¡Œä¸ºæ ‘å’Œè¡Œä¸ºæ ‘ä¹‹é—´ç¡®å®éœ€è¦æœ‰æ•°æ®å…±äº«ï¼Œæ¯”å¦‚å¯¹äºåºåˆ—ï¼ˆSequenceï¼‰èŠ‚ç‚¹æ¥è¯´ï¼Œå®ƒçš„æ‰§è¡Œè¡Œä¸ºæ˜¯ä¾æ¬¡æ‰§è¡Œæ¯ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œç›´ç™½ä¸€ç‚¹è¯´çš„è¯ï¼Œå°±æ˜¯æ‰§è¡Œå®Œä¸€ä¸ªå†æ‰§è¡Œä¸‹ä¸€ä¸ªã€‚ä¸€èˆ¬ç”¨åˆ°åºåˆ—çš„è¡Œä¸ºï¼Œå…¶å­èŠ‚ç‚¹é—´æ€»ä¼šæœ‰ä¸€äº›è”ç³»ï¼Œè¿™é‡Œå°±å¯èƒ½å­˜åœ¨èŠ‚ç‚¹é—´é€šä¿¡çš„é—®é¢˜ã€‚å†æ¯”å¦‚ï¼Œåœ¨ä¸€äº›å›¢é˜Ÿ AI çš„å†³ç­–è¿‡ç¨‹ä¸­ï¼Œå½“å‰ AI çš„è¡Œä¸ºæ ‘å†³ç­–å¯èƒ½éœ€è¦å‚è€ƒå…¶ä»– AI çš„å†³ç­–ç»“æœï¼Œæ‰€ä»¥è¿™æ ·å°±å­˜åœ¨äº†è¡Œä¸ºæ ‘ä¹‹é—´éœ€è¦é€šä¿¡çš„æƒ…å†µã€‚\næ‰€ä»¥ï¼Œåœ¨å®è·µè¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬è¿˜ä¼šå®šä¹‰å¦ä¸€å—é»‘æ¿æ¥è´Ÿè´£è¡Œä¸ºæ ‘é—´å’ŒèŠ‚ç‚¹é—´çš„é€šä¿¡éœ€æ±‚ï¼Œç¤ºæ„å›¾å¦‚ä¸‹\nRO ä¸­çš„ MShareData å¯å…±äº«çš„å˜é‡ç±»å‹public enum MSharedDataType{    kSharedDataInt = 0,    kSharedDataBool,    kSharedDataFloat,    kSharedDataString,    kSharedDataVector,    kSharedDataTransform,    kSharedDataInt64,    kSharedDataTypeCount,};\n\nAI èŠ‚ç‚¹ä¸­å˜é‡åå’Œå€¼çš„å­˜å‚¨  ä¸»è¦ç”±è®°å½•å˜é‡åå¯¹åº”çš„å“ˆå¸Œå€¼ï¼ˆå…¶å®å°±æ˜¯è‡ªå¢å€¼ï¼‰å’Œå­˜å‚¨å„ä¸ªå˜é‡ç±»å‹çš„æ•°ç»„ï¼ˆç±»å‹å€¼æ•°ç»„ï¼‰å»ºç«‹èµ·æ¥çš„æ˜ å°„å…³ç³»ï¼Œè¿™äº›æ•°ç»„é‡Œä»¥å˜é‡åçš„å“ˆå¸Œå€¼ä½œä¸ºä¸‹æ ‡ï¼Œå­˜å‚¨ç›¸åº”çš„å€¼ï¼›ä¸»è¦çš„å˜é‡å¦‚ä¸‹ï¼š\n// å­˜å‚¨å˜é‡åçš„å“ˆå¸Œå€¼ï¼Œæ¯ç§å˜é‡ç±»å‹åˆ†åˆ«è®°å½•ï¼Œè¯»å–æ—¶æ ¹æ®ä¸åŒçš„å˜é‡ç±»å‹è¯»å–ç›¸åº”çš„ç±»å‹å€¼æ•°ç»„private static Dictionary&lt;string, uint&gt;[] name_hash_ =    new Dictionary&lt;string, uint&gt;[(int)MSharedDataType.kSharedDataTypeCount];private static uint[] name_index_ =    new uint[(int)MSharedDataType.kSharedDataTypeCount]; //int å‹æ•°ç»„é‡Œé¢çš„å€¼é»˜è®¤åˆå§‹åŒ–ä¸º 0    // å£°æ˜ç±»å‹å€¼æ•°ç»„private const int kMaxAIDataCount = 150; // æ‰€æœ‰å˜é‡çš„æ•°é‡ä¸Šé™private float[] float_var_;private int[] int_var_;private long[] long_var_;private bool[] bool_var_;private ulong[] trans_var_;private string[] string_var_;private Vector3[] vector3_var_;/* é»˜è®¤åˆå§‹åŒ–  * bool --&gt; false * intã€float --&gt; 0 * å…¶ä»–å€¼ç±»å‹ --&gt; è¯¥ç±»å‹å­—æ®µé»˜è®¤å€¼ * å¼•ç”¨ç±»å‹ï¼ˆåŒ…æ‹¬ string) --&gt; null*/float_var_ = new float[kMaxAIDataCount];int_var_ = new int[kMaxAIDataCount];long_var_ = new long[kMaxAIDataCount];bool_var_ = new bool[kMaxAIDataCount];trans_var_ = new ulong[kMaxAIDataCount];string_var_ = new string[kMaxAIDataCount];vector3_var_ = new Vector3[kMaxAIDataCount];\n\nè¿è¡Œæ—¶é€šè¿‡ä»¥ä¸‹æ˜ å°„å…³ç³»è¯»å–å¯¹åº” AI èŠ‚ç‚¹ä¸­çš„å˜é‡å€¼\n\n    \n\n\nPB æ•°æ®  å®¢æˆ·ç«¯è¡Œä¸ºæ ‘çš„ Node ç”Ÿæˆ\nä¸»è¦è§£æè¿è¡Œæ—¶ AI ä»£ç çš„æºæ–‡ä»¶ï¼Œéå† Assets/Scripts/MoonClient/AI/Node ç›®å½•ä¸‹æ‰€æœ‰ã€‚cs æ–‡ä»¶ï¼Œæºæ–‡ä»¶ä¸­æ¯ä¸ªç±»éƒ½ç»§æ‰¿è‡ª MAINodeAction æˆ–è€… MAINodeActionï¼Œæ ¹æ®åŸºç±»çš„ä¸åŒå¯¼å‡ºä¸åŒç±»å‹çš„èŠ‚ç‚¹[Image]\næ ¹æ®ç±»ä¸­å®šä¹‰ MNodeArgs çš„æˆå‘˜å˜é‡æ·»åŠ  public æˆå‘˜å˜é‡ï¼Œæˆå‘˜å˜é‡çš„ç±»å‹æ ¹æ®ä¸‹é¢çš„å­—å…¸æ˜ å°„private static readonly Dictionary&lt;Type, Type&gt; typeRemapDict = new Dictionary&lt;Type, Type&gt;(){    {typeof(int), typeof(SharedInt) },    {typeof(long), typeof(SharedLong) },    {typeof(ulong), typeof(SharedULong) },    {typeof(float), typeof(SharedFloat) },    {typeof(string), typeof(SharedString) },    {typeof(bool), typeof(SharedBool) },    {typeof(UnityEngine.Vector3), typeof(SharedUnityVector3) },    {typeof(ROGameLibs.Vector3), typeof(SharedVector3) },    {typeof(SWIGTYPE_p_Vector3), typeof(SharedVector3) },#if LIBS_EDITOR    {typeof(SWIGTYPE_p_ROObject), typeof(SharedTransform) },#endif    {typeof(MoonClient.MEntity), typeof(SharedTransform) },    {typeof(IntVector), typeof(SharedIntList) },    {typeof(LongVector), typeof(SharedLongList) },    {typeof(FloatVector), typeof(SharedFloatList) },    {typeof(StringVector), typeof(SharedStringList) },    {typeof(ULongVector), typeof(SharedULongList) },};\nåŒæ—¶æ ¹æ®å±æ€§ NodeCommentï¼Œè®¾ç½®ç¼–è¾‘å™¨ä¸­å˜é‡çš„æ‚¬æµ®æ³¨é‡Š\nå›ºå®šæ ¼å¼çš„ä»£ç æ®µprivate MoonClient.XXX node; // XXX ä¸ºæºæ–‡ä»¶ç±»åprivate MEntity entity;private MoonClient.XXX.MNodeArgs args; // XXX ä¸ºæºæ–‡ä»¶ç±»åpublic override void OnAwake(){    entity = MEntityMgr.singleton.GetEntity(ulong.Parse(Owner.  gameObject.name));    if(entity == null) return;    node = new MoonClient.MAIAutoFollow();    args = new MoonClient.MAIAutoFollow.MNodeArgs();    // args.follow_target_radius = follow_target_radius.swigValue;    // args.teleport_distance = teleport_distance.swigValue;    // æºæ–‡ä»¶ä¸­ MNodeArgs çš„æˆå‘˜å˜é‡èµ‹å€¼    node.SetNodeArgs(args);}public override TaskStatus OnUpdate(){    if(entity == null) return TaskStatus.Failure;    return node.Update(entity) ? TaskStatus.Success : TaskStatus.  Failure;}\n\nè¿è¡Œæ—¶ AIåˆå§‹åŒ–\nåˆå§‹åŒ– AI ç»„ä»¶ï¼šMPlayer::InitComponents\nåˆå§‹åŒ–è¡Œä¸ºæ ‘ï¼šMAIComponent::InitBehaviorTree\nåˆå§‹åŒ–æ‰€æœ‰ç©å®¶é€šç”¨çš„ AI æ ‘ï¼šMAIBehaviorTree::Init\nåŠ è½½ PlayerAI/Player_Auto_AI.bytes æ–‡ä»¶ï¼šMAITreeManager::LoadFile\næ„é€  AI æ ‘ï¼šMAITreeManager::BuildAITree\né€’å½’æ„é€ èŠ‚ç‚¹ï¼šMAITreeManager::BuildOneNode\næœªåˆå§‹åŒ–æ—¶ï¼Œåˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹ç±»å‹å¯¹è±¡çš„å§”æ‰˜ï¼šMAINodeFactory::CreateAINodeByName\nåˆå§‹åŒ–å®Œæˆå³è°ƒç”¨ï¼Œè§£æ PB åˆå§‹åŒ–èŠ‚ç‚¹\n\n\n\n\n\n\n\nè°ƒç”¨é€»è¾‘\nåœ¨ MAIComponent::Update æ¯æ¬¡ Update æ»¡è¶³ä¸€å®šæ¡ä»¶åéƒ½æ‰§è¡Œä¸€æ¬¡_behaviorTree.Tick(Entity)\næ¯æ¬¡ tick éƒ½ä» AINode çš„ RootNode é€’å½’åˆ°æ¯ä¸ªå­èŠ‚ç‚¹ï¼Œæ‰§è¡Œç›¸åº”ä¸šåŠ¡é€»è¾‘èŠ‚ç‚¹çš„ Update å‡½æ•°ä¸­çš„é€»è¾‘\n\nå®¢æˆ·ç«¯å¦‚ä½•è¿›è¡Œè‡ªåŠ¨é‡Šæ”¾\nç­–åˆ’ä¼šåœ¨è¡Œä¸ºæ ‘ä¸­é…ç½®ä¸€äº›åˆ—çš„æ¡ä»¶ï¼ˆé¡ºåºæ‰§è¡Œæˆ–é€‰æ‹©æ‰§è¡Œï¼‰\nè‡ªåŠ¨è·Ÿéšçš„è·ç¦»\nEntity ç±»å‹é™åˆ¶\næˆ˜æ–—åŠå¾„å¤§å°\nå˜èº«æƒ…å†µ\nâ€¦\n\n\nä¾æ¬¡éå†è£…é…åœ¨è‡ªåŠ¨æˆ˜æ–—æ§½ä½çš„æŠ€èƒ½ï¼ˆ1~6ï¼‰\nå½“ç¬¬ i ä¸ªæ§½ä½æœ‰è£…é…æŠ€èƒ½æ—¶ï¼Œæ ¹æ®æŠ€èƒ½ id è¯»å–æŠ€èƒ½è¡¨ä¸­é…ç½®çš„AITreeName\nå°†æŸ¥è¯¢åˆ°çš„ AITreeName æ”¾ç½®åˆ° tree_name å…±äº«å˜é‡ä¸­\nå†é€šè¿‡ MAIDynamicTreeReference è¯»å– tree_name ä¸­çš„å€¼ï¼Œå¹¶è¯»å–æ”¹èŠ‚ç‚¹æ ‘çš„ PBï¼Œåˆå¹¶åˆ°å½“å‰ MAIDynamicTreeReference çš„çˆ¶èŠ‚ç‚¹ä¸Š\nè¯»å–åˆ°ç›¸å…³æŠ€èƒ½èŠ‚ç‚¹æ ‘åï¼Œæ ¹æ®ç­–åˆ’çš„é…ç½®æ¡ä»¶ï¼Œæ»¡è¶³åå¯é‡Šæ”¾\næŠ€èƒ½æ˜¯å¦å­˜åœ¨\né‡Šæ”¾æŠ€èƒ½åï¼Œæ˜¯å¦å­˜åœ¨ä¸å¯å åŠ çš„ buff\nâ€¦\n\n\né‡Šæ”¾æŠ€èƒ½ï¼šé€šè¿‡ MWaitingDataMgr æ·»åŠ å¯é‡Šæ”¾çš„æŠ€èƒ½åˆ°å¾…æ‰§è¡Œé˜Ÿåˆ—ä¸­ï¼Œæ¯æ¬¡ update èµ°æŠ€èƒ½é‡Šæ”¾é€»è¾‘\n\nç›¸å…³æ”¹è¿›  çº¿ä¸Š bugï¼šæŸäº›èŒä¸šé‡Šæ”¾æŠ€èƒ½åï¼Œå·²ç»ä¸Šäº†ä¸å¯å åŠ çš„ buffï¼ˆbuff æ•ˆæœæ¶ˆå¤±ä¹‹å‰ä¸èƒ½å¤Ÿé‡å¤é‡Šæ”¾æ”¹æŠ€èƒ½ï¼‰ï¼Œä½†æ˜¯å®¢æˆ·ç«¯çš„ AI ä¾ç„¶ä¼šç»§ç»­æŒç»­é‡Šæ”¾ï¼Œé€ æˆæŠ½æçš„è¡¨ç°ï¼ˆå¶ç°é—®é¢˜æ²¡æœ‰æŸ¥åˆ°å…·ä½“åŸå› ï¼‰è§£å†³æ–¹æ¡ˆï¼šæ›´æ”¹ MAICastSkill èŠ‚ç‚¹ï¼Œé‡Šæ”¾æ¬¡æ•°è¶…è¿‡ä¸€å®šæ•°å€¼ï¼Œä¸å¯é‡Šæ”¾è¯¥æŠ€èƒ½\né™„èº«  éœ€æ±‚\næŠ€èƒ½ï¼šçµå–µé™„èº«\næŠ€èƒ½æè¿°ï¼šå–µå–µé™„èº«äºé€‰ä¸­çš„é˜Ÿå‹èº«ä¸Šï¼Œæ¯ç§’æ¶ˆè€— 5 ç‚¹è‡ªç„¶åŠ›é‡ï¼ŒæŒç»­ 20 ç§’ï¼Œè‡ªèº«å¤„äºæ— æ•ŒçŠ¶æ€ï¼Œä¸”å°†è‡ªèº« 10% çš„å…­ç»´å±æ€§é™„åŠ äºé™„èº«çš„é˜Ÿå‹\n\nå®ç°æ–¹å¼\né‡Šæ”¾æŠ€èƒ½ä¸ºè§’è‰²æ·»åŠ  Buff\nå®¢æˆ·ç«¯æ ¹æ® Buff çŠ¶æ€ç±»å‹è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ˜¯é™„èº« Buff çŠ¶æ€ç±»å‹\né™„èº«ç›®æ ‡åªæœ‰ä¸€ä¸ªï¼Œå–æœåŠ¡å™¨å‘è¿‡æ¥çš„ç¬¬ä¸€ä¸ª Buff ç›¸å…³ç›®æ ‡ï¼ˆåŒºåˆ«äº Buff ç›®æ ‡ï¼‰çš„ uid\nåœ¨ MBuffComponent ç»„ä»¶ä¸­è®°å½•è¯¥ uid\nå¹¿æ’­ StopMove äº‹ä»¶ï¼Œè®©ç©å®¶æ— æ³•ç§»åŠ¨\nè®¾ç½®ç©å®¶çš„ä½ç½®ã€æœå‘ä¸è¢«é™„èº«çš„ç©å®¶ä¸€è‡´\n\n\nå±è”½ç©å®¶çš„ç¢°æ’ä½“ï¼Œä½¿ç©å®¶å’Œè¢«é™„èº«çš„äººä¿æŒä¸€è‡´\nåœ¨ MHideComponent ç»„ä»¶ä¸­ï¼Œå°†ç©å®¶è®¾ç½®ä¸ºåŠé€æ˜çŠ¶æ€\næ§åˆ¶ç§»åŠ¨\nå±è”½æ‘‡æ†å’Œç‚¹å‡»åœ°é¢çš„ç§»åŠ¨æ•ˆæœ\nåœ¨ MMoveComponent ç»„ä»¶çš„ Update ä¸­ï¼Œæ¯å¸§è®¾ç½®ç©å®¶çš„ç§»åŠ¨è·ç¦»æ”¹ä¸ºå’Œè¢«é™„èº«çš„ç©å®¶åšå·®var buffFollowTarget = Entity.BuffFollowTarget;if (buffFollowTarget != null){    Entity.AppendMove(buffFollowTarget.Position - Entity.Position);}else{    Entity.AppendMove(Entity.ServerPos - Entity.Position);}\n\n\n\nOdin OdinMenuTreeUI æ¡†æ¶Windows ç”Ÿå‘½å‘¨æœŸ\næ‰“å¼€ UIï¼šActive -&gt; BindEvents -&gt; OnActive -&gt; OnShow -&gt; AfterShow\nå…³é—­ UIï¼šDeactive -&gt; UnBindEvents -&gt; OnHide -&gt; OnDeActive -&gt; AfterOnDeActive -&gt; ReleaseAll\n\nUIBase\nOnLoadï¼šåŠ è½½èµ„æº\nbaseloadCallbackï¼šèµ„æºåŠ è½½æˆåŠŸåçš„å›è°ƒ\nInitï¼šåˆå§‹åŒ–\n\n\nOnBindPanelï¼šç»‘å®šé¢„åˆ¶\nOnUnloadï¼šé‡Šæ”¾èµ„æºï¼Œå…³é—­ç•Œé¢æˆ–è€…åˆ‡æ¢è¯­è¨€\nInitï¼šOnUnloadåè°ƒç”¨\nUninitï¼šUnLoadæˆ–å…³é—­æ¸¸æˆè¿›ç¨‹åè°ƒç”¨\nOnActiveï¼šActiveåè°ƒç”¨\nOnDeActiveï¼šDeActiveåè°ƒç”¨\nOnShow\nAfterShowï¼šå½“ä¸Šå±‚ç•Œé¢å®Œå…¨å…³é—­åè°ƒç”¨\nOnHide\nBindEventsï¼šActiveåï¼ŒOnActiveä¹‹å‰è°ƒç”¨\nUpdate\nUpdateInput\nOnLogout\nOnReconnected\n\nUIManager\nUIManager æ‰“å¼€å…³é—­ç•Œé¢ä»¥ç»„çš„æ–¹å¼è¿›è¡Œå¤„ç†ã€‚\næ‰€æœ‰çš„ç»„ä¿¡æ¯éƒ½ä¼šè¿›æ ˆè¿›è¡Œç®¡ç†ã€‚\nä¼šæ ¹æ®é…ç½®æ¥ç¡®å®šè¿™ä¸ªç»„é‡Œé¢æœ‰å“ªäº›ç•Œé¢\næ²¡åšé…ç½®çš„ç•Œé¢ä¼šæŠŠè¿™ä¸€ä¸ªç•Œé¢å½“æˆä¸€ç»„\næ”¯æŒé™æ€é…ç½®å’Œæ‰“å¼€ç•Œé¢æ—¶ä¼ é€’åŠ¨æ€é…ç½®\n\n\n\n\n\nActiveUIæ‰“å¼€æŸä¸ª Window å‡½æ•°å…¥å£\né€šè¿‡ require æŒ‡å®š Window åå­—ï¼Œå¹¶è¿›è¡Œåˆå§‹åŒ–UI[panelClassName].new()\nä¸ºå½“å‰ Window æ·»åŠ groupName\n_createUIPanelConfig ç”Ÿæˆ UIPanel é…ç½®ï¼Œå¾—åˆ°ç•Œé¢çš„é…ç½®æ•°æ®\nActiveUIPanelInGroup æ‰“å¼€ç•Œé¢æ—¶å¯¹æ ˆè¿›è¡Œå¤„ç†\n\n\nè®¾ç½® UI å±‚çº§ï¼ˆUILayerï¼‰---@class UILayerUILayer = {    Normal = 0,   -- 20    Function = 1, -- 40    Tips = 2,     -- 60    Guiding = 3,  -- 80    Top = 4       -- 100}\n\nç•Œé¢ç±»å‹ï¼ˆActiveTypeï¼‰\nNoneï¼šä¸åšä»»ä½•å¤„ç†\nNormalï¼šæ˜¾ç¤ºæ—¶ä¼šæŠŠè¿™ä¸ªç•Œé¢åŠ å…¥ä¸»ç•Œé¢ç»„ä¸­ï¼ˆNormalLayer -&gt; MainPanelsGroupGroupï¼Œæ— è§†è®¾ç½®çš„ UILayer æ”¾åˆ° NormalLayerï¼‰\nExclusiveï¼šæ˜¾ç¤ºæ—¶ä¼šéšè—å‰é¢çš„ç»„ï¼ˆéšè— Normal Exclusive ç±»å‹ UIï¼ŒLayer æ— å…³ï¼‰\nStandaloneï¼šæ˜¾ç¤ºåä¸ä¼šè¢« Exclusive ç±»å‹éšè—\n\nå‰§æœ¬è§£æ  ä»£ç ç»“æ„clientcode\\CSProject\\MoonClient\\CommandSystem:. â”‚  CommandBlock.cs åˆ›å»ºä»¥åŠæ‰§è¡Œ Block çš„æ–¹æ³•éƒ½ä¼šåœ¨è¿™é‡Œâ”‚  CommandBlockManager.cs ä¸Šä¸‹æ–‡ç¯å¢ƒç®¡ç†ï¼Œå˜é‡å‚¨å­˜â”‚  CommandBlockTriggerManager.cs è§¦å‘å™¨ç®¡ç†â”‚  CommandConst.cs æ‰€æœ‰ä¸å‘½ä»¤ç›¸å…³çš„å¸¸é‡éƒ½ä¼šè®°å½•åœ¨è¿™é‡Œâ”‚   â”œâ”€Attribute é™æ€è¯­æ³•æ£€æŸ¥â”‚      CommandArgsAttribute.cs â”‚      CommandCheckAttribute.cs â”‚       â”œâ”€Checker é™æ€è¯­æ³•æ£€æŸ¥â”‚      CommandBlockChecker.cs â”‚       â”œâ”€Commands C# å‘½ä»¤â”‚  â”‚  BaseCommand.cs â”‚  â”‚  LuaCommand.cs â”‚  â”‚   â”‚  â”œâ”€NPC â”‚  â”‚      ChangeEmotionCommand.cs â”‚  â”‚      .â€‹.. çœç•¥â”‚  â”‚       â”‚  â”œâ”€Other â”‚  â”‚      FindElfCommand.cs â”‚  â”‚      ShowModelAlarmCommand.cs â”‚  â”‚       â”‚  â””â”€System â”‚          AddLocalBuffCommand.cs â”‚          .â€‹.. çœç•¥â”‚           â”œâ”€Compile äºŒè¿›åˆ¶ç¼–è¯‘â”‚      CommandBlockBinaryCompiler.cs â”‚      CommandBlockParser.cs â”‚       â”œâ”€Data PB æ•°æ®ç»“æ„ä»¥åŠåŠ¨æ€å‚æ•°è§£æâ”‚      BaseArg.cs â”‚      BlockIndexArg.cs â”‚      BlockVarArg.cs â”‚      CommandBlockArg.cs â”‚      CommandBlockStringArg.cs â”‚      CommandData.cs â”‚      CommandLuaArg.cs â”‚      ExpressionArg.cs â”‚      FunctionArg.cs â”‚      ValueArg.cs â”‚       â”œâ”€Expression è¡¨è¾¾å¼è¯æ³•è§£æå™¨â”‚      EOFToken.cs â”‚      IdentifierToken.cs â”‚      Lexer.cs â”‚      LuaConverter.cs â”‚      NumberToken.cs â”‚      StringToken.cs â”‚      Token.cs â”‚       â””â”€Trigger è§¦å‘å™¨ç›¸å…³    â”‚  CommandTrigger.cs     â”‚       â””â”€Event è§¦å‘å™¨äº‹ä»¶åŸ‹ç‚¹            BaseEvent.cs             OnCollectSuccEvent.cs             OnDamagedByPlayerEvent.cs             OnEnterDungeons.cs             OnExitDungeons.cs             OnKilledByPlayerEvent.cs             OnNpcCreateEvent.cs             OnNpcDestroyEvent.cs             OnStartCollectEvent.cs\n\nåœ¨ ScriptHandle å‡½æ•°è§£ææ¯ä¸€è¡Œå‰§æœ¬æ—¶ç¡®å®šæ˜¯ç”¨ C# ä¸­çš„ BaseCommand è¿˜æ˜¯ Lua ä¸­çš„ LuaCommand è¿›è¡Œè§£æ\n// åªæœ‰åœ¨åˆ—å‡ºçš„ç±»å‹æˆ–è€… Lua ç±»å‹æ‰ä¼šé€šè¿‡æ± å­è¿›è¡Œå¤ç”¨if (CommandConst.CommandTypeDict.TryGetValue(dacommandType, out var type)){    command = UUIDObjectPool.Get(type) as BaseCommand;}else{    var luaCommand = UUIDObjectPool.Get(typeof(LuaCommand)) as LuaCommand;    luaCommand?.SetCodeId(data.commandType);    command = luaCommand;}\n\nè§£æç‰¹æ®Šè¡¨è¾¾å¼// Arg æ•°å­— | ä»»æ„å­—ç¬¦ | LUA&lt;&lt; å‡½æ•°å &gt;&gt; | &lt;&lt; å‡½æ•°å &gt;&gt;public static readonly string ArgsRegex = @\"{{Arg(\\d+?)}}|{{(.+?)}}|LUA&lt;&lt;(.+?)&gt;&gt;|&lt;&lt;(.+?)&gt;&gt;\";public CommandBlockStringArg Init(string origin){    OriginString = origin;    if (origin == null)    {        return this;    }    _formatString = origin;    int argNum = 0;    var argMatch = Regex.Matches(_formatString, ArgsRegex);    foreach (Match match in argMatch)    {        var blockArgValue = match.Groups[1].Value;        var blockVarValue = match.Groups[2].Value;        var luaValue = match.Groups[3].Value;        var exprValue = match.Groups[4].Value;        if (!string.IsNullOrEmpty(blockArgValue))        {            if (int.TryParse(blockArgValue, out int index))            {                var arg = MCommonObjectPool&lt;BlockIndexArg&gt;.Get().Init(index);                _formatArgs.Add(arg);                _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");                argNum++;            }        }        else if (!string.IsNullOrEmpty(blockVarValue))        {            var arg = MCommonObjectPool&lt;BlockVarArg&gt;.Get().Init(blockVarValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }        else if (!string.IsNullOrEmpty(luaValue))        {            var arg = MCommonObjectPool&lt;CommandLuaArg&gt;.Get().Init(luaValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }        else if (!string.IsNullOrEmpty(exprValue))        {            var arg = MCommonObjectPool&lt;ExpressionArg&gt;.Get().Init(exprValue);            _formatArgs.Add(arg);            _formatString = _formatString.Replace(match.Groups[0].Value, $\"{{{argNum}}}\");            argNum++;        }    }    return this;}\n\nUI Renderer Textureä½¿ç”¨ URP ç®¡çº¿è¿›è¡Œ RT æ¸²æŸ“\nCreatUIModelDataï¼šRtModelAssistant[RT åŠ¨æ•ˆåŠ©æ‰‹] è¿›è¡Œæ¨¡å‹åˆ›å»º\nMModel.OriginDataè®¾ç½®ç›¸å…³æ•°æ®\nLayerè®¾ç½®ä¸º ID_RTFACTORYï¼Œåªæ¸²æŸ“ID_RTFACTORY å±‚\n\n\nMUIRTDataï¼šå®šä¹‰ RT æ¸²æŸ“è®¾ç½®æ•°æ®\nRawImage\nç›¸æœºä½ç½®\næè¾¹\né˜´å½±\nåå°„\nå¤§å°\n\n\nCreateRawImageRT\nåˆ›å»ºæ–°çš„ RawImage\nåˆ›å»ºæ–°çš„ RTStageï¼Œç”¨äºç®¡ç† RT\nRTCamera.Init\nåŠ è½½ Camera é¢„åˆ¶ï¼ˆUIRTCameraï¼‰\nCulling Mask\nä½ç½®\nprojectionMatrix\ntargetTexture\næ›¿ä»–\né˜´å½±\nåå°„\n\n\n\n\n\n\nRawImage ä¸ RTStage ç»‘å®š\n\n\nUIRTCameraï¼ˆé‡‡ç”¨ UniversalRenderPipelineAsset_RTRenderer ç®¡çº¿é…ç½®ï¼‰\nç”±äºè®¾å®šäº† Culling Maskï¼Œç›¸æœºåªä¼šç…§åˆ°éœ€è¦æ¸²æŸ“çš„ç‰©ä½“\n\n\n\nè‡ªå®šä¹‰MCBRTRendererFeature\nè°ƒç”¨ CreatUIModelData æ—¶ä¼šå­˜å‚¨ Rt å’Œå¯¹å…¶åº”çš„æ¸²æŸ“æ•°æ®RawImageRtDataDicAdd\nUpdateRawImageRT å¤„ç†æ¨¡å‹çš„ renders\næ”¶é›†å…¨éƒ¨ renders\næ”¶é›†ä¸é€æ˜æè´¨çš„ renders\n\n\nUpdateRendererByRawImage å¼€å§‹çœŸæ­£çš„æ¸²æŸ“\næ¸²æŸ“ All Renders\nåˆå§‹åŒ–CBRTData\nRenderEx\næ£€æŸ¥è®¾å¤‡æ˜¯å¦æ”¯æŒRenderTextureFormat.ARGB32\ntexture å¤§å°æ˜¯å¦ä¸ºæ­£æ•°\nGetRenderTexture\nCameraMode ç›¸æœºæ¨¡å¼\nOutlineRendererShader ä¼ å…¥ç›¸æœºä½ç½®å±æ€§æ ‡è®°_CameraPos\ndata.pMatrix.m00 /= aspect;\nåˆ¤æ–­æ˜¯å¦å¯ä»¥ä½¿ç”¨å…±äº« RT _sharedRT\n_sharedRTä¼šåœ¨ Awake æ—¶åˆå§‹åŒ–ä¸º Vector2.one çš„å¤§å°\nä¸ä½¿ç”¨å…±äº« RT æ—¶ï¼Œåˆ™ä¼šæ ¹æ®ä¼ å…¥çš„ width å’Œheightå¤§å°è·å– texture RenderTexture.GetTemporary\n\n\nåˆ›å»ºæ¸²æŸ“é˜Ÿåˆ—\nè®¾ç½®æè´¨çš„æ ‡è¯†ç¬¦å’Œ rt å…³è”\n\n\n\n\n\n\næè¾¹ã€é˜´å½±ã€æè¾¹\nå› ä¸ºåœ¨åœºæ™¯ä¸­æ¨¡å‹çš„æè´¨å’Œ UI ä¸­ç”¨çš„æè´¨ä¸ä¸€æ ·æ‰€ä»¥éœ€è¦æ›¿æ¢ä¸€ä¸‹\nMResLoader.singleton.CreateMatFromPool(MShaderUtil.EffectOutlineMaterialPath);\nè®°å½•åˆ° CBRTQuene çš„materialDictä¸­\n\n\n\n\nMCBRTRenderPassæ‰§è¡Œ URP ç®¡çº¿ä¸­çš„ Excute å‡½æ•°ï¼Œé€šè¿‡ CommandBuff è¿›è¡Œç»˜åˆ¶\nä¸ä½¿ç”¨å…±äº« RT ç»˜åˆ¶ï¼Œç»˜åˆ¶å•ä¸ª RT\nè®¾ç½®æ¸²æŸ“ç›®æ ‡ SetRenderTarget texture ä¸ºåˆå§‹åŒ– CBRT é˜Ÿåˆ—æ—¶ä¼ å…¥çš„ texture\næ¸…é™¤æ¸²æŸ“çŠ¶æ€ ClearRenderTarget\nè°ƒç”¨ç»˜åˆ¶å‡½æ•° DrawRenderers\n\n\nå¼€å¯äº†å…±äº« RT ç»˜åˆ¶çš„ä¼šç»§ç»­ç»˜åˆ¶å…±äº« RT\nè®¾ç½®æ¸²æŸ“ç›®æ ‡ SetRenderTarget texture ä¸º_sharedRT\næ¸…é™¤æ¸²æŸ“çŠ¶æ€ ClearRenderTarget\nè°ƒç”¨ç»˜åˆ¶å‡½æ•° DrawRenderers\n\n\n\n\nç»˜åˆ¶ DrawRenderers\nè®¾ç½®è‡ªå®šä¹‰ MVP çŸ©é˜µ\næ ¹æ® Render çš„æè´¨ç”Ÿæˆ CommandBuffer åˆ—è¡¨\næ ¹æ® renderQueue å’ŒCameraDistanceå¯¹ CommandBuffer åˆ—è¡¨è¿›è¡Œæ’åº\nè°ƒç”¨ DrawRenderer è¿›è¡Œæ¸²æŸ“\n\n\næ¯å¸§è¿›è¡Œ _sharedRT å¤§å°æ£€æµ‹ï¼Œè¶…å‡º 256 è¿›è¡Œæ‰©å®¹  private void LateUpdate(){    //if (_temporaryCBRTs.Count &gt; _GCThreshold)    {        // å½“æ± ä¸­æ•°é‡è¶…è¿‡é˜ˆå€¼æ—¶è§¦å‘æ¸…ç©ºç©ºé˜Ÿåˆ—ï¼Œæå‡ä¸€äº›æ€§èƒ½        ReleaseEmpty();    }    // åˆå¹¶ RT å›¾é›†    List&lt;CBRTQuene&gt; rtQuenes = MListPool&lt;CBRTQuene&gt;.Get();    foreach (var rtQuene in _CBRTQuenes)    {        if (rtQuene.isValid &amp;&amp; rtQuene.isRTAltas &amp;&amp; rtQueneIsInActiveRawImage())        {            rtQuenes.Add(rtQuene);        }    }    if (rtQuenes.Count == 0)    {        ResizeShareRT(Vector2.one);        MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);        return;    }    rtQuenes.Sort((x, y) =&gt; y.clipRect.width.CompareTo(xclipRect.width));    // clipRect è®¡ç®— x y    Vector2 targetSize = new Vector2(256, 256);    bool loop = true; // é‡æ–°è®¡ç®—    while (loop)    {        Vector2 position = Vector2.zero;        float nextX = 0.0f;        loop = false;        foreach (var rtQuene in rtQuenes)        {            // ä¸€ä¸ª ClipRect.height é«˜è¶…å‡º yï¼Œåˆ™ y *= 2            if (rtQuene.clipRect.height &gt; targetSize.y)            {                loop = true;                targetSize.y *= 2;                break;            }            // é«˜è¶…å‡ºäº† yï¼Œåˆ™ä¸‹ä¸€åˆ—            if (position.y + rtQuene.clipRect.height &gt;targetSize.y)            {                position.x = nextX;                position.y = 0;                                    }            rtQuene.clipRect.x = position.x;            rtQuene.clipRect.y = position.y;            nextX = Mathf.Max(nextX, position.x + rtQueneclipRect.width);            // nextX è¶…å‡º x            if (nextX &gt; targetSize.x)            {                loop = true;                // å…ˆæ‰©å±• x                if (targetSize.x &lt;= targetSize.y)                {                    targetSize.x += 256;                }                // å†æ‰©å±• y                else                {                    targetSize.y += 256;                }                break;            }            position.y += rtQuene.clipRect.height;        }    }    ResizeShareRT(targetSize);    foreach (var rtQuene in rtQuenes)    {        rtQuene.renderTexture = _sharedRT;        rtQuene.AltasComplete();    }    MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);}\n\n\nRenderTexture.GetTemporary\nAllocate a temporary render texture.\nThis function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using ReleaseTemporary as soon as youâ€™re done with it, so another call can start reusing it if needed.\nInternally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually &gt; destroyed when they arenâ€™t used for a couple of frames.\nIf you are doing a series of post-processing â€œblitsâ€, itâ€™s best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. &gt; This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a DiscardContents call which helps to avoid costly restore operations on the previous render texture contents.\nYou can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform\n\nTimeLine\n    \n\n\nè¿è¡Œæ—¶MCutSceneMgr\nå¤–éƒ¨è°ƒç”¨ Play(int id, DirectoreWrapMode mode = DirectorWrapMode.Hold, Action endCallback = null, Action = startCallback = null) è¿›è¡Œ CutScene æ’­æ”¾\næ ¹æ®è¡¨æ ¼é…ç½®çš„è·¯å¾„è¿›è¡Œ  èµ„æº  é¢„å¤„ç†preAll\næ’­æ”¾é»‘å± æ˜¾ç¤ºé»‘å± UI\nè®¾ç½®æ’­æ”¾çŠ¶æ€ä¸ºCutSceneState.Prepare\nåˆ©ç”¨å¼•ç”¨è®¡æ•°æ¥å†³å®šæ‰€æœ‰èµ„æºæ˜¯å¦åŠ è½½å®Œæˆï¼Œå¼•ç”¨è®¡æ•°ä¸º 0 æ—¶è¡¨ç¤ºèµ„æºéƒ½åŠ è½½å¥½äº†\næ¯æ¬¡è¿›è¡Œèµ„æºåŠ è½½æˆ–é¢„åŠ è½½å¼•ç”¨è®¡æ•°åŠ  1ï¼Œåœ¨åŠ è½½å®Œæˆåçš„å›è°ƒå‡½æ•°ä¸­å¼•ç”¨è®¡æ•°å‡ 1\nå¼•ç”¨è®¡æ•°åŒ…æ‹¬ï¼š_necessaryLoadCountã€_preloadFlagã€_preloadRootCount\nåŠ è½½å®Œæˆåå¯ä»¥è¿›è¡Œæ’­æ”¾\n\n\næ¨¡å‹ã€ç‰¹æ•ˆç­‰ Root èŠ‚ç‚¹åˆå§‹åŒ–ï¼›æ‰©å±•åŠŸèƒ½åˆå§‹åŒ–\nèµ„æºå¼‚æ­¥åŠ è½½ï¼ŒåŠ è½½çš„èµ„æºç±»å‹ä¸º.playable\nåŠ è½½ .playable èµ„æºæˆåŠŸåç»§ç»­é¢„åŠ è½½å„ç§æ ¹èŠ‚ç‚¹\nVcRoot\nVcPathRoot\nSpineRoot\n\n\nåŠ è½½ Track\nç‰¹æ•ˆ\nè§†é¢‘\nå¤©æ°”\næ¨¡å‹\nè™šæ‹Ÿç›¸æœº\nCinemachine\nåŠ¨ç”»\nSpine åŠ¨ç”»\n\n\n\n\nUpdateå‡½æ•°ä¸­æ¯å¸§æ‰§è¡Œ\nèµ„æºå…¨éƒ¨åŠ è½½å¥½ä¹‹åï¼ˆæ‰€æœ‰åŠ è½½èµ„æºç›¸å…³çš„å¼•ç”¨è®¡æ•°ä¸º 0ï¼‰ï¼Œè®¾ç½®æ’­æ”¾çŠ¶æ€ä¸ºCutSceneState.Ready\nè®¾ç½®ç›¸æœºçš„è£å‰ªé®ç½©\nè®¾ç½®æ’­æ”¾çŠ¶æ€ä¸ºCutSceneState.Play\nè°ƒç”¨ CutScene æ’­æ”¾å¼€å§‹çš„å›è°ƒå‡½æ•°_startAction\nè°ƒç”¨ PlayableDirector.Play() è¿›è¡Œæ’­æ”¾\nè°ƒç”¨æ‰©å±•åŠŸèƒ½çš„ Update å‡½æ•°\nè°ƒç”¨ CutScene æ’­æ”¾ç»“æŸçš„å›è°ƒå‡½æ•°_endCallback\næ£€æµ‹æ˜¯å¦å¯ä»¥æ›´æ–°ä¸‹ä¸€ä¸ª CutScene\næ²¡æœ‰å¾ªç¯æ’­æ”¾æˆ–è€…æ­£åœ¨æ’­æ”¾ï¼Œå¯è¿›è¡Œä¸‹é¢çš„åˆ¤æ–­\nè®¡ç®—å‰©ä½™æ—¶é•¿  çš„ç›¸åæ•° remain = (float)(_playableDirector.time - _playableDirector.duration);\nDirectorWrapModeä¸º Hold æ—¶ï¼Œremain &gt;= 0fæ—¶ç«‹å³å‡†å¤‡ä¸‹ä¸€ä¸ª CutScene æ’­æ”¾\nDirectorWrapModeä¸º None æ—¶ï¼Œä¸å¤ªæ¸…é™¤è¿™å—çš„é€»è¾‘äº†if (MCommonFunctions.IsEqual(_playableDirector.time, 0)){    _cntZeroTime++;}if (_cntZeroTime &lt;= 1 &amp;&amp; (_playPath.Count &lt;= 0 || !(Mathf.Abs(tmp) &lt;= 0.1f)) &amp;&amp; !(tmp &gt;= 0f)) return;\næ ¹æ®è¡¨æ ¼ä¸­çš„ CutScene é…ç½®ï¼Œå–ç¬¬äºŒä¸ªè·¯å¾„ä¸º nextPath ç»§ç»­èµ°èµ„æºåŠ è½½ç„¶åæ’­æ”¾çš„çš„æµç¨‹\n\n\n\n\n\n\n&gt;public enum DirectorWrapMode&gt;{   //   // æ‘˜è¦ï¼š   //     Hold the last frame when the playable time reaches it's duration.   Hold,   //   // æ‘˜è¦ï¼š   //     Loop back to zero time and continue playing.   Loop,   //   // æ‘˜è¦ï¼š   //     Do not keep playing when the time reaches the duration.   None&gt;}\n\nå…¶ä»–è¾…åŠ©ç±»\nMCutsceneObject ç»§æ‰¿è‡ªMGameObject\nMCutSceneHelper å®šä¹‰åœ¨ Hierarchy ç»“æ„ä¸­æ˜¾ç¤ºçš„èŠ‚ç‚¹åç§°\nMCutSceneData åºåˆ—åŒ– CutScene äºŒè¿›åˆ¶\nList&lt;MCutSceneTrack&gt; åºåˆ—åŒ–è½¨é“æ•°æ®\nCStrackType\nMCutSceneModelData\nMCutSceneCirtualCameraData\nList&lt;MCutSceneAnimClip&gt;\nList&lt;MCutSceneCirCamClip&gt;\nMCutSceneSpineData\n\n\nMDollyCart å¯ç†è§£ä¸ºè£…è½½è½¨é“æ‘‡è‡‚çš„â€œè½¨é“è½¦â€\n\n\n\nPlayableBehaviourã€PlayableAssetå’ŒTrackAsset\nTrackAssetï¼šè½¨é“èµ„æºï¼Œç”¨æ¥åˆ›å»ºç‰‡æ®µå’Œ Playable æ··åˆå™¨ï¼Œæä¾›åºåˆ—åŒ–æ•°æ®ä¸ Binding\nPlayableAssetï¼šç‰‡æ®µèµ„æºï¼Œç”¨æ¥åˆ›å»º Playable ä»¥åŠæä¾›åºåˆ—åŒ–æ•°æ®\nPlayableBehaviourï¼šé€»è¾‘è¡Œä¸ºï¼Œç”¨æ¥å®ç° Playable å…·ä½“çš„ä¸šåŠ¡é€»è¾‘\n\nèµ„æºç®¡ç† RO çš„èµ„æºæ‰“åŒ…æµç¨‹ æ‰€æœ‰å¯èƒ½è¢«æ‰“åŒ…çš„èµ„æºéƒ½ä¼šè¢«å½’ç±»åˆ°ä¸€ä¸ªä¸ªçš„ filter ç±»ä¸­\n\nABDirï¼šå¤„ç†åçš„èµ„æºå­˜æ”¾çš„æ–‡ä»¶å¤¹ï¼ˆå‰ç¼€éƒ½æ˜¯ roab/ å¹³å°ï¼‰\nAbTypeï¼šèµ„æºç±»å‹ã€‚ä¸€å…±ä¸‰å¤§ç±»å‹ï¼š\nABï¼šéœ€è¦æ‰“æˆ AB çš„èµ„æº   åŸºç±»ä¸ºï¼šABBaseFilter\nbytesï¼šåç¼€ä¸º robytes çš„èµ„æº   åŸºç±»ä¸ºï¼šABBaseFilter\nç›´æ¥ copy çš„èµ„æºï¼šéŸ³é¢‘ã€è§†é¢‘ã€Resources\\QualitySetting å’Œ MiniStringPool ä¸­çš„ json æ–‡ä»¶åŸºç±»ä¸ºï¼šABCopyBaseFilterã€‚ä»–çš„åŸºç±»ä¸ºï¼šABBaseFilter\n\n\nFiltersï¼šå°†è¦å¤„ç†çš„èµ„æºåˆ—è¡¨ã€‚ æ‰€æœ‰çš„èµ„æºéƒ½ä¼šç”¨ ABFilter æ•°æ®ç»“æ„å­˜å‚¨\n\næ‰“ AB æµç¨‹\nXbuildABï¼šæ‰“ AB çš„æ¥å£æ–‡ä»¶ï¼Œè¿™é‡Œå¯ä»¥çœ‹åˆ°æ‰“ AB çš„å„ä¸ªæ­¥éª¤\nXABContainerï¼šç®¡ç†æ‰€æœ‰çš„ XABItem\nXABItemï¼šAB çš„æœ€å°å•ä½ï¼Œä¸€ä¸ªå°çš„èµ„æºå¯¹åº”ä¸€ä¸ª XABItem å®ä¾‹ã€‚ä½†å¹¶ä¸æ˜¯æ‰€æœ‰çš„éƒ½ä¼šå¯¼å‡º\n\næ­¥éª¤\n\né€šè¿‡ XABContainer ç”Ÿæˆ filter ä¸­çš„æ–‡ä»¶å¯¹åº”çš„ XABItem ç±»ï¼Œåˆåˆ†ä¸ºä¸‰ç±»ï¼š\næ™®é€š AB\nAtlas å›¾é›†\nShaderï¼Œå°†æ‰€æœ‰ Shader æ‰“æˆäº†ä¸€ä¸ª ABï¼Œab åå­—ä¸º shader çš„è·Ÿæ–‡ä»¶å¤¹è·¯å¾„çš„ hash\n\n\nåˆ†æä¾èµ–\nåˆ†ææ­¥éª¤ä¸€ä¸­ç”Ÿæˆçš„æ‰€æœ‰ XABItem çš„ä¾èµ–å…³ç³»ï¼Œä»è€Œæ‰¾åˆ°æ‰€æœ‰å¯èƒ½è¢«æ‰“æˆ AB çš„èµ„æºï¼Œå¹¶è®°ä¸‹æ¥å…¶å‰åä¾èµ–å…³ç³»ï¼ˆæˆ‘ä¾èµ–äº†å“ªäº›ï¼Œå“ªäº›ä¾èµ–äº†æˆ‘ï¼Œè¦æ±‚ä¸èƒ½å¾ªç¯å¼•ç”¨ï¼‰\nç¡®å®šéœ€è¦å¯¼å‡ºçš„ AB åˆ—è¡¨ï¼Œæ˜¯å¦å¯¼å‡ºæ ¹æ®å¦‚ä¸‹è§„åˆ™\nAsset = 1  // æ™®é€šç´ æï¼Œè¢«æ ¹ç´ æä¾èµ–çš„ï¼Œè·Ÿéšå…¶æ ¹ç´ æåˆ°ä¸€ä¸ª AB ä¸­\nRoot = 1 &lt;&lt; 1 // æ ¹ï¼Œåªæœ‰ filter ä¸­æŒ‡å®šçš„æ‰ä¼šæ˜¯æ ¹ï¼Œä¼šè¢«å•ç‹¬æ‰“æˆ AB\nStandalone = 1 &lt;&lt; 2 // è¢«ä¸¤ä¸ªæˆ–è€…ç¦»ä¸¤ä¸ªä»¥ä¸Šç´ æå¼•ç”¨çš„ä¼šè¢«å•ç‹¬æ‰“æˆ AB\n\n\n\n\nå¯¼å‡º AB\nå¯¼å‡ºçš„ AB åœ¨ roab è¿™ä¸ªå·¥ç¨‹ç›®å½•ä¸­\nå…ˆæ‰“å›¾é›†çš„ ABï¼Œå†æ‰“éå›¾é›†çš„ã€‚å›¾é›†è¦EditorSettings.spritePackerMode = SpritePackerMode.AlwaysOnAtlasï¼Œéå›¾é›†è¦è®¾ç½®ä¸ºSpritePackerMode.Disabled\nå‹ç¼©ç®—æ³•é€‰äº† lz4, ç§»åŠ¨ç«¯ &amp;PC ç«¯å…³é—­ typetree, ä¸ºäº†çƒ­æ›´çš„éœ€è¦è®¾ç½®äº†DeterministicAssetBundle\næ„å»º AssetBundleBuild çš„æ—¶å€™ï¼Œåœºæ™¯æ–‡ä»¶ä¸ç”¨è®°å½•æ‰€æœ‰ä¾èµ–ï¼ŒUnity ä¼šè‡ªåŠ¨åš\n\n\nå†™å…¥ dep.all æ–‡ä»¶\nAB ä¸­åŒ…å«çš„èµ„æºåˆ—è¡¨ã€‚å®é™…æµ‹ä¸‹æ¥ï¼Œåªæœ‰ shader æœ‰å¤šä¸ªï¼Œå…¶ä½™çš„éƒ½æ˜¯åªæœ‰ä¸€ä¸ª\nAB çš„ hash å€¼\nAB çš„ç±»å‹\néœ€è¦ä¾èµ–çš„ AB æ•°é‡åŠåˆ—è¡¨\n\n\nåˆ é™¤å†—ä½™çš„ ABï¼ˆç»™å¢é‡ bundle ä½¿ç”¨ï¼‰\nå…ˆä»å…¶ä»–ç›®å½•æ‹·è´ ABï¼ˆèµ„æºä¼šæœ‰åˆ é™¤çš„ï¼‰\nå†æ‰“å¢é‡ AB\nåˆ¤æ–­æ²¡æœ‰ç”¨çš„ AB éœ€è¦åˆ é™¤æ‰\n\n\nBytes\nç¿»è¯‘\nå…¶ä»–é…ç½®æ–‡ä»¶\nç›´æ¥æ‹·è´\n\n\nè„šæœ¬\né€šè¿‡ luajit å°†ã€‚lua æ–‡ä»¶å¤„ç†æˆäºŒè¿›åˆ¶æ–‡ä»¶\n\n\nå…¶ä»–èµ„æº\n\n\n_analyze_step == 0ï¼šå¼€å§‹åˆ†æ_analyze_step == 1ï¼šå­˜åœ¨å¾ªç¯ä¾èµ–ï¼ˆA â†’ B â†’ A æˆ– A â†’ B â†’ C â†’ Aï¼‰ï¼Œç›´æ¥æŠ›å‡ºå¼‚å¸¸_analyze_step == 2ï¼šå·²ç»åˆ†æè¿‡\n\nè¯»è¡¨  è¯»å–æ•´è¡¨function GetTable()    local l_tables = {}    if l_tablePtr ~= nil then        for i=1, l_tableSize do            table.insert(l_tables, GetRow(i))        end\telse        logError(\"SkillTable l_tablePtr is nil\")    end    return l_tablesend\n\nè¯»å–ä¸€è¡Œ\nROGameLibs.TableDataLuaProxy:GetRowIDByINT\n\nHash/// &lt;sumarry&gt;/// ä¸æ–­åœ°ä¹˜ 33 ï¼ˆ(hash &lt;&lt; 5) + hashï¼‰/// &lt;/summary&gt;public static uint GetHash(string str){    if (str == null) return 0;    uint hash = 0;    for (int i = 0; i &lt; str.Length; i++&gt;)    {        hash = (hash &lt;&lt; 5) + hash + str[i];    }    return hash;}","categories":["æ¸¸æˆå¼€å‘"],"tags":["è¡Œä¸ºæ ‘","å‰§æƒ…è„šæœ¬","èµ„æºç®¡ç†"]},{"title":"é¢ç»","url":"/2024/05/13/51/","content":"æ³¢å…‹åŸå¸‚  åç¨‹æ˜¯å¦å…±äº«å †æ ˆ\nè¿›ç¨‹æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„å †å’Œæ ˆï¼Œæ—¢ä¸å…±äº«å †ï¼Œäº¦ä¸å…±äº«æ ˆï¼Œè¿›ç¨‹ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦\nçº¿ç¨‹æ‹¥æœ‰è‡ªå·±ç‹¬ç«‹çš„æ ˆå’Œå…±äº«çš„å †ï¼Œå…±äº«å †ï¼Œä¸å…±äº«æ ˆï¼Œçº¿ç¨‹äº¦ç”±æ“ä½œç³»ç»Ÿè°ƒåº¦ï¼ˆæ ‡å‡†çº¿ç¨‹æ˜¯çš„ï¼‰\nåç¨‹å’Œçº¿ç¨‹  ä¸€æ ·å…±äº«å †ï¼Œä¸å…±äº«æ ˆï¼Œåç¨‹ç”±ç¨‹åºå‘˜åœ¨åç¨‹çš„ä»£ç é‡Œæ˜¾ç¤ºè°ƒåº¦\n\né€æ˜ç‰©ä½“ä½äº Unity å“ªä¸ªæ¸²æŸ“é˜¶æ®µ  å·²çŸ¥æ³•å‘çº¹ç†ï¼Œå¦‚ä½•è¿˜åŸæ³•çº¿å‘é‡  å¦‚ä½•è®¡ç®— MipMap ä¸ªæ•°  æè¿° Blooming æ–¹æ³•  å¦‚ä½•è§£å†³ AssetBundle ä¾èµ– B ç«™ å›¾é›†æ˜¯æ€æ ·ç”Ÿæˆçš„  èµ„æºåŠ è½½ Unity AssetDatabase å’ŒResourcesèµ„æºç®¡ç†Unity å¸¸ç”¨çš„èµ„æºå¤§æ¦‚æœ‰ä»¥ä¸‹å‡ ç±»ï¼š\n\nçº¯èµ„æºï¼ˆmaterialï¼Œtextureï¼Œshaderï¼Œaudioï¼Œâ€¦ï¼‰è¿™äº›èµ„æºä¸èƒ½ç›´æ¥æ‹–åˆ°åœºæ™¯é‡Œä½¿ç”¨\né¢„ç½®ï¼ˆprefabï¼‰ï¼Œè¿™ç§èµ„æºéœ€è¦å®ä¾‹åŒ–ä¹‹åæ‰èƒ½ä½¿ç”¨\nscene ä¹Ÿæ˜¯ä¸€ç§èµ„æº\nè„šæœ¬å¯¹è±¡ï¼Œæ–‡æœ¬æ–‡ä»¶ï¼Œunity è‡ªå·±å†…ç½®çš„èµ„æºï¼ˆåƒæ–°å»ºç²’å­æ—¶çš„é»˜è®¤æè´¨ä¹‹ç±»çš„ï¼‰\n\nUnity ç®¡ç†è¿™äº›èµ„æºåˆ†ä¸ºä¸¤ç§ï¼š\n\nåœ¨ç¼–è¾‘å™¨å†…ç®¡ç†ï¼Œä½¿ç”¨ AssetDatabase åŠ è½½å¸è½½èµ„æº\nåœ¨ç¼–è¾‘å™¨å†…åŠ è½½å¸è½½èµ„æºï¼Œå¹¶ä¸èƒ½åœ¨æ¸¸æˆå‘å¸ƒæ—¶ä½¿ç”¨ï¼Œå®ƒåªèƒ½åœ¨ç¼–è¾‘å™¨å†…ä½¿ç”¨ã€‚ä½†æ˜¯ï¼Œå®ƒåŠ è½½é€Ÿåº¦å¿«ï¼Œæ•ˆç‡é«˜ï¼Œé€‚åˆåœ¨æµ‹è¯•æ—¶ä½¿ç”¨\n\n\nè¿è¡Œæ—¶ç®¡ç†ï¼Œç®€å•åŒ–ä½¿ç”¨Resourcesï¼Œå¤æ‚åŒ–ä½¿ç”¨ AssetBundle\nåœ¨è¿è¡Œæ—¶ç®¡ç†èµ„æºï¼Œç®€å•çš„æ–¹æ³•å°±æ˜¯ä½¿ç”¨ Resources æ¥å£ã€‚è¿™ç§æ–¹å¼æ§åˆ¶èµ„æºçš„ç®¡ç†æ•ˆç‡é«˜ï¼Œèµ„æºéœ€è¦æ”¾åœ¨ Resources æ–‡ä»¶å¤¹ä¸‹ã€‚è¿™å°±è¯´æ˜ Unity åœ¨æ‰“åŒ…æ—¶åªä¼šæ‰“åŒ… Resources æ–‡ä»¶å¤¹ä¸‹çš„èµ„æºåˆ°ç»ˆç«¯ä¸Šã€‚ åŠ è½½è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹çš„èµ„æºä¸éœ€è¦æ‰©å±•åã€‚æœ€å¥½ä¸è¦å»ºç«‹å¤šä¸ª Resources æ–‡ä»¶å¤¹ï¼Œå¦åˆ™ Unity å¯èƒ½ä¼šä¸çŸ¥é“è¦åŠ è½½å“ªä¸€ä¸ª\n\n\n\nå çº¸ä¸€é¢ C# è°ƒç”¨ Lua GC æ˜¯å¦‚ä½•äº§ç”Ÿçš„ï¼Œå¦‚ä½•é¿å… GCUGUI è‡ªé€‚åº”å¤§å° å¦‚ä½•é¿å…è£…ç®±æ‹†ç®± Lua å…ƒè¡¨æ˜¯ä»€ä¹ˆ åŸè¡¨æ˜¯ Lua ä¸­å…ƒè¡¨ï¼ˆMetatableï¼‰çš„ä¸€ç§ç‰¹æ®Šç±»å‹ã€‚å…ƒè¡¨æ˜¯ä¸€ç§å¯é€‰çš„é™„åŠ åˆ°è¡¨ä¸Šçš„è¡¨ï¼Œç”¨äºæ§åˆ¶è¡¨çš„è¡Œä¸ºã€‚å½“æˆ‘ä»¬è¿›è¡Œç‰¹å®šçš„æ“ä½œæ—¶ï¼Œä¾‹å¦‚è®¿é—®è¡¨ä¸­ä¸å­˜åœ¨çš„é”®ã€è¿›è¡Œç®—æœ¯è¿ç®—æˆ–æ¯”è¾ƒç­‰ï¼ŒLua ä¼šåœ¨å…ƒè¡¨ä¸­æŸ¥æ‰¾ç›¸åº”çš„å…ƒæ–¹æ³•å¹¶æ‰§è¡Œç›¸å…³çš„æ“ä½œã€‚\nå…ƒè¡¨é€šè¿‡å®šä¹‰å…ƒæ–¹æ³•æ¥å®šä¹‰ç‰¹å®šæ“ä½œçš„è¡Œä¸ºã€‚å…ƒæ–¹æ³•æ˜¯ä¸€ç»„é¢„å®šä¹‰çš„å‡½æ•°ï¼Œä»¥ç‰¹å®šçš„é”®å­˜å‚¨åœ¨å…ƒè¡¨ä¸­ã€‚å½“æ‰§è¡Œç›¸å…³æ“ä½œæ—¶ï¼ŒLua ä¼šæ£€æŸ¥å…ƒè¡¨ä¸­æ˜¯å¦å­˜åœ¨å¯¹åº”çš„å…ƒæ–¹æ³•ï¼Œå¹¶æ ¹æ®å…ƒæ–¹æ³•çš„å®šä¹‰æ¥å¤„ç†æ“ä½œã€‚\nä»¥ä¸‹æ˜¯ä¸€äº›å¸¸è§çš„å…ƒæ–¹æ³•åŠå…¶å¯¹åº”çš„æ“ä½œï¼š\n\n__indexï¼šè¯¥å…ƒæ–¹æ³•ç”¨äºå¤„ç†å½“è®¿é—®è¡¨ä¸­ä¸å­˜åœ¨çš„é”®æ—¶çš„è¡Œä¸ºã€‚å½“ Lua æ— æ³•åœ¨è¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é”®æ—¶ï¼Œå®ƒä¼šæŸ¥æ‰¾å…ƒè¡¨ä¸­çš„__index å…ƒæ–¹æ³•ã€‚å¦‚æœå­˜åœ¨ï¼ŒLua ä¼šè°ƒç”¨è¯¥å…ƒæ–¹æ³•ï¼Œå¹¶å°†è¡¨å’Œè¢«è®¿é—®çš„é”®ä½œä¸ºå‚æ•°ä¼ é€’ç»™å®ƒã€‚è¯¥å…ƒæ–¹æ³•å¯ä»¥è¿”å›ä¸€ä¸ªå€¼æ¥ä½œä¸ºè®¿é—®çš„ç»“æœï¼Œæˆ–è€…å¯ä»¥æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä»¥ä¾¿è¿›è¡Œè¿›ä¸€æ­¥çš„æ“ä½œã€‚\n__newindexï¼šè¯¥å…ƒæ–¹æ³•ç”¨äºå¤„ç†å½“å¯¹è¡¨ä¸­ä¸å­˜åœ¨çš„é”®è¿›è¡Œèµ‹å€¼æ—¶çš„è¡Œä¸ºã€‚å½“ Lua æ— æ³•åœ¨è¡¨ä¸­æ‰¾åˆ°å¯¹åº”çš„é”®æ—¶ï¼Œå®ƒä¼šæŸ¥æ‰¾å…ƒè¡¨ä¸­çš„__newindex å…ƒæ–¹æ³•ã€‚å¦‚æœå­˜åœ¨ï¼ŒLua ä¼šè°ƒç”¨è¯¥å…ƒæ–¹æ³•ï¼Œå¹¶å°†è¡¨ã€è¢«èµ‹å€¼çš„é”®å’Œèµ‹äºˆçš„å€¼ä½œä¸ºå‚æ•°ä¼ é€’ç»™å®ƒã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¯¥å…ƒæ–¹æ³•ä¸­è‡ªå®šä¹‰å¤„ç†é€»è¾‘ï¼Œä¾‹å¦‚æ•è·èµ‹å€¼æ“ä½œå¹¶æ‰§è¡Œè‡ªå®šä¹‰çš„æ“ä½œæˆ–è€…æŠ›å‡ºé”™è¯¯ã€‚\n__addã€__subã€__mulã€__divç­‰ï¼šè¿™äº›å…ƒæ–¹æ³•ç”¨äºé‡è½½è¡¨çš„ç®—æœ¯è¿ç®—ç¬¦ã€‚å½“è¿›è¡Œç›¸åº”çš„ç®—æœ¯è¿ç®—æ—¶ï¼ŒLua ä¼šæŸ¥æ‰¾å…ƒè¡¨ä¸­å¯¹åº”çš„å…ƒæ–¹æ³•ï¼Œå¹¶æ ¹æ®å…ƒæ–¹æ³•çš„å®šä¹‰æ¥æ‰§è¡Œè‡ªå®šä¹‰çš„æ“ä½œã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›å…ƒæ–¹æ³•ä¸­å®ç°è‡ªå®šä¹‰çš„ç®—æœ¯è¿ç®—é€»è¾‘ã€‚\n__eqã€__ltã€__leï¼šè¿™äº›å…ƒæ–¹æ³•ç”¨äºé‡è½½è¡¨çš„æ¯”è¾ƒè¿ç®—ç¬¦ã€‚å½“è¿›è¡Œç›¸åº”çš„æ¯”è¾ƒæ“ä½œæ—¶ï¼ŒLua ä¼šæŸ¥æ‰¾å…ƒè¡¨ä¸­å¯¹åº”çš„å…ƒæ–¹æ³•ï¼Œå¹¶æ ¹æ®å…ƒæ–¹æ³•çš„å®šä¹‰æ¥æ‰§è¡Œè‡ªå®šä¹‰çš„æ¯”è¾ƒé€»è¾‘ã€‚æˆ‘ä»¬å¯ä»¥åœ¨è¿™äº›å…ƒæ–¹æ³•ä¸­å®ç°è‡ªå®šä¹‰çš„æ¯”è¾ƒé€»è¾‘ã€‚è¦å°†å…ƒè¡¨å…³è”åˆ°è¡¨ä¸Šï¼Œæˆ‘ä»¬ä½¿ç”¨ setmetatable å‡½æ•°ã€‚é€šè¿‡å°†è¡¨ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°ï¼Œå…ƒè¡¨ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°ä¼ é€’ç»™ setmetatable å‡½æ•°ï¼Œå³å¯å°†å…ƒè¡¨å…³è”åˆ°è¡¨ä¸Šã€‚\n\nåŸè¡¨çš„åº”ç”¨éå¸¸å¹¿æ³›ï¼Œå¯ä»¥ç”¨äºå®ç°é¢å‘å¯¹è±¡çš„ç‰¹æ€§ï¼Œä¾‹å¦‚ç»§æ‰¿ã€å¤šæ€ç­‰ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡å®šä¹‰å…ƒæ–¹æ³•æ¥è‡ªå®šä¹‰å¯¹è±¡çš„è¡Œä¸ºï¼ŒåŒæ—¶è¿˜å¯ä»¥é€šè¿‡åŸè¡¨æ¥å®ç°ä¸€äº›é«˜çº§åŠŸèƒ½ï¼Œå¦‚ä»£ç†ï¼ˆProxyï¼‰ã€å±æ€§è®¿é—®ã€äº‹ä»¶è§¦å‘ç­‰ã€‚é€šè¿‡å®šä¹‰é€‚å½“çš„å…ƒæ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥æ‹¦æˆªå’Œé‡å®šä¹‰å¯¹è¡¨çš„æ“ä½œï¼Œä»è€Œå®ç°å„ç§å®šåˆ¶åŒ–çš„è¡Œä¸ºã€‚\nä»¥ä¸‹æ˜¯ä¸€ä¸ªæ›´å…·ä¸“ä¸šæ€§çš„ç¤ºä¾‹ï¼Œæ¼”ç¤ºäº†å¦‚ä½•ä½¿ç”¨åŸè¡¨æ¥å®ç°ä»£ç†æ¨¡å¼ï¼š\n-- åŸå§‹å¯¹è±¡local realObject = {  value = 42,  getName = function(self)    return \"Real Object\"  end}-- ä»£ç†å¯¹è±¡local proxyObject = {  value = 0,  getName = function(self)    return \"Proxy Object\"  end}-- å®šä¹‰ä»£ç†çš„å…ƒè¡¨local proxyMetatable = {  __index = function(table, key)    -- å½“è®¿é—®å€¼æ—¶ï¼Œä»£ç†è¿”å›ä»£ç†å¯¹è±¡çš„å€¼    if key == \"value\" then      return table.value    end    -- å½“è°ƒç”¨æ–¹æ³•æ—¶ï¼Œä»£ç†è¿”å›åŸå§‹å¯¹è±¡çš„æ–¹æ³•    if key == \"getName\" then      return realObject.getName    end  end,  __newindex = function(table, key, value)    -- ä»£ç†åªå…è®¸ä¿®æ”¹ä»£ç†å¯¹è±¡çš„å€¼ï¼Œè€Œä¸å½±å“åŸå§‹å¯¹è±¡    if key == \"value\" then      table.value = value    end  end}\n\nTimeLine å’Œ AnimatorAnimator æ˜¯ç»„ä»¶ï¼Œè€Œ Timeline æ˜¯èµ„äº§\nAnimator è¿™ä¸ªç»„ä»¶ï¼Œæ˜¯ç”¨æ¥å®ç°â€œä½¿ç”¨æŸç§åŠ¨ç”»æ•°æ®æ¥é©±åŠ¨æ‰€åœ¨ GameObject åŠå…¶å­ç‰©ä½“çš„å„ç§å‚æ•°éšæ—¶é—´æ¨ç§»è€Œå‘ç”Ÿå˜åŒ–â€è¿™ä¸€åŠŸèƒ½çš„ã€‚æ¯”å¦‚ï¼šAnimator å‘Šè¯‰ Transform ç»„ä»¶å°† position å’Œ rotation è®¾ç½®åˆ°æŸä¸€ä¸ªæ•°å€¼ï¼Œè€Œè¿™ä¸ªæ•°å€¼çš„æ¥æºå°±æ˜¯æˆ‘ä»¬çš„åŠ¨ç”»ç‰‡æ®µï¼ˆAnimation clipï¼Œä¹Ÿå°±æ˜¯ã€‚anim æ–‡ä»¶èµ„äº§ï¼‰\nä½† Animator è¿™ä¸ªç»„ä»¶å¹¶ä¸ç›´æ¥è¯»å–ã€‚anim èµ„äº§çš„æ•°æ®ï¼Œè€Œæ˜¯é€šè¿‡ Animator Controller èµ„äº§æ¥é—´æ¥è·å–ã€‚Animator Controller æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œå¯ä»¥è®¾ç½®ä¸€ç³»åˆ—å‚æ•°æ¥æ§åˆ¶å¤šä¸ªå¤šä¸ªåŠ¨ç”»ç‰‡æ®µä¹‹é—´çš„èåˆè¿‡æ¸¡ã€‚æœ‰äº† Animator Controller çš„å‚ä¸ï¼ŒAnimator ç»„ä»¶å°±ä¸éœ€è¦ç›´æ¥æ§åˆ¶å¾ˆå¤šå¾ˆå¤šçš„åŠ¨ç”»ç‰‡æ®µäº†ï¼ˆç‰¹åˆ«ç‰¹åˆ«éº»çƒ¦ï¼‰ï¼Œåªéœ€è¦æ§åˆ¶ç›¸åº”çš„â€œå‚æ•°â€å°±å¯ä»¥è¾¾åˆ°æ§åˆ¶å¾ˆå¤šåŠ¨ç”»ç‰‡æ®µä¹‹é—´çš„èåˆè¿‡æ¸¡çš„ç›®çš„\nAnimator Controller æ˜¯ç”¨æ¥æ•´åˆã€‚anim æ•°æ®çš„èµ„äº§ï¼ŒTimeline ä¸€å®šç¨‹åº¦ä¸Šä¹Ÿæ˜¯ã€‚Timeline çš„ Animation Track åšåˆ°äº‹æƒ…ï¼Œå°±æ˜¯å°†å¤šä¸ªåŠ¨ç”»ç‰‡æ®µæŒ‰æ—¶é—´é¡ºåºè¿æ¥èµ·æ¥ï¼ˆä½ å¯ä»¥æŠŠ Timeline ç†è§£æˆä¸€ä¸ªéçº¿æ€§åŠ¨ç”»ç¼–è¾‘å™¨ï¼‰ï¼Œè¿™æ ·æˆ‘ä»¬å°±ä¸éœ€è¦æ‰‹åŠ¨æ§åˆ¶è¿™äº›åŠ¨ç”»ç‰‡æ®µçš„æ’­æ”¾æ—¶é—´ï¼Œåªéœ€è¦åœ¨éœ€è¦çš„æ—¶å€™æ’­æ”¾ Timeline å³å¯ã€‚å½“ç„¶ï¼Œä½¿ç”¨ Animator Controller ä¹Ÿèƒ½è¾¾åˆ°ç±»ä¼¼çš„ç›®çš„ï¼Œæ¯”å¦‚å°†å¤šä¸ªç‰‡æ®µâ€œä¸²èµ·æ¥â€ï¼Œä½† Timeline çš„æ•´åˆæ˜¾ç„¶æ›´ç›´è§‚æ›´å¥½ç”¨\nAnimator å¦‚ä½•è§£å†³å¸§æ•°å†²çª Lua æ’å…¥å“ˆå¸Œè¡¨è¿˜æ˜¯æ•°ç»„readonly å’ŒconståŒºåˆ«\nconstä¿®é¥°ç¬¦\nåˆå§‹åŒ–æ—¶æœºï¼šç¼–è¯‘æ—¶ï¼Œå³ç¼–è¯‘ç¨‹åºæ—¶å°†å€¼å·²ç»åµŒå…¥ä»£ç ä¸­ï¼›\nå€¼çŠ¶æ€ï¼šä¸å…è®¸åŠ¨æ€ä¿®æ”¹\nä¿®é¥°èŒƒå›´ï¼šå­—æ®µã€å±€éƒ¨å˜é‡\nä¸»è¦åº”ç”¨åœºæ™¯ï¼šä¸»è¦åº”ç”¨äºç¨‹åºè¿è¡Œä¸­ä¸éœ€è¦æ”¹å˜çš„å˜é‡çš„å€¼ï¼Œæ¯”å¦‚æ•°å­¦ç¬¦å· PIï¼›\n\n\nstaticä¿®é¥°ç¬¦\nåˆå§‹åŒ–æ—¶æœºï¼šè¿è¡Œæ—¶ï¼Œå¯ä»¥å£°æ˜æ—¶èµ‹å€¼ï¼Œä¹Ÿå¯ä»¥åœ¨æ„é€ å‡½æ•°ï¼Œæˆ–ä½¿ç”¨æ—¶èµ‹å€¼\nå€¼çŠ¶æ€ï¼šå…è®¸ä¿®æ”¹\nä¿®é¥°èŒƒå›´ï¼šç±»ã€å­—æ®µã€å±æ€§ã€æ–¹æ³•ã€è¿ç®—ç¬¦ã€äº‹ä»¶ã€æ„é€ å‡½æ•°ï¼ˆä¸èƒ½ç”¨äºç´¢å¼•å™¨ã€ææ„å‡½æ•°æˆ–ç±»ä»¥å¤–çš„ç±»å‹ï¼‰\nä¸»è¦åº”ç”¨åœºæ™¯ï¼šä¸»è¦ä½œç”¨äºç±»çš„å…¬å…±å±æ€§\n\n\nreadonlyä¿®é¥°ç¬¦\nåˆå§‹åŒ–æ—¶æœºï¼šè¿è¡Œæ—¶ï¼Œå¯ä»¥å£°æ˜æ—¶èµ‹å€¼æˆ–åœ¨ç±»ä¸­çš„æ„é€ å‡½æ•°ä¸­èµ‹å€¼\nå€¼çŠ¶æ€ï¼šå…è®¸ä¿®æ”¹ï¼Œä½†åªèƒ½åœ¨æ„é€ å‡½æ•°ä¸­ä¿®æ”¹\nä¿®é¥°èŒƒå›´ï¼šå­—æ®µ\nä¸»è¦åº”ç”¨åœºæ™¯ï¼šä¸»è¦ä½œç”¨äºå®ä¾‹åŒ–çš„å¯¹è±¡çš„åªè¯»å±æ€§\n\n\nstatic readonlyä¿®é¥°ç¬¦\nåˆå§‹åŒ–æ—¶æœºï¼šè¿è¡Œæ—¶ï¼Œæ˜¯ä¸¤ä¸ªå…³é”®å­—çš„ç»„åˆ\nå€¼çŠ¶æ€ï¼šå…è®¸ä¿®æ”¹ï¼Œå£°æ˜æ—¶èµ‹å€¼æˆ–è€…é™æ€æ„é€ å‡½æ•°ä¸­èµ‹å€¼\nä¿®é¥°èŒƒå›´ï¼šå­—æ®µ\nä¸»è¦åº”ç”¨åœºæ™¯ï¼š\nå’Œ const ç›¸æ¯”ï¼Œå®ƒä¸»è¦åº”ç”¨äºå¼•ç”¨æ€§å˜é‡ï¼›è€Œ constï¼Œåªèƒ½ç”¨äºstring ç±»å‹çš„å¼•ç”¨æ€§å˜é‡ï¼›\nç±»çš„åªè¯»å…¬å…±å±æ€§  æ€»ç»“ï¼š\n\n\n\n\nconstæ˜¯é™æ€çš„ã€ç¼–è¯‘æœŸå˜é‡ï¼Œåªèƒ½åœ¨å£°æ˜å˜é‡çš„æ—¶å€™èµ‹å€¼ã€‚\nreadonlyæ˜¯è¿è¡Œæ—¶å˜é‡ï¼Œå¯ä»¥åœ¨å£°æ˜çš„æ—¶å€™æˆ–åœ¨æ„é€ å‡½æ•°å†…èµ‹å€¼ã€‚\nstatic readonlyå˜é‡å°±å˜æˆäº†é™æ€çš„ã€ç¼–è¯‘æœŸå˜é‡ã€‚åªèƒ½é™æ€æ„é€ å‡½æ•°ä¸­è¿›è¡Œåˆå§‹åŒ–ã€‚\nåŒæ—¶ static readonly å¯ä»¥ç†è§£ä¸ºæ˜¯æœ€ç®€å•çš„ä¸€ç§å•ä¾‹æ¨¡å¼å®ç°æ–¹å¼ã€‚\nconstæ˜¯é™æ€å¸¸é‡ï¼Œreadonlyæ˜¯åŠ¨æ€å¸¸é‡ã€‚consté«˜æ•ˆï¼Œreadonlyçµæ´»ï¼ä½†å®é™…å¼€å‘ä¸­æˆ‘ä»¬ç»å¸¸ç”¨ static readonly æ¥ä»£æ›¿ const, ä»¥å¹³è¡¡const åœ¨çµæ´»æ€§ä¸Šçš„ä¸è¶³\n\nå çº¸äºŒé¢ Used Total å’Œ Reserved Total åœ¨ Profiler å·¥å…·ä¸­æä¾›äº†ä¸¤ç§æ¨¡å¼ä¾›æˆ‘ä»¬ç›‘æµ‹å†…å­˜çš„ä½¿ç”¨æƒ…å†µï¼Œå³ç®€æ˜“æ¨¡å¼å’Œè¯¦ç»†æ¨¡å¼ã€‚åœ¨ç®€æ˜“æ¨¡å¼ä¸­ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°æ€»çš„å†…å­˜ï¼ˆtotalï¼‰åˆ—å‡ºäº†ä¸¤åˆ—ï¼Œå³ Used Totalï¼ˆä½¿ç”¨æ€»å†…å­˜ï¼‰å’Œ Reserved Totalï¼ˆé¢„å®šæ€»å†…å­˜ï¼‰ã€‚Used Total å’Œ Reserved å‡æ˜¯ç‰©ç†å†…å­˜ï¼Œå…¶ä¸­ Reserved æ˜¯ unity å‘ç³»ç»Ÿç”³è¯·çš„æ€»å†…å­˜ï¼ŒUnity åº•å±‚ä¸ºäº†ä¸ç»å¸¸å‘ç³»ç»Ÿç”³è¯·å¼€è¾Ÿå†…å­˜ï¼Œå¼€å¯äº†è¾ƒå¤§ä¸€å—å†…å­˜ä½œä¸ºç¼“å­˜ï¼Œå³æ‰€è°“çš„ Reserved å†…å­˜ï¼Œè€Œè¿è¡Œæ—¶ï¼Œunity æ‰€ä½¿ç”¨çš„å†…å­˜é¦–å…ˆæ˜¯å‘ Reserved ä¸­æ¥ç”³è¯·å†…å­˜ï¼Œå½“ä¸ä½¿ç”¨æ—¶ä¹Ÿæ˜¯å…ˆå‘ Reserved ä¸­é‡Šæ”¾å†…å­˜ï¼Œä»è€Œæ¥ä¿è¯æ¸¸æˆè¿è¡Œçš„æµç•…æ€§ã€‚ä¸€èˆ¬æ¥è¯´ï¼ŒUsed Total è¶Šå¤§ï¼Œåˆ™ Reserved Total è¶Šå¤§ï¼Œè€Œå½“ Used Total é™ä¸‹å»åï¼ŒReserved Total ä¹Ÿæ˜¯ä¼šéšä¹‹ä¸‹é™çš„ï¼ˆä½†å¹¶ä¸ä¸€å®šä¸ Used Total åŒæ­¥ï¼‰\nå¦‚ä½•å®ç°å†å²è®°å½• EditorWindow ç”Ÿå‘½å‘¨æœŸ\n    \n\n\nAnimation Clipæ•°æ®ç»“æ„  åç¨‹çš„åŸç† yield å’ŒIEnumeratorä»€ä¹ˆå…³ç³» yield æ˜¯ C# çš„å…³é”®å­—ï¼Œå…¶å®å°±æ˜¯å¿«é€Ÿå®šä¹‰è¿­ä»£å™¨çš„è¯­æ³•ç³–ã€‚åªè¦æ˜¯ yield å‡ºç°åœ¨å…¶ä¸­çš„æ–¹æ³•å°±ä¼šè¢«ç¼–è¯‘å™¨è‡ªåŠ¨ç¼–è¯‘æˆä¸€ä¸ªè¿­ä»£å™¨ï¼Œå¯¹äºè¿™æ ·çš„å‡½æ•°å¯ä»¥ç§°ä¹‹ä¸ºè¿­ä»£å™¨å‡½æ•°ã€‚è¿­ä»£å™¨å‡½æ•°çš„è¿”å›å€¼å°±æ˜¯è‡ªåŠ¨ç”Ÿæˆçš„è¿­ä»£å™¨ç±»çš„ä¸€ä¸ªå¯¹è±¡\nè¯•è¯•æƒ³è±¡å¦‚æœæ²¡æœ‰ yield å…³é”®å­—ï¼Œæˆ‘ä»¬æ¯å®šä¹‰ä¸€ä¸ªè¿­ä»£å™¨ï¼Œå°±è¦åˆ›å»ºä¸€ä¸ªç±»ï¼Œå®ç° IEnumerator æ¥å£ï¼Œæ¥å£åŒ…å«çš„å±æ€§ä¸æ–¹æ³•éƒ½è¦æ­£ç¡®çš„å®ç°ï¼Œæ˜¯ä¸æ˜¯å¾ˆéº»çƒ¦ï¼Ÿè€Œåˆ©ç”¨ yield å…³é”®å­—ï¼Œåªéœ€è¦ä¸‹é¢ç®€å•çš„å‡ è¡Œä»£ç ï¼Œå°±å¯ä»¥å¿«é€Ÿå®šä¹‰ä¸€ä¸ªè¿­ä»£å™¨ã€‚è¯¸å¦‚è¿­ä»£å™¨ç±»çš„åˆ›å»ºï¼ŒIEnumeratoræ¥å£çš„å®ç°å·¥ä½œç¼–è¯‘å™¨é€šé€šå¸®ä½ åšäº†\n// ç”±è¿­ä»£å™¨å‡½æ•°å®šä¹‰çš„è¿­ä»£å™¨IEnumerator Test(){    yield return 1;    Debug.Log(\"Surprise\");    yield return 3;    yield break;    yield return 4;}\n\nUnity åç¨‹æœºåˆ¶çš„å®ç°åŸç†  åç¨‹æ˜¯ä¸€ç§æ¯”çº¿ç¨‹æ›´è½»é‡çº§çš„å­˜åœ¨ï¼Œåç¨‹å¯å®Œå…¨ç”±ç”¨æˆ·ç¨‹åºæ§åˆ¶è°ƒåº¦ã€‚åç¨‹å¯ä»¥é€šè¿‡ yield æ–¹å¼è¿›è¡Œè°ƒåº¦è½¬ç§»æ‰§è¡Œæƒï¼Œè°ƒåº¦æ—¶è¦èƒ½å¤Ÿä¿å­˜ä¸Šä¸‹æ–‡ï¼Œåœ¨è°ƒåº¦å›æ¥çš„æ—¶å€™è¦èƒ½å¤Ÿæ¢å¤ã€‚è¿™æ˜¯ä¸æ˜¯å’Œä¸Šé¢â€œåœä½â€ä»£ç ç„¶ååˆåŸä½æ¢å¤çš„æ‰§è¡Œæ•ˆæœå¾ˆåƒï¼Ÿæ²¡é”™ï¼ŒUnity å®ç°åç¨‹çš„åŸç†ï¼Œå°±æ˜¯é€šè¿‡ yield return ç”Ÿæˆçš„ IEnumerator å†é…åˆæ§åˆ¶ä½•æ—¶è§¦å‘ MoveNext æ¥å®ç°äº†æ‰§è¡Œæƒçš„è°ƒåº¦\nå…·ä½“è€Œè¨€ï¼ŒUnity æ¯é€šè¿‡ MonoBehaviour.StartCoroutine å¯åŠ¨ä¸€ä¸ªåç¨‹ï¼Œå°±ä¼šè·å¾—ä¸€ä¸ª IEnumeratorï¼ˆStartCoroutine çš„å‚æ•°å°±æ˜¯ IEnumeratorï¼Œå‚æ•°æ˜¯æ–¹æ³•åçš„é‡è½½ç‰ˆæœ¬ä¹Ÿä¼šé€šè¿‡åå°„æ‹¿åˆ°è¯¥æ–¹æ³•å¯¹åº”çš„IEnumeratorï¼‰ã€‚å¹¶åœ¨å®ƒçš„æ¸¸æˆå¾ªç¯ä¸­ï¼Œæ ¹æ®æ¡ä»¶åˆ¤æ–­æ˜¯å¦è¦æ‰§è¡ŒMoveNext æ–¹æ³•ã€‚è€Œè¿™ä¸ªæ¡ä»¶å°±æ˜¯æ ¹æ® IEnumerator çš„Currentå±æ€§è·å¾—çš„ï¼Œå³ yield return è¿”å›çš„å€¼ã€‚\nåœ¨å¯åŠ¨ä¸€ä¸ªåç¨‹æ—¶ï¼ŒUnity ä¼šå…ˆè°ƒç”¨å¾—åˆ°çš„ IEnumerator çš„MoveNextä¸€æ¬¡ï¼Œä»¥æ‹¿åˆ° IEnumerator çš„Currentå€¼ã€‚æ‰€ä»¥æ¯å¯åŠ¨ä¸€ä¸ªåç¨‹ï¼Œåç¨‹å‡½æ•°ä¼šç«‹å³æ‰§è¡Œåˆ°ç¬¬ä¸€ä¸ª yield return å¤„ç„¶åâ€œåœä½â€ã€‚\nå¯¹äºä¸åŒçš„ Current ç±»å‹ï¼ˆä¸€èˆ¬æ˜¯ YieldInstruction çš„å­ç±»ï¼‰ï¼ŒUnity å·²åšå¥½äº†ä¸€äº›é»˜è®¤å¤„ç†ï¼Œæ¯”å¦‚ï¼š\n\nå¦‚æœ Current æ˜¯nullï¼Œå°±ç›¸å½“äºä»€ä¹ˆä¹Ÿä¸åšã€‚åœ¨ä¸‹ä¸€æ¬¡æ¸¸æˆå¾ªç¯ä¸­ï¼Œå°±ä¼šè°ƒç”¨ MoveNextã€‚æ‰€ä»¥yield return null å°±èµ·åˆ°äº†ç­‰å¾…ä¸€å¸§çš„ä½œç”¨\nå¦‚æœ Current æ˜¯WaitForSecondsç±»å‹ï¼ŒUnity ä¼šè·å–å®ƒçš„ç­‰å¾…æ—¶é—´ï¼Œæ¯æ¬¡æ¸¸æˆå¾ªç¯ä¸­éƒ½ä¼šåˆ¤æ–­æ—¶é—´æ˜¯å¦åˆ°äº†ï¼Œåªæœ‰æ—¶é—´åˆ°äº†æ‰ä¼šè°ƒç”¨ MoveNextã€‚æ‰€ä»¥yield return WaitForSeconds å°±èµ·åˆ°äº†ç­‰å¾…æŒ‡å®šæ—¶é—´çš„ä½œç”¨\nå¦‚æœ Current æ˜¯UnityWebRequestAsyncOperationç±»å‹ï¼Œå®ƒæ˜¯ AsyncOperation çš„å­ç±»ï¼Œè€Œ AsyncOperation æœ‰isDoneå±æ€§ï¼Œè¡¨ç¤ºæ“ä½œæ˜¯å¦å®Œæˆï¼Œåªæœ‰ isDone ä¸ºtrueæ—¶ï¼ŒUnity æ‰ä¼šè°ƒç”¨ MoveNextã€‚å¯¹äº UnityWebRequestAsyncOperation è€Œè¨€ï¼Œåªæœ‰è¯·æ±‚å®Œæˆäº†ï¼Œæ‰ä¼šå°† isDone å±æ€§è®¾ç½®ä¸ºtrueã€‚\n\nä¹Ÿå› æ­¤æˆ‘ä»¬æ‰å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„åŒæ­¥ä»£ç ï¼Œå®Œæˆæœ¬æ¥æ˜¯å¼‚æ­¥çš„ç½‘ç»œè¯·æ±‚æ“ä½œã€‚\nusing(UnityWebRequest webRequest = UnityWebRequest.Get(\"https://www.cnblogs.com/iwiniwin/p/13705456.html\")){    yield return webRequest.SendWebRequest();    if(webRequest.isNetworkError)    {        Debug.Log(\"Error\" + webRequest.error);    }    else    {        Debug.Log(\"Received\" + webRequest.downloadHandler.text);    }}\n\nLua åç¨‹ Lua åç¨‹çš„ç›¸å…³å‡½æ•°å°è£…åœ¨ coroutine ä¸­ï¼Œå¯¹åº”çš„ C API ä¸ºlua_newthreadï¼Œlua_resume ç­‰ã€‚Lua æ–‡æ¡£ä¸­çš„ thread å’Œ coroutine æ˜¯ä¸€ä¸ªæ¦‚å¿µï¼Œä½†ä¸æ“ä½œç³»ç»Ÿçš„çº¿ç¨‹æ˜¯ä¸¤ä¸ªä¸œè¥¿ã€‚C API é€šè¿‡ lua_State ç»´æŠ¤ä¸€ä¸ªåç¨‹çš„çŠ¶æ€ï¼ˆä»¥åŠ Lua è™šæ‹ŸæœºçŠ¶æ€çš„å¼•ç”¨ï¼‰ï¼Œåç¨‹çš„çŠ¶æ€ä¸»è¦æŒ‡åç¨‹ä¸Šä¸‹æ–‡ï¼ˆå¦‚äº¤äº’æ ˆï¼‰ï¼ŒLua è™šæ‹ŸæœºçŠ¶æ€æ˜¯å…¨å±€çš„ï¼Œå¯è¢«å¤šä¸ªåç¨‹å…±äº«\nå½“è°ƒç”¨ lua_newstate æ—¶ï¼Œå®é™…ä¸Šåˆ†ä¸ºä¸¤æ­¥\n\nåˆ›å»ºå¹¶åˆå§‹åŒ–ä¸€ä¸ª Lua è™šæ‹Ÿæœºglobal_State\nåˆ›å»ºä¸€ä¸ªä¸»åç¨‹è¿è¡Œäºè™šæ‹Ÿæœºä¸­ï¼Œå¹¶è¿”å›ä¸»åç¨‹çš„æ‰§è¡Œä¸Šä¸‹æ–‡ LuaState\n\nè°ƒç”¨ lua_newthread æ—¶ï¼Œå°†åœ¨å·²æœ‰ Lua è™šæ‹Ÿæœºä¸Šï¼Œåˆ›å»ºå¦ä¸€ä¸ªåç¨‹æ‰§è¡Œç¯å¢ƒï¼Œè¯¥åç¨‹ä¸å·²æœ‰åç¨‹å…±äº«è™šæ‹ŸæœºçŠ¶æ€ï¼ˆåŒä¸€ä¸ª Lua è™šæ‹Ÿæœºä¸­çš„ä¸åŒåç¨‹å…±äº«global_State)ï¼Œå¹¶è¿”å›æ–°çš„æ‰§è¡Œä¸Šä¸‹æ–‡ã€‚å› æ­¤å°† LuaState ç†è§£ä¸ºåç¨‹æ‰§è¡Œä¸Šä¸‹æ–‡å¯èƒ½æ›´åˆé€‚ï¼ŒLuaState æœ¬èº«ä¹Ÿæ˜¯ä¸€ä¸ªç±»å‹ä¸º thread çš„ GCObjectï¼Œæ— éœ€æ‰‹åŠ¨é‡Šæ”¾\næ¸¸å¡ LoopScrollViewUI æ¡†æ¶ è¡¨æ ¼åŠ è½½  è‰è‰ä¸C# å­—ç¬¦ä¸²ä¼˜åŒ–\nä½¿ç”¨ string.Empty ç»™ä¸€ä¸ªç©ºå­—ç¬¦ä¸²å˜é‡èµ‹åˆå§‹å€¼ï¼ŒString.Emptyæ˜¯ä¸€ä¸ªæŒ‡ä»£ï¼Œè€Œ \"\" æ˜¯å…·ä½“çš„å®ç°\n\nä½¿ç”¨ str.Length == 0 åšç©ºä¸²æ¯”è¾ƒ\n\né¿å…ä¸å¿…è¦çš„å­—ç¬¦ä¸² ToUpperã€ToLower ç±»æ“ä½œ\n\nToUpperã€ToLowerè¿™ç±»æ–¹æ³•å‡ä¼šé‡æ–°ç”Ÿæˆå­—ç¬¦ä¸²å¯¹\nString.Compareå¯å®ç°å¿½ç•¥å­—ç¬¦ä¸²å¤§å°å†™\n\n// ä¸æ¨èçš„å†™æ³•if(s1.ToUpper() == s2.ToUpper())// æ¨èçš„å†™æ³•if(String.Compare(s1, s2, true) == 0)\nç”¨ StringBuilder è¿›è¡Œå­—ç¬¦ä¸²æ‹¼æ¥æ“ä½œ\n\nåˆ›å»º StringBuilder åº”æŒ‡å®šåˆå§‹å¤§å°\n\né¿å…æ»¥ç”¨StringBuilder\n\nç±»ä¼¼ str1 + str2 + str3 + str4 çš„å­—ç¬¦ä¸²æ‹¼æ¥æ“ä½œä¼šè¢«ç¼–è¯‘ä¸º String.Concat(str1, str2, str3, str4)ï¼Œæ•ˆç‡åè€Œé«˜äºStringBuilderã€‚String.Concat ä¼šä¸€æ¬¡æ€§ç¡®å®šå­—ç¬¦ä¸²é•¿åº¦ï¼ŒStringBuilderéœ€è¦åš Resizeï¼Œé€‚ç”¨äºå¤šæ¬¡ç”Ÿæˆstring å¯¹è±¡çš„æƒ…å†µ\n\n\né€šè¿‡ç›´æ¥è®¾ç½® .Length = 0 æ¥åˆå§‹åŒ–StringBuilder\n\nä¸è¦ä½¿ç”¨ .Length = 0 æ¥é‡Šæ”¾ StringBuilder å ç”¨çš„å†…å­˜\n\n\nå›¾ç‰‡å‹ç¼©  æœ¯è¯­\nå†…å­˜ ï¼šä¾‹å¦‚A8R8G8B8 æ ¼å¼ä¸­ä¸€ä¸ªåƒç´ å  4 å­—èŠ‚ï¼Œå¦‚æœæ˜¯ 512x512 åˆ†è¾¨ç‡å†…å­˜å°±å ç”¨512 * 512 * 4B = 1048576B = 1MBï¼Œè¿™ç§å†…å­˜æ¶ˆè€—åœ¨ä½ç«¯è®¾å¤‡ä¸Šæ ¹æœ¬æ— æ³•æ¥å—\nå¸¦å®½ï¼šåœ¨æ¸²æŸ“ 3D åœºæ™¯æ—¶ï¼Œä¼šæœ‰å¤§é‡çš„è´´å›¾è¢«ä¼ è¾“åˆ° GPUï¼Œè‹¥ä¸é™åˆ¶ï¼Œæ€»çº¿å¸¦å®½å¾ˆå¿«å°±ä¼šæˆä¸ºç“¶é¢ˆ\næœ‰æŸï¼šè¡¨ç¤ºå¯¹äºæ¸²æŸ“æ¥è¯´ï¼Œæœ‰æŸå‹ç¼©æ˜¯å¯ä»¥æ¥å—çš„ï¼Œä¸€èˆ¬é€‰æ‹©å‹ç¼©æ ¼å¼æ—¶éœ€è¦åœ¨çº¹ç†è´¨é‡å’Œæ–‡ä»¶å¤§å°ä¸Šå¯»æ±‚ä¸€ä¸ªå¹³è¡¡\nå›ºå®šé€Ÿç‡å‹ç¼©ï¼šå› ä¸º GPU éœ€è¦èƒ½å¤Ÿé«˜æ•ˆçš„éšæœºè®¿é—®ä¸€ä¸ªåƒç´ ï¼Œè¿™æ„å‘³ç€å¯¹ä»»æ„åƒç´ ï¼Œè§£ç é€Ÿåº¦ä¸è¯¥æœ‰å¤ªå¤§çš„å˜åŒ–ã€‚å› æ­¤ï¼Œè§çš„è´´å›¾å‹ç¼©ç®—æ³•éƒ½æ˜¯å›ºå®šé€Ÿç‡å‹ç¼©ã€‚ç›¸åçš„ä¾‹å¦‚ zip åˆ™æ˜¯ä¸€ç§å¯å˜é€Ÿç‡å‹ç¼©\nå‘é‡é‡åŒ–ï¼ˆVector Quantizationï¼ŒVQï¼‰ï¼šæ­¤æŠ€æœ¯åŸç”¨äºèµ„æ–™å‹ç¼©ï¼Œé€è¿‡åˆ†å‰²å¤§æ•°é‡çš„èµ„æ–™ç‚¹ï¼ˆå‡½æ•°ï¼‰ï¼Œè®©æ¯ä¸ªå°ç¾¤é›†éƒ½æœ‰ç›¸åŒçš„èµ„æ–™ç‚¹ï¼Œè€Œè¿™äº›å°ç¾¤é›†çš„æ‰€æœ‰èµ„æ–™å°±ç”±å…¶æ­£ä¸­å¤®çš„ç‚¹ä½œä¸ºä»£è¡¨\nç¼–ç å’Œè§£ç é€Ÿåº¦ï¼šä¸€èˆ¬æ¥è¯´ç¼–ç é€Ÿåº¦æ…¢æ²¡å…³ç³»ï¼Œå› ä¸ºé€šå¸¸çº¹ç†å‹ç¼©åªéœ€è¦åœ¨æ¸¸æˆæ‰“åŒ…æ—¶è¿›è¡Œä¸€æ¬¡ï¼Œå¯¹äºç”¨æˆ·è¿è¡Œæ—¶ä½“éªŒå®Œå…¨æ²¡æœ‰å½±å“ã€‚ä½†è§£ç é€Ÿåº¦å¿…é¡»è¶³å¤Ÿå¿«ï¼Œè€Œä¸”åŸºæœ¬ä¸Šä¸èƒ½å½±å“åˆ°æ¸²æŸ“æ€§èƒ½\nå‹ç¼©æ¯”ï¼šé€šå¸¸ä»¥æ¯”ç‰¹ç‡æˆ–æ¯åƒç´ çš„å¹³å‡æ¯”ç‰¹æ•°ï¼ˆbits per pixelï¼Œbppï¼‰è¡¨ç¤ºï¼Œå¸¸è§çš„ä¸º 2~8bppã€‚ä¸€èˆ¬ RGB åŸç”Ÿçº¹ç†çš„åƒç´ æŒ‡ 24 ä½ï¼Œ4bpp è¡¨ç¤ºæ¯åƒç´ å  4 ä½ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥è®¤ä¸º 4bpp è¡¨ç¤ºå‹ç¼©æ¯”ä¸º 6:1\n\nETCåŸºæœ¬æ€æƒ³  å°†å›¾ç‰‡åˆ†æˆ 4x4 çš„è‹¥å¹²ä¸ªåƒç´ å—ï¼Œæ¯ä¸ªåƒç´ å—æŒ‰ç…§ä¸€å®šè§„åˆ™ç¼–ç æˆä¸ºä¸€ä¸ª 64 ä½ (8 å­—èŠ‚ï¼‰çš„æ•°æ®ï¼Œå¤§æ¦‚çš„æƒ³æ³•æ˜¯è®¡ç®—åƒç´ å—çš„å¹³å‡é¢œè‰²ï¼Œç„¶åè®°å½•è¿™ä¸ªå¹³å‡é¢œè‰²å’Œæ¯ä¸ªåƒç´ ç›¸å¯¹å¹³å‡é¢œè‰²çš„å·®å€¼ï¼Œå¹³å‡é¢œè‰²åªè€—è´¹äº†ä¸€ä¸ªåƒç´ çš„æ•°æ®ï¼Œè€Œå·®å€¼ä¹Ÿå¹¶ä¸è®°å½•å®Œå…¨çœŸå®çš„å·®å€¼ï¼Œè€Œæ˜¯ä»ä¸€ä¸ªå›ºå®šçš„é™æ€æ•°æ®ä¸­æ‰¾åˆ°æœ€æ¥è¿‘çš„å·®å€¼ï¼ˆRGB ä¸‰ä¸ªé€šé“å·®å€¼ä¸€æ ·ï¼‰ï¼Œæ¯ä¸ªåƒç´ åªéœ€è¦è®°å½•å…¶å·®å€¼åœ¨é™æ€æ•°æ®ä¸­çš„ç´¢å¼•å³å¯\n\nå‹ç¼©æ¯”ï¼šå¯¹äº RGB24 å›¾ç‰‡ï¼Œæ¯ä¸ªå—çš„æ•°æ®ç”± 4x4x3 = 48 å­—èŠ‚ï¼Œå‹ç¼©ä¸º 8 å­—èŠ‚ï¼Œå‹ç¼©æ¯”ä¸º 6:1ï¼Œé’ˆå¯¹ Alpha å›¾ç‰‡ï¼Œç”± 4x4x1 = 16 å­—èŠ‚ å‹ç¼©ä¸º 8 å­—èŠ‚ï¼Œæ‰€ä»¥ï¼Œå¯¹äºæ™®é€šçš„ RGBA åˆ†ç¦»ä¸º RGB24 å’Œ Alpha ä¹‹ååˆ†åˆ«è¿›è¡Œ ETC1 å‹ç¼©çš„å›¾ç‰‡ï¼Œæ•´ä½“å‹ç¼©æ¯”ä¸º (48 + 16) : (8 + 8) = 4:1\næ–‡ä»¶å¤´æ•°æ®ï¼šé™¤äº†ç¼–ç åçš„æ•°æ®å—ä¹‹å¤–ï¼Œè¿˜ä¼šå­˜å‚¨ä¸€éƒ¨åˆ†æ–‡ä»¶å¤´æ•°æ®ï¼Œç”¨æ¥è¡¨ç¤ºæ–‡ä»¶çš„ç‰¹å¾ç ã€å®½é«˜ç­‰\n\nåƒç´ å—ç¼–ç æ€æƒ³\nå°† 4x4 çš„åƒç´ å—åˆ†ä¸ºä¸¤ä¸ª 4x2 çš„å­å—ï¼Œæœ‰æ°´å¹³å’Œç«–ç›´ä¸¤ç§åˆ†æ³•ã€‚ä½¿ç”¨ 1 ä½æ•°æ® flipbit æ¥è¡¨ç¤ºæ˜¯å“ªä¸€ç§åˆ†æ³•ï¼Œè¿˜å‰©ä¸‹ 63 ä½æ•°æ®\n\n\n    \n\n\n\nåˆ†åˆ«è®¡ç®—ä¸¤ä¸ªåˆ†å—ä¸­ 8 ä¸ªåƒç´ é¢œè‰²çš„å¹³å‡å€¼ï¼Œæ ¹æ®ä¸¤ä¸ªå—é¢œè‰²å¹³å‡å€¼çš„å·®å€¼ï¼Œç¡®å®šä½¿ç”¨ individual æ¨¡å¼è¿˜æ˜¯ differential æ¨¡å¼ã€‚ä½¿ç”¨ 1 ä½æ•°æ® diffbit æ¥è¡¨ç¤ºæ˜¯å“ªç§æ¨¡å¼ï¼Œè¿˜å‰©ä¸‹ 62 ä½æ•°æ®\nå­˜æ”¾ä¸¤ä¸ªå­å—çš„å¹³å‡é¢œè‰²ä¿¡æ¯ï¼Œindividual æ¨¡å¼ç”¨ R4G4B4 çš„æ ¼å¼åˆ†åˆ«è¡¨ç¤ºä¸¤ä¸ªå­å—çš„å¹³å‡é¢œè‰²ï¼Œdifferential æ¨¡å¼ä½¿ç”¨ R5G5B5 æ ¼å¼è¡¨ç¤ºç¬¬ä¸€ä¸ªå­å—çš„å¹³å‡é¢œè‰²ï¼ŒR3G3B3 æ ¼å¼è¡¨ç¤ºç¬¬äºŒä¸ªå­å—ä¸ç¬¬ä¸€ä¸ªå­å—å¹³å‡é¢œè‰²çš„å·®å€¼ã€‚è¿™é‡Œä½¿ç”¨äº† 8 * 3 = 24 ä½æ•°æ®ï¼Œè¿˜å‰©ä¸‹ 62 - 24 = 38 ä½æ•°æ®\næ‰€æœ‰çš„å›¾ç‰‡å…±äº«ä¸€ä¸ªå…¨å±€çš„æ˜ å°„è¡¨æ•°æ®ï¼Œè¿™ä¸ªæ•°æ®æ˜¯å›ºå®šçš„å…¨å±€é™æ€æ•°æ®ï¼Œå¹¶ä¸ä¼šè¿›å…¥åˆ°ç¼–ç æ•°æ®ä¸­ï¼Œè¿™ä¸ªè¡¨æ˜¯ä¸€ä¸ª 8 x 4 çš„äºŒç»´æ•°ç»„ï¼Œä½¿ç”¨ 3 ä½æ•°è¡¨ç¤ºç¬¬ä¸€ä¸ªå­å—åœ¨æ˜ å°„è¡¨ä¸­æŸ¥è¯¢çš„ç¬¬ä¸€ç»´ç´¢å¼•ï¼Œéœ€è¦ 3 ä½æ¥è¡¨ç¤º 0 - 7 çš„ä¸‹æ ‡ï¼Œç¬¬äºŒä¸ªå­å—åŒæ ·éœ€è¦ 3 ä½æ•°æ¥è¡¨ç¤ºï¼Œè¿˜å‰©ä¸‹ 38 - 3 * 2 = 32 ä½æ•°æ®\n4 x 4 åƒç´ å—ä¸­çš„æ¯ä¸ªåƒç´ ï¼Œä½¿ç”¨ 2 ä½æ•°æ¥è¡¨ç¤ºè¯¥åƒç´ åœ¨æ˜ å°„è¡¨ä¸­æŸ¥è¯¢çš„ç¬¬äºŒç»´ç´¢å¼•ï¼Œéœ€è¦ 2 ä½æ•°æ¥è¡¨ç¤º 0 - 3 çš„ä¸‹æ ‡ï¼Œæ‰€ä»¥æ¶ˆè€—äº† 4 x 4 x 2 = 32 ä½æ•°æ®\n\nå†…å­˜å¸ƒå±€å’Œè§£ç è¿‡ç¨‹  ä»¥ RGB555 åŸºæœ¬è‰²å’Œ RGB3333 é¢œè‰²å·®è¡¨ç¤ºçš„ç¼–ç ä¸ºä¾‹ï¼Œæ¯ä¸ª 4x4 åƒç´ å—ç»è¿‡ ETC1 ç¼–ç åçš„ 64 ä½æ•°æ®çš„å†…å­˜å¸ƒå±€å¤§æ¦‚æ˜¯è¿™æ ·\n\n    \n\n\nå‡å¦‚ç¼–ç å‰åƒç´ å—è¡¨ç¤ºä¸ºä¸‹å›¾ï¼Œéœ€è¦å¾—åˆ°å›¾ä¸­ç¼–å· 2 å¯¹åº”åƒç´ çš„é¢œè‰²ï¼Œéœ€è¦è¿›è¡Œå¦‚ä¸‹çš„è§£ç æ­¥éª¤ï¼š\n\n    \n\n\n\nè·å–ç›®æ ‡æ‰€åœ¨çš„å­å—ï¼šæ ¹æ®ç¬¬ 32 ä½ flipbit æ ‡å¿—ä½ï¼ŒçŸ¥é“è¿™ä¸ªåƒç´ å—é‡‡ç”¨çš„æ˜¯æ¨ªç‰ˆåˆ’åˆ†å­å—ï¼Œ2 å·åƒç´ å¤„åœ¨å­å— 2 ä¸­\nè·å–å­å— 1 åŸºæœ¬é¢œè‰²ï¼šé¦–å…ˆæ ¹æ®ç¬¬ 33 ä½ diffbit æ ‡å¿—ä½å¾—çŸ¥ï¼Œè¿™é‡Œé‡‡ç”¨çš„æ˜¯ R5G5B5 åŸºæœ¬è‰² + R3G3B3 å·®å€¼çš„æ–¹å¼ã€‚åˆ†åˆ«ä» 59-63 ä½ (11100)ã€51-55 ä½ (00100) å’Œ 43-47 ä½ (00011) è¯»å–å­å— 1 åŸºæœ¬è‰² RGB1=(11100, 00100, 00011) = (28, 4, 3)\nè·å–å­å— 2 çš„é¢œè‰²å·®å€¼ï¼šè¿™é‡Œæ˜¯ differential æ¨¡å¼ï¼Œæ‰€ä»¥éœ€è¦è¯»å–å­å— 2 çš„é¢œè‰²å·®å€¼ï¼Œä» 56-58 ä½ (100)ã€48-50 ä½ (010) å’Œ 40-42 ä½ (000) è·å¾—é¢œè‰²å·®å€¼ RGB_offset=(100, 010, 000) = (-4, 2, 0)ï¼Œæ³¨æ„è¿™é‡Œçš„ 3 ä½æ•°æ®ä¸­æœ€é«˜ä½æ˜¯ç¬¦å·ä½ï¼Œæ‰€ä»¥å·®å€¼éƒ¨åˆ†çš„å–å€¼èŒƒå›´æ˜¯ [-4, 3]\nè®¡ç®—å­å— 2 çš„åŸºæœ¬è‰²ï¼šå°†å­å— 1 åŸºæœ¬è‰²å’Œå­å— 2 å·®å€¼ç›¸åŠ ï¼Œå¾—åˆ°å­å— 2 çš„åŸºæœ¬è‰²ï¼ŒRGB2=RGB1 + RGB_offset = (28 - 4, 4+2, 3+0) = (24, 6, 3)ï¼Œè½¬ä¸º 5 ä½äºŒè¿›åˆ¶è¡¨ç¤ºä¸º RGB2=(11000, 00110, 00011)\næ‰©å±•å­å— 2 åŸºæœ¬è‰²åˆ†é‡ä¸º 8 ä½ï¼šå¯¹ 5 ä½æ ‡è¯†çš„åŸºæœ¬è‰²è¡¥ä½ä¸º 8 ä½è¡¨ç¤ºï¼Œå¾—åˆ° RGB1 = (11000110, 00110110, 00011011) = (198, 54, 27)ï¼Œè¿™å°±æ˜¯å­å— 2 çš„åŸºæœ¬è‰²\nè¡¥ä½è§„åˆ™ï¼š\n\nindividual æ¨¡å¼ï¼Œç›´æ¥å°† 4 ä½æ•°å¤åˆ¶åˆ°å°¾éƒ¨ï¼Œå¾—åˆ° 8 ä½\ndifferential æ¨¡å¼ï¼Œå°† 5 ä½ä¸­çš„é«˜ 3 ä½å¤åˆ¶åˆ°å°¾éƒ¨ï¼Œå¾—åˆ° 8 ä½\ndifferential æ¨¡å¼ï¼Œä¸€å®šæ˜¯å°†å­å— 1 åŸºæœ¬è‰²å’Œå­å— 2 åç§»å€¼ç›¸åŠ åå†è¿›è¡Œè¡¥ä½\n\n\n\nè·å¾—ç›®æ ‡åƒç´ çš„é¢œè‰²åç§»å€¼ï¼šç›®æ ‡åƒç´ ä¸‹æ ‡ä¸º 2ï¼Œåœ¨ç¼–ç æ•°æ®çš„ç¬¬ 2 ä½å¾—åˆ°æ˜ å°„è¡¨çš„ä¸‹æ ‡çš„ä½ä½ (lsb) ä¸º 1ï¼Œç¬¬ 18 ä½å¾—åˆ°æ˜ å°„è¡¨çš„ä¸‹æ ‡é«˜ä½ (msb) ä¸º 1ï¼Œå‡å¦‚ä½¿ç”¨å¦‚ä¸‹çš„æ˜ å°„è¡¨ï¼Œåˆ™å¯ä»¥å¾—åˆ°æ˜ å°„è¡¨ä¸‹æ ‡ä¸º(lsb, msb) = (1, 1)ï¼Œå¯¹åº”ä¸‹æ ‡ä¸º-b\n\n\n    \n\n\n  ä¸Šé¢çŸ¥é“ç›®æ ‡åƒç´ ä½äºå­å— 2ï¼Œè¿™é‡Œè¿˜éœ€è¦ä»ç¼–ç æ•°æ®çš„ 34-36 è·å¾—å­å— 2 çš„ä¿®æ­£è¡¨ç´¢å¼•ï¼Œå¾—åˆ°ç´¢å¼•ä¸º (1, 1, 0) = 6ï¼Œæ ¹æ®ä¸Šé¢çš„æ˜ å°„è¡¨ï¼Œæ ¹æ®ä¸‹æ ‡(6, -b) å¯ä»¥ç´¢å¼•åˆ°åƒç´ çš„é¢œè‰²å·®å€¼ä¸º -106\n\nè®¡ç®—ç›®æ ‡åƒç´ çš„æœ€ç»ˆé¢œè‰²å€¼ï¼šè¿™é‡Œ RGB ä¸‰ä¸ªåˆ†é‡çš„å·®å€¼ç›¸åŒï¼Œç›®æ ‡åƒç´ æœ€ç»ˆçš„é¢œè‰²å€¼ä¸ºå­å— 2 çš„åŸºæœ¬é¢œè‰² + ç›®æ ‡åƒç´ çš„é¢œè‰²åç§»å€¼ï¼šRGB_target = RGB2 + (-106, -106, -106) = (198 - 106, 54 - 106, 27 - 106)ï¼Œä¿®æ­£åå¾—åˆ°ç›®æ ‡é¢œè‰²å€¼RGB_target = (92, 204, 177)\n\nç¼–ç è¿‡ç¨‹\nå°†å›¾åˆ’åˆ†ä¸º 4x4 çš„åƒç´ å—ï¼Œå¦‚æœä¸å¤Ÿ 4x4ï¼Œåˆ™å°†è¿™äº›åƒç´ å¡«å……åœ¨ 4x4 å—çš„å·¦ä¸Šè§’\né’ˆå¯¹æ¯ä¸ª 4x4 çš„åƒç´ å—å°è¯•ä»¥ä¸‹ç¼–ç ï¼Œå–è§£ç åå’ŒåŸåƒç´ å·®å€¼æœ€å°çš„é‚£ç§ç¼–ç ä½œä¸ºç»“æœ\nç¡®å®š flipbitï¼Œå¹¶è®¡ç®—ä¸¤ä¸ªå­å—çš„å¹³å‡é¢œè‰²å€¼ï¼Œè¿™é‡Œæˆ‘çŒœæµ‹æ˜¯å…ˆå°† 8 ä¸ªåƒç´ çš„R8G8B8 å–å‡å€¼å¾—åˆ°åƒç´ çš„å¹³å‡å€¼ï¼Œç„¶åå°†æ¯ä¸ªåˆ†é‡çš„åä¸‰ä½ç›´æ¥æŠ›å¼ƒï¼Œå¾—åˆ°R5G5B5\næ ¹æ®ä¸¤ä¸ªå­å—é¢œè‰²å€¼çš„å·®å€¼ï¼Œç¡®å®š diffbitï¼Œæ ¹æ®ä¸Šé¢å¾—åˆ°çš„ä¸¤ä¸ªå­å—çš„R5G5B5ï¼Œè®¡ç®—å·®å€¼ï¼Œå¦‚æœå·®å€¼åœ¨[-4, 3] ä¹‹é—´ï¼Œè¯´æ˜å·®å€¼å¯ä»¥ç”¨ 3 ä½å¸¦ç¬¦å·çš„äºŒè¿›åˆ¶æ•°è¡¨ç¤ºï¼Œå¯ä»¥ç”¨ differential æ¨¡å¼ï¼Œå¦åˆ™ç”¨ individual æ¨¡å¼\næšä¸¾ä¸åŒçš„å­å—ç´¢å¼•ï¼Œç¡®å®šæ¯ä¸ªå­å—ä½¿ç”¨æ˜ å°„è¡¨ä¸­çš„å“ªä¸€ç»„åç§»å€¼\næšä¸¾æ¯ä¸ªåƒç´ çš„æ˜ å°„ä¸‹æ ‡ï¼Œç¡®å®šåƒç´ ä½¿ç”¨æ˜ å°„è¡¨ä¸­çš„å“ªä¸€ä¸ªåç§»å€¼\né’ˆå¯¹ç¬¬ 3 æ­¥å’Œç¬¬ 4 æ­¥çš„æšä¸¾ï¼Œå¯ä»¥å¾—åˆ°å¾ˆå¤šç»„ä¸åŒçš„ç¼–ç ï¼Œå°†ç¼–ç ç»“æœè§£å‹åå’ŒåŸå§‹åƒç´ æ•°æ®å¯¹æ¯”ï¼Œå–ç›¸å·®æœ€å°çš„ä¸€ç»„ç¼–ç ä½œä¸ºæœ€ç»ˆç»“æœ\n\n\nå°†å›¾ç‰‡ä¸­å„ä¸ªåƒç´ å—ç¼–ç åˆå¹¶\n\nUnity çš„å‡ ç§ ETC çº¹ç†å‹ç¼©æ ¼å¼\nRGB ETC1 4 bitï¼š4 bits/pixelï¼Œå¯¹ RGB å‹ç¼©æ¯” 6:1ï¼Œä¸æ”¯æŒ Alphaï¼Œç»å¤§éƒ¨åˆ†å®‰å“è®¾å¤‡éƒ½æ”¯æŒ\nRGB ETC2 4 bitï¼š4 bits/pixelï¼Œå¯¹ RGB å‹ç¼©æ¯” 6:1ã€‚ä¸æ”¯æŒ Alphaï¼ŒETC2 å…¼å®¹ ETC1ï¼Œå‹ç¼©è´¨é‡å¯èƒ½æ›´é«˜ï¼Œä½†å¯¹äºè‰²åº¦å˜åŒ–å¤§çš„å—è¯¯å·®ä¹Ÿæ›´å¤§ï¼Œéœ€è¦åœ¨ OpenGL ES 3.0 å’Œ OpenGL 4.3 ä»¥ä¸Šç‰ˆæœ¬\nRGBA ETC2 8bitï¼š8 bits/pixelï¼Œå¯¹ RGBA å‹ç¼©æ¯” 4:1ã€‚æ”¯æŒå®Œå…¨çš„é€æ˜é€šé“ï¼Œç‰ˆæœ¬è¦æ±‚åŒä¸Š\nRGB +1bit Alpha ETC2 4bitï¼š4 bits/pixelã€‚æ”¯æŒ 1bit çš„ Alpha é€šé“ï¼Œä¹Ÿå°±æ˜¯åªæ”¯æŒé•‚ç©ºå›¾ï¼Œå›¾ç‰‡åªæœ‰é€æ˜å’Œä¸é€æ˜éƒ¨åˆ†ï¼Œæ²¡æœ‰ä¸­é—´çš„é€æ˜åº¦\n\nDXTDXT æ˜¯ä¸€ç§æœ‰æŸçº¹ç†å‹ç¼©ç®—æ³•ï¼Œå¾®è½¯çš„ Direct ä¸­æ”¯æŒï¼ŒDXT çš„æ ¼å¼åŒ…æ‹¬ DXT1~DXT5ï¼Œå…¶ä¸­ DXT1 å’Œ DXT5 è¾ƒä¸ºå¤šè§\n\n    \n\n\nDXT ç®—æ³•éå¸¸å®¹æ˜“ç†è§£ï¼Œè€Œä¸”æ•´ä½“çœ‹ä¸Šå»æ•ˆæœä¸é”™ï¼Œä½†å¦‚æœå¯¹å±€éƒ¨ç‰¹å†™ï¼Œä¼šå‘ç°åœ¨ç»†èŠ‚ä¸Šä¼šæœ‰å¾ˆå¤šä¸¢å¤±ï¼Œè¿™ä¹Ÿæ˜¯ç®—æ³•æœ¬èº«å¯¼è‡´çš„ï¼Œæ¯•ç«Ÿæ¯ä¸ªå—åªæœ‰ä¸¤ä¸ªé¢œè‰²ï¼Œè€Œå…¶ä»–é¢œè‰²éƒ½æ˜¯åœ¨è¿™ä¸¤ä¸ªé¢œè‰²åŒºé—´çš„å·®å€¼ï¼Œå¦‚æœå½“å‰åŒºåŸŸå†…è¿˜æœ‰å…¶ä»–æ˜¾è‘—é¢œè‰²åˆ™å¿…ç„¶ä¼šæœ‰ä¸¢å¤±\nè¿™ç§ä¿¡æ¯çš„ä¸¢å¤±ä¸»è¦é›†ä¸­åœ¨æ¯”è¾ƒç»†çš„è¾¹ç•Œä¸­ï¼Œä½† DXT1 åœ¨å‹ç¼©ç‡ä¸Šæ˜¯ RGB çš„ 6 å€ï¼Œè¿™ç§é—®é¢˜å¯ä»¥é€šè¿‡æé«˜çº¹ç†åˆ†è¾¨ç‡çš„æ–¹å¼æ¥è§£å†³ï¼Œé«˜å®½æ”¾å¤§ 41%(1.41 * 1.41 = 1.9881)ï¼Œè¿™æ ·æ•´ä¸ªçº¹ç†æ˜¯ä»¥å‰çš„ 2 å€ï¼Œä½†å‹ç¼©ç‡è¿˜èƒ½ä¿æŒä¸º 3 å€ï¼Œä¹Ÿæ˜¯å¯ä»¥æ¥å—çš„ã€‚åœ¨ DXT ä¸­è¿˜æœ‰ä¸€ä¸ªä¸»è¦çš„æŸå¤±ï¼Œå°±æ˜¯ RGB çš„ 24 ä½è½¬ä¸ºäº† 16 ä½é¢œè‰²ï¼Œ16 ä½ä¸­ R&amp;B å„å  5 ä½ï¼Œä½†æ˜¯ G å äº† 6 ä½ï¼Œè¿™æ˜¯å› ä¸ºäººçœ¼å¯¹ç»¿è‰²æœ€ä¸ºæ•æ„Ÿ\n\n    \n\n\nå¦å¤–ä¸€ä¸ªé—®é¢˜å°±æ˜¯ DXT3 å’Œ DXT5 ä¹‹é—´çš„å¯¹æ¯”ï¼Œç›¸æ¯” DXT1 ä¸æ”¯æŒé€æ˜åº¦ï¼ˆä½†æ”¯æŒæ˜¯å¦é€æ˜ï¼‰ï¼ŒDXT5 è¦å¤§ä¸€å€ï¼ˆå¤šäº† 64bitï¼‰ï¼Œå’Œä¹‹å‰é¢œè‰²ä¿å­˜æ–¹æ¡ˆä¸€æ ·å¯¹é€æ˜åº¦ä¹Ÿä¿å­˜äº†ä¸¤ä¸ª 16 ä½çš„é¢œè‰²å’Œå¯¹åº”çš„è°ƒè‰²æ¿ï¼Œå¯¹ RGBA çš„æ•ˆæœä¹Ÿå¾—åˆ°äº†ä¿è¯ï¼Œä½† DXT3 æ€è·¯ä¸ä¸€æ ·ï¼Œå®ƒæ˜¯å¯¹æ¯ä¸€ä¸ªåƒç´ ä¿å­˜äº† 4bit çš„é€æ˜åº¦ï¼ŒåŒæ ·ä¹Ÿæ˜¯å¤šäº† 64bitï¼Œä½†æ­¤æ—¶æ¯•ç«Ÿåªæœ‰ 16 ä¸ªé€æ˜åº¦é€‰é¡¹ï¼Œç›¸æ¯” DXT5ï¼Œåœ¨å‹ç¼©ç‡ä¸Šç›¸å½“ï¼Œä½†å¯¹é€æ˜è‰²çš„å¤„ç†ä¸å¤Ÿç»†è…»ï¼Œå› æ­¤åœ¨å®ç”¨æ€§ä¸Šå¹¶ä¸æ¨è DXT3\nPVRTCPVRTC ä¸åŒäº DXT å’Œ ETC è¿™ç±»åŸºäºå—çš„ç®—æ³•ï¼Œè€Œå°†æ•´å¼ çº¹ç†åˆ†ä¸ºäº†é«˜é¢‘ä¿¡å·å’Œä½é¢‘ä¿¡å·ï¼Œä½é¢‘ä¿¡å·ç”±ä¸¤å¼ ä½åˆ†è¾¨ç‡çš„å›¾åƒ A å’Œ B è¡¨ç¤ºï¼Œè¿™ä¸¤å¼ å›¾åœ¨ä¸¤ä¸ªç»´åº¦ä¸Šéƒ½ç¼©å°äº† 4 å€ï¼Œé«˜é¢‘ä¿¡å·åˆ™æ˜¯å…¨åˆ†è¾¨ç‡ä½†ä½ç²¾åº¦çš„è°ƒåˆ¶å›¾åƒ Mï¼ŒM è®°å½•äº†æ¯ä¸ªåƒç´ æ··åˆçš„æƒé‡ã€‚è¦è§£ç æ—¶ï¼ŒA å’Œ B å›¾åƒç»è¿‡åŒçº¿æ€§æ’å€¼ï¼ˆBilinearlyï¼‰å®½é«˜æ”¾å¤§ 4 å€ï¼Œç„¶åä¸ M å›¾ä¸Šçš„æƒé‡è¿›è¡Œæ··åˆ\n\n    \n\n\nPVRTC 4-bpp æ¨¡å¼ä¸‹ï¼Œæ¯ 4x4 åƒç´ å ä¸€ä¸ª 64 ä½æ•°æ®å—ï¼Œ2-bpp æ¨¡å¼ä¸‹æ¯ 8x4 åƒç´ ä¼šæœ‰ä¸€ä¸ª 64 ä½æ•°æ®å—ã€‚4-bpp æ¨¡å¼ä¸‹ï¼ŒA å›¾å’Œ B å›¾ç¼©å°åéƒ½åªä¿å­˜ä¸€ä¸ªé¢œè‰²å€¼ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼ŒColor A æ¯” Color B å°‘ 1 ä½ï¼Œä½†ä¸¤å¼ å›¾éƒ½å¯ä»¥é€‰æ‹©ä»¥ RGB æˆ– ARGB çš„æ–¹å¼å­˜å‚¨ï¼ˆæœ€é«˜ä½å†³å®šä¸ºå“ªç§ï¼‰ï¼ŒColor A å¯ä»¥ç”¨ RGB554 æˆ– ARGB3443 æ ¼å¼ç¼–ç ï¼ŒColor B å¯ä»¥ç”¨ RGB555 æˆ– ARGB3444 æ ¼å¼ç¼–ç \n\n    \n\n\nåœ¨è§£ç æ—¶ï¼Œä¸ºäº†è§£ç ä»»æ„åƒç´ ï¼Œå¿…é¡»è¯»å– 4 ä¸ªç›¸é‚»çš„ PVRTC å—ï¼Œä½¿ç”¨è¿™ 4 ä¸ªå—æ¥è§£ç ä¸€ä¸ª 5x5 å—\n\n    \n\n\nä½¿ç”¨åŒçº¿æ€§è¿‡æ»¤æ¥å¯¹ A å’Œ B å›¾è¿›è¡Œæ‰©å¤§ï¼Œç„¶å A å’Œ B å›¾æ ¹æ® M å›¾ä¸ Mode ä½è¿›è¡Œæ··åˆï¼Œè¿™é‡Œçš„ Mode ä½ä¸º 1 æ—¶ï¼ŒM å›¾ä¸­ 10 å€¼åƒç´ è¢«çœ‹ä½œæ˜¯å¼€å¯äº† punch-through alphaï¼ŒAlpha é€šé“ä¼šè¢«å¼ºåˆ¶æ¸…é›¶ï¼Œæ˜¯ä¸ºäº†å…¼å®¹æ—§åº”ç”¨ç¨‹åº\n\n    \n\n\nASTCä»¥ä¸‹æ¯ä¸ªç”¨ä¾‹éƒ½å¯¹å‹ç¼©æ–¹æ¡ˆæœ‰è‡ªå·±çš„è¦æ±‚ï¼š\n\næ”¯æŒä» 1 åˆ° 4 ä¸ªåˆ†é‡çš„çº¹ç†ã€‚è™½ç„¶å•é€šé“çº¹ç†ä¹Ÿå¯ä»¥ä½¿ç”¨ BC7ã€PVRTC2 æˆ– ETC2 æ¥å­˜å‚¨ï¼Œä½†ç©ºé€šé“ä¸Šå¤§é‡ bit è¢«æµªè´¹æ‰äº†ã€‚\nåœ¨é€šé“ä¹‹é—´æ•°æ®æ— ç›¸å…³æ€§çš„æƒ…å†µä¸‹ï¼Œæ‹¥æœ‰å¯ä»¥æ¥å—çš„è´¨é‡ã€‚è¿™å¯¹äºæ³•çº¿å›¾å’Œ RGBA å›¾åƒæ¥è¯´éå¸¸é‡è¦ã€‚\næ”¯æŒ LDR å’Œ HDRã€‚BC6H å¯ç”¨äº HDR çº¹ç†å‹ç¼©ï¼Œä½†å®ƒä¸æ”¯æŒ alpha é€šé“ã€‚\nè·¨å¹³å°ã€‚ç‰¹åˆ«æ˜¯ï¼šPVRTC åªåœ¨ iOS å¹³å°ä¸Šå¯ç”¨ï¼ŒBC6H/BC7 åœ¨ç§»åŠ¨è®¾å¤‡ä¸­ç¼ºå¤±ï¼ŒETC ä¸è¢«æ¡Œé¢çº§ GPU æ‰€æ”¯æŒã€‚å¯¹äºè·¨å¹³å°åº”ç”¨ç¨‹åºçš„å¼€å‘è€…æ¥è¯´ï¼Œæœ‰è¯¸å¤šä¸ä¾¿ã€‚æ¯”ç‰¹ç‡ / è´¨é‡æ¯”çš„çµæ´»æ€§ã€‚æ ¹æ®çº¹ç†ç±»å‹ï¼Œä¸åŒç¨‹åº¦çš„å‹ç¼©ä¼ªå½±æ˜¯å¯ä»¥æ¥å—çš„ï¼Œå› ä¸ºä¸åŒå›¾åƒçš„å¯å‹ç¼©æ€§æ˜¯ä¸åŒçš„ã€‚å‰æ–‡ä¸­æåˆ°çš„æ ¼å¼é‡Œï¼Œèƒ½æä¾›çš„æ¯”ç‰¹ç‡ / è´¨é‡é€‰é¡¹çš„ä¸è¶…è¿‡ä¸¤ä¸ª (BC1/BC7 æˆ– PVRTC 4bpp/2bpp) ã€‚å¦‚æœä¸èƒ½ä½¿ç”¨ 5bpp çš„å‹ç¼©çº§åˆ« ï¼ˆå¦‚æœ 4bpp çš„è´¨é‡ç•¥æ˜¾ä¸è¶³ï¼‰ ï¼Œå°±å¿…é¡»ä½¿ç”¨ 8bpp çš„é€‰é¡¹ã€‚å¸¦å®½å¢åŠ äº†ä¸€å€ï¼Œä½†è´¨é‡å´æ²¡æœ‰æ˜æ˜¾æ”¹å–„ã€‚\næ”¯æŒ 2D å’Œ 3D çº¹ç†ã€‚\n\næ¦‚å¿µä¸Šè®²ï¼ŒASTC ç±»ä¼¼äº S3TC/BC7ï¼šä¸€ä¸ªå‹ç¼©å—ä¸­æœ€å¤šå­˜å‚¨å››ä¸ªç«¯ç‚¹å¯¹å’Œæ’å€¼æƒé‡ï¼Œåªæ”¯æŒé¢„å®šä¹‰çš„åˆ†åŒºï¼Œç‰¹å®šçš„åˆ†åŒºç”±åˆ†åŒº ID æŒ‡å®šï¼Œä¹Ÿå­˜å‚¨åœ¨ä¸€ä¸ªå—ä¸­ã€‚åœ¨å¼±ç›¸å…³çš„æƒ…å†µä¸‹ï¼Œè¯¥é€šé“ä¼šå­˜å‚¨ä¸€ä¸ªç‹¬ç«‹çš„ç´¢å¼•è¡¨ã€‚æ¯ä¸ªç‹¬ç«‹çš„ç¼–ç è¢«ç§°ä¸ºä¸€ä¸ªå¹³é¢ã€‚æˆ–è®¸ ASTC æœ€ä¸»è¦ã€æœ€æœ‰è¶£çš„åˆ›æ–°æ˜¯ç”¨å°æ•°ä½ç¼–ç æ•´æ•°å€¼çš„æŠ€æœ¯ï¼Œç§°ä¸º BISEã€‚åŒæ—¶ï¼ŒBISE å¯ä»¥åœ¨ç¡¬ä»¶ä¸­æœ‰æ•ˆå®ç°\næœ‰ç•Œæ•´æ•°åºåˆ—ç¼–ç  (Bounded Integer Sequence Encoding, BISE)æœ‰ç•Œæ•´æ•°åºåˆ—ç¼–ç ï¼Œæˆ–ç§° BISEï¼Œè§£å†³äº†å¦‚ä¸‹æŠ½è±¡é—®é¢˜ï¼šä»å¤§å°ä¸º  çš„å­—æ¯è¡¨ä¸­ç»™å®šç­‰æ¦‚ç‡çš„ç¬¦å·åºåˆ—ï¼Œ æ‰¾åˆ°ä¸€ç§ç¼–ç ï¼Œä½¿å¾—èƒ½å¤Ÿåœ¨å¸¸æ•°æ—¶é—´å¤æ‚åº¦å†…ä½¿ç”¨æœ€å°‘çš„ç¡¬ä»¶æ¶ˆè€—æå–ç¬¬  ä¸ªç¬¦å·ï¼Œå¹¶å…è®¸ç›¸åŒç¡¬ä»¶è®¾è®¡èƒ½å¤Ÿç”¨äºå¤šç§ä¸åŒå¤§å°çš„å­—æ¯è¡¨ï¼ŒåŒæ—¶å…·å¤‡å­˜å‚¨æ•ˆç‡\nä¾‹å¦‚ï¼Œè€ƒè™‘ä¸€ä¸ªç”± 5 ä¸ªæ•´æ•°ç»„æˆçš„åºåˆ—ï¼Œå…¶ä¸­æ¯ä¸ªæ•´æ•°å¯ä»¥æ˜¯ 0ï¼Œ1 æˆ– 2ï¼ˆè¯‘è€…æ³¨ï¼š5 ä½çš„ 3 è¿›åˆ¶æ•°ï¼‰ã€‚ä½¿ç”¨æ ‡å‡†äºŒè¿›åˆ¶ç¼–ç æ—¶ï¼Œéœ€è¦ä¸ºæ¯ä¸ªå€¼åˆ†é… 2 ä½ï¼Œæ€»å…± 10 ä½ã€‚ä½†ä¸åŒåºåˆ—çš„æ•°é‡æ˜¯ï¼Œå°äºã€‚å› æ­¤ï¼Œå¯ä»¥ç”¨ 8 æ¯”ç‰¹å¯¹æ•´ä¸ªåºåˆ—è¿›è¡Œç¼–ç ï¼Œæ¯ä¸ªå€¼çš„æ¯”ç‰¹ç‡ä¸º 1.6ã€‚æ¢å¥è¯è¯´ï¼Œå¯ä»¥ç”¨ 8 æ¯”ç‰¹æ¥è¡¨ç¤º 5 ä½çš„ 3 è¿›åˆ¶æ•°\nç°åœ¨ï¼Œè€ƒè™‘ä»»æ„é•¿åº¦çš„åºåˆ—ï¼Œå…¶ä¸­æ¯ä¸ªå€¼éƒ½å±äºèŒƒå›´ ï¼Œå…¶ä¸­ã€‚æ¯ä¸ªå€¼éƒ½å¯ä»¥ç”¨ä¸€ä¸ªä¸‰è¿›åˆ¶ä½å’Œ ä¸ªæ¯”ç‰¹æ¥è¡¨ç¤ºã€‚å‡è®¾ ï¼Œé‚£ä¹ˆæ»¡è¶³è¯¥æ¡ä»¶çš„ä»»ä½•å€¼éƒ½å¯ä»¥ç”¨ä»¥ä¸‹å½¢å¼è¡¨ç¤ºï¼šï¼Œå…¶ä¸­ æ˜¯ä¸€ä¸ªä¸‰è¿›åˆ¶ä½ï¼Œå’Œ  æ˜¯æ¯”ç‰¹ä½ã€‚æ•´ä¸ªåºåˆ—å¯ä»¥è¢«åˆ’åˆ†ä¸ºäº”ç»„å€¼ï¼Œæœ€åä¸€ç»„ä¼šåœ¨å¿…è¦æ—¶å¡«å…… ã€‚äºŒè¿›åˆ¶å½¢å¼ä¸‹ï¼Œä¸€ä¸ªç‰¹å®šçš„ç»„å¯ä»¥è¡¨ç¤ºä¸ºä¸€ä¸ªæ¯”ç‰¹ä¸²ï¼Œå…¶ä¸­ æ˜¯ä¸€ä¸ªä¸‰è¿›åˆ¶ä½çš„  æ¯”ç‰¹è¡¨ç¤ºï¼Œæ˜¯ä¸€ä¸ªå€¼çš„å‰©ä½™æ¯”ç‰¹ä½ï¼ˆè¯‘æ³¨ï¼šå³ä¸Šæ–‡ä¸­çš„  å’Œ)ã€‚åªè¦ä¸‰è¿›åˆ¶ä½ä¸æ¯”ç‰¹ä¿¡æ¯ä¿æŒè¿™ç§ç›¸å…³æ€§ï¼Œå°±å¯ä»¥ç”¨æ¯”ç‰¹ä¸²  ä¿å­˜è¿™äº”ç»„å€¼ã€‚å…¶ä¸­  ä¸ºçš„å„ä¸ªæ¯”ç‰¹ï¼Œè¿™æ®µæ•°æ®è¦æ¯”åŸå…ˆçŸ­  æ¯”ç‰¹\näº‹å®è¯æ˜ï¼Œè¿™ç§ç¼–ç èƒ½å¤Ÿä¿ç•™å°¾éƒ¨çš„é›¶ã€‚ä¾‹å¦‚ï¼Œå¦‚æœæˆ‘ä»¬åºåˆ—ä¸­çš„æœ€åä¸€ç»„è¢«å¡«å……äº†ä¸¤ä¸ªé›¶ ï¼ˆæ‰€ä»¥  å’Œæ˜¯é›¶ï¼‰ ï¼Œé‚£ä¹ˆ  å’Œæ˜¯é›¶ï¼Œå®ƒä»¬ä¸éœ€è¦è¢«å­˜å‚¨ã€‚å› æ­¤ï¼Œä»»ä½•é•¿åº¦çš„åºåˆ—ï¼Œå‡å¦‚å…¶æ•°å€¼èŒƒå›´ä»  åˆ°ï¼Œéƒ½å¯ä»¥ç”¨æ¥è¿‘äºç†è®ºä¸Šçš„æœ€å°çš„æ¯”ç‰¹ç‡è¿›è¡Œç¼–ç ã€‚åŒæ—¶ï¼Œå…¶ä¸­çš„ä»»æ„å€¼èƒ½ä»¥æœ€å°çš„ç¡¬ä»¶æ¶ˆè€—å®¹æ˜“çš„æå–å‡ºæ¥\nåŒæ ·çš„æ¨ç†ä¹Ÿå¯ä»¥åº”ç”¨äº  çš„åºåˆ—ã€‚è¿™é‡Œï¼Œä¸ªäº”è¿›åˆ¶æ•° ï¼ˆåŸºæ•°ä¸º  çš„æ•°å­—ï¼‰ å¯ä»¥ç”¨  ä½æ¥ç¼–ç ï¼Œå› ä¸º  å°äºã€‚å› æ­¤ï¼Œä½¿ç”¨ä¸‰è¿›åˆ¶æ•°å’Œäº”è¿›åˆ¶æ•°çš„ BISE æŠ€æœ¯åœ¨å­˜å‚¨æ–¹é¢éƒ½æ˜¯æ˜¯æœ‰æ•ˆç‡çš„ \n\n    \n\n\nå…¶ä»–æ”¹è¿›ASTC è¿˜æ”¹è¿›äº†åˆ†åŒºæ¨¡å¼ã€‚BC6H å’Œ BC7 å‹ç¼©æ–¹æ¡ˆä¹Ÿä½¿ç”¨äº†é¢„å®šä¹‰çš„åˆ†åŒºé›†è¡¨ï¼Œä½†è¿™ç§æ–¹æ³•ä¸é€‚åˆ ASTCï¼Œå› ä¸ºå®ƒæ”¯æŒå¤§é‡çš„ç“¦ç‰‡å°ºå¯¸ï¼Œæ”¯æŒæ›´å¤šçš„åŒºåŸŸï¼Œè¿˜å¢åŠ äº†åˆ†åŒº ID å­—æ®µçš„å¤§å° (10 ä½ï¼Œè€Œ BC7 æ˜¯ 6 ä½ï¼‰ ã€‚ASTC çš„åˆ†åŒºæ¨¡å¼æ˜¯ç”¨ä¸€ä¸ªç‰¹æ®Šçš„å“ˆå¸Œå‡½æ•°ç”Ÿæˆçš„ï¼Œå®ƒä¸ºæ¯ä¸ªçº¹ç´ åˆ†é…ä¸€ä¸ªåˆ†åŒºç´¢å¼•ã€‚è¿™ä¸ªå‡½æ•°å°†çº¹ç´ åœ¨ç“¦ç‰‡ä¸­çš„ä½ç½®ã€åˆ†åŒº IDã€ç“¦ç‰‡å¤§å°å’Œåˆ†åŒºæ•°é‡ä½œä¸ºè¾“å…¥ï¼Œå¹¶è¾“å‡ºä¸€ä¸ªåˆ†åŒºç´¢å¼•ã€‚è¯¥å‡½æ•°å¾ˆç®€å•ï¼Œå¯ä»¥ç”¨ç¡¬ä»¶å®ç°ã€‚è¯¥å‡½æ•°ä¹Ÿç”¨äº 3D çº¹ç†ã€‚å›¾ä¸­æè¿°äº† 8x8 ç“¦ç‰‡çš„æ‰€æœ‰åˆ†åŒºæ¨¡å¼\n\n    \n\n\nASTC çš„ä¸€ä¸ªæ›´æ˜¾è‘—çš„ç‰¹ç‚¹æ˜¯å†…æ’æƒé‡çš„ç¼–ç æ–¹å¼ã€‚S3TC ç³»åˆ—æ–¹æ¡ˆä½¿ç”¨æ¯ä¸ªé¡¶ç‚¹çš„ç´¢å¼•æ¥è®¾ç½®æ’å€¼æƒé‡ã€‚æ ¹æ®å—çš„ç±»å‹ï¼Œç´¢å¼•çš„å¤§å°å¯ä»¥æ˜¯ 2ã€3 æˆ– 4 æ¯”ç‰¹ã€‚ç„¶è€Œï¼Œå¯¹äº 12x12 ç“¦ç‰‡æ¥è¯´ï¼Œå³ä½¿æ¯ä¸ªåƒç´ ä½¿ç”¨ 1bit çš„ç´¢å¼•ï¼Œä¹Ÿæ— æ³•å­˜å‚¨åœ¨ä¸€ä¸ª 128 ä½å—ã€‚å› æ­¤ï¼ŒASTC ä¸ºæƒé‡å’Œçº¹ç´ æä¾›ç‹¬ç«‹çš„ç½‘æ ¼å¤§å°ã€‚ä¾‹å¦‚ï¼Œå¯¹äº 12x12 çš„ç“¦ç‰‡ï¼Œåªèƒ½å­˜å‚¨ 4x6 çš„æƒé‡ç½‘æ ¼ã€‚åœ¨è§£ç é˜¶æ®µï¼Œæƒé‡ç½‘æ ¼è¢«åŒçº¿æ€§åœ°æ”¾å¤§åˆ°ç“¦ç‰‡å¤§å°ã€‚ä¸è¿‡è™½ç„¶çœ‹èµ·æ¥åƒï¼Œä½†æ˜¯å®ƒå’Œç®€å•çš„ç“¦ç‰‡ç¼©æ”¾å¹¶ä¸ä¸€æ ·ã€‚ä¾‹å¦‚ï¼Œå¹³æ»‘çš„æ¢¯åº¦é€šå¸¸å¯ä»¥ç”¨ä¸€ä¸ªå°çš„æƒé‡ç½‘æ ¼æ¥è¡¨ç¤ºï¼Œå¦‚ 2x2ã€‚å› æ­¤æœ‰æ›´å¤šçš„æ¯”ç‰¹å¯ç”¨äºç«¯ç‚¹ã€‚åŒæ—¶å°–é”çš„è¾¹ç¼˜å’Œé¢œè‰²è¿‡æ¸¡å¯ä»¥ç”¨é€‚åˆçš„åˆ†åŒºæ¨¡å¼è¿›è¡Œç¼–ç ã€‚æƒé‡ç½‘æ ¼çš„å¤§å°æ˜¯æ ¹æ®æ¯ä¸ªå—æ¥é€‰æ‹©çš„ã€‚å› æ­¤æŸäº›å…·æœ‰å¼ºçƒˆå‚ç›´ç‰¹å¾çš„ç“¦ç‰‡ï¼Œå¯ä»¥ç”¨ 4x2 æˆ– 8x4 çš„æƒé‡ç½‘æ ¼è¿›è¡Œç¼–ç \næ‰€æœ‰è¿™äº›é…ç½®æ•°æ® ï¼ˆç½‘æ ¼å¤§å°ã€åˆ†åŒºæ•°é‡ã€ç«¯ç‚¹æ ¼å¼ï¼‰ éƒ½å¿…é¡»å­˜å‚¨åœ¨ä¸€ä¸ªå‹ç¼©å—ä¸­ã€‚è™½ç„¶ä¸å¾—ä¸ç‰ºç‰²ä¸€äº›é¢œè‰²æ•°æ®ä½ï¼Œå› è€Œå¯èƒ½é™ä½å›¾åƒè´¨é‡ï¼Œä½†è¿™ç§æ–¹æ³•å¸¦æ¥äº†å¾ˆå¥½çš„çµæ´»æ€§ï¼Œå¹¶ä¸”å¤§å¤§å¢å¼ºäº†å‹ç¼©è´¨é‡ã€‚ASTC å…è®¸åœ¨æ¯ä¸ªå—ä¸­è¿›è¡Œä¸åŒçš„æ¯”ç‰¹æƒè¡¡ï¼Œä»»æ„ç“¦ç‰‡éƒ½å¯ä»¥åœ¨åˆ†åŒºã€ç«¯ç‚¹å’Œæƒé‡ä¹‹é—´çš„åˆ†å¸ƒé€‰ç”¨æœ€åˆé€‚çš„æ¯”ç‰¹åˆ†å¸ƒè¿›è¡Œç¼–ç ã€‚äº‹å®è¯æ˜ï¼Œå³ä½¿åœ¨è¾ƒä½çš„æ¯”ç‰¹ç‡ä¸‹ï¼ŒASTC ä¹Ÿèƒ½å¤Ÿæä¾›æ¯” PVRTCã€BC1-BC5 å’Œ ETC æ›´å¥½çš„è´¨é‡ã€‚PSNR ï¼ˆè¯‘æ³¨ï¼šå³°å€¼ä¿¡å™ªæ¯”ï¼‰ å¢ç›Šå¹³å‡ä¸º 1.5dB è‡³ 2dBï¼Œå¤§å¤šæ•°è§‚å¯Ÿè€… ï¼ˆè¯‘æ³¨ï¼šæ¨æµ‹æ­¤å¤„æ•°å€¼ä¸º ASTC å¯¹æ¯”å…¶ä»–å‹ç¼©æ ¼å¼è·å¾—çš„å¢ç›Š ) å¤§çº¦èƒ½å¯Ÿè§‰ 0.25dB çš„å¢ç›Šã€‚BC6H çš„è´¨é‡ä¸ä¹‹ç›¸å½“ï¼Œè€Œ BC7 å¹³å‡æ¯” ASTC å¤šå‡º 0.5dBã€‚ä¸è¿‡åœ¨ 8bpp æ—¶ï¼ŒASTC å’Œ BC7 å‹ç¼©å›¾åƒçš„ PSNR è´¨é‡éƒ½åœ¨ 45dB å·¦å³ï¼Œè¿™ç§å·®å¼‚å¾ˆéš¾ä»è§†è§‰ä¸Šå‘ç°\næ­¤å¤–ï¼ŒASTC æ˜¯ç¬¬ä¸€ä¸ªæ”¯æŒ 3D çº¹ç†çš„æ ‡å‡†å‹ç¼©æ–¹æ¡ˆï¼Œå®ƒåˆ©ç”¨äº†æ‰€æœ‰ä¸‰ä¸ªç»´åº¦çš„é¢œè‰²ç›¸å…³æ€§ã€‚nVidia çš„ OpenGL(26) çš„ VTC æ‰©å±•ä¹Ÿæ˜¯é’ˆå¯¹ 3D çº¹ç†çš„ï¼Œä½†å®ƒåªæ˜¯æŠŠä¸€ä¸ª 3D ç“¦ç‰‡åˆ†æˆ 2D ç‰‡ï¼Œä½¿ç”¨ BC1 æ–¹æ¡ˆè¿›è¡Œå‹ç¼©ã€‚ASTC åˆ™ä½¿ç”¨ 3D æƒé‡ç½‘æ ¼å’Œåˆ†åŒºï¼Œåˆ©ç”¨åˆ†åŒºæ¨¡å¼ç”Ÿæˆå™¨æ¥å‹ç¼©æ•´ä¸ª 3D ç“¦ç‰‡ã€‚ä¸è¿‡æƒé‡ç½‘æ ¼æ˜¯ç”¨å•çº¿æ³•è€Œéä¸‰çº¿æ’å€¼æ³•è¿›è¡Œæ”¾å¤§çš„ (67) ã€‚æ•´ä¸ª 3D ç“¦ç‰‡çš„å‹ç¼©æ¯”åˆ†ç‰‡å‹ç¼©çš„ PSNR é«˜å‡º 2dB\nå¦å¤–ï¼ŒASTC çš„æ‰€æœ‰ç‰¹å¾éƒ½æ˜¯ â€œæ­£äº¤ â€œçš„ï¼Œå³ä»»ä½•ç‰¹å¾éƒ½å¯ä»¥ç‹¬ç«‹ä½¿ç”¨ï¼Œä¾‹å¦‚å¯ä»¥ç”¨ä¸¤ä¸ªå¼±ç›¸å…³çš„ HDR é€šé“æ¥å‹ç¼©ä¸€ä¸ªä¸‰ç»´çº¹ç†\nASTC å—  é¦–å…ˆæ˜¯ä¸€äº›å…¨å±€è§£ç å‚æ•°ï¼Œè¿™äº›å‚æ•°å¯¹ä»»ä½•ç‰¹å®šçš„çº¹ç†éƒ½æ˜¯ä¸€æ ·çš„ã€‚å› æ­¤ï¼Œæ²¡æœ‰å¿…è¦åœ¨å‹ç¼©å—ä¸­å­˜å‚¨è¿™äº›\n\nåŠ¨æ€èŒƒå›´ (LDR/HDR)\nçº¹ç†å°ºå¯¸ (2D/3D)\nç“¦ç‰‡å°ºå¯¸\nè¾“å‡ºè‰²å½©ç©ºé—´ (sRGB/RGB)\n\nè€Œæ¯å—æŒ‡å®šçš„æ•°æ®å¦‚ä¸‹\n\næƒé‡ç½‘æ ¼å¤§å°\næƒé‡èŒƒå›´ ï¼ˆç”¨äº BISE è§£ç ï¼‰\næƒé‡å€¼\nåˆ†åŒºçš„æ•°é‡\nåˆ†åŒºæ¨¡å¼ ID\né¢œè‰²ç«¯ç‚¹æ¨¡å¼\né¢œè‰²ç«¯ç‚¹æ•°æ®\nå¹³é¢çš„æ•°é‡ (1 æˆ– 2)\nå¹³é¢åˆ°é€šé“çš„åˆ†é…\n\nçº¹ç†å¯ä»¥è¢«ç¼–ç ä¸ºå•é€šé“ã€åŒé€šé“ã€ä¸‰é€šé“æˆ–å››é€šé“å›¾åƒã€‚ä½†è§£ç åçš„å€¼æ€»æ˜¯ä»¥ RGBA æ ¼å¼è¾“å‡ºã€‚åœ¨ LDR sRGB æ¨¡å¼ä¸‹ï¼Œé¢œè‰²å€¼ä»¥ 8 ä½æ•´æ•°è¿”å›ï¼Œå¦åˆ™ä»¥ 16 ä½æµ®ç‚¹æ•°è¿”å›ã€‚å›¾ 40 å±•ç¤ºäº† ASTC å—çš„å¸ƒå±€\n\n    \n\n\né™¤äº† BlockMode å’Œ Part å­—æ®µï¼Œæ‰€æœ‰å­—æ®µçš„é•¿åº¦éƒ½æ˜¯å¯å˜çš„ã€‚\nPart å­—æ®µæŒ‡å®šäº†åˆ†åŒºçš„æ•°é‡ ï¼ˆå‡ä¸€ï¼‰ ã€‚åœ¨åŒå¹³é¢æ¨¡å¼ä¸‹ï¼Œåˆ†åŒºçš„æ•°é‡å¿…é¡»æ˜¯ 1ã€2 æˆ– 3ã€‚BlockMode å­—æ®µæŒ‡å®šäº†å¹³é¢æ•°ã€æƒé‡èŒƒå›´å’Œæƒé‡ç½‘æ ¼çš„å¤§å°ã€‚ConfigData å’Œ MoreConfigData å­—æ®µæŒ‡å®šæ¯ä¸ªç«¯ç‚¹å¯¹çš„ç«¯ç‚¹æ¨¡å¼ã€‚\nå¦‚æœæ˜¯ 2D ç“¦ç‰‡ï¼ŒBlockMode ç”± 5 ä¸ªå­—æ®µç»„æˆã€‚Aã€Bã€Rã€Dã€Hã€‚ ç‰¹æ®Šçš„ void-exten æ¨¡å¼æœ‰ä¸€ä¸ªå•ç‹¬çš„ç¼–ç ï¼Œç”¨äºå•è‰²ç“¦ç‰‡ã€‚void-exten å—è¿˜å…è®¸è¯†åˆ«é™„è¿‘çš„å•è‰²åŒºåŸŸã€‚å¯ä»¥ç¼©çŸ­è·å–ç›¸åŒçš„å—çš„è¿‡ç¨‹ï¼Œå¹¶è¿›ä¸€æ­¥å‡å°‘å†…å­˜å¸¦å®½å ç”¨\n\n    \n\n\nAã€B å­—æ®µåˆ†åˆ«æŒ‡å®šæƒé‡ç½‘æ ¼çš„å®½åº¦ (N) å’Œé«˜åº¦ (M) ã€‚D ä½ ï¼ˆåŒå€ï¼‰ è¢«è®¾ç½®ä¸ºè¡¨ç¤ºåŒå¹³é¢æ¨¡å¼ã€‚R å­—æ®µ ï¼ˆèŒƒå›´ï¼‰ å’Œ H ä½ ï¼ˆé«˜ç²¾åº¦ï¼‰ æŒ‡å®šé‡é‡èŒƒå›´ ï¼ˆè§è¡¨ 14) ã€‚æ³¨æ„ï¼Œç”±äº R å­—æ®µçš„ç¼–ç ï¼Œä¸ºäº†é¿å…äº§ç”Ÿæ­§ä¹‰ï¼Œä½  å’Œä¸èƒ½åŒæ—¶ä¸ºé›¶\n\n    \n\n\nConfigData å’Œ MoreConfigData æŒ‡å®šäº†ç«¯ç‚¹å¯¹çš„ç¼–ç ï¼Œæ¯ä¸ªç«¯ç‚¹å¯¹éƒ½å¯ä»¥æœ‰ç‹¬ç«‹çš„ç¼–ç æ¨¡å¼ã€‚å…±æœ‰ 16 ç§ç¼–ç æ¨¡å¼ï¼š10 ç§ LDR æ ¼å¼å’Œ 6 ç§ HDR æ ¼å¼ã€‚ç„¶è€Œï¼ŒHDR çº¹ç†å¯ä»¥ä½¿ç”¨å…¶ä¸­ä»»ä½•ä¸€ç§ã€‚æ‰€æœ‰è¿™äº›ç«¯ç‚¹æ ¼å¼éƒ½æ˜¯åŸºäºä»¥ä¸‹åŸºæœ¬æ–¹æ³•ä¹‹ä¸€ï¼š\n\nç‹¬ç«‹æ€§ã€‚ä¸¤ä¸ª k ä½çš„å€¼ç›´æ¥å­˜å‚¨ã€‚\nbase + offsetï¼ˆç±»ä¼¼äº ETC çš„å·®åˆ†ç¼–ç ï¼‰ ã€‚ç¬¬ä¸€ä¸ªå€¼ä¸º base, ç”¨ (k+1) ä½å­˜å‚¨ã€‚ç¬¬äºŒä¸ªå€¼ä¸º offset, ç”¨ (k-1) ä½å­˜å‚¨ã€‚\nbase + scaleã€‚ä¸¤ä¸ª RGB å€¼ç”±å››ä¸ªæ•°å€¼ (Rã€Gã€Bã€s) è¡¨ç¤ºã€‚é¢œè‰²ä¸€ç­‰äº(Rï¼ŒGï¼ŒB)ï¼Œé¢œè‰²äºŒç­‰äº(sRï¼ŒsGï¼ŒsB)\n\nä»æ¦‚å¿µä¸Šè®²ï¼ŒASTC å—çš„è§£ç æ˜¯è¿™æ ·è¿›è¡Œçš„ã€‚BlockMode å­—æ®µç”¨äºç¡®å®šæƒé‡èŒƒå›´å’Œæƒé‡ç½‘æ ¼çš„å¤§å°ã€‚æƒé‡æ•°æ®ä»å‹ç¼©å—çš„å°¾éƒ¨è¯»å–ï¼Œå¹¶ä½¿ç”¨ BISE è¿›è¡Œè§£åŒ…ã€‚ä¹‹åï¼Œæƒé‡è¢«åé‡åŒ–ä¸º [0, 64] èŒƒå›´ã€‚å¦‚æœæƒé‡ç½‘æ ¼çš„å°ºå¯¸å°äºç“¦ç‰‡çš„å°ºå¯¸ï¼Œåˆ™ä½¿ç”¨åŒçº¿æ€§æ’å€¼è¿›è¡Œå‡æ ¼ã€‚\nä¹‹åï¼ŒPart å­—æ®µç”¨äºæŒ‡å®šåˆ†åŒºçš„æ•°å€¼ã€‚åˆ†åŒºæ¨¡å¼ ID ä»å—ä¸­è¯»å‡ºï¼Œç„¶åé’ˆå¯¹æ¯ä¸ªçº¹ç´ ç”Ÿæˆå“ˆå¸Œä½œä¸ºåˆ†åŒºç´¢å¼•ã€‚ç»™å®šåˆ†åŒºæ•°é‡ï¼Œè¿˜å¯ä»¥åˆ©ç”¨ ConfigData å’Œ MoreConfigData å­—æ®µè®¡ç®—æ ‡é‡çš„æ€»å€¼ï¼Œè¯¥å€¼ä¼šè¢«ç”¨äºç«¯ç‚¹ç¼–ç  ï¼ˆç«¯ç‚¹å¯ä»¥æœ‰ä¸åŒæ•°é‡çš„é€šé“ï¼Œä¸åŒçš„ç«¯ç‚¹å­˜å‚¨æ¨¡å¼ä¸‹ä¼šä½¿ç”¨ä¸åŒæ•°é‡çš„å€¼ï¼‰ ã€‚ç„¶è€Œï¼Œè¿™äº›æ ‡é‡å€¼çš„èŒƒå›´åœ¨ BISE è§£ç æ—¶å¿…é¡»æ˜¯å·²çŸ¥çš„ï¼Œå› ä¸ºè¯¥èŒƒå›´å¹¶æ²¡æœ‰è¢«æ˜ç¡®æŒ‡å‡ºã€‚åœ¨æƒé‡å’Œåˆ†åŒºæ•°æ®è§£ç é˜¶æ®µä¹‹åï¼Œå°±å¯ä»¥çŸ¥é“å¯ç”¨äºå½©è‰²ç«¯ç‚¹æ•°æ®çš„æ¯”ç‰¹æ•°ã€‚é¢œè‰²ç«¯ç‚¹çš„å€¼ä¼šä½¿ç”¨é€‚ç”¨äºä¸Šè¿°æ¯”ç‰¹æ•°çš„æœ€å¤§èŒƒå›´çš„å€¼æ¥å­˜å‚¨ã€‚ç«¯ç‚¹è¢«è§£å‹ç¼©å’Œåé‡åŒ–ã€‚ç«¯ç‚¹å¯¹ä¼šæ ¹æ®åˆ†åŒºç´¢å¼•æ¥é€‰æ‹©ã€‚ç«¯ç‚¹çš„é¢œè‰²åˆ™ä½¿ç”¨æ’å€¼æƒé‡æ¥æ··åˆ\nå çº¸ä¸‰é¢C#å†…å­˜åˆ†é…C# å¼€å‘ä¸‰ä¸ªé‡è¦çš„å†…å­˜åŒºåŸŸï¼šæ‰˜ç®¡å †å†…å­˜ã€éæ‰˜ç®¡å †å†…å­˜å’Œæ ˆå†…å­˜\n\n    \n\n\næ‰˜ç®¡å †å†…å­˜ï¼ˆManaged Heap Memoryï¼‰\n    \n\n\næ‰˜ç®¡å †å†…å­˜æ˜¯ç”± .NET è¿è¡Œæ—¶ï¼ˆCLRï¼‰è‡ªåŠ¨ç®¡ç†çš„å†…å­˜åŒºåŸŸï¼Œç”¨äºå­˜å‚¨å¯¹è±¡å®ä¾‹å’Œæ•°ç»„ç­‰å¼•ç”¨ç±»å‹æ•°æ®ã€‚åœ¨å †ä¸Šåˆ†é…çš„å†…å­˜ä¼šé€šè¿‡åƒåœ¾å›æ”¶å™¨ï¼ˆGarbage Collectorï¼‰è¿›è¡Œè‡ªåŠ¨å›æ”¶ï¼Œå¯¹è±¡çš„åˆ›å»ºå’Œé”€æ¯éƒ½æ˜¯ç”±åƒåœ¾å›æ”¶å™¨è´Ÿè´£ç®¡ç†\néæ‰˜ç®¡å †å†…å­˜ï¼ˆUnmanaged Heap Memoryï¼‰\n    \n\n\néæ‰˜ç®¡å †å†…å­˜æ˜¯ç”±æœ¬æœºä»£ç æˆ–å¤–éƒ¨èµ„æºåˆ†é…çš„å†…å­˜åŒºåŸŸï¼Œé€šå¸¸ç”¨äºä¸éæ‰˜ç®¡ä»£ç è¿›è¡Œäº¤äº’ã€è¿›è¡Œåº•å±‚çš„ç³»ç»Ÿç¼–ç¨‹æˆ–ä½¿ç”¨ç‰¹å®šçš„å¤–éƒ¨åº“ã€‚éœ€è¦æ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾å†…å­˜ï¼Œæ²¡æœ‰è‡ªåŠ¨åƒåœ¾å›æ”¶çš„æœºåˆ¶ï¼Œå¯ä»¥ä½¿ç”¨ Marshal ç±»æˆ–unsafe ä¸Šä¸‹æ–‡æ¥è¿›è¡Œéæ‰˜ç®¡å†…å­˜çš„æ“ä½œ\næ ˆå†…å­˜ï¼ˆStack Memoryï¼‰\n    \n\n\næ ˆå†…å­˜ç”¨äºå­˜å‚¨å±€éƒ¨å˜é‡ã€æ–¹æ³•è°ƒç”¨å’Œæ‰§è¡Œä¸Šä¸‹æ–‡ç­‰ä¿¡æ¯ï¼Œå­˜å‚¨çš„æ˜¯å€¼ç±»å‹æ•°æ®å’Œå¼•ç”¨ç±»å‹æ•°æ®çš„å¼•ç”¨ã€‚æ ˆå†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾æ˜¯ç”±ç¼–è¯‘å™¨è‡ªåŠ¨å®Œæˆçš„ï¼Œå…·æœ‰è¾ƒé«˜çš„æ•ˆç‡ï¼Œæ ˆå†…å­˜çš„ä½œç”¨åŸŸä»…é™äºæ‰€å±çš„ä»£ç å—æˆ–æ–¹æ³•\nä¼˜åŒ–æŠ€å·§  æ‰˜ç®¡å †å†…å­˜ä¼˜åŒ–\nä½¿ç”¨å¯¹è±¡æ± ï¼šé¿å…é¢‘ç¹åœ°åˆ›å»ºå’Œé”€æ¯å¯¹è±¡ï¼Œå¯ä»¥ä½¿ç”¨å¯¹è±¡æ± æ¥é‡å¤åˆ©ç”¨å¯¹è±¡å®ä¾‹\nå‡å°‘è£…ç®±å’Œæ‹†ç®±ï¼šå°½é‡ä½¿ç”¨æ³›å‹é›†åˆï¼ˆå¦‚Listï¼‰æ¥é¿å…å€¼ç±»å‹çš„è£…ç®±å’Œæ‹†ç®±æ“ä½œ\nåŠæ—¶é‡Šæ”¾èµ„æºï¼šæ‰‹åŠ¨é‡Šæ”¾ä¸å†ä½¿ç”¨çš„æ‰˜ç®¡å†…å­˜ï¼Œå¦‚è°ƒç”¨å¯¹è±¡çš„ Dispose() æ–¹æ³•æˆ–ä½¿ç”¨ using è¯­å¥æ¥ç¡®ä¿åŠæ—¶é‡Šæ”¾èµ„æº\n\néæ‰˜ç®¡å †å†…å­˜ä¼˜åŒ–\nå°½é‡é¿å…ç›´æ¥ä½¿ç”¨éæ‰˜ç®¡å†…å­˜ï¼šæ¨èä¼˜å…ˆä½¿ç”¨æ‰˜ç®¡å†…å­˜ï¼Œä»…åœ¨å¿…è¦æ—¶ä¸éæ‰˜ç®¡ä»£ç äº¤äº’ï¼Œå¹¶ä½¿ç”¨ Marshal ç±»çš„ç›¸å…³æ–¹æ³•æ¥ç®¡ç†éæ‰˜ç®¡å†…å­˜çš„åˆ†é…å’Œé‡Šæ”¾\né¿å…å†…å­˜æ³„æ¼ï¼šç¡®ä¿å°†éæ‰˜ç®¡å†…å­˜æ­£ç¡®é‡Šæ”¾ï¼Œé¿å…å†…å­˜æ³„æ¼é—®é¢˜\n\næ ˆå†…å­˜ä¼˜åŒ–\nå°½é‡ä½¿ç”¨å±€éƒ¨å˜é‡ï¼šå°†æ•°æ®å­˜å‚¨åœ¨æ ˆä¸Šçš„å±€éƒ¨å˜é‡ä¸­ï¼Œè€Œä¸æ˜¯ä½¿ç”¨ç±»çš„å®ä¾‹å˜é‡ã€‚è¿™æ ·å¯ä»¥å‡å°‘æ‰˜ç®¡å †å†…å­˜çš„å‹åŠ›ï¼ŒåŒæ—¶ä¹Ÿæé«˜è®¿é—®é€Ÿåº¦\nä½¿ç”¨å€¼ç±»å‹ï¼šå¯¹äºå°å‹æ•°æ®ï¼Œè€ƒè™‘ä½¿ç”¨å€¼ç±»å‹è€Œä¸æ˜¯å¼•ç”¨ç±»å‹æ¥å‡å°‘å†…å­˜å¼€é”€å’Œåƒåœ¾å›æ”¶çš„æˆæœ¬\n\nå…¶ä»–ä¼˜åŒ–æŠ€å·§\né¿å…ä½¿ç”¨è¿‡å¤šçš„å­—ç¬¦ä¸²æ‹¼æ¥æ“ä½œï¼šé¢‘ç¹çš„å­—ç¬¦ä¸²æ‹¼æ¥å¯èƒ½ä¼šå¯¼è‡´å†…å­˜ç¢ç‰‡å’Œæ€§èƒ½ä¸‹é™ï¼Œå°½é‡ä½¿ç”¨ StringBuilder ç±»æ¥å¤„ç†å¤§é‡å­—ç¬¦ä¸²æ‹¼æ¥\nç¼“å­˜é‡å¤è®¡ç®—ç»“æœï¼šå¦‚æœæœ‰ä¸€äº›è®¡ç®—ç»“æœä¼šè¢«é‡å¤ä½¿ç”¨ï¼Œå¯ä»¥å°†ç»“æœç¼“å­˜èµ·æ¥ï¼Œé¿å…é‡å¤è®¡ç®—å’Œå†…å­˜æ¶ˆè€—\nä½¿ç”¨åˆé€‚çš„æ•°æ®ç»“æ„ï¼šé€‰æ‹©é€‚å½“çš„æ•°æ®ç»“æ„å’Œç®—æ³•æ¥ä¼˜åŒ–å†…å­˜å’Œæ€§èƒ½ï¼Œå¦‚ä½¿ç”¨å“ˆå¸Œè¡¨ã€é›†åˆç­‰æ•°æ®ç»“æ„\nä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·ï¼šä½¿ç”¨æ€§èƒ½åˆ†æå·¥å…·ï¼ˆå¦‚ã€‚NET Memory Profilerï¼‰æ¥æ£€æµ‹å†…å­˜æ³„æ¼ã€é«˜å†…å­˜ä½¿ç”¨å’Œæ½œåœ¨æ€§èƒ½é—®é¢˜\n\nå †å’Œæ ˆçš„è®¿é—®é€Ÿåº¦  æ ˆæ˜¯æœºå™¨ç³»ç»Ÿæä¾›çš„æ•°æ®ç»“æ„ï¼Œè®¡ç®—æœºä¼šåœ¨åº•å±‚å¯¹æ ˆæä¾›æ”¯æŒï¼šåˆ†é…ä¸“é—¨çš„å¯„å­˜å™¨å­˜æ”¾æ ˆçš„åœ°å€ï¼Œå‹æ ˆå‡ºæ ˆéƒ½æœ‰ä¸“é—¨çš„æŒ‡ä»¤æ‰§è¡Œï¼Œè¿™å°±å†³å®šäº†æ ˆçš„æ•ˆç‡æ¯”è¾ƒé«˜ã€‚å †åˆ™æ˜¯ C/C++ å‡½æ•°åº“æä¾›çš„ï¼Œå®ƒçš„æœºåˆ¶æ˜¯å¾ˆå¤æ‚çš„ï¼Œä¾‹å¦‚ä¸ºäº†åˆ†é…ä¸€å—å†…å­˜ï¼Œåº“å‡½æ•°ä¼šæŒ‰ç…§ä¸€å®šçš„ç®—æ³•ï¼ˆå…·ä½“çš„ç®—æ³•å¯ä»¥å‚è€ƒæ•°æ®ç»“æ„ / æ“ä½œç³»ç»Ÿï¼‰åœ¨å †å†…å­˜ä¸­æœç´¢å¯ç”¨çš„è¶³å¤Ÿå¤§å°çš„ç©ºé—´ï¼Œå¦‚æœæ²¡æœ‰è¶³å¤Ÿå¤§å°çš„ç©ºé—´ï¼ˆå¯èƒ½æ˜¯ç”±äºå†…å­˜ç¢ç‰‡å¤ªå¤šï¼‰ï¼Œå°±æœ‰å¯èƒ½è°ƒç”¨ç³»ç»ŸåŠŸèƒ½å»å¢åŠ ç¨‹åºæ•°æ®æ®µçš„å†…å­˜ç©ºé—´ï¼Œè¿™æ ·å°±æœ‰æœºä¼šåˆ†åˆ°è¶³å¤Ÿå¤§å°çš„å†…å­˜ï¼Œç„¶åè¿›è¡Œè¿”å›ã€‚æ˜¾ç„¶ï¼Œå †çš„æ•ˆç‡æ¯”æ ˆè¦ä½å¾—å¤š\nçº¢ç‚¹ç³»ç»Ÿ  ç±³å“ˆæ¸¸ä¸€é¢ Top K é—®é¢˜ å°é¡¶å †  å¯ä»¥é€šè¿‡æ„é€ ä¸€ä¸ªå‰  ä¸ªæœ€å¤§å…ƒç´ å°é¡¶å †æ¥è§£å†³ï¼Œå°é¡¶å †ä¸Šçš„ä»»æ„èŠ‚ç‚¹å€¼éƒ½å¿…é¡»å°äºç­‰äºå…¶å·¦å³å­èŠ‚ç‚¹å€¼ï¼Œå³å †é¡¶æ˜¯æœ€å°å€¼ã€‚å…·ä½“æ­¥éª¤å¦‚ä¸‹ï¼š\n\nä»æ•°ç»„ä¸­å–å‰  ä¸ªæ•°ï¼ˆåˆ°  ä½ï¼‰ï¼Œæ„é€ ä¸€ä¸ªå°é¡¶å †\nä»  ä½å¼€å§‹éå†æ•°ç»„ï¼Œæ¯ä¸€ä¸ªæ•°æ®éƒ½å’Œå°é¡¶å †çš„å †é¡¶å…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æœå°äºå †é¡¶å…ƒç´ ï¼Œåˆ™ä¸åšä»»ä½•å¤„ç†ï¼Œç»§ç»­éå†ä¸‹ä¸€å…ƒç´ ï¼›å¦‚æœå¤§äºå †é¡¶å…ƒç´ ï¼Œåˆ™å°†è¿™ä¸ªå…ƒç´ æ›¿æ¢æ‰å †é¡¶å…ƒç´ ï¼Œç„¶åå†å †åŒ–æˆä¸€ä¸ªå°é¡¶å †ã€‚\néå†å®Œæˆåï¼Œå †é¡¶çš„æ•°æ®å°±æ˜¯ç¬¬  å¤§çš„æ•°æ®\n\nä»£ç å®ç°let findKthLargest = function(nums, k) {    // ä» nums ä¸­å–å‡ºå‰ k ä¸ªæ•°ï¼Œæ„å»ºä¸€ä¸ªå°é¡¶å †    let heap = [,], i = 0    while(i &lt; k) {       heap.push(nums[i++])     }    buildHeap(heap, k)        // ä» k ä½å¼€å§‹éå†æ•°ç»„    for(let i = k; i &lt; nums.length; i++) {        if(heap[1] &lt; nums[i]) {            // æ›¿æ¢å¹¶å †åŒ–            heap[1] = nums[i]            heapify(heap, k, 1)        }    }        // è¿”å›å †é¡¶å…ƒç´     return heap[1]};// åŸåœ°å»ºå †ï¼Œä»åå¾€å‰ï¼Œè‡ªä¸Šè€Œä¸‹å¼å»ºå°é¡¶å †let buildHeap = (arr, k) =&gt; {    if(k === 1) return    // ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œè‡ªä¸Šè€Œä¸‹å¼å †åŒ–    for(let i = Math.floor(k/2); i&gt;=1 ; i--) {        heapify(arr, k, i)    }}// å †åŒ–let heapify = (arr, k, i) =&gt; {    // è‡ªä¸Šè€Œä¸‹å¼å †åŒ–    while(true) {        let minIndex = i        if(2*i &lt;= k &amp;&amp; arr[2*i] &lt; arr[i]) {            minIndex = 2*i        }        if(2*i+1 &lt;= k &amp;&amp; arr[2*i+1] &lt; arr[minIndex]) {            minIndex = 2*i+1        }        if(minIndex !== i) {            swap(arr, i, minIndex)            i = minIndex        } else {            break        }    }}// äº¤æ¢let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}\n\nå¿«é€Ÿé€‰æ‹©ï¼ˆQuick Selectï¼‰ç®—æ³•  å¿«æ’  å¿«æ’ä½¿ç”¨äº†åˆ†æ²»ç­–ç•¥çš„æ€æƒ³ï¼Œæ‰€è°“åˆ†æ²»ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯åˆ†è€Œæ²»ä¹‹ï¼Œå°†ä¸€ä¸ªå¤æ‚çš„é—®é¢˜ï¼Œåˆ†æˆä¸¤ä¸ªæˆ–å¤šä¸ªç›¸ä¼¼çš„å­é—®é¢˜ï¼Œåœ¨æŠŠå­é—®é¢˜åˆ†æˆæ›´å°çš„å­é—®é¢˜ï¼Œç›´åˆ°æ›´å°çš„å­é—®é¢˜å¯ä»¥ç®€å•æ±‚è§£ï¼Œæ±‚è§£å­é—®é¢˜ï¼Œåˆ™åŸé—®é¢˜çš„è§£åˆ™ä¸ºå­é—®é¢˜è§£çš„åˆå¹¶ã€‚\nå¿«æ’çš„è¿‡ç¨‹ç®€å•çš„è¯´åªæœ‰ä¸‰æ­¥ï¼š\n\né¦–å…ˆä»åºåˆ—ä¸­é€‰å–ä¸€ä¸ªæ•°ä½œä¸ºåŸºå‡†æ•°\nå°†æ¯”è¿™ä¸ªæ•°å¤§çš„æ•°å…¨éƒ¨æ”¾åˆ°å®ƒçš„å³è¾¹ï¼ŒæŠŠå°äºæˆ–è€…ç­‰äºå®ƒçš„æ•°å…¨éƒ¨æ”¾åˆ°å®ƒçš„å·¦è¾¹ ï¼ˆä¸€æ¬¡å¿«æ’partitionï¼‰\nç„¶ååˆ†åˆ«å¯¹åŸºå‡†çš„å·¦å³ä¸¤è¾¹é‡å¤ä»¥ä¸Šçš„æ“ä½œï¼Œç›´åˆ°æ•°ç»„å®Œå…¨æ’åº\n\nå…·ä½“æŒ‰ä»¥ä¸‹æ­¥éª¤å®ç°ï¼š\n\nåˆ›å»ºä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«æŒ‡å‘æ•°ç»„çš„æœ€å·¦ç«¯ä»¥åŠæœ€å³ç«¯\nåœ¨æ•°ç»„ä¸­ä»»æ„å–å‡ºä¸€ä¸ªå…ƒç´ ä½œä¸ºåŸºå‡†\nå·¦æŒ‡é’ˆå¼€å§‹å‘å³ç§»åŠ¨ï¼Œé‡åˆ°æ¯”åŸºå‡†å¤§çš„åœæ­¢\nå³æŒ‡é’ˆå¼€å§‹å‘å·¦ç§»åŠ¨ï¼Œé‡åˆ°æ¯”åŸºå‡†å°çš„å…ƒç´ åœæ­¢ï¼Œäº¤æ¢å·¦å³æŒ‡é’ˆæ‰€æŒ‡å‘çš„å…ƒç´ \né‡å¤ 3ï¼Œ4ï¼Œç›´åˆ°å·¦æŒ‡é’ˆè¶…è¿‡å³æŒ‡é’ˆï¼Œæ­¤æ—¶ï¼Œæ¯”åŸºå‡†å°çš„å€¼å°±éƒ½ä¼šæ”¾åœ¨åŸºå‡†çš„å·¦è¾¹ï¼Œæ¯”åŸºå‡†å¤§çš„å€¼ä¼šå‡ºç°åœ¨åŸºå‡†çš„å³è¾¹\nç„¶ååˆ†åˆ«å¯¹åŸºå‡†çš„å·¦å³ä¸¤è¾¹é‡å¤ä»¥ä¸Šçš„æ“ä½œï¼Œç›´åˆ°æ•°ç»„å®Œå…¨æ’åº\n\nä»£ç å®ç°let quickSort = (arr) =&gt; {  quick(arr, 0 , arr.length - 1)}let quick = (arr, left, right) =&gt; {  let index  if(left &lt; right) {    // åˆ’åˆ†æ•°ç»„    index = partition(arr, left, right)    if(left &lt; index - 1) {      quick(arr, left, index - 1)    }    if(index &lt; right) {      quick(arr, index, right)    }  }}// ä¸€æ¬¡å¿«æ’let partition = (arr, left, right) =&gt; {  // å–ä¸­é—´é¡¹ä¸ºåŸºå‡†  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],      i = left,      j = right  // å¼€å§‹è°ƒæ•´  while(i &lt;= j) {        // å·¦æŒ‡é’ˆå³ç§»    while(arr[i] &lt; datum) {      i++    }        // å³æŒ‡é’ˆå·¦ç§»    while(arr[j] &gt; datum) {      j--    }        // äº¤æ¢    if(i &lt;= j) {      swap(arr, i, j)      i += 1      j -= 1    }  }  return i}// äº¤æ¢let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}// æµ‹è¯•let arr = [1, 3, 2, 5, 4]quickSort(arr)console.log(arr) // [1, 2, 3, 4, 5]// ç¬¬ 2 ä¸ªæœ€å¤§å€¼console.log(arr[arr.length - 2])  // 4\n\nå¿«é€Ÿé€‰æ‹©  ä»…ä»…éœ€è¦åœ¨æ¯æ‰§è¡Œä¸€æ¬¡å¿«æ’çš„æ—¶å€™ï¼Œæ¯”è¾ƒåŸºå‡†å€¼ä½ç½®æ˜¯å¦åœ¨  ä½ç½®ä¸Š\n\nå¦‚æœå°äº ï¼Œåˆ™ç¬¬ ä¸ªæœ€å¤§å€¼åœ¨åŸºå‡†å€¼çš„å³è¾¹ï¼Œæˆ‘ä»¬åªéœ€é€’å½’å¿«æ’åŸºå‡†å€¼å³è¾¹çš„å­åºåˆ—å³å¯ï¼›\nå¦‚æœå¤§äº ï¼Œåˆ™ç¬¬ ä¸ªæœ€å¤§å€¼åœ¨åŸºå‡†å€¼çš„åšè¾¹ï¼Œæˆ‘ä»¬åªéœ€é€’å½’å¿«æ’åŸºå‡†å€¼å·¦è¾¹çš„å­åºåˆ—å³å¯ï¼›\nå¦‚æœç­‰äº ï¼Œåˆ™ç¬¬ ä¸ªæœ€å¤§å€¼å°±æ˜¯åŸºå‡†å€¼\n\nä»£ç å®ç°let findKthLargest = function(nums, k) {    return quickSelect(nums, nums.length - k)};let quickSelect = (arr, k) =&gt; {  return quick(arr, 0 , arr.length - 1, k)}let quick = (arr, left, right, k) =&gt; {  let index  if(left &lt; right) {    // åˆ’åˆ†æ•°ç»„    index = partition(arr, left, right)    // Top k    if(k === index) {        return arr[index]    } else if(k &lt; index) {        // Top k åœ¨å·¦è¾¹        return quick(arr, left, index-1, k)    } else {        // Top k åœ¨å³è¾¹        return quick(arr, index+1, right, k)    }  }  return arr[left]}let partition = (arr, left, right) =&gt; {  // å–ä¸­é—´é¡¹ä¸ºåŸºå‡†  var datum = arr[Math.floor(Math.random() * (right - left + 1)) + left],      i = left,      j = right  // å¼€å§‹è°ƒæ•´  while(i &lt; j) {        // å·¦æŒ‡é’ˆå³ç§»    while(arr[i] &lt; datum) {      i++    }        // å³æŒ‡é’ˆå·¦ç§»    while(arr[j] &gt; datum) {      j--    }        // äº¤æ¢    if(i &lt; j) swap(arr, i, j)    // å½“æ•°ç»„ä¸­å­˜åœ¨é‡å¤æ•°æ®æ—¶ï¼Œå³éƒ½ä¸º datumï¼Œä½†ä½ç½®ä¸åŒ    // ç»§ç»­é€’å¢ iï¼Œé˜²æ­¢æ­»å¾ªç¯    if(arr[i] === arr[j] &amp;&amp; i !== j) {        i++    }  }  return i}// äº¤æ¢let swap = (arr, i , j) =&gt; {    let temp = arr[i]    arr[i] = arr[j]    arr[j] = temp}\n\nRebatch å’Œ Rebuild çš„ä½œç”¨  æœ¯è¯­\nCanvas æ˜¯ Unity æ¸²æŸ“ç³»ç»Ÿç»™å±‚çŠ¶å‡ ä½•ä½“ (layered geometry) æä¾›çš„å¯ä»¥è¢«ç”»å…¥ã€è¢«æ”¾åœ¨ä¸Šé¢æˆ–è€…æ”¾åœ¨ä¸–ç•Œç©ºé—´çš„åº•å±‚ Unity ç»„ä»¶ã€‚Canvas è´Ÿè´£å°†å®ƒåŒ…å«çš„å‡ ä½•ä½“ç»„åˆæˆ batchï¼Œç”Ÿæˆåˆé€‚çš„æ¸²æŸ“å‘½ä»¤å‘é€ç»™ Unity å›¾å½¢ç³»ç»Ÿã€‚è¿™ä¸ªè¿‡ç¨‹åœ¨åº•å±‚çš„ C++ ä»£ç ä¸­å®Œæˆï¼Œè¿™ä¸ªè¿‡ç¨‹è¢«ç§°ä¸ºä¸€æ¬¡ rebatch æˆ–è€…ä¸€æ¬¡ batch buildã€‚å½“ä¸€ä¸ª Canvas è¢«æ ‡è®°ä¸ºåŒ…å«éœ€è¦ rebatch çš„å‡ ä½•ä½“æ—¶ï¼Œè¿™ä¸ª Canvas è¢«è®¤ä¸ºæ˜¯ dirty çš„ã€‚layered geometry , ç”± Canvas Renderer ç»„ä»¶æä¾›ç»™ Canvasã€‚Canvas è´Ÿè´£è¿›è¡Œæ¸²æŸ“ï¼ŒCanvas Renderer è´Ÿè´£é‡‡é›† / æ¥æ”¶\n\nåŠ¨é™éš”ç¦» ä¸€ä¸ªå­ Canvas ä»…ä»…æ˜¯ä¸€ä¸ªåµŒå¥—åœ¨çˆ¶ Canvas ä¸­çš„ç»„ä»¶ï¼Œå­ Canvas å°†å®ƒçš„å­ç‰©ä½“å’Œå®ƒçš„çˆ¶ Canvas éš”ç¦»ï¼Œä¸€ä¸ªå­ Canvas ä¸‹ dirty çš„å­ç‰©ä½“ä¸ä¼šè§¦å‘çˆ¶ Canvas çš„ rebuildï¼Œåä¹‹äº¦ç„¶ï¼ˆè¿™äº›åœ¨æŸäº›ç‰¹æ®Šæƒ…å†µä¸‹æ˜¯ä¸ç¡®å®šçš„ï¼Œæ¯”å¦‚è¯´æ”¹å˜çˆ¶ Canvas çš„å¤§å°å¯¼è‡´å­ Canvas çš„å¤§å°æ”¹å˜ï¼‰\n\nGraphic æ˜¯ UGUI çš„ C# åº“æä¾›çš„ä¸€ä¸ªåŸºç±»ã€‚å®ƒæ˜¯ UGUI æ‰€æœ‰ç±»çš„åŸºç±»ï¼Œç»™æ‰€æœ‰çš„ UGUI ç±»æä¾›å¯ä»¥ç”»åœ¨ Canvas ç³»ç»Ÿä¸Šçš„å‡ ä½•å›¾å½¢ã€‚å¤§å¤šæ•° Unity å†…ç½®çš„ç»§æ‰¿ Graphic çš„ç±»éƒ½æ˜¯é€šè¿‡ç»§æ‰¿ä¸€ä¸ªå« MaskableGraphic çš„å­ç±»æ¥å®ç°ï¼Œè¿™ä½¿å¾—ä»–ä»¬å¯ä»¥é€šè¿‡ IMaskable æ¥å£æ¥è¢«éšè—ã€‚Drawable ç±»çš„å­ç±»ä¸»è¦æ˜¯ image å’Œ textï¼Œå·²ç»æä¾›äº†åŒåçš„ç»„ä»¶\n\nLayout ç»„ä»¶æ§åˆ¶ç€ RectTransform çš„å¤§å°å’Œä½ç½®ï¼Œç»å¸¸è¢«ç”¨äºè¦ç”Ÿæˆå…·æœ‰ç›¸ä¼¼çš„å¤§å°å’Œä½ç½®å…³ç³»å†…å®¹çš„å¤æ‚å¸ƒå±€ã€‚å®ƒåªä¾é  RectTransformï¼Œåªå½±å“ä¸å…¶ç›¸å…³çš„ RectTransform çš„å±æ€§ã€‚è¿™äº› layout ç»„ä»¶ä¸ä¾èµ–äº Graphic ç±»ï¼Œå¯ä»¥ç‹¬ç«‹äº UGUI çš„ Graphic ç»„ä»¶ä¹‹å¤–ä½¿ç”¨\n\nCanvasUpdateRegistry Graphic å’Œ Layout ç»„ä»¶éƒ½ä¾èµ–äº CanvasUpdateRegistry ç±»ï¼Œå®ƒä¸ä¼šåœ¨ Unity ç¼–è¾‘å™¨çš„ç•Œé¢ä¸­æ˜¾ç¤ºã€‚è¿™ä¸ªç±»è¿½è¸ªé‚£äº› Graphic å’Œ Layout ç»„ä»¶å¿…é¡»è¢«æ›´æ–°çš„æ—¶å€™ï¼Œè¿˜æœ‰ä¸å…¶å¯¹åº”çš„ Canvas è§¦å‘äº† willRenderCanvases äº‹ä»¶çš„æ—¶å€™ã€‚æ›´æ–° Graphic ç±»å’Œ Layout ç±»å«åš ** Rebuild**\n\n\n\nåœ¨ä½¿ç”¨ UGUI åˆ¶ä½œ UI æ—¶ï¼Œè¯·ç‰¢è®° Canvas ä¸­æ‰€æœ‰å‡ ä½•ä½“çš„ç»˜åˆ¶éƒ½åœ¨ä¸€ä¸ªé€æ˜é˜Ÿåˆ—ä¸­ï¼Œè¿™å°±æ„å‘³ç€ç”± UGUI åˆ¶ä½œçš„å‡ ä½•ä½“å°†ä»å§‹è‡³ç»ˆä¼´éšç€ alpha æ··åˆï¼Œæ‰€ä»¥ä»å¤šè¾¹å½¢æ …æ ¼åŒ–çš„æ¯ä¸ªåƒç´ éƒ½å°†è¢«é‡‡æ ·ï¼Œå³ä½¿å®ƒè¢«å®Œå…¨ä¸é€æ˜çš„ç‰©ä½“æ‰€è¦†ç›–ã€‚åœ¨æ‰‹æœºè®¾å¤‡ä¸Šï¼Œè¿™ç§é«˜ç­‰çº§çš„è¿‡åº¦ç»˜åˆ¶å°†è¿…é€Ÿè¶…è¿‡ GPU å¡«å……é¢‘ç‡çš„æ‰¿å—èƒ½åŠ›\n\nBatch æ„å»ºè¿‡ç¨‹ï¼ˆCanvasï¼‰\nBatch æ„å»ºè¿‡ç¨‹æ˜¯æŒ‡ Canvas é€šè¿‡ç»“åˆç½‘æ ¼ç»˜åˆ¶å®ƒæ‰€æ‰¿è½½çš„ UI å…ƒç´ ï¼Œç”Ÿæˆé€‚å½“çš„æ¸²æŸ“å‘½ä»¤å‘é€ç»™ Unity å›¾å½¢æµæ°´çº¿ã€‚Batch çš„ç»“æœè¢«ç¼“å­˜å¤ç”¨ï¼Œç›´åˆ°è¿™ä¸ª Canvas è¢«æ ‡ä¸º dirtyï¼Œå½“ Canvas ä¸­æŸä¸€ä¸ªæ„æˆçš„ç½‘æ ¼æ”¹å˜çš„æ—¶å€™å°±ä¼šæ ‡è®°ä¸º dirty\nCanvas çš„ç½‘æ ¼ä»é‚£äº› Canvas ä¸‹çš„ CnavasRenderer ç»„ä»¶ä¸­è·å–ï¼Œä½†ä¸åŒ…å«ä»»ä½•å­ Canvas\nè®¡ç®— Batch è¦æ±‚æŒ‰ç…§æ·±åº¦æ’åºç½‘æ ¼ï¼Œæµ‹è¯•å®ƒä»¬æ˜¯å¦æœ‰é‡å ï¼Œå…±äº«æè´¨ç­‰ç­‰ã€‚è¿™ä¸ªè¿‡ç¨‹æ˜¯å¤šçº¿ç¨‹çš„ï¼Œåœ¨ä¸åŒçš„ CPU æ¶æ„ä¸‹æ€§èƒ½è¡¨ç°éå¸¸ä¸åŒï¼Œç‰¹åˆ«æ˜¯åœ¨æ‰‹æœºèŠ¯ç‰‡ï¼ˆé€šå¸¸ CPU æ ¸å¿ƒå¾ˆå°‘ï¼‰å’Œç°ä»£æ¡Œé¢ CPUï¼ˆé€šå¸¸æ‹¥æœ‰å››æ ¸å¿ƒæˆ–è€…æ›´å¤šï¼‰ä¹‹é—´éå¸¸ä¸åŒ\n\nRebuild è¿‡ç¨‹ï¼ˆGraphicsï¼‰Rebuild è¿‡ç¨‹æ˜¯æŒ‡ Layout å’Œ UGUI çš„ C# çš„ Graphic ç»„ä»¶çš„ç½‘æ ¼è¢«é‡æ–°è®¡ç®—ï¼Œè¿™æ˜¯åœ¨ CanvasUpdateRegistry ç±»ä¸­æ‰§è¡Œçš„ã€‚è¿™æ˜¯ä¸€ä¸ª Cï¼ƒç±»ï¼Œå®ƒçš„æºç å¯ä»¥åœ¨ Unity çš„ Bitbucket ä¸Šæ‰¾åˆ°ã€‚CanvasUpdateRegistry ç±»ä¸­ï¼ŒPerformUpdate æ–¹æ³•ï¼Œå½“ä¸€ä¸ª Canvas ç»„ä»¶è§¦å‘å®ƒçš„ WillRenderCanvases äº‹ä»¶æ—¶ï¼Œè¿™ä¸ªæ–¹æ³•å°±ä¼šè¢«æ‰§è¡Œã€‚è¿™ä¸ªäº‹ä»¶æ¯å¸§è°ƒç”¨ä¸€æ¬¡ã€‚PerformUpdate å‡½æ•°è¿è¡Œçš„ä¸‰ä¸ªæ­¥éª¤ï¼š\n\né€šè¿‡ ICanvasElement.Rebuild å‡½æ•°ï¼Œè¯·æ±‚ rebuild è¢« Dirty çš„ Layout ç»„ä»¶\næ‰€æœ‰è¢«æ³¨å†Œçš„è£å‰ªç»„ä»¶ï¼ˆä¾‹å¦‚ Maskï¼‰ï¼Œå¯¹éœ€è¦è¢«è£å‰ªçš„ç»„ä»¶è¿›è¡Œå‰”é™¤ã€‚è¿™åœ¨ ClippingRegistry.Cull ä¸­æ‰§è¡Œ\ndirty çš„ Graphic ç»„ä»¶è¢«è¦æ±‚ rebuild å…¶å›¾å½¢å…ƒç´ \n\nLayout å’Œ Graphic çš„ Rebuild\nLayout Rebuild è¦é‡æ–°è®¡ç®—ä¸€ä¸ªæˆ–è€…å¤šä¸ª Layout ç»„ä»¶æ‰€åŒ…å«çš„ UI ç»„ä»¶çš„é€‚å½“ä½ç½®ï¼ˆä»¥åŠå¯èƒ½çš„å¤§å°ï¼‰ï¼Œæœ‰å¿…è¦å¯¹ Layout åº”ç”¨å±‚æ¬¡çš„æ’åºã€‚åœ¨ GameObject çš„ hierarchy ä¸­é è¿‘ root çš„ Layout å¯èƒ½ä¼šå½±å“æ”¹å˜åµŒå¥—åœ¨å®ƒé‡Œé¢çš„å…¶ä»– Layout çš„ä½ç½®å’Œå¤§å°ï¼Œæ‰€ä»¥å¿…é¡»é¦–å…ˆè®¡ç®—ã€‚ ä¸ºæ­¤ï¼ŒUGUI æ ¹æ®å±‚æ¬¡ç»“æ„ä¸­çš„æ·±åº¦å¯¹ dirty çš„ Layout ç»„ä»¶åˆ—è¡¨è¿›è¡Œæ’åºã€‚å±‚æ¬¡ç»“æ„ä¸­è¾ƒé«˜çš„ Layoutï¼ˆå³æ‹¥æœ‰è¾ƒå°‘çš„çˆ¶ transformï¼‰å°†è¢«ç§»åˆ°åˆ—è¡¨çš„å‰é¢ã€‚ç„¶åï¼Œæ’åºå¥½çš„ Layout ç»„ä»¶çš„åˆ—è¡¨å°†è¢« rebuildï¼Œåœ¨è¿™ä¸ªæ­¥éª¤ Layout ç»„ä»¶æ§åˆ¶çš„ UI å…ƒç´ çš„ä½ç½®å’Œå¤§å°å°†è¢«å®é™…æ”¹å˜\nGraphic Rebuild å½“ Graphic ç»„ä»¶è¢« rebuild çš„æ—¶å€™ï¼ŒUGUI å°†æ§åˆ¶ä¼ é€’ç»™ ICanvasElement æ¥å£çš„ Rebuild æ–¹æ³•ã€‚Graphic æ‰§è¡Œäº†è¿™ä¸€æ­¥ï¼Œå¹¶åœ¨ rebuild è¿‡ç¨‹ä¸­çš„ PreRender é˜¶æ®µè¿è¡Œäº†ä¸¤ä¸ªä¸åŒçš„ rebuild æ­¥éª¤ï¼š\nå¦‚æœé¡¶ç‚¹æ•°æ®å·²ç»è¢«æ ‡ä¸º Dirtyï¼ˆä¾‹å¦‚ç»„ä»¶çš„ RectTransform å·²ç»æ”¹å˜å¤§å°ï¼‰ï¼Œåˆ™é‡å»ºç½‘æ ¼\nå¦‚æœæè´¨æ•°æ®å·²ç»è¢«æ ‡ä¸º Dirtyï¼ˆä¾‹å¦‚ç»„ä»¶çš„ material æˆ–è€… texture å·²ç»è¢«æ”¹å˜ï¼‰ï¼Œåˆ™å…³è”çš„ Canvas Renderer çš„æè´¨å°†è¢«æ›´æ–°ã€‚Graphic çš„ Rebuild ä¸ä¼šæŒ‰ç…§ Graphic ç»„ä»¶çš„ç‰¹æ®Šé¡ºåºè¿›è¡Œï¼Œä¹Ÿä¸ä¼šè¿›è¡Œä»»ä½•çš„æ’åºæ“ä½œ\n\n\n\nå‰å‘æ¸²æŸ“å’Œå»¶è¿Ÿæ¸²æŸ“  æ­£å‘æ¸²æŸ“  æ­£å‘æ¸²æŸ“ (Forward Rendering) æˆ–è€…æ­£å‘ç€è‰²æ³• (Forward Shading)ï¼Œå®ƒæ˜¯æˆ‘ä»¬æ¸²æŸ“ç‰©ä½“çš„ä¸€ç§éå¸¸ç›´æ¥çš„æ–¹å¼ï¼Œåœ¨åœºæ™¯ä¸­æˆ‘ä»¬æ ¹æ®æ‰€æœ‰å…‰æºç…§äº®ä¸€ä¸ªç‰©ä½“ï¼Œä¹‹åå†æ¸²æŸ“ä¸‹ä¸€ä¸ªç‰©ä½“ï¼Œä»¥æ­¤ç±»æ¨ã€‚å®ƒéå¸¸å®¹æ˜“ç†è§£ï¼Œä¹Ÿå¾ˆå®¹æ˜“å®ç°ï¼Œä½†æ˜¯åŒæ—¶å®ƒå¯¹ç¨‹åºæ€§èƒ½çš„å½±å“ä¹Ÿå¾ˆå¤§ï¼Œå› ä¸ºå¯¹äºæ¯ä¸€ä¸ªéœ€è¦æ¸²æŸ“çš„ç‰©ä½“ï¼Œç¨‹åºéƒ½è¦å¯¹æ¯ä¸€ä¸ªå…‰æºæ¯ä¸€ä¸ªéœ€è¦æ¸²æŸ“çš„ç‰‡æ®µè¿›è¡Œè¿­ä»£ï¼Œè¿™æ˜¯éå¸¸å¤šçš„ï¼å› ä¸ºå¤§éƒ¨åˆ†ç‰‡æ®µç€è‰²å™¨çš„è¾“å‡ºéƒ½ä¼šè¢«ä¹‹åçš„è¾“å‡ºè¦†ç›–ï¼Œæ­£å‘æ¸²æŸ“è¿˜ä¼šåœ¨åœºæ™¯ä¸­å› ä¸ºé«˜æ·±çš„å¤æ‚åº¦ï¼ˆå¤šä¸ªç‰©ä½“é‡åˆåœ¨ä¸€ä¸ªåƒç´ ä¸Šï¼‰æµªè´¹å¤§é‡çš„ç‰‡æ®µç€è‰²å™¨è¿è¡Œæ—¶é—´ã€‚å»¶è¿Ÿç€è‰²æ³• (Deferred Shading)ï¼Œæˆ–è€…è¯´æ˜¯å»¶è¿Ÿæ¸²æŸ“ (Deferred Rendering)ï¼Œä¸ºäº†è§£å†³ä¸Šè¿°é—®é¢˜è€Œè¯ç”Ÿäº†ï¼Œå®ƒå¤§å¹…åº¦åœ°æ”¹å˜äº†æˆ‘ä»¬æ¸²æŸ“ç‰©ä½“çš„æ–¹å¼\nå»¶è¿Ÿç€è‰²æ³•åŸºäºæˆ‘ä»¬å»¶è¿Ÿ (Defer) æˆ–æ¨è¿Ÿ (Postpone) å¤§éƒ¨åˆ†è®¡ç®—é‡éå¸¸å¤§çš„æ¸²æŸ“ï¼ˆåƒæ˜¯å…‰ç…§ï¼‰åˆ°åæœŸè¿›è¡Œå¤„ç†çš„æƒ³æ³•ã€‚å®ƒåŒ…å«ä¸¤ä¸ªå¤„ç†é˜¶æ®µ (Pass)ï¼š\n\nåœ¨ç¬¬ä¸€ä¸ªå‡ ä½•å¤„ç†é˜¶æ®µ (Geometry Pass) ä¸­ï¼Œæˆ‘ä»¬å…ˆæ¸²æŸ“åœºæ™¯ä¸€æ¬¡ï¼Œä¹‹åè·å–å¯¹è±¡çš„å„ç§å‡ ä½•ä¿¡æ¯ï¼Œå¹¶å‚¨å­˜åœ¨ä¸€ç³»åˆ—å«åš G ç¼“å†² (G-buffer) çš„çº¹ç†ä¸­ï¼›ä½ç½®å‘é‡ (Position Vector)ã€é¢œè‰²å‘é‡ (Color Vector)ã€æ³•å‘é‡ (Normal Vector) å’Œ / æˆ–é•œé¢å€¼ (Specular Value)ã€‚åœºæ™¯ä¸­è¿™äº›å‚¨å­˜åœ¨ G ç¼“å†²ä¸­çš„å‡ ä½•ä¿¡æ¯å°†ä¼šåœ¨ä¹‹åç”¨æ¥åšï¼ˆæ›´å¤æ‚çš„ï¼‰å…‰ç…§è®¡ç®—ã€‚ä¸‹é¢æ˜¯ä¸€å¸§ä¸­ G ç¼“å†²çš„å†…å®¹\n\n\n    \n\n\n\nç¬¬äºŒä¸ªå…‰ç…§å¤„ç†é˜¶æ®µ (Lighting Pass) ä¸­ä½¿ç”¨ G ç¼“å†²å†…çš„çº¹ç†æ•°æ®ã€‚åœ¨å…‰ç…§å¤„ç†é˜¶æ®µä¸­ï¼Œæˆ‘ä»¬æ¸²æŸ“ä¸€ä¸ªå±å¹•å¤§å°çš„æ–¹å½¢ï¼Œå¹¶ä½¿ç”¨ G ç¼“å†²ä¸­çš„å‡ ä½•æ•°æ®å¯¹æ¯ä¸€ä¸ªç‰‡æ®µè®¡ç®—åœºæ™¯çš„å…‰ç…§ï¼›åœ¨æ¯ä¸ªåƒç´ ä¸­æˆ‘ä»¬éƒ½ä¼šå¯¹ G ç¼“å†²è¿›è¡Œè¿­ä»£ã€‚æˆ‘ä»¬å¯¹äºæ¸²æŸ“è¿‡ç¨‹è¿›è¡Œè§£è€¦ï¼Œå°†å®ƒé«˜çº§çš„ç‰‡æ®µå¤„ç†æŒªåˆ°åæœŸè¿›è¡Œï¼Œè€Œä¸æ˜¯ç›´æ¥å°†æ¯ä¸ªå¯¹è±¡ä»é¡¶ç‚¹ç€è‰²å™¨å¸¦åˆ°ç‰‡æ®µç€è‰²å™¨ã€‚å…‰ç…§è®¡ç®—è¿‡ç¨‹è¿˜æ˜¯å’Œæˆ‘ä»¬ä»¥å‰ä¸€æ ·ï¼Œä½†æ˜¯ç°åœ¨æˆ‘ä»¬éœ€è¦ä»å¯¹åº”çš„ G ç¼“å†²è€Œä¸æ˜¯é¡¶ç‚¹ç€è‰²å™¨ï¼ˆå’Œä¸€äº› uniform å˜é‡ï¼‰é‚£é‡Œè·å–è¾“å…¥å˜é‡äº†\n\n\n    \n\n\nè¿™ç§æ¸²æŸ“æ–¹æ³•ä¸€ä¸ªå¾ˆå¤§çš„å¥½å¤„å°±æ˜¯èƒ½ä¿è¯åœ¨ G ç¼“å†²ä¸­çš„ç‰‡æ®µå’Œåœ¨å±å¹•ä¸Šå‘ˆç°çš„åƒç´ æ‰€åŒ…å«çš„ç‰‡æ®µä¿¡æ¯æ˜¯ä¸€æ ·çš„ï¼Œå› ä¸ºæ·±åº¦æµ‹è¯•å·²ç»æœ€ç»ˆå°†è¿™é‡Œçš„ç‰‡æ®µä¿¡æ¯ä½œä¸ºæœ€é¡¶å±‚çš„ç‰‡æ®µã€‚è¿™æ ·ä¿è¯äº†å¯¹äºåœ¨å…‰ç…§å¤„ç†é˜¶æ®µä¸­å¤„ç†çš„æ¯ä¸€ä¸ªåƒç´ éƒ½åªå¤„ç†ä¸€æ¬¡\nå½“ç„¶è¿™ç§æ–¹æ³•ä¹Ÿå¸¦æ¥å‡ ä¸ªç¼ºé™·ï¼Œ ç”±äº G ç¼“å†²è¦æ±‚æˆ‘ä»¬åœ¨çº¹ç†é¢œè‰²ç¼“å†²ä¸­å­˜å‚¨ç›¸å¯¹æ¯”è¾ƒå¤§çš„åœºæ™¯æ•°æ®ï¼Œè¿™ä¼šæ¶ˆè€—æ¯”è¾ƒå¤šçš„æ˜¾å­˜ï¼Œå°¤å…¶æ˜¯ç±»ä¼¼ä½ç½®å‘é‡ä¹‹ç±»çš„éœ€è¦é«˜ç²¾åº¦çš„åœºæ™¯æ•°æ®ã€‚ å¦å¤–ä¸€ä¸ªç¼ºç‚¹å°±æ˜¯ä»–ä¸æ”¯æŒæ··è‰²ï¼ˆå› ä¸ºæˆ‘ä»¬åªæœ‰æœ€å‰é¢çš„ç‰‡æ®µä¿¡æ¯ï¼‰ï¼Œ å› æ­¤ä¹Ÿä¸èƒ½ä½¿ç”¨ MSAA äº†\nG ç¼“å†²G ç¼“å†² (G-buffer) æ˜¯å¯¹æ‰€æœ‰ç”¨æ¥å‚¨å­˜å…‰ç…§ç›¸å…³çš„æ•°æ®ï¼Œå¹¶åœ¨æœ€åçš„å…‰ç…§å¤„ç†é˜¶æ®µä¸­ä½¿ç”¨çš„æ‰€æœ‰çº¹ç†çš„æ€»ç§°ã€‚åœ¨æ­£å‘æ¸²æŸ“ä¸­ç…§äº®ä¸€ä¸ªç‰‡æ®µæ‰€éœ€è¦çš„æ‰€æœ‰æ•°æ®ï¼š\n\nä¸€ä¸ª 3D ä½ç½®å‘é‡æ¥è®¡ç®—ï¼ˆæ’å€¼ï¼‰ç‰‡æ®µä½ç½®å˜é‡ä¾› lightDir å’ŒviewDirä½¿ç”¨\nä¸€ä¸ª RGB æ¼«åå°„é¢œè‰²å‘é‡ï¼Œä¹Ÿå°±æ˜¯åç…§ç‡ (Albedo)\nä¸€ä¸ª 3D æ³•å‘é‡æ¥åˆ¤æ–­å¹³é¢çš„æ–œç‡\nä¸€ä¸ªé•œé¢å¼ºåº¦ (Specular Intensity) æµ®ç‚¹å€¼\næ‰€æœ‰å…‰æºçš„ä½ç½®å’Œé¢œè‰²å‘é‡\nç©å®¶æˆ–è€…è§‚å¯Ÿè€…çš„ä½ç½®å‘é‡\n\nå…‰æºçš„ä½ç½®ï¼Œé¢œè‰²ï¼Œå’Œç©å®¶çš„è§‚å¯Ÿä½ç½®å¯ä»¥é€šè¿‡ uniform å˜é‡æ¥è®¾ç½®ï¼Œä½†æ˜¯å…¶å®ƒå˜é‡å¯¹äºæ¯ä¸ªå¯¹è±¡çš„ç‰‡æ®µéƒ½æ˜¯ä¸åŒçš„ã€‚å¦‚æœæˆ‘ä»¬èƒ½ä»¥æŸç§æ–¹å¼ä¼ è¾“å®Œå…¨ç›¸åŒçš„æ•°æ®åˆ°æœ€ç»ˆçš„å»¶è¿Ÿå…‰ç…§å¤„ç†é˜¶æ®µä¸­ï¼Œæˆ‘ä»¬å°±èƒ½è®¡ç®—ä¸ä¹‹å‰ç›¸åŒçš„å…‰ç…§æ•ˆæœäº†\nwhile(...) // æ¸¸æˆå¾ªç¯{    // 1. å‡ ä½•å¤„ç†é˜¶æ®µï¼šæ¸²æŸ“æ‰€æœ‰çš„å‡ ä½• / é¢œè‰²æ•°æ®åˆ° G ç¼“å†²     glBindFramebuffer(GL_FRAMEBUFFER, gBuffer);    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    gBufferShader.Use();    for(Object obj : Objects)    {        ConfigureShaderTransformsAndUniforms();        obj.Draw();    }      // 2. å…‰ç…§å¤„ç†é˜¶æ®µï¼šä½¿ç”¨ G ç¼“å†²è®¡ç®—åœºæ™¯çš„å…‰ç…§    glBindFramebuffer(GL_FRAMEBUFFER, 0);    glClear(GL_COLOR_BUFFER_BIT);    lightingPassShader.Use();    BindAllGBufferTextures();    SetLightingUniforms();    RenderQuad();}\n\nå»¶è¿Ÿå…‰ç…§å¤„ç†é˜¶æ®µ  ç°åœ¨æˆ‘ä»¬å·²ç»æœ‰äº†ä¸€å¤§å †çš„ç‰‡æ®µæ•°æ®å‚¨å­˜åœ¨ G ç¼“å†²ä¸­ä¾›æˆ‘ä»¬å¤„ç½®ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©é€šè¿‡ä¸€ä¸ªåƒç´ ä¸€ä¸ªåƒç´ åœ°éå†å„ä¸ª G ç¼“å†²çº¹ç†ï¼Œå¹¶å°†å‚¨å­˜åœ¨å®ƒä»¬é‡Œé¢çš„å†…å®¹ä½œä¸ºå…‰ç…§ç®—æ³•çš„è¾“å…¥ï¼Œæ¥å®Œå…¨è®¡ç®—åœºæ™¯æœ€ç»ˆçš„å…‰ç…§é¢œè‰²ã€‚ç”±äºæ‰€æœ‰çš„ G ç¼“å†²çº¹ç†éƒ½ä»£è¡¨çš„æ˜¯æœ€ç»ˆå˜æ¢çš„ç‰‡æ®µå€¼ï¼Œæˆ‘ä»¬åªéœ€è¦å¯¹æ¯ä¸€ä¸ªåƒç´ æ‰§è¡Œä¸€æ¬¡æ˜‚è´µçš„å…‰ç…§è¿ç®—å°±è¡Œäº†ã€‚è¿™ä½¿å¾—å»¶è¿Ÿå…‰ç…§éå¸¸é«˜æ•ˆï¼Œç‰¹åˆ«æ˜¯åœ¨éœ€è¦è°ƒç”¨å¤§é‡é‡å‹ç‰‡æ®µç€è‰²å™¨çš„å¤æ‚åœºæ™¯ä¸­\nç½‘æ˜“ C++ æ„é€ å‡½æ•°å¯ä»¥æ˜¯è™šå‡½æ•°å— ä¸ºä»€ä¹ˆæ„é€ å‡½æ•°ä¸å¯ä»¥æ˜¯è™šå‡½æ•°  ä»å†…å­˜çš„è§’åº¦çœ‹  è™šå‡½æ•°å¯¹åº”ä¸€ä¸ªè™šå‡½æ•°è¡¨ï¼Œè™šå‡½æ•°è¡¨æ˜¯å­˜å‚¨åœ¨å¯¹è±¡çš„å†…å­˜ç©ºé—´ä¸­çš„ã€‚è€Œè°ƒç”¨è™šå‡½æ•°ä½¿ç”¨è¿‡è°ƒç”¨è™šå‡½æ•°è¡¨æ¥å®ç°çš„ã€‚å¦‚æœæ„é€ å‡½æ•°æ˜¯è™šå‡½æ•°ï¼Œé‚£ä¹ˆå°±éœ€è¦é€šè¿‡è™šå‡½æ•°è¡¨æ¥è°ƒç”¨ï¼Œä½†æ˜¯å¯¹è±¡æ˜¯é€šè¿‡æ„é€ å‡½æ•°å®ä¾‹åŒ–çš„ï¼Œåœ¨è°ƒç”¨æ„é€ å‡½æ•°ä¹‹å‰ï¼Œè™šå‡½æ•°è¡¨å†…å­˜ç©ºé—´è¿˜æ²¡æœ‰è¢«åˆ›å»ºï¼Œæ— æ³•æ‰¾åˆ°è™šè¡¨ã€‚æ‰€ä»¥æ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°\nä»ä½¿ç”¨çš„è§’åº¦çœ‹  è™šå‡½æ•°æ˜¯é€šè¿‡æŒ‡å‘æ´¾ç”Ÿç±»çš„åŸºç±»æŒ‡é’ˆæˆ–å¼•ç”¨ï¼Œè®¿é—®æ´¾ç”Ÿç±»ä¸­åŒåè¦†ç›–æˆå‘˜å‡½æ•°ã€‚ä½†æ˜¯æ„é€ å‡½æ•°æ˜¯é€šè¿‡åˆ›å»ºå¯¹è±¡æ—¶è‡ªåŠ¨è°ƒç”¨çš„ï¼Œä¸å¯èƒ½é€šè¿‡çˆ¶ç±»çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨å»è°ƒç”¨ï¼Œæ‰€ä»¥è§„å®šæ„é€ å‡½æ•°ä¸èƒ½æ˜¯è™šå‡½æ•°\nä¸ºä»€ä¹ˆææ„å‡½æ•°å¯ä»¥æ˜¯è™šå‡½æ•°  ä¸€ä¸ªæ´¾ç”Ÿç±»çš„æŒ‡é’ˆå¯ä»¥å®‰å…¨åœ°è½¬åŒ–ä¸ºä¸€ä¸ªåŸºç±»çš„æŒ‡é’ˆã€‚è¿™æ ·åˆ é™¤ä¸€ä¸ªåŸºç±»çš„æŒ‡é’ˆçš„æ—¶å€™ï¼ŒC++ ä¸ç®¡è¿™ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€ä¸ªåŸºç±»å¯¹è±¡è¿˜æ˜¯ä¸€ä¸ªæ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œè°ƒç”¨çš„éƒ½æ˜¯åŸºç±»çš„ææ„å‡½æ•°è€Œä¸æ˜¯æ´¾ç”Ÿç±»çš„ã€‚å¦‚æœä½ ä¾èµ–äºåŸºç±»çš„ææ„å‡½æ•°çš„ä»£ç æ¥é‡Šæ”¾èµ„æºï¼Œè€Œæ²¡æœ‰é‡è½½ææ„å‡½æ•°ï¼Œé‚£ä¹ˆä¼šæœ‰èµ„æºæ³„æ¼ã€‚C++ ä¸æŠŠè™šææ„å‡½æ•°ç›´æ¥ä½œä¸ºé»˜è®¤å€¼çš„åŸå› æ˜¯è™šå‡½æ•°è¡¨çš„å¼€é”€ä»¥åŠå’Œ C è¯­è¨€çš„ç±»å‹çš„å…¼å®¹æ€§ã€‚æœ‰è™šå‡½æ•°çš„å¯¹è±¡æ€»æ˜¯åœ¨å¼€å§‹çš„ä½ç½®åŒ…å«ä¸€ä¸ªéšå«çš„è™šå‡½æ•°è¡¨æŒ‡é’ˆæˆå‘˜\næ¸²æŸ“æµç¨‹ï¼ŒCPU é˜¶æ®µçš„å‰”é™¤æ“ä½œæœ‰å“ªäº›  å‰”é™¤æœ‰è§†é”¥ä½“å‰”é™¤ï¼ˆFrustum Cullingï¼‰ã€å±‚çº§å‰”é™¤ï¼ˆLayer Culling Maskï¼‰ã€é®æŒ¡å‰”é™¤ï¼ˆOcclusion Cullingï¼‰ç­‰æ­¥éª¤ï¼Œç›®çš„æ˜¯å°†ä¸æƒ³è¢«æ‘„åƒæœºçœ‹åˆ°çš„ç‰©ä½“å‰”é™¤æ‰ï¼Œå‡å°‘ä¸å¿…è¦çš„æ€§èƒ½å¼€é”€ï¼Œæé«˜æ¸²æŸ“æ•ˆç‡\nè§†é”¥ä½“å‰”é™¤  åœ¨ Unity ä¸­ï¼Œæ‘„åƒæœºçš„å¯è§†åŒºåŸŸæ˜¯ä¸€ä¸ªæ¨ªæ”¾çš„é‡‘å­—å¡”å½¢ç§°ä¸ºè§†é”¥ä½“ï¼Œç”±è¿‘è£é¢ã€è¿œè£é¢ã€è§†åœºè§’ä¸‰ä¸ªå‚æ•°æ§åˆ¶ï¼Œé€šè¿‡è®¡ç®—è¿™ä¸ªè§†é”¥ä½“ä¸åœºæ™¯ä¸­çš„æ¨¡å‹æ˜¯å¦ç›¸äº¤ï¼Œæ²¡æœ‰ç›¸äº¤å°±è¯´æ˜ä½äºå¯è§†åŒºåŸŸå¤–ï¼Œè¿™æ ·çš„æ¨¡å‹å°±åº”è¯¥è¿›è¡Œå‰”é™¤\n\n    \n\n\nç”±äºæ¨¡å‹ä¸€èˆ¬é¢æ•°è¾ƒå¤šï¼Œå› æ­¤ä¼šé‡‡ç”¨ç»™æ¨¡å‹åˆ›å»ºåŒ…å›´ä½“å†è®¡ç®—åŒ…å›´ä½“ä¸å¯è§†åŒºåŸŸæ˜¯å¦ç›¸äº¤çš„æ–¹å¼ç®€åŒ–è®¡ç®—ã€‚åŒ…å›´ä½“æœ‰å¤šç§è®¡ç®—æ–¹æ³•ï¼Œå¸¸ç”¨çš„æœ‰ OBBï¼ˆOriented Bounding Boxï¼Œæœ‰å‘åŒ…å›´ç›’ï¼‰ã€AABBï¼ˆAxis-Aligned Bounding Boxï¼Œè½´å¯¹é½åŒ…å›´ç›’ï¼‰ã€çƒå½¢åŒ…å›´ä½“ï¼ˆå¤–æ¥çƒï¼‰ç­‰ï¼Œå…¶ä¸­ AABB å› ä¸ºè®¡ç®—æ–¹ä¾¿è€Œæ›´ä¸ºå¸¸ç”¨\n\n    \n\n\nå±‚çº§å‰”é™¤Unity ä¸­çš„æ¨¡å‹å¯ä»¥è®¾ç½®è‡ªèº«æ‰€å¤„çš„å±‚çº§ï¼ˆLayerï¼‰ï¼Œè€Œæ‘„åƒæœºåˆ™å¯ä»¥è®¾ç½®éœ€è¦å‰”é™¤æ‰çš„å±‚çº§ï¼Œä»è€Œè·³è¿‡ç‰¹å®šç‰©ä½“çš„æ¸²æŸ“\n\n    \n\n\né®æŒ¡å‰”é™¤  åœ¨æ¸²æŸ“æ—¶ï¼Œå¦‚æœç‰©ä½“æœ‰å‰åé¡ºåºå¹¶ä¸”åæ–¹çš„ç‰©ä½“å®Œå…¨è¢«å‰æ–¹ç‰©ä½“é®æŒ¡ä½ï¼Œæ­¤æ—¶åæ–¹ç‰©ä½“åœ¨æ‘„åƒæœºä¸­å®Œå…¨çœ‹ä¸è§ï¼Œä¹Ÿå°±æ²¡æœ‰å¿…è¦è¿›è¡Œè®¡ç®—ï¼Œå¯ä»¥è¿›è¡Œå‰”é™¤\n\n    \n\n\nLRU ç®—æ³•LRUï¼ˆLeast recently usedï¼Œæœ€è¿‘æœ€å°‘ä½¿ç”¨ï¼‰æ˜¯ç¼“å­˜ç½®æ¢ç­–ç•¥ä¸­çš„ä¸€ç§å¸¸ç”¨çš„ç®—æ³•ã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯â€œå¦‚æœæ•°æ®æœ€è¿‘è¢«è®¿é—®è¿‡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„å‡ ç‡ä¹Ÿæ›´é«˜â€ã€‚å½“ç¼“å­˜é˜Ÿåˆ—å·²æ»¡æ—¶ï¼Œæ–°çš„å…ƒç´ åŠ å…¥é˜Ÿåˆ—æ—¶ï¼Œéœ€è¦ä»ç°æœ‰é˜Ÿåˆ—ä¸­ç§»é™¤ä¸€ä¸ªå…ƒç´ ï¼ŒLRU ç­–ç•¥å°±æ˜¯å°†æœ€è¿‘æœ€å°‘è¢«è®¿é—®çš„å…ƒç´ ç§»é™¤ï¼Œä»è€Œè…¾å‡ºç©ºé—´ç»™æ–°çš„å…ƒç´ ã€‚\nå½“å¯¹ key è¿›è¡Œè®¿é—®æ—¶ï¼ˆä¸€èˆ¬æœ‰æŸ¥è¯¢ï¼Œæ›´æ–°ï¼Œå¢åŠ ï¼Œåœ¨ get() å’Œset()ä¸¤ä¸ªæ–¹æ³•ä¸­å®ç°å³å¯ï¼‰æ—¶ï¼Œå°†è¯¥ key æ”¾åˆ°é˜Ÿåˆ—çš„æœ€å‰ç«¯ï¼ˆæˆ–æœ€åç«¯ï¼‰å°±è¡Œäº†ï¼Œè¿™æ ·å°±å®ç°äº†å¯¹ key æŒ‰å…¶æœ€åä¸€æ¬¡è®¿é—®çš„æ—¶é—´é™åºï¼ˆæˆ–å‡åºï¼‰æ’åˆ—ï¼Œå½“å‘ç©ºé—´ä¸­å¢åŠ æ–°å¯¹è±¡æ—¶ï¼Œå¦‚æœç©ºé—´æ»¡äº†ï¼Œåˆ é™¤é˜Ÿå°¾ï¼ˆæˆ–é˜Ÿé¦–ï¼‰çš„å¯¹è±¡ã€‚\næ™®é€šå®ç°  å€ŸåŠ©äºæ™®é€š dict å’Œ list æ¥å®ç°ï¼Œdict ä¿å­˜é”®å€¼å¯¹ï¼Œlist ä¿è¯æ’å…¥çš„æœ‰åºï¼ˆå€ŸåŠ©åˆ—è¡¨æ¥è®°å½•æ’å…¥çš„é¡ºåºï¼‰\n# åŸºäºæ™®é€š dict å’Œ list å®ç°class LRUCache(object):    def __init__(self, size=5):        self.size = size        self.cache = dict()        self.key_list = []     def get(self, key):        if key in self.cache:            self.key_list.remove(key)            self.key_list.insert(0, key)            return self.cache[key]        else:            return None     def set(self, key, value):        if key in self.cache:  # æ›´æ–°            self.key_list.remove(key)          elif len(self.cache) == self.size:  # åˆ é™¤æ’å…¥            old_key = self.key_list.pop()            self.cache.pop(old_key)        self.cache[key] = value       # ä¸€èˆ¬æ’å…¥        self.key_list.insert(0, key)\n\nä½¿ç”¨ hash è¡¨æ¥å®šä½ç»“ç‚¹ä½ç½®ï¼Œget()å’Œ set() çš„æ—¶é—´å¤æ‚åº¦å‡ä¸ºï¼Œç©ºé—´å¤æ‚åº¦ä¸º\nå€ŸåŠ©OrderedDictpython ä¸­æœ‰ä¸€ä¸ªæ ‡å‡†åº“çš„ç±»çš„OrderedDictï¼ˆæœ‰åºå­—å…¸ï¼‰ï¼Œè¯¥ç±»æœ‰ä»¥ä¸‹ä¸¤ä¸ªæ–¹æ³•ç”¨æ¥å®ç° LRU ç®—æ³•å°±ååˆ†ç®€å•ï¼š\n\npopitem(last=True)ï¼šæœ‰åºå­—å…¸çš„ popitem() æ–¹æ³•ç§»é™¤å¹¶è¿”å›ä¸€ä¸ª (key, value) é”®å€¼å¯¹ã€‚ å¦‚æœ last å€¼ä¸ºçœŸï¼Œåˆ™æŒ‰ LIFO åè¿›å…ˆå‡ºçš„é¡ºåºè¿”å›é”®å€¼å¯¹ï¼Œå¦åˆ™å°±æŒ‰ FIFO å…ˆè¿›å…ˆå‡ºçš„é¡ºåºè¿”å›é”®å€¼å¯¹\nmove_to_end(key, last=True)ï¼šå°†ç°æœ‰ key ç§»åŠ¨åˆ°æœ‰åºå­—å…¸çš„ä»»ä¸€ç«¯ã€‚ å¦‚æœ last ä¸ºçœŸå€¼ï¼ˆé»˜è®¤ï¼‰åˆ™å°†å…ƒç´ ç§»è‡³æœ«å°¾ï¼›å¦‚æœ last ä¸ºå‡å€¼åˆ™å°†å…ƒç´ ç§»è‡³å¼€å¤´ã€‚å¦‚æœ key ä¸å­˜åœ¨åˆ™ä¼šè§¦å‘ KeyError`\n\nfrom collections import OrderedDict, defaultdict class LRU:    def __init__(self, capacity=128):        self.capacity = capacity    # ç¼“å­˜å®¹é‡        self.cache = OrderedDict()  # æœ‰åºå­—å…¸ç¼“å­˜     def put(self, key, value):        if key in self.cache:            # è‹¥æ•°æ®å·²å­˜åœ¨ï¼Œè¡¨ç¤ºå‘½ä¸­ä¸€æ¬¡ï¼Œéœ€è¦æŠŠæ•°æ®ç§»åˆ°ç¼“å­˜é˜Ÿåˆ—æœ«ç«¯            self.cache.move_to_end(key)            return        if len(self.cache) &gt;= self.capacity:            # è‹¥ç¼“å­˜å·²æ»¡ï¼Œåˆ™éœ€è¦æ·˜æ±°æœ€æ—©æ²¡æœ‰ä½¿ç”¨çš„æ•°æ®            self.cache.popitem(last=False)        # å½•å…¥ç¼“å­˜        self.cache[key]=value     # éå† key    def travel(self):        for key in self.cache.keys():            print(key)     def get(self, key):        if key in self.cache:            val = self.cache.pop(key)            self.cache[key] = val        else:            val = None         return val\n\nç¼“å­˜ç®—æ³• FIFO ç®—æ³• å¦‚æœä¸€ä¸ªæ•°æ®æœ€å…ˆè¿›å…¥ç¼“å­˜ï¼Œåˆ™åº”è¯¥æœ€æ—©æ·˜æ±°æ‰\n\nget(key)ï¼šå¦‚æœ Cache ä¸­å­˜åœ¨è¯¥ keyï¼Œåˆ™è¿”å›å¯¹åº”çš„ value å€¼ï¼Œå¦åˆ™ï¼Œè¿”å› -1\nset(key,value)ï¼šå¦‚æœ Cache ä¸­å­˜åœ¨è¯¥ keyï¼Œåˆ™é‡ç½® value å€¼ï¼›å¦‚æœä¸å­˜åœ¨è¯¥ keyï¼Œåˆ™å°†è¯¥ key æ’å…¥ Cacheï¼Œè‹¥ Cache å·²æ»¡ï¼Œåˆ™æ·˜æ±°æœ€æ—©è¿›å…¥ Cache çš„æ•°æ®\n\nLRUï¼šLeast Recently usedå¦‚æœæ•°æ®æœ€è¿‘è¢«è®¿é—®è¿‡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„å‡ ç‡ä¹Ÿæ›´é«˜\nLFUï¼šLeast Frequency Usedå¦‚æœæ•°æ®è¿‡å»è¢«è®¿é—®å¤šæ¬¡ï¼Œé‚£ä¹ˆå°†æ¥è¢«è®¿é—®çš„é¢‘ç‡ä¹Ÿæ›´é«˜ã€‚æ³¨æ„ LFU å’Œ LRU çš„åŒºåˆ«ï¼ŒLRU çš„æ·˜æ±°è§„åˆ™æ˜¯åŸºäºè®¿é—®æ—¶é—´ï¼Œè€Œ LFU æ˜¯åŸºäºè®¿é—®æ¬¡æ•°\nä¸ºäº†èƒ½å¤Ÿæ·˜æ±°æœ€å°‘ä½¿ç”¨çš„æ•°æ®ï¼ŒLFU ç®—æ³•æœ€ç®€å•çš„ä¸€ç§è®¾è®¡æ€è·¯å°±æ˜¯ï¼šåˆ©ç”¨ä¸€ä¸ªæ•°ç»„å­˜å‚¨æ•°æ®é¡¹ï¼Œç”¨ hashmap å­˜å‚¨æ¯ä¸ªæ•°æ®é¡¹åœ¨æ•°ç»„ä¸­å¯¹åº”çš„ä½ç½®ï¼Œç„¶åä¸ºæ¯ä¸ªæ•°æ®é¡¹è®¾è®¡ä¸€ä¸ªè®¿é—®é¢‘æ¬¡ï¼Œå½“æ•°æ®é¡¹è¢«å‘½ä¸­æ—¶ï¼Œè®¿é—®é¢‘æ¬¡è‡ªå¢ï¼Œåœ¨æ·˜æ±°çš„æ—¶å€™æ·˜æ±°è®¿é—®é¢‘æ¬¡æœ€å°‘çš„æ•°æ®ã€‚è¿™æ ·ä¸€æ¥ï¼Œåœ¨æ’å…¥æ•°æ®å’Œè®¿é—®æ•°æ®çš„æ—¶å€™éƒ½èƒ½è¾¾åˆ°  çš„æ—¶é—´å¤æ‚åº¦ï¼Œåœ¨æ·˜æ±°æ•°æ®çš„æ—¶å€™ï¼Œé€šè¿‡é€‰æ‹©ç®—æ³•å¾—åˆ°åº”è¯¥æ·˜æ±°çš„æ•°æ®é¡¹åœ¨æ•°ç»„ä¸­çš„ç´¢å¼•ï¼Œå¹¶å°†è¯¥ç´¢å¼•ä½ç½®çš„å†…å®¹æ›¿æ¢ä¸ºæ–°æ¥çš„æ•°æ®å†…å®¹å³å¯ï¼Œè¿™æ ·çš„è¯ï¼Œæ·˜æ±°æ•°æ®çš„æ“ä½œæ—¶é—´å¤æ‚åº¦ä¸º ã€‚ å¦å¤–è¿˜æœ‰ä¸€ç§å®ç°æ€è·¯å°±æ˜¯åˆ©ç”¨å°é¡¶å † +hashmapï¼Œå°é¡¶å †æ’å…¥ã€åˆ é™¤æ“ä½œéƒ½èƒ½è¾¾åˆ°  æ—¶é—´å¤æ‚åº¦ï¼Œå› æ­¤æ•ˆç‡ç›¸æ¯”ç¬¬ä¸€ç§å®ç°æ–¹æ³•æ›´åŠ é«˜æ•ˆ\néªæ¢¦ Unity èµ„æºç®¡ç† åœ¨ Unity ä¸­ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œèµ„æºåŠ è½½æ–¹å¼ä¸»è¦åˆ†ä¸º Resources åŠ è½½å’Œ AssetBundle åŠ è½½ã€‚Unity æœ‰ä¸ªç‰¹æ®Šæ–‡ä»¶å¤¹ Resourcesï¼Œæ”¾åœ¨è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹çš„èµ„æºå¯ä»¥é€šè¿‡ Resources.Load() æ¥ç›´æ¥åŠ è½½ã€‚å³ Resources åŠ è½½èµ„æºæ–¹å¼ã€‚å½“è·å¾— AssetBundle ä¹‹åï¼Œä¹Ÿå¯ä»¥è°ƒç”¨ AssetBundle å¯¹åº” çš„ API æ¥åŠ è½½èµ„æº\nAB åŒ…å…¨å AssetBundleï¼ˆèµ„æºåŒ…ï¼‰ã€‚æ˜¯ä¸€ç§ Unity æä¾›çš„ç”¨äºå­˜æ”¾èµ„æºçš„åŒ…ã€‚é€šè¿‡å°†èµ„æºåˆ†å¸ƒåœ¨ä¸åŒçš„ AB åŒ…ä¸­å¯ä»¥æœ€å¤§ç¨‹åº¦åœ°å‡å°‘è¿è¡Œæ—¶çš„å†…å­˜å‹åŠ›ï¼Œå¹¶ä¸”å¯ä»¥æœ‰é€‰æ‹©åœ°åŠ è½½å†…å®¹\nä¸ºä»€ä¹ˆè¦ç”¨ AB åŒ…\nçƒ­æ›´æ–°ï¼ˆè¦çƒ­æ›´æ–°éœ€è¦ç¡®ä¿ AB åŒ…æ‰“å‡ºæ¥çš„èµ„æºå…·æœ‰å”¯ä¸€æ€§ï¼Œä¸”ç›¸åŒèµ„æºçš„ AB åŒ…æ£€éªŒç ç›¸åŒï¼‰\nResources åŠ è½½è™½ç„¶ç®€å•æ–¹ä¾¿ï¼Œä½†æ˜¯ä¹Ÿæœ‰å¾ˆå¤šé—®é¢˜\nå¯¹å†…å­˜ç®¡ç†é€ æˆä¸€å®šçš„è´Ÿæ‹…\nåœ¨æ‰“å¼€åº”ç”¨æ—¶åŠ è½½æ—¶é—´å¾ˆé•¿\nResources æ–‡ä»¶å¤¹ä¸‹çš„æ‰€æœ‰èµ„æºç»Ÿä¸€åˆå¹¶åˆ°ä¸€ä¸ªåºåˆ—åŒ–æ–‡ä»¶ä¸­ï¼ˆå¯ä»¥çœ‹æˆç»Ÿä¸€æ‰“ä¸€ä¸ªå¤§åŒ…ï¼Œå·¨å‹ AB åŒ…æœ‰ä»€ä¹ˆé—®é¢˜å®ƒå°±æœ‰ä»€ä¹ˆé—®é¢˜ï¼‰ï¼Œå¯¹èµ„æºä¼˜åŒ–æœ‰ä¸€å®šçš„é™åˆ¶\nä¸å»ºè®®å¤§é‡ä½¿ç”¨ Resources\n\n\n\nè·å– AB åŒ…æ–¹æ³•AssetBundle.LoadFromFile(string path)AssetBundle.LoadFromFileAsync(string path)AssetBundle.LoadFromMemory(byte[] binary)AssetBundle.LoadFromMemoryAsync(byte[] binary)AssetBundle.LoadFromStream(Stream stream)AssetBundle.LoadFromStreamAsync(Stream stream)WWW.AssetBundle\n\n\nLoadFromFileæ˜¯ä»æ–‡ä»¶ä¸­åŠ è½½ AB åŒ…ï¼Œå®ƒä»ä¸€ä¸ªç»™å®šçš„è·¯å¾„æ¥åŠ è½½ AB åŒ…ã€‚å¦‚æœ AB åŒ…æ˜¯ LZ4 åŠ è½½æ–¹å¼ï¼Œå®ƒåªä¼šåŠ è½½ AB åŒ…çš„ Headerï¼Œä¹‹åéœ€è¦ä»€ä¹ˆèµ„æºå†åŠ è½½é‚£éƒ¨åˆ†çš„ AB åŒ… chunkã€‚æå¤§çš„å‡å°‘äº†å†…å­˜å ç”¨ã€‚\nLoadFromFileAsyncæ˜¯å®ƒçš„å¼‚æ­¥ç‰ˆæœ¬\n\n\nLoadFromMemoryæ˜¯ä»å†…å­˜ä¸­åŠ è½½ AB åŒ…ï¼Œå®ƒä»å†…å­˜ä¸­çš„ byte[] ä¸­åŠ è½½ AB åŒ…ã€‚å®ƒä¼šå®Œæ•´çš„æŠŠ AB åŒ…åŠ è½½å‡ºæ¥\nLoadFromMemoryAsyncæ˜¯å®ƒçš„å¼‚æ­¥ç‰ˆæœ¬\n\n\nLoadFromStreamæ˜¯ä»æµä¸­åŠ è½½ AB åŒ…ï¼Œå®ƒä»ä¸€ä¸ª Stream ä¸­åŠ è½½ AB åŒ…ã€‚è·Ÿ LoadFromFile ä¸€æ ·ï¼Œå¦‚æœ AB åŒ…æ˜¯ LZ4 åŠ è½½æ–¹å¼ï¼Œå®ƒä¹Ÿæ˜¯åªä¼šåŠ è½½ AB åŒ…çš„ Headerã€‚\nLoadFromStreamAsyncæ˜¯å®ƒçš„å¼‚æ­¥ç‰ˆæœ¬\n\n\nWWW æ˜¯ Unity ä¸­çš„è·Ÿç½‘ç»œç›¸å…³çš„ç±»ï¼Œå¯ä»¥é€šè¿‡è¯¥ç±»ä»ç½‘ç»œä¸­ä¸‹è½½èµ„æºï¼Œä¹‹ååŠ è½½æˆ AB åŒ…\n\nåŠ è½½èµ„æºæ–¹æ³•AssetBundle.LoadAsset(string assetName, Type resType)AssetBundle.LoadAssetAsync(string assetName, Type resType)\n\nLZMA å’Œ LZ4LZMA æ˜¯æµå‹ç¼©æ–¹å¼ï¼ˆstream-basedï¼‰ã€‚æµå‹ç¼©å†å¤„ç†æ•´ä¸ªæ•°æ®å—æ—¶ä½¿ç”¨åŒä¸€ä¸ªå­—å…¸ï¼Œå®ƒæä¾›äº†æœ€å¤§å¯èƒ½çš„å‹ç¼©ç‡ï¼Œä½†æ˜¯åªæ”¯æŒé¡ºåºè¯»å–ã€‚æ‰€ä»¥åŠ è½½ AB åŒ…æ—¶ï¼Œéœ€è¦å°†æ•´ä¸ªåŒ…è§£å‹ï¼Œä¼šé€ æˆå¡é¡¿å’Œé¢å¤–å†…å­˜å ç”¨ã€‚\nLZ4 æ˜¯å—å‹ç¼©æ–¹å¼ï¼ˆchunk-basedï¼‰ã€‚å—å‹ç¼©çš„æ•°æ®è¢«åˆ†ä¸ºå¤§å°ç›¸åŒçš„å—ï¼Œå¹¶è¢«åˆ†åˆ«å‹ç¼©ã€‚å¦‚æœéœ€è¦å®æ—¶è§£å‹éšæœºè¯»å–ï¼Œå—å‹ç¼©æ˜¯æ¯”è¾ƒå¥½çš„é€‰æ‹©ã€‚LoadFromFile()å’Œ LoadFromStream() éƒ½åªä¼šåŠ è½½ AB åŒ…çš„ Headerï¼Œç›¸å¯¹ LoadFromMemory() æ¥è¯´å¤§å¤§èŠ‚çœäº†å†…å­˜\nå†…å­˜å ç”¨ AB åŒ…å†…çš„èµ„æºéœ€è¦é€šè¿‡AssetBundle.Load() æ¥åŠ è½½åˆ°å†…å­˜ä¸­\n\nå¯¹äº GameObject æ¥è¯´ï¼Œé€šå¸¸æƒ…å†µä¸‹éœ€è¦å¯¹å…¶è¿›è¡Œæ”¹åŠ¨ï¼Œæ‰€ä»¥å®ƒæ˜¯å®Œå…¨å¤åˆ¶ä¸€ä»½è¯¥èµ„æºæ¥è¿›è¡Œçš„å®ä¾‹åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ AB åŒ…ä¸­çš„ GameObject ä»å†…å­˜ä¸­å¸è½½åï¼Œå®ä¾‹åŒ–çš„ GameObject ä¸ä¼šå› æ­¤ä¸¢å¤±ã€‚å¹¶ä¸”å¯¹å®ä¾‹åŒ–å¯¹è±¡çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ° GameObject èµ„æº\nå¯¹äº Shader å’Œ Texture æ¥è¯´ï¼Œé€šå¸¸æƒ…å†µä¸‹ä¸éœ€è¦å¯¹å…¶è¿›è¡Œæ”¹åŠ¨ï¼Œæ‰€ä»¥å®ƒæ˜¯é€šè¿‡å¼•ç”¨æ¥è¿›è¡Œçš„å®ä¾‹åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ AB åŒ…ä¸­çš„ Shader å’Œ Texture èµ„æºä»å†…å­˜ä¸­å¸è½½åï¼Œå®ä¾‹åŒ–çš„ Shader å’Œ Texture ä¼šå‡ºç°èµ„æºä¸¢å¤±çš„æƒ…å†µã€‚å¹¶ä¸”å¯¹å®ä¾‹åŒ–å¯¹è±¡çš„ä¿®æ”¹ä¼šå½±å“åˆ° Shader å’Œ Texture èµ„æº\nå¯¹äº Material å’Œ Mesh æ¥è¯´ï¼Œæœ‰æ—¶å€™å¯èƒ½éœ€è¦å¯¹å…¶è¿›è¡Œæ”¹åŠ¨ï¼Œæ‰€ä»¥å®ƒæ˜¯é€šè¿‡å¼•ç”¨ + å¤åˆ¶æ¥è¿›è¡Œçš„å®ä¾‹åŒ–ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“ AB åŒ…ä¸­çš„ Material å’Œ Mesh èµ„æºä»å†…å­˜ä¸­å¸è½½åï¼Œå®ä¾‹åŒ–çš„ Material å’Œ Mesh ä¼šå‡ºç°èµ„æºä¸¢å¤±çš„æƒ…å†µã€‚å¹¶ä¸”å¯¹å®ä¾‹åŒ–å¯¹è±¡çš„ä¿®æ”¹ä¸ä¼šå½±å“åˆ° Material å’Œ Mesh èµ„æº\n\n\nAB åŒ…å…ˆè¦ä»ç¡¬ç›˜æˆ–è€…ç½‘ç»œä¸­åŠ è½½åˆ°å†…å­˜ä¸­ï¼Œç„¶åå°† AB åŒ…å†…çš„æ¯ä¸€ä»½èµ„æºåŠ è½½åˆ°å†…å­˜ä¸­ï¼Œå†ä¹‹ååœ¨å†…å­˜ä¸­å®ä¾‹åŒ–è¿™äº›èµ„æºã€‚æ¯ç§èµ„æºæœ‰å…¶è‡ªå·±ä¸åŒçš„å®ä¾‹åŒ–æ–¹å¼ï¼Œå¸è½½èµ„æºçš„æ—¶å€™éœ€è¦æ³¨æ„\n\nAB åŒ…å†…éƒ¨ç»“æ„\nAssetBundleFileHeaderï¼šè®°å½•äº†ç‰ˆæœ¬å·ã€å‹ç¼©ç­‰ä¸»è¦æè¿°ä¿¡æ¯\nAssetFileHeaderï¼šåŒ…å«ä¸€ä¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œè®°å½•äº†æ¯ä¸ªèµ„æºçš„ nameã€offsetã€length ç­‰ä¿¡æ¯\nAsset1ï¼š\nAssetHeaderï¼šè®°å½•äº† TypeTree å¤§å°ã€æ–‡ä»¶å¤§å°ã€format ç­‰ä¿¡æ¯\nTypeTreeï¼ˆå¯é€‰ï¼‰ï¼šè®°å½•äº† Asset å¯¹è±¡çš„ class IDã€‚Unity å¯ä»¥ç”¨ class ID æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–ä¸€ä¸ªç±»ï¼ˆæ¯ä¸ª class å¯¹åº”äº†ä¸€ä¸ª IDï¼Œå¦‚ 0 æ˜¯ Object ç±»ï¼Œ1 æ˜¯ GameObject ç±»ç­‰ï¼Œå…·ä½“å¯åœ¨ Unity å®˜ç½‘ä¸ŠæŸ¥è¯¢ï¼‰\nObjectPathï¼šè®°å½•äº† path IDï¼ˆèµ„æºå”¯ä¸€ç´¢å¼• IDï¼‰ç­‰\nAssetRefï¼šè®°å½•äº† AB åŒ…å¯¹å¤–éƒ¨èµ„æºå¯¹å¼•ç”¨æƒ…å†µ\n\n\nAsset2\nâ€¦\n\nä¾èµ–é—®é¢˜  ä¾èµ–é—®é¢˜ï¼Œé€šä¿—çš„è¯æ¥è¯´å°±æ˜¯ A åŒ…ä¸­æŸèµ„æºç”¨äº† B åŒ…ä¸­çš„æŸèµ„æºã€‚ç„¶è€Œå¦‚æœ A åŒ…åŠ è½½äº†ï¼ŒB åŒ…æ²¡æœ‰åŠ è½½ï¼Œè¿™å°±ä¼šå¯¼è‡´ A åŒ…ä¸­çš„èµ„æºå‡ºç°ä¸¢èµ„æºçš„ç°è±¡ã€‚åœ¨ Unity5.0 åï¼ŒBuildAssetBundleOptions.CollectDependenciesæ°¸ä¹…å¼€å¯ï¼Œå³ Unity ä¼šè‡ªåŠ¨æ£€æµ‹ç‰©ä½“å¼•ç”¨çš„èµ„æºå¹¶ä¸”ä¸€å¹¶æ‰“åŒ…ï¼Œé˜²æ­¢èµ„æºä¸¢å¤±é—æ¼çš„é—®é¢˜å‡ºç°ã€‚å› ä¸ºè¿™ä¸ªç‰¹æ€§ï¼Œæœ‰äº›æƒ…å†µä¸‹ï¼Œå¦‚æœæ²¡æŒ‡å®šæŸå…¬å…±èµ„æºçš„å­˜æ”¾åœ¨å“ªä¸ª AB åŒ…ä¸­ï¼Œè¿™ä¸ªå…¬å…±èµ„æºå°±ä¼šè¢«è‡ªåŠ¨æ‰“è¿›å¼•ç”¨å®ƒçš„ AB åŒ…ä¸­ï¼Œæ‰€ä»¥å‡ºç°å¤šä¸ªä¸åŒçš„ AB åŒ…ä¸­æœ‰é‡å¤çš„èµ„æºå­˜åœ¨çš„ç°è±¡ã€‚è¿™å°±æ˜¯èµ„æºå†—ä½™ã€‚\nè¦é˜²æ­¢èµ„æºå†—ä½™ï¼Œå°±éœ€è¦æ˜ç¡®æŒ‡å‡ºèµ„æºå­˜æ”¾åœ¨å“ªä¸ª AB åŒ…ä¸­ï¼Œå½¢æˆä¾èµ–å…³ç³»ã€‚æ‰€ä»¥å¯¹äºä¸€äº›å…¬å…±èµ„æºï¼Œå»ºè®®å•ç‹¬å­˜æ”¾åœ¨ä¸€ä¸ª AB åŒ…ä¸­ã€‚åœ¨åŠ è½½çš„æ—¶å€™ï¼Œå¦‚æœ AB åŒ…ä¹‹é—´ç›¸äº’ä¾èµ–ï¼Œé‚£ä¹ˆåŠ è½½ä¸€ä¸ª AB åŒ…ä¸­çš„èµ„æºæ—¶ï¼Œå…ˆéœ€è¦åŠ è½½å‡ºå¦ä¸€ä¸ª AB åŒ…çš„èµ„æºã€‚è¿™æ ·å°±ä¼šå¯¼è‡´ä¸å¿…è¦çš„æ¶ˆè€—ã€‚æ‰€ä»¥è¯´å°½å¯èƒ½åœ°å‡å°‘ AB åŒ…ä¹‹é—´çš„ä¾èµ–ï¼Œå¹¶ä¸”å…¬å…±èµ„æºå°½é‡æå‰åŠ è½½å®Œæˆ\nç»†ç²’åº¦é—®é¢˜  ç»†ç²’åº¦é—®é¢˜å³æ¯ä¸ª AB åŒ…åˆ†åˆ«æ”¾å…¥å¤šå°‘èµ„æºçš„é—®é¢˜ï¼Œä¸€ä¸ªå¥½çš„ç­–ç•¥è‡³å…³é‡è¦ã€‚åŠ è½½èµ„æºæ—¶ï¼Œå…ˆè¦åŠ è½½ AB åŒ…ï¼Œå†åŠ è½½èµ„æºã€‚å¦‚æœ AB åŒ…ä½¿ç”¨äº† LZMA æˆ– LZ4 å‹ç¼©ç®—æ³•ï¼Œè¿˜éœ€è¦å…ˆç»™ AB åŒ…è§£å‹ã€‚\n\nAB åŒ…æ•°é‡è¾ƒå¤šï¼ŒåŒ…å†…èµ„æºè¾ƒå°‘ï¼›AB åŒ…æ•°é‡è¾ƒå°‘ï¼ŒåŒ…å†…èµ„æºè¾ƒå¤š\nåŠ è½½ä¸€ä¸ª AB åŒ…åˆ°å†…å­˜çš„æ—¶é—´çŸ­ï¼Œç©å®¶ä¸ä¼šæœ‰å¡é¡¿æ„Ÿï¼Œä½†æ¯ä¸ªèµ„æºå®é™…ä¸ŠåŠ è½½æ—¶é—´å˜é•¿ï¼›åŠ è½½ä¸€ä¸ª AB åŒ…åˆ°å†…å­˜çš„æ—¶é—´è¾ƒé•¿ï¼Œç©å®¶ä¼šæœ‰å¡é¡¿æ„Ÿï¼Œä½†ä¹‹ååŒ…å†…çš„æ¯ä¸ªèµ„æºåŠ è½½å¾ˆå¿«\nçƒ­æ›´æ–°çµæ´»ï¼Œè¦æ›´æ–°ä¸‹è½½çš„åŒ…ä½“è¾ƒå°ï¼›çƒ­æ›´æ–°ä¸çµæ´»ï¼Œè¦æ›´æ–°ä¸‹è½½çš„åŒ…ä½“è¾ƒå¤§\nIO æ¬¡æ•°è¿‡å¤šï¼Œå¢å¤§äº†ç¡¬ä»¶è®¾å¤‡è€—èƒ½å’Œå‘çƒ­å‹åŠ›ï¼›IO æ¬¡æ•°ä¸å¤šï¼Œç¡¬ä»¶å‹åŠ›å°\n\nç®€å•ç­–ç•¥ï¼š\n\nç»å¸¸æ›´æ–°å’Œä¸ç»å¸¸æ›´æ–°çš„å¯¹è±¡æ‹†åˆ†åˆ°ä¸åŒçš„ AB åŒ…ä¸­\nåŒæ—¶åŠ è½½çš„å¯¹è±¡æ”¾åœ¨ä¸€ä¸ª AB åŒ…ä¸­\nä¸å¯èƒ½åŒæ—¶åŠ è½½çš„å¯¹è±¡æ‹†åˆ†åˆ°ä¸åŒçš„ AB åŒ…ä¸­\næ ¹æ®é¡¹ç›®é€»è¾‘åŠŸèƒ½æ¥åˆ†ç»„æ‰“ AB åŒ…\næ ¹æ®åŒä¸€ç±»å‹å¯¹è±¡æ¥åˆ†ç»„æ‰“ AB åŒ…\nå…¬å…±èµ„æºå’Œéå…¬å…±èµ„æºæ‹†åˆ†åˆ°ä¸åŒçš„ AB åŒ…ä¸­\n\nå¸è½½é—®é¢˜\nå½“è°ƒç”¨ Resources.UnloadAsset() æ—¶ï¼Œè™½ Object è¢«é”€æ¯ï¼Œä½† Instance ID è¢«ä¿ç•™ä¸”åŒ…å«æœ‰æ•ˆçš„ GUID å’Œ Local ID å¼•ç”¨\nå½“è°ƒç”¨ AssetBundle.Unload(true) æ—¶ï¼Œä¸ä»… Object è¢«é”€æ¯ï¼Œè€Œä¸” Instance ID çš„ GUID å’Œ Local ID å¼•ç”¨å˜æ— æ•ˆ\nå½“è°ƒç”¨ AssetBundle.Unload(false) æ—¶ï¼Œè™½ Object ä¸è¢«é”€æ¯ï¼Œä½† Instance ID çš„ GUID å’Œ Local ID å¼•ç”¨å˜æ— æ•ˆã€‚åœºæ™¯ä¸­çš„ç‰©ä½“ä¼šä¸è¯¥ AB åŒ…åˆ†ç¦»é“¾æ¥ã€‚å³è¯¥ç‰©ä½“çš„ Instance ID å¼•ç”¨çš„ GUID å’Œ Local ID ä¼šæ–­å¼€å¼•ç”¨ï¼Œæ— æ³•å†é€šè¿‡è¯¥ Instance ID æ‰¾åˆ° GUID å’Œ Local ID\nå¦‚æœå†æ¬¡åŠ è½½è¯¥ AB åŒ…æ—¶ï¼Œåˆ†ç¦»äº†é“¾æ¥çš„ç‰©ä½“ä¸ä¼šå—è¯¥æ–°åŠ è½½çš„ AB åŒ…ç®¡ç†ã€‚å› æ­¤å¦‚æœä¸æ³¨æ„çš„è¯å¯èƒ½ä¼šå¯¼è‡´ä¸€äº›ä¸å¯æ§çš„é—®é¢˜ã€‚Unity ä¸­æœ‰ Resources.UnloadUnusedAssets() æ–¹æ³•å¯ä»¥å¾ˆå¥½åœ°è§£å†³è¿™ä¸ªé—®é¢˜\n\nå„ç§ ID\nåºåˆ—åŒ–åï¼Œèµ„æºç”¨ GUID å’Œ Local ID ç®¡ç†\nGUID å¯¹åº” Assetï¼ŒGUID å­˜åœ¨ã€‚meta æ–‡ä»¶ä¸­ï¼Œæä¾›äº†æ–‡ä»¶ç‰¹å®šä½ç½®çš„æŠ½è±¡ï¼Œæ˜¯ä¸€ç§æ˜ å°„ï¼Œæ— éœ€å…³å¿ƒèµ„æºåœ¨ç£ç›˜ä¸Šçš„å­˜æ”¾ä½ç½®\nLocal ID å¯¹åº” Asset å†…çš„æ¯ä¸€ä¸ª Object\nè™½ç„¶ GUID å’Œ Local ID æ¯”è¾ƒå¥½ç”¨ï¼Œä½†æ˜¯æ¯•ç«Ÿå› ä¸ºå­˜åœ¨ç£ç›˜ä¸Šï¼Œè¯»å–æ¯”è¾ƒè€—æ—¶ã€‚å› æ­¤ Unity ç¼“å­˜ä¸€ä¸ª Instance ID å¯¹åº” Objectï¼Œé€šè¿‡ Instance ID å¿«é€Ÿæ‰¾åˆ° Objectã€‚Instance ID æ˜¯ä¸€ç§å¿«é€Ÿè·å–å¯¹è±¡å®ä¾‹çš„ IDï¼ŒåŒ…å«ç€å¯¹ GUID å’Œ Local ID çš„å¼•ç”¨ã€‚è§£æ Instance ID å¯ä»¥å¿«é€Ÿè¿”å› Instance è¡¨ç¤ºçš„å·²åŠ è½½å¯¹è±¡ï¼Œå¦‚æœä¸ºåŠ è½½ç›®æ ‡å¯¹è±¡ï¼Œåˆ™å¯ä»¥å°†æ–‡ä»¶ GUID å’Œ Local ID è§£æä¸ºå¯¹è±¡æºæ•°æ®ï¼Œä»è€Œå…è®¸ Unity å³æ—¶åŠ è½½å¯¹è±¡ã€‚æ¯æ¬¡ AB åŒ…é‡æ–°åŠ è½½æ—¶ï¼Œéƒ½ä¼šä¸ºæ¯ä¸ªå¯¹è±¡åˆ›å»ºæ–°çš„ Instance ID\n\nLua å¼±è¡¨  å¼±è¡¨æ˜¯ç”¨æ¥å‘Šè¯‰ Lua è™šæ‹Ÿæœºï¼Œè¢«å¼±è¡¨å¼•ç”¨çš„å¯¹è±¡ï¼Œä¸åº”è¯¥é˜»æ­¢ä»–ä»¬è¢« gc å›æ”¶ã€‚ä¸å¼±è¡¨ç›¸å¯¹çš„æ˜¯å¼ºè¡¨ã€‚å¯¹äºå¼ºè¡¨æ¥è¯´ï¼Œæ‰€æœ‰è¢«å¼ºè¡¨å¼•ç”¨åˆ°çš„ gc å¯¹è±¡ï¼Œéƒ½ä¼šè¢«æ ‡è®°ï¼Œä»è€Œä¸ä¼šè¢« gc æœºåˆ¶å›æ”¶ï¼Œå“ªæ€•è¿™äº›å˜é‡å†ä¹Ÿæ²¡è¢«ä½¿ç”¨åˆ°ã€‚å› æ­¤ï¼Œå¯¹äºå¼ºè¡¨æ¥è¯´ï¼Œå¦‚æœä½ å¸Œæœ›è¢«å®ƒå¼•ç”¨çš„å¯¹è±¡èƒ½å¤Ÿè¢« gc å›æ”¶ï¼Œé‚£ä¹ˆä½ éœ€è¦å°†å®ƒçš„å€¼è®¾ç½®ä¸º nilã€‚å¯¹äºå¼±è¡¨æ¥è¯´ï¼Œä½†å‡¡è¢«è®¾ç½®ä¸ºå¼±å¼•ç”¨çš„å¯¹è±¡ï¼Œå‡ä¸ä¼šè¢« gc æ ‡è®°ï¼Œå½“å†ä¹Ÿæ²¡æœ‰å…¶ä»–åœ°æ–¹å¼•ç”¨è¯¥å¯¹è±¡æ—¶ï¼Œå®ƒä»¬ä¼šä»å¼±è¡¨ä¸­è¢«æ¸…é™¤\nt = {}-- ä½¿ç”¨ä¸€ä¸ª table ä½œä¸º t çš„ key å€¼key1 = {name = \"key1\"}t[key1] = 1key1 = nil-- åˆä½¿ç”¨ä¸€ä¸ª table ä½œä¸º t çš„ key å€¼key2 = {name = \"key2\"}t[key2] = 1key2 = nilfor key, value in pairs(t) do    print(key.name .. \":\" .. value)end-- å¼ºåˆ¶è¿›è¡Œä¸€æ¬¡åƒåœ¾æ”¶é›†-- æ­¤æ—¶ key1 å’Œ key2 è¡¨éƒ½è¢«ç½® nilï¼Œä½†æ˜¯å¹¶æ²¡æœ‰è¢«å¼ºåˆ¶å›æ”¶ï¼Œæ¢å¥è¯è¯´ï¼Œè™½ç„¶ key1 æœ¬èº«ä¸º nilï¼Œä½†æ˜¯ä»–å…ˆå‰æŒ‡å‘çš„å†…å®¹å¹¶æ²¡æœ‰è¢«åˆ é™¤ï¼Œå› ä¸ºè¿™ä¸ªå†…å®¹è¢«ä¿å­˜åœ¨äº† t ä¸­collectgarbage()for key, value in pairs(t) do    print(key.name .. \":\" .. value)end\n\nt = {}-- ç»™ t è®¾ç½®ä¸€ä¸ªå…ƒè¡¨ï¼Œå¢åŠ __mode å…ƒæ–¹æ³•ï¼Œèµ‹å€¼ä¸º \"k\"setmetatable(t, {__mode = \"k\"});-- ä½¿ç”¨ä¸€ä¸ª table ä½œä¸º t çš„ key å€¼key1 = {name = \"key1\"}t[key1] = 1key1 = nil-- åˆä½¿ç”¨ä¸€ä¸ª table ä½œä¸º t çš„ key å€¼key2 = {name = \"key2\"}t[key2] = 1key2 = nilfor key, value in pairs(t) do    print(key.name .. \":\" .. value)end-- å¼ºåˆ¶è¿›è¡Œä¸€æ¬¡åƒåœ¾æ”¶é›†collectgarbage()for key, value in pairs(t) do    print(key.name .. \":\" .. value)end\n\nä»¥ä¸Šä»£ç åœ¨åˆ›å»ºäº†è¡¨ t åï¼Œç«‹å³å°† t è®¾ç½®ä¸ºå…ƒè¡¨ï¼Œå…ƒè¡¨é‡Œé¢æœ‰ä¸€ä¸ª __mode å­—æ®µï¼Œå€¼ä¸º kï¼Œåœ¨æ‰§è¡Œcollectgarbage() ä¹‹å‰ï¼Œèƒ½å¤Ÿè¾“å‡º t ä¸­çš„å…ƒç´ ï¼Œä½†æ˜¯æ‰§è¡Œåƒåœ¾å›æ”¶ä¹‹åï¼Œå°±ä¸èƒ½å†æ¬¡è¾“å‡º t ä¸­çš„å…ƒç´ çš„ï¼Œè¿™æ˜¯å› ä¸ºå°†è¡¨è®¾ç½®ä¸ºå…ƒè¡¨åï¼Œé€šè¿‡ __mode = \"k\" å°†å…¶æŒ‡å®šä¸ºå¯¹é”®çš„å¼±å¼•ç”¨ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸€æ—¦è¡¨ä¸­çš„æŸä¸ªé”®è¢«åƒåœ¾å›æ”¶ï¼Œtä¸­ä¼šåˆ é™¤è¿™ä¸ªé”®å¯¹åº”çš„å…ƒç´ \nå¼±è¡¨çš„ç”¨é€”\nç¼“å­˜æœºåˆ¶æ·»åŠ è‡ªåŠ¨å›æ”¶åŠŸèƒ½  å½“å¤–éƒ¨é€šè¿‡ getFromCache è·å–åˆ° tbl[key] çš„å€¼ä¹‹åï¼Œå¦‚æœä¸€ç›´æŒæœ‰ï¼Œé‚£ä¹ˆè¿™ä¸ªå€¼å°±ä¼šä¸€ç›´åœ¨ tbl ç¼“å­˜ä¸­ï¼Œå¦‚æœå¤–éƒ¨ä¸å†å¼•ç”¨ tbl[key] å€¼æ—¶ï¼Œé‚£ä¹ˆå®ƒä¼šåœ¨ä¸‹ä¸€è½® gc çš„æ—¶å€™ä» tbl è¢«æ¸…ç†ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±ä¸ç”¨å»å®ç°ç›¸å¯¹å¤æ‚çš„ LRU æœºåˆ¶ï¼Œæ¥å¯¹ tbl çš„å†…å­˜è¿›è¡Œé™åˆ¶å’Œå¤„ç†äº†\n\nlocal mt = {__mode=\"v\"}local tbl = setmetable({}, mt)local function getFromCache(key)    if tbl[key] then        return tbl[key]    end    tbl[key] = loadFromDB(key)    return tbl[key]end\n\n\nå¼±è¡¨å®ç°é»˜è®¤å€¼\n\nlocal defaults = {}setmetatable(defaults, {__mode = \"k\"})local mt = {__index = function(t) return defaults[t]  end} function setDefault(t, d)    defaults[t] = d    setmetatable(t, mt)end\n\nlocal metas = {}setmetatable(metas, {__mode = \"v\"}) function setDefault(t, d)    local mt = metas[d]    if mt == nil then        mt = {__index = function() return d  end}        metas[d] = mt    end    setmetatable(t, mt)end\n\nC# å§”æ‰˜å’Œ event åŒºåˆ«  å§”æ‰˜ delegate å…¶å®å°±æ˜¯å‡½æ•°çš„æ¨¡ç‰ˆï¼Œè¿™ä¸ªæ¨¡ç‰ˆå¯ä»¥ç”¨æ¥æ”¾å…¥å„ç§æ ¼å¼å’Œä»–ç›¸åŒçš„å‡½æ•°ï¼Œä¹Ÿå°±æ˜¯è¿™äº›çœŸå®å‡½æ•°çš„å¼•ç”¨  å½“å£°æ˜å§”æ‰˜æ—¶ï¼Œåœ¨ç¼–è¯‘é˜¶æ®µä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªç±»ï¼Œå¹¶ä¸”ç»§æ‰¿è‡ª MulticastDelegateï¼ŒMulticastDelegate ç»§æ‰¿è‡ª Delegateã€‚å½“å¯¹å§”æ‰˜+= æ“ä½œæ—¶å€™å…¶å®æ˜¯è°ƒç”¨äº† Delegate.Combine() å‡½æ•°ï¼Œå½“å¯¹å§”æ‰˜ -= æ“ä½œæ—¶å€™å…¶å®æ˜¯è°ƒç”¨äº† Delegate.Remove() å‡½æ•°ï¼Œä¸€æ—¦æ‰§è¡ŒInvokeï¼Œä¾¿è°ƒç”¨æ‰€æœ‰çš„å›è°ƒå‡½æ•°\näº‹ä»¶å°±æ˜¯å§”æ‰˜çš„ä¸€ç§ç‰¹æ®Šå°è£…ï¼Œäº‹ä»¶æœ¬èº«å…¶å®å°±æ˜¯ä¸€ç§ç‰¹æ®Šçš„å§”æ‰˜ã€‚å¦‚æœåŠ äº† event çš„æƒ…å†µä¸‹ï¼Œåœ¨å…¶ä»–ç±»ä¸­ä½¿ç”¨å¸¦ event å­—æ®µçš„å§”æ‰˜æ˜¯ä¸èƒ½ç›´æ¥ä½¿ç”¨ = èµ‹å€¼ç¬¦å·çš„ï¼Œåªèƒ½ä½¿ç”¨ +=ï¼Œæ³¨æ„è¿™é‡Œè¯´çš„æ˜¯å…¶ä»–ç±»ä¸­ï¼Œå¦‚æœç›´æ¥åœ¨å£°æ˜event çš„ç±»ä¸­è¿˜æ˜¯å¯ä»¥ç›´æ¥ä½¿ç”¨ = èµ‹å€¼çš„ï¼Œå½“åœ¨å§”æ‰˜å£°æ˜çš„æ—¶å€™åŠ äº† event å­—æ®µä¹‹åï¼Œç›´æ¥èµ‹å€¼çš„æ“ä½œä¼šå˜æˆ private æƒé™ï¼Œé‚£ä¹ˆè‡ªç„¶åœ¨å…¶ä»–ç±»ä¸­å°±æ— æ³•ç›´æ¥èµ‹å€¼äº†ï¼Œ+=å’Œ -= é‡å†™å˜æˆäº† add å’Œremoveçš„æ–¹æ³•ï¼Œæ˜¯ public çš„ï¼Œæ‰€ä»¥å¯ä»¥åœ¨å¤–éƒ¨è°ƒç”¨\nLambda è¡¨è¾¾å¼çš„æ•è·å˜é‡ Lambda è¡¨è¾¾å¼å¯ä»¥æ•è·å…¶æ‰€åœ¨ä½œç”¨åŸŸä¸­çš„å˜é‡ã€‚è¿™äº›å˜é‡å°†ä½œä¸º Lambda è¡¨è¾¾å¼çš„å¤–éƒ¨å˜é‡ï¼Œåœ¨ Lambda è¡¨è¾¾å¼å†…éƒ¨è¢«å¼•ç”¨ã€‚ä½†æ˜¯ï¼ŒLambda è¡¨è¾¾å¼åªèƒ½æ•è·å¼•ç”¨ç±»å‹çš„å˜é‡ï¼Œè€Œä¸èƒ½æ•è·å€¼ç±»å‹çš„å˜é‡ï¼ˆé™¤éé˜€é—¨æ˜¯å±€éƒ¨å˜é‡å¹¶ä¸”è¢«æ ‡è®°ä¸ºreadonly æˆ–åœ¨ Lamda è¡¨è¾¾å¼ä¹‹å‰èµ‹å€¼ï¼‰\nLua ç©ºè¡¨å¤§å°\ndebug.tablemem(t)å‡½æ•°ç”¨äºè·å– table è‡ªèº«å ç”¨å†…å­˜ç©ºé—´çš„å¤§å°ï¼Œè¯¥å‡½æ•°è¿”å›å››ä¸ªå­—æ®µï¼štableå ç”¨å†…å­˜å¤§å°ã€æ•°ç»„éƒ¨åˆ†é•¿åº¦ã€ä»¥ 2 ä¸ºåº•å“ˆå¸Œè¡¨éƒ¨åˆ†é•¿åº¦çš„å¯¹æ•°ã€å“ˆå¸Œè¡¨éƒ¨åˆ†æ˜¯å¦ä¸ºå‡èŠ‚ç‚¹ã€‚debug.tablemem\n\nlocal tbl = {}print(debug.tablemem(tbl)) --&gt; 56   0   0   true\n\n// luaobject.htypedef union lua_Value {    struct GCObject* gc;    void* p;    int b;    lua_Interger i;    lua_Number n;    lua_CFunction f;} Value;typedef struct lua_TValue {    Value value_;    int tt_;} TValue;// lua Tabletypedef union TKey {    struct {        Value value_;        int tt; // ç”¨æ¥æ ‡è®° value_æ˜¯ä»€ä¹ˆç±»å‹        int next;    } nk;    TValue tvk;} TKey;typedef struct Node {    TKey key;    TValue value;} Node;struct Table {    CommonHeader;               // GC éƒ¨åˆ†    TValue* array;              // æ•°ç»„éƒ¨åˆ†    unsigned int arraysize;     // æ•°ç»„å¤§å°    Node* node;                 // hash éƒ¨åˆ†    unsigned int lsizenode;     // hash å¤§å°ï¼Œå®é™…å¤§å°ä¸º 2&lt;sup&gt;lsizenode    Node* lastfree;             // ç©ºé—²æŒ‡é’ˆ    struct GCObject* gclist;    // GC éƒ¨åˆ†}\n\nC# å­—å…¸åŸç†private int[] buckets;  // Hash æ¡¶private Entry[] entries; // Entry æ•°ç»„ï¼Œå­˜æ”¾å…ƒç´ \n\nå­—å…¸å†…éƒ¨æœ‰ä¸¤ä¸ªä¸»è¦çš„æ•°ç»„\n\nEntryç»“æ„ä½“æ•°ç»„ï¼šå…¶ä¸­å­˜å‚¨ hash å€¼ã€é”®å€¼å¯¹ã€å‘ç”Ÿå†²çªæŒ‡å‘çš„ä¸Šä¸€ä¸ª Entry ä½ç½®\nbucketsæ•°ç»„ï¼šå­˜æ”¾å¯¹åº” Entry ä¸‹æ ‡\n\nC# å˜é‡èµ‹å€¼\nå€¼ç±»å‹å˜é‡çš„èµ‹å€¼ï¼š å€¼ç±»å‹å˜é‡ä¸­ä¿å­˜çš„æ˜¯å®é™…æ•°æ®ï¼Œåœ¨èµ‹å€¼çš„æ—¶å€™åªæ˜¯æŠŠæ•°æ®å¤åˆ¶ä¸€ä»½ï¼Œç„¶åèµ‹ç»™å¦ä¸€ä¸ªå˜é‡\n\nint var1 = 2;int var2 = var1; // ç¼–è¯‘å™¨ä¼šå…ˆå¤åˆ¶ var1 çš„å€¼ï¼Œç„¶åæŠŠå®ƒèµ‹ç»™ var2. å¾ˆæ˜æ˜¾ var2 çš„å€¼ä¹Ÿä¸º 2\n\n\nå¼•ç”¨ç±»å‹å˜é‡çš„èµ‹å€¼ï¼š å¼•ç”¨ç±»å‹å˜é‡ä¸­ä¿å­˜çš„æ˜¯â€œæŒ‡å‘å®é™…æ•°æ®çš„å¼•ç”¨æŒ‡é’ˆâ€ã€‚åœ¨è¿›è¡Œèµ‹å€¼æ“ä½œçš„æ—¶å€™ï¼Œå®ƒå’Œå€¼ç±»å‹ä¸€æ ·ï¼Œä¹Ÿæ˜¯å…ˆæœ‰ä¸€ä¸ªå¤åˆ¶çš„æ“ä½œï¼Œä¸è¿‡å®ƒå¤åˆ¶çš„ä¸æ˜¯å®é™…çš„æ•°æ®ï¼Œè€Œæ˜¯å¼•ç”¨ï¼ˆçœŸå®æ•°æ®çš„å†…å­˜åœ°å€ï¼‰æ‰€ä»¥å¼•ç”¨ç±»å‹çš„å˜é‡åœ¨èµ‹å€¼çš„æ—¶å€™ï¼Œèµ‹ç»™å¦ä¸€å˜é‡çš„å®é™…ä¸Šæ˜¯å†…å­˜åœ°å€\n\nclass MyClass{    public int val;}struct MyStruct {    public int val;}class Program {    static void Main(string[] args)    {        MyClass objectA = new MyClass();        MyClass objectB = objectA; // å¼•ç”¨å˜é‡çš„èµ‹å€¼ èµ‹å€¼æ“ä½œå®Œæˆåï¼Œä¸¤ä¸ªå˜é‡éƒ½æŒ‡å‘åŒä¸€å†…å­˜åœ°å€         objectA.val = 10; // ç»™ objectA.val èµ‹å€¼ =10 ç”±äº objectB å’Œ objectA æŒ‡å‘åŒä¸€å†…å­˜åœ°å€ï¼Œæ‰€ä»¥ ojbectB.val çš„å€¼ä¹Ÿä¸º 10        objectB.val = 20; // ç»™ objectB.val èµ‹å€¼ =20 ç”±äº objectB å’Œ objectA æŒ‡å‘åŒä¸€å†…å­˜åœ°å€ï¼Œæ‰€ä»¥ objectA.val çš„å€¼ä¹Ÿä¸º 20        MyStruct structA = new MyStruct();        MyStruct structB = structA; // ç»“æ„æ˜¯å€¼ç±»å‹ èµ‹å€¼æ“ä½œå®Œæˆåï¼Œä¸¤ä¸ªç»“æ„ä¸­çš„ç»“æ„ä¿¡æ¯ä¸€è‡´ã€‚æ³¨æ„æ˜¯â€œç»“æ„ä¸­çš„ä¿¡æ¯â€ä¸€è‡´ã€‚        structA.val = 30;        structB.val = 40;        Console.WriteLine(\"objectA.val={0}\", objectA.val); // è¾“å‡ºç»“æœæ˜¯ 20        Console.WriteLine(\"objectB.val={0}\", objectB.val); // è¾“å‡ºç»“æœæ˜¯ 20        Console.WriteLine(\"structA.val={0}\", structA.val); // è¾“å‡ºç»“æœæ˜¯ 30        Console.WriteLine(\"structB.val={0}\", structB.val); // è¾“å‡ºç»“æœæ˜¯ 40    }}\n\nè…¾è®¯Unity ä¸­å½±å“æ¸²æŸ“é¡ºåºçš„å› ç´ \n    \n\n\n\nCanvas\nä¸åŒ Canvas ä¹‹é—´å¯ä»¥ç”¨ä»¥ä¸‹ä¸¤ä¸ªå±æ€§æ§åˆ¶æ¸²æŸ“å±‚çº§\nSorting Layer\nOrder in Layer\n\n\n\n\nHierarchy ä¸­é¡ºåº\nåœ¨åŒä¸€ä¸ª Canvas ä¸­ï¼ŒHierarchy çš„é¡ºåºå†³å®šäº†æ§ä»¶çš„å±‚çº§å…³ç³»\n\n\n\næ¨¡å‹æ·±åº¦çš„æ§åˆ¶\nç©ºé—´æ·±åº¦ï¼šå¯¹äº 3D ç‰©ä½“çš„æ˜¾ç¤ºå…ˆåå°±æ˜¯å®Œå…¨æŒ‰ç©ºé—´çš„å…ˆåæ¥çš„ï¼Œå½“ç„¶å¯ä»¥åœ¨ fragment shader ä¸­å…³é—­æ·±åº¦æµ‹è¯•ï¼Œæˆ–è¿›è¡Œå…¶ä»–å½±å“å¸§ç¼“å†²åŒºçš„æ“ä½œ\nRenderQueueï¼šRenderQueue æ˜¯å¯¹ unity ä¸­æ‰€æœ‰å¯ä»¥æ¸²æŸ“çš„ç‰©ä½“éƒ½é€‚ç”¨\n\nç²’å­ç‰¹æ•ˆæ¸²æŸ“å±‚çº§çš„æ§åˆ¶\nç©ºé—´æ·±åº¦ï¼šå’Œ 3D æ¨¡å‹ä¸€è‡´\nRenderQueueï¼šå’Œ 3D æ¨¡å‹ä¸€è‡´\nSorting Orderï¼šç²’å­ç³»ç»Ÿæœ¬èº«æ˜¯ä¸€ä¸ª Renderer ç»„ä»¶ï¼Œå®ƒæ¸²æŸ“çš„æ˜¯ä¸€ä¸ªä¸€ä¸ªç²¾çµï¼Œæ˜¯ä¸€ä¸ªä¸€ä¸ªç‰‡ï¼Œè¯¥å±æ€§æœ‰æ•ˆ\n\nC# åƒåœ¾å›æ”¶  æ£€æŸ¥å›æ”¶å¯¹è±¡GC èƒ½å¤Ÿäº†è§£æŸä¸ªå®ä½“ç›®å‰æ˜¯å¦ä¾æ—§è¢«åº”ç”¨ç¨‹åºçš„æŸäº›æ´»åŠ¨å¯¹è±¡æ‰€å¼•ç”¨ï¼›å¯¹äºé‚£äº›æ²¡æœ‰è¢«ä»»ä½•æ´»åŠ¨å¯¹è±¡ç›´æ¥æˆ–é—´æ¥å¼•ç”¨çš„å¯¹è±¡ï¼ŒGC ä¼šå°†å…¶åˆ¤æ–­ä¸ºåƒåœ¾ã€‚GC åœ¨å…¶ä¸“é—¨çš„çº¿ç¨‹ä¸­è¿è¡Œï¼Œé»˜é»˜åœ°ä¸ºç¨‹åºæ¸…é™¤ä¸å†ä½¿ç”¨çš„å†…å­˜ã€‚å‹ç¼©æ‰˜ç®¡å †ï¼ˆå°†å½“å‰ä»æ—§ä½¿ç”¨çš„å¯¹è±¡æ”¾åœ¨è¿ç»­çš„å†…å­˜ä¸­ï¼Œå¯ä»¥åˆ©ç”¨å±€éƒ¨æ€§åŸç†æé«˜æ€§èƒ½ï¼‰ï¼Œå› æ­¤ç©ºä½™çš„ç©ºé—´ä¹Ÿä¼šæ˜¯ä¸€å—è¿ç»­çš„å†…å­˜\nåƒåœ¾å›æ”¶å™¨é‡‡ç”¨çš„æ˜¯ mark-and-compact ç®—æ³•ï¼ˆæ ‡è®°å’Œæ›´æ”¹å¯¹è±¡çš„åŒæ­¥å—ç´¢å¼•ä¸­çš„ä¸€ä¸ªä½ bitï¼‰ï¼Œåœ¨æ‰§è¡Œåƒåœ¾å›æ”¶çš„æ—¶å€™ï¼ŒGC ä¸æ˜¯æšä¸¾æ‰€æœ‰è®¿é—®ä¸åˆ°çš„å¯¹è±¡ï¼›ç›¸åï¼Œå®ƒæ˜¯é€šè¿‡å‹ç¼©æ‰€æœ‰ç›¸é‚»çš„å¯è¾¾å¯¹è±¡æ¥æ‰§è¡Œåƒåœ¾å›æ”¶ã€‚è¿™æ ·ï¼Œç”±ä¸å¯è®¿é—®çš„å¯¹è±¡å ç”¨çš„å†…å­˜å°±ä¼šè¢«è¦†ç›–\nä»£  è‡ªä¸Šä¸€æ¬¡åƒåœ¾æ”¶é›†ä»¥æ¥ï¼Œæ–°åˆ›å»ºçš„å¯¹è±¡å±äºç¬¬ 0 ä»£å¯¹è±¡ï¼Œè€Œè‹¥æ˜¯æŸä¸ªå¯¹è±¡åœ¨ç»è¿‡è¿‡ä¸€æ¬¡åƒåœ¾æ”¶é›†ä¹‹åä»æ—§å­˜æ´»ï¼Œé‚£ä¹ˆå®ƒå°†æˆä¸ºç¬¬ 1 ä»£å¯¹è±¡ã€‚ä¸¤æ¬¡åŠä¸¤æ¬¡ä»¥ä¸Šåƒåœ¾æ”¶é›†åä»æ—§æ²¡æœ‰è¢«é”€æ¯çš„å¯¹è±¡å°±å˜æˆäº†ç¬¬ 2 ä»£å¯¹è±¡ã€‚ï¼ˆç¬¬ 0 ä»£å¯¹è±¡å¤§å¤šå±äºå±€éƒ¨å˜é‡ï¼Œè€Œæˆå‘˜å˜é‡å’Œå…¨å±€å˜é‡ï¼ˆCLR å…è®¸å…¨å±€å˜é‡çš„å®šä¹‰ï¼Œå³ä¾¿ C# ä¸­ä¸æ”¯æŒï¼‰åˆ™ä¼šå¾ˆå¿«æˆä¸ºç¬¬ 1 ä»£å¯¹è±¡ï¼Œç›´è‡³ç¬¬ 2 ä»£ï¼‰\næ¯ä¸€ä»£éƒ½ä¼šæœ‰ä¸€ä¸ªé¢„ç®—å®¹é‡ï¼ˆä»¥ KB ä¸ºå•ä½ï¼‰ï¼Œå¦‚æœåˆ†é…ä¸€ä¸ªæ–°å¯¹è±¡é€ æˆè¶…å‡ºé¢„ç®—ï¼Œå°±ä¼šå¯åŠ¨ä¸€æ¬¡åƒåœ¾å›æ”¶ã€‚CLR åƒåœ¾å›æ”¶å™¨æ˜¯è‡ªè°ƒèŠ‚çš„ï¼Œæ‰€ä»¥ä¼šæ ¹æ®å›æ”¶åƒåœ¾å¯¹è±¡çš„æ•°é‡åŠ¨æ€è®¾ç½®é¢„ç®—å®¹é‡çš„å¤§å°ã€‚ ä¸€èˆ¬æ¥è¯´ï¼Œå¤§æ¦‚ 10 ä¸ªå‘¨æœŸçš„ GC ä¸­ï¼Œä¼šæœ‰ä¸€æ¬¡åŒæ—¶æ£€æŸ¥ç¬¬ 0 ä»£å’Œç¬¬ 1 ä»£å¯¹è±¡ï¼Œå¤§æ¦‚ 100 ä¸ªå‘¨æœŸçš„ GC ä¸­ï¼Œä¼šæœ‰ä¸€æ¬¡åŒæ—¶æ£€æŸ¥æ‰€æœ‰å¯¹è±¡\néæ‰˜ç®¡èµ„æº .Net æä¾›äº†ä¸¤ç§æ§åˆ¶éæ‰˜ç®¡èµ„æºç”Ÿå‘½å‘¨æœŸçš„æœºåˆ¶ï¼šç»ˆç»“å™¨ï¼ˆfinalizerï¼‰å’Œ IDisposable æ¥å£\nç»ˆç»“å™¨\nç»ˆç»“å™¨å°†ç”± GC è°ƒç”¨ï¼Œè°ƒç”¨å°†å‘ç”Ÿåœ¨å¯¹è±¡æˆä¸ºåƒåœ¾ä¹‹åçš„æŸä¸ªæ—¶é—´ï¼ˆæ— æ³•ç¡®å®šå…¶å‘ç”Ÿçš„å…·ä½“æ—¶é—´ï¼‰ï¼Œå› æ­¤ .Net å¹¶ä¸èƒ½ä¿è¯ææ„æ“ä½œçš„ç¡®åˆ‡æ—¶é—´\nä¾èµ–ç»ˆç»“å™¨è¿˜ä¼šå¸¦æ¥æ€§èƒ½ä¸Šçš„é—®é¢˜ã€‚å½“ GC å‘ç°æŸä¸ªå¯¹è±¡å±äºåƒåœ¾ï¼Œä½†è¯¥å¯¹è±¡éœ€è¦æ‰§è¡Œç»ˆç»“æ“ä½œæ—¶ï¼ˆå®šä¹‰äº†ææ„å‡½æ•°ï¼‰ï¼Œå°±ä¸èƒ½å°†å…¶ç›´æ¥ä»å†…å­˜ä¸­ç§»é™¤ã€‚é¦–å…ˆï¼ŒGC å°†è°ƒç”¨å…¶ç»ˆç»“å™¨ï¼Œè€Œç»ˆç»“å™¨å¹¶ä¸åœ¨æ‰§è¡Œåƒåœ¾æ”¶é›†çš„çº¿ç¨‹ä¸Šæ‰§è¡Œã€‚GC å°†æŠŠæ‰€æœ‰éœ€è¦æ‰§è¡Œç»ˆç»“çš„å¯¹è±¡æ”¾åœ¨ä¸“é—¨çš„é˜Ÿåˆ—ä¸­ï¼Œç„¶åè®©å¦ä¸€ä¸ªçº¿ç¨‹æ¥æ‰§è¡Œè¿™äº›å¯¹è±¡çš„ç»ˆç»“å™¨ã€‚è¿™æ ·ï¼ŒGC å¯ä»¥ç»§ç»­æ‰§è¡Œå…¶å½“å‰çš„å·¥ä½œï¼Œåœ¨å†…å­˜ä¸­ç§»é™¤åƒåœ¾å¯¹è±¡ã€‚è€Œåœ¨ä¸‹ä¸€æ¬¡çš„ GC è°ƒç”¨æ—¶ï¼Œæ‰ä¼šä»å†…å­˜ä¸­ç§»é™¤è¿™äº›å·²è¢«ç»ˆç»“çš„å¯¹è±¡ã€‚å› æ­¤éœ€è¦è°ƒç”¨ç»ˆç»“å™¨çš„å¯¹è±¡å°†åœ¨å†…å­˜ä¸­å¤šåœç•™ä¸€æ¬¡ GC å‘¨æœŸçš„æ—¶é—´ï¼Œå¦‚æœç»ˆç»“å¯¹è±¡è¿›å…¥ç¬¬ 1 ä»£æˆ–ç¬¬ 2 ä»£ï¼Œé‚£ä¹ˆå°†åœç•™æ›´é•¿çš„ GC å‘¨æœŸ\n\nå› æ­¤ï¼Œå°½é‡ä¸è¦ä½¿ç”¨ç»ˆç»“å™¨æ¥é‡Šæ”¾éæ‰˜ç®¡èµ„æº\nIDisposableæ¥å£ IDisposable.Dispose() æ–¹æ³•çš„å®ç°ä¸­éœ€è¦å®Œæˆå¦‚ä¸‹ 4 ä¸ªä»»åŠ¡\n\né‡Šæ”¾æ‰€æœ‰éæ‰˜ç®¡èµ„æº\né‡Šæ”¾æ‰€æœ‰æ‰˜ç®¡èµ„æºï¼ŒåŒ…æ‹¬é‡Šæ”¾äº‹ä»¶ç›‘å¬ç¨‹åº\nè®¾ç½®ä¸€ä¸ªçŠ¶æ€æ ‡å¿—ï¼Œè¡¨ç¤ºè¯¥å¯¹è±¡å·²ç»è¢«é”€æ¯ï¼Œè‹¥æ˜¯åœ¨é”€æ¯ä¹‹åå†æ¬¡è°ƒç”¨å¯¹è±¡çš„å…¬æœ‰æ–¹æ³•ï¼Œé‚£ä¹ˆåº”è¯¥æŠ›å‡º ObjectDisposedå¼‚å¸¸ã€‚\nè·³è¿‡ç»ˆç»“æ“ä½œï¼Œè°ƒç”¨ GC.SuppressFinalize(this) å³å¯\n\nç”±äºå¾ˆå¤šéæ‰˜ç®¡èµ„æºéƒ½éå¸¸å®è´µï¼ˆå¦‚æ•°æ®åº“å’Œæ–‡ä»¶å¥æŸ„ï¼‰ï¼Œæ‰€ä»¥å®ƒä»¬åº”å°½å¯èƒ½å¿«åœ°è¢«æ¸…é™¤ï¼Œè€Œä¸èƒ½ä¾é åƒåœ¾å›æ”¶çš„å‘ç”Ÿã€‚.Net ä¸­ä½¿ç”¨äº†ä¸€ç§æ ‡å‡†çš„æ¨¡å¼èƒ½å¤Ÿåœ¨ä½¿ç”¨è€…æ­£å¸¸è°ƒç”¨æ˜¯é€šè¿‡ IDisposable æ¥å£é‡Šæ”¾æ‰éæ‰˜ç®¡èµ„æºï¼Œä¹Ÿä¼šåœ¨ä½¿ç”¨è€…å¿˜è®°çš„æƒ…å†µä¸‹ä½¿ç”¨ç»ˆç»“å™¨é‡Šæ”¾ã€‚è¿™ä¸ªæ¨¡å¼å’Œ GC é…åˆï¼Œå¯ä»¥ä¿è¯ä»…åœ¨æœ€ç³Ÿç³•çš„æƒ…å†µä¸‹æ‰è°ƒç”¨ç»ˆç»“å™¨ï¼Œå°½å¯èƒ½é™ä½å…¶å¸¦æ¥çš„æ€§èƒ½å½±å“\nå¦‚ä½•è¿›è¡Œå†…å­˜ä¼˜åŒ–\nç±»ä¸­å­˜åœ¨ç©ºçš„ Updateã€LateUpdate å’ŒFixedUpdateæ–¹æ³•\nUnity ä¸­çš„è„šæœ¬å…¶å®é»˜è®¤éƒ½æ˜¯ç»§æ‰¿è‡ªè¿™ä¸ª Monobehaviorã€‚Updateã€LateUpdate å’ŒFixedUpdateå±äº Monobehaviour ç±»çš„â€œMessagesâ€ï¼Œè™½ç„¶ä¸ç”± Monobehavior ç±»ç»§æ‰¿è€Œæ¥ï¼Œä½†æ˜¯åœ¨ Monobehaviour ç±»çš„è„šæœ¬ä¸­ä¼šç”Ÿæ•ˆâ€”â€”å¦‚æœè„šæœ¬ä¸­å†™ä¸Šäº†è¿™äº›æ–¹æ³•ï¼Œç›¸åº”çš„è„šæœ¬æ”¾åˆ°åœºæ™¯ä¸­ï¼Œå¹¶ä¸” enable ä¸ºtrueï¼Œé‚£ä¹ˆæ¸¸æˆè¿è¡Œè¿‡ç¨‹ä¸­æ¯å¸§éƒ½ä¼šå¯¹å…¶è¿›è¡Œè°ƒç”¨ã€‚å³ä½¿è¿™äº›æ–¹æ³•ä¸ºç©ºï¼Œåœ¨è¿è¡Œæ—¶ï¼Œå®ƒä»¬ä¾ç„¶ä¼šå› ä¸ºè¢«è°ƒç”¨è€Œé€ æˆ CPU æ—¶é—´çš„å¼€é”€ï¼Œå…¶åŸå› ä¸»è¦æœ‰ä¸¤ç‚¹\n\nè¿™äº›æ–¹æ³•æ˜¯ Native å±‚å¯¹æ‰˜ç®¡å±‚çš„è°ƒç”¨ï¼ŒC++ ä¸ C# ä¹‹é—´çš„é€šä¿¡æœ¬èº«å­˜åœ¨ä¸€å®šçš„å¼€é”€\nå½“è°ƒç”¨è¿™äº›æ–¹æ³•æ—¶ï¼ŒUnity ä¼šè¿›è¡Œä¸€ç³»åˆ—å®‰å…¨æ£€æµ‹ï¼ˆæ¯”å¦‚ç¡®ä¿ GameObject æ²¡æœ‰è¢«é”€æ¯ç­‰ï¼‰å¯¼è‡´ CPU æ—¶é—´çš„æ¶ˆè€—\n\n\nå¯¹çº¹ç† SetPixels çš„è°ƒç”¨\nSetPixelså¯ç”¨äºå¯¹çº¹ç†ç‰¹å®šçš„ mipmap å±‚çš„åƒç´ è¿›è¡Œä¿®æ”¹ï¼Œå®ƒä¼šå°†ä¸€ç»„æ•°ç»„çš„åƒç´ å€¼èµ‹å€¼åˆ°è´´å›¾çš„æŒ‡å®š mipmap å±‚ï¼Œè°ƒç”¨ Apply() åä¼šå°†åƒç´ ä¼ è‡³æ˜¾å¡ã€‚éœ€æ³¨æ„çš„æ˜¯ï¼Œç”±äº Color32 æ¯”Colorç±»å‹æ‰€å çš„ç©ºé—´æ›´å°ï¼Œä½¿ç”¨ SetPixels32 æ¯”SetPixelsé€ æˆçš„ CPU è€—æ—¶ä¹Ÿæ›´å°ã€‚æ‰€ä»¥åœ¨æ•ˆæœå…è®¸çš„æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬æ¨èä½¿ç”¨ SetPixels32() æ–¹æ³•æ¥å–ä»£SetPixels()\n\nä»å†…å­˜åˆ†é…ä¸Šè®²ï¼Œè¯¥å‡½æ•°ä¼šåœ¨æ‰˜ç®¡å †ä¸­åˆ†é…å†…å­˜ï¼Œç”¨ä»¥å­˜å‚¨çº¹ç†æ•°æ®çš„åƒç´ ä¿¡æ¯ï¼Œä½†å¼•æ“ä¸ä¼šå¯¹å…¶è¿›è¡Œç¼“å­˜ã€‚æ‰€ä»¥å¦‚æœåœ¨é¢‘ç¹è°ƒç”¨çš„å‡½æ•°ä¸­ä½¿ç”¨ï¼Œå°±ä¼šé€ æˆæŒç»­æ€§çš„å †å†…å­˜åˆ†é…\nä»è€—æ—¶ä¸Šè®²ï¼Œæ“…é•¿æ‰§è¡Œå¤§è§„æ¨¡å¹¶è¡Œè¿ç®—çš„ GPU æ¥å¤„ç†å›¾ç‰‡ä¿¡æ¯æ˜¯éå¸¸å®¹æ˜“çš„ï¼Œä½† CPU åœ¨è¿›è¡Œé€ä¸ªåƒç´ ä¿¡æ¯çš„è·å–æ—¶ï¼Œå°±æ˜¾å¾—æœ‰äº›åƒåŠ›äº†ã€‚å¹¶ä¸” GetPixels() åœ¨å®ç°ä¸Šæ˜¯ç”± CPU åŒæ­¥æ‰§è¡Œçš„ï¼Œæ‰€ä»¥è€—æ—¶ä¼šè¾ƒé«˜ï¼ŒåŒæ—¶ä¼šé˜»å¡è°ƒç”¨çš„çº¿ç¨‹ï¼Œä»è€Œå¯èƒ½ä¼šé€ æˆå¡é¡¿ã€‚å› æ­¤åœ¨éå¿…è¦çš„æƒ…å†µä¸‹ï¼Œå¹¶ä¸å»ºè®®ä½¿ç”¨GetPixels()\n\n\nGetComponentsInChildrenå’Œ GetComponentsInParent çš„è°ƒç”¨\nGetComponentsInChildrenç”¨äºè·å¾—  å½“å‰ GameObject åŠå…¶  å­èŠ‚ç‚¹  çš„æ‰€æœ‰ç»™å®šç±»å‹çš„ç»„ä»¶ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªåŒ…å«æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„å¯¹è±¡çš„æ•°ç»„ï¼›è€Œ GetComponentsInParent åˆ™æ˜¯ç”¨äºè·å¾—  å½“å‰  å¯¹è±¡åŠå…¶  çˆ¶èŠ‚ç‚¹  ä¸Šçš„æ‰€æœ‰ç»™å®šç±»å‹çš„ç»„ä»¶\nè¿™ä¸¤è€…çš„ä½¿ç”¨éƒ½ä¼šæ¶‰åŠåˆ°è¾ƒå¤§èŒƒå›´å†…çš„æœç´¢éå†ï¼Œä¼šæŒ¤å  CPU è¾ƒå¤§çš„è®¡ç®—èµ„æºï¼Œæ‰€ä»¥åº”å½“å°½é‡å‡å°‘ç›¸å…³çš„è°ƒç”¨ï¼Œå¯ä»¥å°è¯•ç¼“å­˜è°ƒç”¨çš„ç»“æœï¼Œé¿å…ä½¿å…¶å‡ºç°åœ¨ Update è¿™æ ·çš„é¢‘ç¹è°ƒç”¨çš„å‡½æ•°å½“ä¸­ã€‚æ­¤å¤–ï¼Œå¯¹äºè¿™ä¸¤ä¸ªå‡½æ•°ï¼Œå»ºè®®ä½¿ç”¨æ¥å— List ç±»å‹çš„å¼•ç”¨ä½œä¸ºå‚æ•°çš„ç‰ˆæœ¬ï¼Œè¿™æ ·å°±å¯ä»¥é¿å…æ¯æ¬¡è°ƒç”¨éƒ½é€ æˆå †å†…å­˜çš„åˆ†é…\n\nLinqç›¸å…³å‡½æ•°çš„è°ƒç”¨\nLinqç›¸å…³çš„å‡½æ•°ä¸€èˆ¬éƒ½ç”¨äºå¯¹æ•°æ®çš„æŸ¥è¯¢å’Œå¤„ç†ã€‚åŠŸèƒ½ä¸Šç®€å•æ¥è®²ï¼Œå°±æ˜¯å¯¹ä¸€å †æ•°æ®è¿›è¡Œå„ç§ if åˆ¤æ–­å’Œ for å¾ªç¯å¤„ç†ã€‚ä½¿ç”¨ Linq æä¾›çš„ APIï¼Œå¯ä»¥å†™å‡º SQL è¯­å¥é£æ ¼çš„ä»£ç æ¥è¿›è¡Œé›†åˆæ•°æ®çš„å¤„ç†ï¼Œè¿™èƒ½å¤Ÿæ˜æ˜¾æå‡ä»£ç çš„ç®€æ˜æ€§ã€å¯è¯»æ€§ï¼Œç»´æŠ¤ä¸Šä¹Ÿæ›´æ–¹ä¾¿ï¼Œä»è€Œæå‡ç¼–å†™æ•ˆç‡ï¼Œä½†æ˜¯è¿™äº›ä¼˜ç‚¹æ˜¯ä»¥æ€§èƒ½çš„å¼€é”€ä¸ºä»£ä»·çš„\nLinqåœ¨æ‰§è¡Œè¿‡ç¨‹ä¸­ä¼šäº§ç”Ÿä¸€äº›ä¸´æ—¶å˜é‡ï¼Œè€Œä¸”ä¼šç”¨åˆ°å§”æ‰˜ï¼ˆlambdaè¡¨è¾¾å¼ï¼‰ã€‚å¦‚æœä½¿ç”¨å§”æ‰˜ä½œä¸ºæ¡ä»¶çš„åˆ¤å®šæ–¹æ³•ï¼Œæ—¶é—´å¼€é”€å°±ä¼šå¾ˆé«˜ï¼Œå¹¶ä¸”ä¼šé€ æˆä¸€å®šçš„å †å†…å­˜åˆ†é…ã€‚æ‰€ä»¥åœ¨ä¸€èˆ¬çš„ Unity æ¸¸æˆé¡¹ç›®å¼€å‘ä¸­ï¼Œä¸æ¨èä½¿ç”¨ Linq ç›¸å…³çš„å‡½æ•°ã€‚åœ¨ç¼–è¾‘å™¨åŠŸèƒ½å¼€å‘ä¸­ï¼Œæ‰å¸¸å¸¸æŠŠ Linq å’ŒReflectionè¿›è¡Œé…åˆä½¿ç”¨\n\nå¯¹ Renderer è¿›è¡Œ Material/Materials çš„è·å–\nåœ¨ Unity ä¸­ï¼Œå¦‚æœå¯¹ Renderer ç±»å‹è°ƒç”¨ .material å’Œ.materialsï¼Œé‚£ä¹ˆ Unity å°±ä¼šç”Ÿæˆæ–°çš„æè´¨çƒå®ä¾‹ã€‚å…¶ä¸»è¦å½±å“å¦‚ä¸‹ï¼š\n\né€šè¿‡.materialï¼Œåˆ›å»ºæè´¨å®ä¾‹ï¼Œå¹¶ä¿®æ”¹å±æ€§çš„æ–¹å¼å®ç°å¤šæ ·çš„æ¸²æŸ“æ•ˆæœï¼Œæ—¶é—´å¼€é”€ä¼šè¾ƒé«˜\nä½¿ç”¨ç›¸åŒ Shaderï¼Œä½†å› ä¸º Material å®ä¾‹ä¸åŒçš„GameObjectï¼Œæ‰€ä»¥æ— æ³•è¿›è¡Œåˆæ‰¹ï¼Œå¯¼è‡´ Draw Call å¢åŠ ï¼Œå˜ç›¸é€ æˆäº† CPU è€—æ—¶çš„å¢åŠ \næ¯æ¬¡å¯¹æ–°çš„ GameObject çš„Rendererè°ƒç”¨ .materialï¼Œéƒ½ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„Material å®ä¾‹ï¼Œä¸” GameObject é”€æ¯åï¼ŒMaterialå®ä¾‹æ— æ³•è‡ªåŠ¨é”€æ¯ï¼Œè¿™ä¼šå¯¹èµ„æºç®¡ç†é€ æˆä¸€å®šçš„æˆæœ¬ï¼Œæƒ³è¦å¤„ç†çš„è¯å°±éœ€è¦æ‰‹åŠ¨è°ƒç”¨ UnloadUnusedAssets æ¥å¸è½½ï¼Œä½†è¿™æ ·å°±é€ æˆäº†æ€§èƒ½å¼€é”€ï¼›ç®¡ç†ä¸å¥½å¯èƒ½ä¼šé€ æˆæè´¨çƒå¤§é‡å†—ä½™ç”šè‡³æ³„éœ²ï¼Œæç«¯æƒ…å†µä¸‹ç”šè‡³ä¼šå¯¼è‡´è¿‡é«˜çš„å†…å­˜\n\n\n\nUI å¦‚ä½•é™ä½ Draw Call\næ¯ä¸ªå•ç‹¬çš„æè´¨ / çº¹ç†çš„æ¸²æŸ“ä¸€å®šæ˜¯ä¼šäº§ç”Ÿ DrawCall çš„ï¼Œå°†å¤šå¼ å°å›¾æ‰“åŒ…æˆä¸€ä¸ªå›¾é›†ï¼Œåœ¨æ¸²æŸ“ UI æ—¶å°±å¯ä½¿ç”¨åŒä¸€ä¸ªæè´¨ / çº¹ç†ï¼Œå³å¯æœ‰æ•ˆé™ä½ Draw Call çš„äº§ç”Ÿ\nä»åŠŸèƒ½è§’åº¦åˆ’åˆ†å›¾é›†ï¼Œä¾‹å¦‚å°†å…¬å…± UI æ‰“åŒ…æˆä¸€ä¸ªå›¾é›†ï¼Œå°†æ¯ä¸ªç³»ç»Ÿçš„ UI åˆ†åˆ«æ‰“æˆå•ç‹¬çš„å›¾é›†ï¼Œä¸»è¦åŸåˆ™æ˜¯å°†æ˜¾ç¤ºä¸Šå¯†åˆ‡ç›¸å…³çš„å›¾ç‰‡æ‰“åŒ…åˆ°ä¸€èµ·\né¿å…å°†æ— å…³è”çš„ä¸œè¥¿æ‰“åŒ…åœ¨ä¸€ä¸ªå›¾é›†é‡Œï¼Œç‰¹åˆ«æ˜¯é‚£äº›ä¸å¯èƒ½åŒæ—¶å‡ºç°çš„å…ƒç´ ï¼Œè¿™æ ·ä¸ä½†æ— æ³•å‡å°‘ DrawCallï¼Œè¿˜ä¼šå¢åŠ å†…å­˜æ¶ˆè€—\næ§åˆ¶å›¾é›†å¤§å°ï¼Œä¸è¦è®©å›¾é›†å¤ªå¤§\n\n\nåˆå¹¶ UI å…ƒç´ \nUGUI çš„æ¸²æŸ“è¿‡ç¨‹æ˜¯é€šè¿‡ Canvas ç»„ä»¶å®ç°çš„ã€‚æ¯ä¸ª Canvas éƒ½æœ‰ä¸€ä¸ª Sorting Layer å’Œä¸€ä¸ª Order in Layer å±æ€§ï¼Œç”¨äºæ§åˆ¶ UI å…ƒç´ çš„æ¸²æŸ“é¡ºåºã€‚å¦‚æœ UI å…ƒç´ åœ¨åŒä¸€ä¸ª Sorting Layer å’Œ Order in Layer ä¸‹ï¼Œå®ƒä»¬å°±ä¼šè¢«åˆå¹¶æˆä¸€ä¸ª DrawCallã€‚å¯ä»¥å°†ç›¸åŒçš„ UI å…ƒç´ æ”¾åœ¨åŒä¸€ä¸ª Sorting Layer å’Œ Order in Layer ä¸‹ï¼Œä»¥å‡å°‘ DrawCall çš„æ•°é‡\n\n\n\nåˆæ‰¹çš„è§„åˆ™UGUI åœ¨åˆæ‰¹ä¹‹å‰ï¼Œä¼šæ ¹æ®èŠ‚ç‚¹çš„ Depthã€Material InstanceID ã€Texture InstanceIDã€RendererOrder è¿›è¡Œæ’åºï¼Œä¹‹åå¯¹ç›¸é‚»çš„èŠ‚ç‚¹è¿›è¡Œæ£€æµ‹ï¼Œåˆ¤æ–­ Material InstanceID å’Œ Texture InstanceID æ˜¯å¦ç›¸åŒï¼Œå¦‚æœç›¸åŒåˆ™å¯ä»¥è¿›è¡Œåˆæ‰¹å¤„ç†ï¼Œå¦‚æœè¿™ä¸¤ä¸ª UI çš„ Material InstanceID å’Œ Texture InstanceID éƒ½ç›¸åŒï¼Œä½†æ˜¯ä¸è¿ç»­ï¼Œä¸­é—´æœ‰å…¶ä»–ä¸åŒ Material InstanceID æˆ– Texture InstanceID çš„ UI åˆ™ä¼šæ‰“æ–­åˆæ‰¹\nDepth æ’åº\n\nç­›é€‰æ‰ Depth ä¸º -1 çš„å€¼ï¼Œè¿™éƒ¨åˆ†é»˜è®¤ä¸æ¸²æŸ“\nåˆ¤æ–­æ˜¯å¦è¯¥å…ƒç´ åº•éƒ¨æ˜¯å¦æœ‰ç‰©ä½“ï¼Œå¦‚æœæ²¡æœ‰åˆ™èµ‹å€¼ Depth ä¸º 0ï¼Œå¦‚æœç›–ä½ç‰©ä½“ï¼ˆè¿™å—æ˜¯é€šè¿‡ Mesh è¿›è¡Œåˆ¤æ–­ï¼Œåˆ¤æ–­ Mesh æ˜¯å¦ç›¸äº¤ï¼‰åˆ™ç­‰äºåº•éƒ¨ç›–ä½çš„ UI å…ƒç´ ä¸­ Depth æœ€å¤§çš„å€¼ +1\nå¦‚æœä¸¤ä¸ªç›¸é‚»å…ƒç´ é€šè¿‡äº†åˆæ‰¹æµ‹è¯•ï¼Œåˆ™è¿™ä¸¤ä¸ªç›¸é‚»å…ƒç´ çš„æ·±åº¦å€¼ç›¸ç­‰\n\næ·±åº¦æ’åºä¹‹åï¼Œå°±ä¼šæ ¹æ® Texture InstanceID è¿›è¡Œæ’åºï¼Œå¦‚æœæè´¨ç›¸åŒåˆ™å¯¹ Texture InstanceID è¿›è¡Œæ’åºï¼Œå¦‚æœä¹Ÿç›¸åŒï¼Œé‚£ä¼šæ ¹æ® Inspection é¢æ¿ä¸Šçš„ RendererOrderï¼Œæœ€åçœŸæ­£è¿›è¡Œ UI çš„åˆæ‰¹\nMask å½±å“åˆæ‰¹\nåœ¨ StencilMaterial.Add çš„æ—¶å€™ä¸ºè¿™ä¸ªèŠ‚ç‚¹å¢åŠ äº†ä¸€ä¸ªæ–°çš„æè´¨ï¼Œå¯¼è‡´äº† Mask å†…çš„ç‰©ä½“æ— æ³•å’Œå¤–éƒ¨åŒæ ·æè´¨çš„ç‰©ä½“åˆæ‰¹\nMask ä¼šè¿›è¡Œä¸¤æ¬¡ Passï¼Œç¬¬ä¸€æ­¥æ˜¯å¯¹åœ¨æ¨¡æ¿ç¼“å†²ä¸­çš„å€¼è¿›è¡Œèµ‹å€¼ï¼Œå°†è¦æ˜¾ç¤ºçš„éƒ¨åˆ†ç¼“å­˜å€¼è®¾ç½®ä¸º 1ï¼Œä¸æ˜¾ç¤ºçš„éƒ¨åˆ†è®¾ç½®ä¸º 0ï¼Œåœ¨ç¬¬äºŒä¸ª Pass ç»˜åˆ¶æ—¶å¯¹æ¨¡æ¿ç¼“å†²å€¼ä¸º 0 çš„éƒ¨åˆ†è¿›è¡Œå‰”é™¤ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ª Pass ä¹Ÿä¼šå¸¦æ¥ä¸¤ä¸ª Draw Call çš„ç”Ÿæˆ\n\næ‰€ä»¥æ·»åŠ ä¸€ä¸ª Mask æœ€èµ·ç ä¼šå¢åŠ  3 ä¸ª Draw Call\n\nä¸åŒçš„ Mask ä¹‹é—´æ˜¯å¯ä»¥åˆæ‰¹çš„ï¼Œè™½ç„¶ Mask ä¼šå¯¹åŸæ¥çš„æè´¨è¿›è¡Œæ›¿æ¢ï¼Œæ·»åŠ ä¸€ä¸ªæ–°çš„æè´¨ï¼Œä½†æ˜¯ä¸¤ä¸ª Mask æ·»åŠ çš„æè´¨æ˜¯ç›¸åŒçš„å°±æ”¯æŒåˆæ‰¹ï¼ˆå‰ææ˜¯ä¸¤ä¸ª Mask ä¸é‡å ï¼Œå½“ä»–ä»¬é‡å æ—¶ï¼Œå› ä¸ºè¢«å‰”é™¤çš„éƒ¨åˆ†å‚ä¸äº†è¿ç®—ï¼Œå‘ç° Depth ä¸åŒå¹¶ä¸” Material InstanceID ä¹Ÿä¸åŒï¼Œå°±æ— æ³•è¿›è¡Œåˆæ‰¹ï¼‰\n\nRectMask2D ä¸ Mask çš„åŒºåˆ«  å’Œ Mask ä¸åŒçš„æ˜¯ï¼ŒRectMask2D å¹¶ä¸ä¼šäº§ç”Ÿä¸¤é¢å¤–çš„ Pass å¢åŠ ä¸¤ä¸ª Draw Call çš„æ¶ˆè€—ã€‚RectMask2D æ˜¯é€šè¿‡ canvasRender é‡Œé¢è¿›è¡Œäº† ClipRect çš„å‰”é™¤ï¼Œè¿™æ ·ç›¸æ¯”äº Mask ä¼šå¸¦æ¥ä»¥ä¸‹ä¸åŒ\n\nRectMask2D ä¹‹é—´æ— æ³•è¿›è¡Œåˆæ‰¹\nè¢« RectMask2D éšè—çš„ç‰©ä½“ä¸ä¼šå‚ä¸åˆæ‰¹è®¡ç®—\nRectMask2D ç»„ä»¶ä¸ŠæŒ‚è½½çš„ Image å¯ä»¥å‚ä¸å¤–éƒ¨çš„åˆæ‰¹\n\nLua ä¸­çš„ pcall å’Œxpcall\npcall(f, arg1, Â·Â·Â·)ï¼šåœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œç”¨ç»™å®šçš„å‚æ•°è°ƒç”¨å‡½æ•° fï¼Œè¿™æ„å‘³ç€f å†…éƒ¨çš„ä»»ä½•é”™è¯¯ï¼Œéƒ½ä¼šè¢« pcall æ•è·ï¼Œè€Œä¸ä¼šä¼ æ’­å‡ºå»ã€‚pcallçš„ç¬¬ä¸€ä¸ªè¿”å›å€¼æ˜¯ boolean ç±»å‹çš„çŠ¶æ€ç ã€‚å¦‚æœ f å†…éƒ¨æ²¡æœ‰å‘ç”Ÿé”™è¯¯ï¼Œé‚£ä¹ˆ pcall è¿”å› true åŠ è°ƒç”¨ f(arg, ...) è¿”å›çš„æ‰€æœ‰å€¼ï¼Œå¦åˆ™è¿”å› nil åŠ é”™è¯¯ä¿¡æ¯\nxpcall (f, err, ...)ï¼šä¸ pcall ç±»ä¼¼ï¼Œä½†æ˜¯å¯ä»¥è®¾ç½®ä¸€ä¸ªé”™è¯¯å¤„ç†å‡½æ•°ã€‚xpcallåœ¨ä¿æŠ¤æ¨¡å¼ä¸‹ï¼Œç”¨ç»™å®šçš„å‚æ•°è°ƒç”¨å‡½æ•° fï¼Œä½¿ç”¨err ä½œä¸ºé”™è¯¯å¤„ç†å‡½æ•°ã€‚åœ¨ f å†…éƒ¨å‘ç”Ÿçš„ä»»ä½•é”™è¯¯ï¼Œéƒ½ä¼šè¢« xpcall æ•è·ï¼Œè€Œä¸ä¼šä¼ æ’­å‡ºå»ã€‚å½“å‡½æ•° f å†…éƒ¨å‘ç”Ÿé”™è¯¯æ—¶ï¼Œä¼šä½¿ç”¨åŸå§‹çš„é”™è¯¯ä¿¡æ¯è°ƒç”¨ err å‡½æ•°ï¼Œxpcallè¿”å› false åŠ errå‡½æ•°çš„ç¬¬ä¸€ä¸ªè¿”å›å€¼ï¼›å¦åˆ™ï¼Œè¿”å› true åŠ è°ƒç”¨ f(...) è¿”å›çš„æ‰€æœ‰å€¼\n\né›·ç«  åŠ¨ç”»èµ„æºæ˜¯å¦‚ä½•åŠ è½½çš„ Animator å’Œ Animation åŒºåˆ«GPU Instance æè´¨ç›¸åŒï¼Œæè´¨çš„å‚æ•°ä¸åŒå¯ä»¥è¿›è¡ŒåŠ¨æ€åˆæ‰¹å—  çŠ¶æ€æœºå’Œè¡Œä¸ºæ ‘çš„åŒºåˆ« Playable çš„ä½¿ç”¨ é¡¶ç‚¹åŠ¨ç”»  å¤šä¸ªå®ä½“å¦‚ä½•å¤„ç†åŠ¨ç”»  å¿«æ‰‹ Unity ä¸­ C# ä¸ Lua çš„äº¤äº’Lua ä¸å®¿ä¸»è¯­è¨€æ˜¯é€šè¿‡æ ˆè¿›è¡Œäº¤äº’çš„ã€‚åœ¨ c ä¸­é€šå¸¸ä»¥lua_State* L çš„å½¢å¼è¡¨ç¤ºæŒ‡å‘æ ˆçš„ä¸€ä¸ªæŒ‡é’ˆï¼Œåœ¨ C# ä¸­ä»¥ System.IntPtr L çš„å½¢å¼å­˜åœ¨ã€‚æ ˆçš„å…ƒç´ ç”¨è¿‡ index è¿›è¡Œç´¢å¼•ã€‚ä»¥è´Ÿæ•°è¡¨ç¤ºä»é¡¶å‘åº•ç´¢å¼•ï¼Œä»¥æ­£æ•°è¡¨ç¤ºç”±åº•å‘é¡¶ç´¢å¼•\nLua æ˜¯è·å–ä¸€ä¸ª C# å¯¹è±¡  ä¸»è¦æ˜¯é€šè¿‡ PushUserObject æ¥è·å–\nstatic void PushUserObject(IntPtr L, object o){    Type type = o.GetType();    int reference = LuaStatic.GetMetaReference(L, type);    if (reference &lt;= 0)    {        reference = LoadPreType(L, type);    }                    PushUserData(L, o, reference);}\n\né€šè¿‡ä¸€ä¸ª GetMetaReference æ–¹æ³•è·å–äº†ä¸€ä¸ª reference å€¼ï¼Œè¿™ä¸ªæ˜¯ C# ç±»å¯¼å‡º Wrap æ–‡ä»¶æ—¶åˆ›å»ºçš„ Wrap ç±»å¯¹åº”çš„å…ƒè¡¨å¼•ç”¨ï¼ˆå› ä¸ºå…ƒè¡¨æ˜¯ Lua çš„ä¸œè¥¿ï¼ŒC# é‡Œä¸èƒ½ç›´æ¥è·å–å…ƒè¡¨ï¼Œæ‰€ä»¥è¿™é‡Œåªèƒ½æ‹¿åˆ°å…ƒè¡¨åœ¨å†…å­˜ä¸­çš„å¼•ç”¨ Id)\npublic static void PushUserData(IntPtr L, object o, int reference){    int index;    ObjectTranslator translator = ObjectTranslator.Get(L);    if (translator.Getudata(o, out index))    {        if (LuaDLL.tolua_pushudata(L, index))        {            return;        }        translator.Destroyudata(index);    }    index = translator.AddObject(o);    LuaDLL.tolua_pushnewudata(L, reference, index);}\n\nLua ä» C# è·å–å¯¹è±¡çš„æ—¶å€™ï¼Œå®é™…ä¸Šè·å–çš„æ˜¯ä¸€ä¸ª userdataï¼Œè¿™ä¸ª userdata ä»¥ C# å¯¼å‡ºçš„ Wrap ç±»ä¸ºå…ƒè¡¨ï¼Œä»¥å®ç° Lua å¯¹ C# æ–¹æ³•çš„è°ƒç”¨ã€‚Lua ä» C# è¿™è¾¹è·å–çš„å¯¹è±¡ï¼Œéƒ½å°†è¢«ç¼“å­˜åˆ° ObjectTranlator ä¸­çš„ LuaObjectPool ä¸­\nå½“ Lua è°ƒç”¨ C# æ–¹æ³•çš„æ—¶å€™ï¼ŒC# éœ€è¦è·å¾—å¯¹è±¡çš„å®ä¾‹ã€‚é€šè¿‡è°ƒç”¨ C API tolua_rawnetobjï¼Œä» Lua è°ƒç”¨æ ˆä¸­æ‹¿åˆ° userdata çš„å€¼ï¼Œä¹Ÿå°±æ˜¯å‰é¢è¯´çš„ LuaObjectPool ä¸­ç¼“å­˜çš„ç´¢å¼•å€¼ï¼Œæ ¹æ®è¿™ä¸ªç´¢å¼•å€¼ä» ObjectTranslator ä¸­æ‹¿å›ç¼“å­˜çš„ C# å¯¹è±¡\nC# æ‰§è¡Œ Lua ä»£ç  C# ä» Lua è·å–çš„å¯¹è±¡ä¸»è¦æ˜¯ Lua æ–¹æ³•å’Œtableã€‚è·å– Lua æ–¹æ³•ä¸€èˆ¬éƒ½æ˜¯ Lua è¿™è¾¹ç»‘å®šä¸€ä¸ªæ–¹æ³•åˆ° C# çš„å§”æ‰˜ã€‚é€šè¿‡CheckDelegate æ–¹æ³•è·å–åˆ° Lua æ–¹æ³•å¯¹è±¡ã€‚è°ƒç”¨ ToLuaFunction ä» Lua æ ˆä¸­è·å–åˆ°æ–¹æ³•å¼•ç”¨å¹¶åˆ›å»ºä¸€ä¸ªå¯¹åº” C# çš„LuaFunction\npublic static LuaFunction ToLuaFunction(IntPtr L, int stackPos){    LuaTypes type = LuaDLL.lua_type(L, stackPos);    if (type == LuaTypes.LUA_TNIL)    {        return null;    }    stackPos = LuaDLL.abs_index(L, stackPos);    LuaDLL.lua_pushvalue(L, stackPos);    int reference = LuaDLL.toluaL_ref(L);    return LuaStatic.GetFunction(L, reference);}\n\nToLuaFunctionä¼šåˆ›å»ºä¸€ä¸ªå½“å‰æ ˆé¡¶çš„å¯¹è±¡çš„å¼•ç”¨å¹¶è¿”å› referenceï¼Œlua_pushvalue æ¥å£è°ƒè¿‡ä¹‹åï¼Œå°† Lua æ–¹æ³•çš„æ ˆç´¢å¼•é‡æ–°å‹æ ˆï¼Œä¹Ÿå°±æ˜¯è¯´åˆ›å»ºçš„å½“å‰æ ˆé¡¶çš„å¼•ç”¨ï¼Œè¿™ä¸ª reference ç°åœ¨æ˜¯æŒ‡å‘çš„æ˜¯ Lua æ–¹æ³•çš„æ ˆç´¢å¼•ã€‚ä¹‹åå†ä»¥è¿™ä¸ª reference è°ƒç”¨ GetFunction æ–¹æ³•ï¼Œè·å–LuaFunction\npublic LuaFunction GetFunction(int reference){    LuaFunction func = TryGetLuaRef(reference) as LuaFunction;    if (func == null)    {        func = new LuaFunction(reference, this);        funcRefMap.Add(reference, new WeakReference(func));        if (LogGC)            Debugger.Log(\"Alloc LuaFunction name , id {0}\", reference);          }    RemoveFromGCList(reference);    return func;}\n\nè‹¥å½“å‰ Lua æ–¹æ³•æ²¡æœ‰ç¼“å­˜ï¼Œè¿™é‡Œå°±ä¼šä»¥è¿™ä¸ª Lua æ–¹æ³•çš„æ ˆç´¢å¼•å¼•ç”¨åˆ›å»ºä¸€ä¸ª LuaFunction å¯¹è±¡ã€‚å¹¶ç¼“å­˜åˆ° funcRefMap ä¸­ã€‚æ³¨æ„è¿™é‡Œç¼“å­˜çš„æ˜¯ LuaFunction çš„å¼±å¼•ç”¨å¯¹è±¡ï¼Œè¿™æ · LuaFunction å¯¹è±¡å°±ä¸ä¼šå› ä¸ºè¢« funcRefMap æŒæœ‰å¼•ç”¨è€Œå¯¼è‡´æ— æ³•è¢« C# GC å›æ”¶ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ª funcRefMap çº¯ç²¹æ˜¯ç”¨æ¥åšä¸€ä¸ªç¼“å­˜ï¼Œé¿å…åŒä¸€ä¸ª LuaFunction çš„åå¤åˆ›å»ºç”¨ï¼Œä¸ä¼šå¹²æ‰° LuaFunction çš„å†…å­˜é‡Šæ”¾ã€‚\nGC çš„å¤„ç†  å½“ Lua ä» C# è·å–ä¸€ä¸ªå¯¹è±¡çš„æ—¶å€™ï¼ŒC# ä¼šæŠŠè¿™ä¸ªå¯¹è±¡ç¼“å­˜åˆ° ObjectTranslator ä¸­çš„ LuaObjectPool ä¸­ï¼Œä»è€Œå®ç° C# ç«¯å¯ä»¥æ ¹æ® Lua ä¼ é€’çš„ Wrap å¯¹åº”çš„ userdata æ‹¿å›å¯¹åº”çš„ C# å¯¹è±¡ã€‚å¹¶ä¸”ä¹Ÿä¿è¯äº†å½“ Lua ç«¯æŒæœ‰ userdata å¼•ç”¨çš„æ—¶å€™ C# å¯¹è±¡ä¸ä¼šå› ä¸ºåœ¨ C# ç«¯æ— å…¶å®ƒå¼•ç”¨è€Œè¢« C# GC å›æ”¶æ‰ã€‚ç¼“å­˜åœ¨ ObjectPool ä¸­çš„å¼•ç”¨å°†ä¼šåœ¨ lua ç«¯ GC æ¸…ç†äº† userdata ä¹‹åï¼Œç”± userdata çš„å…ƒæ–¹æ³• __gc è§¦å‘ç§»é™¤ç¼“å­˜ï¼Œä»è€Œé‡Šæ”¾ C# å¯¹è±¡çš„å†…å­˜\nå½“ C# è·å–ä¸€ä¸ª Lua å¯¹è±¡çš„æ—¶å€™ï¼Œ å°†ä¼šåœ¨ C# ç«¯å»ºç«‹ä¸€ä¸ª LuaBaseRef å¯¹è±¡ï¼Œå¹¶è°ƒç”¨ C API åœ¨ Lua ç«¯åˆ›å»ºä¸€ä¸ªå¯¹è±¡å¼•ç”¨ï¼Œå¹¶æŒæœ‰åœ¨ C ç¯å¢ƒï¼Œä»è€Œä¿è¯äº†åœ¨ C# ç«¯æŒæœ‰ Lua å¯¹è±¡çš„æ—¶å€™ï¼ŒLua å¯¹è±¡ä¸ä¼šå› ä¸ºåœ¨ Lua ç«¯æ— å…¶å®ƒå¼•ç”¨è€Œè¢« Lua GC å›æ”¶æ‰ã€‚ C API åˆ›å»ºçš„å¼•ç”¨å°†åœ¨ C# ç«¯ GC æ¸…ç†äº† LuaBaseRef å¼•ç”¨æˆ–æ‰‹åŠ¨è°ƒç”¨ Dispose() æ–¹æ³•ä¹‹åè§£é™¤ï¼Œä»è€Œé‡Šæ”¾ Lua å¯¹è±¡çš„å†…å­˜\næ³Šæ¾  ç¬”è¯• #include &lt;xxx.h&gt;å’Œ #include \"xxx.h\" æœ‰ä»€ä¹ˆå·®åˆ«\nç”¨å¼•å·ï¼Œä»£è¡¨ç¼–è¯‘ç¨‹åºä¼šä¼˜å…ˆåœ¨ç¨‹åºçš„æœ¬åœ°ç›®å½•æœç´¢è¿™ä¸ªæ–‡ä»¶ï¼Œæ‰¾ä¸åˆ°å†æœç´¢ç³»ç»Ÿç›®å½•\nç”¨å°–æ‹¬å·ï¼Œä»£è¡¨ç¼–è¯‘ç¨‹åºåªä¼šåœ¨ç³»ç»Ÿç›®å½•ï¼ˆç³»ç»Ÿç¯å¢ƒå˜é‡å’Œç¼–è¯‘æœ¬èº«è®¾ç½®çš„é»˜è®¤æœç´¢ç›®å½•ï¼‰æœç´¢è¿™ä¸ªæ–‡ä»¶\n\nè¢« static ä¿®é¥°çš„å˜é‡ / å‡½æ•°æœ‰ä»€ä¹ˆä½œç”¨\nä¿®é¥°å˜é‡\nå±€éƒ¨å˜é‡\né™æ€å±€éƒ¨å˜é‡ä¿å­˜åœ¨å…¨å±€æ•°æ®åŒºï¼ˆé™æ€å­˜å‚¨åŒºï¼‰ï¼Œè€Œä¸æ˜¯ä¿å­˜åœ¨æ ˆä¸­ï¼Œæ¯æ¬¡çš„å€¼ä¿æŒåˆ°ä¸‹ä¸€æ¬¡è°ƒç”¨ï¼Œç›´åˆ°ä¸‹ä¸€æ¬¡èµ‹æ–°å€¼\né™æ€å±€éƒ¨å˜é‡å€¼åˆå§‹åŒ–ä¸€æ¬¡ï¼›è‹¥ä¸èµ‹åˆå€¼ï¼Œåœ¨åˆå§‹åŒ–çš„æ—¶å€™ä¼šè‡ªåŠ¨èµ‹å€¼ä¸º 0ï¼›åªå¯¹å®šä¹‰è‡ªå·±çš„å‡½æ•°ä½“å§‹ç»ˆå¯è§ï¼›æŠŠå±€éƒ¨å˜é‡æ”¹å˜ä¸ºé™æ€å˜é‡æ˜¯æ”¹å˜äº†ä»–çš„å­˜å‚¨æ–¹å¼å³æ”¹å˜äº†ä»–çš„ç”Ÿå­˜å‘¨æœŸ\n\n\nå…¨å±€å˜é‡\nå…¨å±€å˜é‡æœ¬èº«å°±æ˜¯é™æ€å­˜å‚¨æ–¹å¼ï¼Œ é™æ€å…¨å±€å˜é‡å½“ç„¶ä¹Ÿæ˜¯é™æ€å­˜å‚¨æ–¹å¼ã€‚ è¿™ä¸¤è€…åœ¨å­˜å‚¨æ–¹å¼ä¸Šå¹¶æ— ä¸åŒ\nä¸¤è€…çš„åŒºåˆ«åœ¨äºéé™æ€å…¨å±€å˜é‡çš„ä½œç”¨åŸŸæ˜¯æ•´ä¸ªæºç¨‹åºï¼Œ å½“ä¸€ä¸ªæºç¨‹åºç”±å¤šä¸ªæºæ–‡ä»¶ç»„æˆæ—¶ï¼Œéé™æ€çš„å…¨å±€å˜é‡åœ¨å„ä¸ªæºæ–‡ä»¶ä¸­éƒ½æ˜¯æœ‰æ•ˆçš„\né™æ€å…¨å±€å˜é‡åˆ™é™åˆ¶äº†å…¶ä½œç”¨åŸŸï¼Œ å³åªåœ¨å®šä¹‰è¯¥å˜é‡çš„æºæ–‡ä»¶å†…æœ‰æ•ˆï¼Œ åœ¨åŒä¸€æºç¨‹åºçš„å…¶å®ƒæºæ–‡ä»¶ä¸­ä¸èƒ½ä½¿ç”¨å®ƒ\n\n\n\n\nä¿®é¥°å‡½æ•°\nå¦‚æœè¿™ä¸ªé™æ€å‡½æ•°å‡ºç°åœ¨ç±»é‡Œï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªé™æ€æˆå‘˜å‡½æ•°ï¼Œè°ƒç”¨è¿™ä¸ªå‡½æ•°ä¸ä¼šè®¿é—®æˆ–è€…ä¿®æ”¹ä»»ä½•å¯¹è±¡ï¼ˆéstaticï¼‰æ•°æ®æˆå‘˜\nå¦‚æœå®ƒä¸æ˜¯å‡ºç°åœ¨ç±»ä¸­ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªæ™®é€šçš„å…¨å±€çš„é™æ€å‡½æ•°ã€‚ç”¨ static ä¿®é¥°çš„å‡½æ•°ï¼Œé™å®šåœ¨æœ¬æºç æ–‡ä»¶ä¸­ï¼Œä¸èƒ½è¢«æœ¬æºç æ–‡ä»¶ä»¥å¤–çš„ä»£ç æ–‡ä»¶è°ƒç”¨ã€‚è€Œæ™®é€šçš„å‡½æ•°ï¼Œé»˜è®¤æ˜¯ extern çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒå¯ä»¥è¢«å…¶å®ƒä»£ç æ–‡ä»¶è°ƒç”¨\n\n\n\nåœ¨ C++ å·¥ç¨‹é‡Œé¢å¼•å…¥ C è¯­è¨€åº“çš„æ—¶å€™ä¸ºä»€ä¹ˆè¦ç”¨â€extern Câ€ç”±äº C å’Œ C++ ç¼–è¯‘å™¨å¯¹å‡½æ•°çš„ç¼–è¯‘å¤„ç†æ˜¯ä¸å®Œå…¨ç›¸åŒçš„ï¼Œå°¤å…¶å¯¹äº C++ æ¥è¯´ï¼Œæ”¯æŒå‡½æ•°çš„é‡è½½ï¼Œç¼–è¯‘åçš„å‡½æ•°ä¸€èˆ¬æ˜¯ä»¥å‡½æ•°åå’Œå½¢å‚ç±»å‹æ¥å‘½åçš„\nä¾‹å¦‚å‡½æ•° void fun(int, int) ç¼–è¯‘åçš„å¯èƒ½æ˜¯ _fun_int_int ä¸åŒç¼–è¯‘å™¨å¯èƒ½ä¸åŒï¼Œä½†éƒ½é‡‡ç”¨äº†ç›¸ä¼¼æœºåˆ¶ï¼Œç”¨å‡½æ•°åå’Œå‚æ•°ç±»å‹æ¥å‘½åç¼–è¯‘åçš„å‡½æ•°åï¼›è€Œ C è¯­è¨€æ²¡æœ‰ç±»ä¼¼çš„é‡è½½æœºåˆ¶ï¼Œä¸€èˆ¬æ˜¯åˆ©ç”¨å‡½æ•°åæ¥æŒ‡æ˜ç¼–è¯‘åçš„å‡½æ•°åçš„ï¼Œå¯¹åº”ä¸Šé¢çš„å‡½æ•°å¯èƒ½ä¼šæ˜¯ _fun è¿™æ ·çš„åå­—\nè¯´å‡º const çš„ä½œç”¨\nä¿®é¥°å˜é‡\nå½“ const ä¿®é¥°å˜é‡æ—¶ï¼Œè¯¥å˜é‡å°†è¢«è§†ä¸ºåªè¯»å˜é‡ï¼Œå³ä¸èƒ½è¢«ä¿®æ”¹\n\n\nä¿®é¥°å‡½æ•°å‚æ•°ï¼Œè¡¨ç¤ºå‡½æ•°ä¸ä¼šä¿®æ”¹å‚æ•°\nä¿®é¥°å‡½æ•°è¿”å›å€¼\nconstä¿®é¥°å‡½æ•°è¿”å›å€¼æ—¶ï¼Œè¡¨ç¤ºå‡½æ•°çš„è¿”å›å€¼ä¸ºåªè¯»ï¼Œä¸èƒ½è¢«ä¿®æ”¹ã€‚è¿™æ ·åšå¯ä»¥ä½¿å‡½æ•°è¿”å›çš„å€¼æ›´åŠ å®‰å…¨ï¼Œé¿å…è¢«è¯¯ä¿®æ”¹\n\n\nä¿®é¥°æŒ‡é’ˆæˆ–å¼•ç”¨\næŒ‡å‘åªè¯»å˜é‡çš„æŒ‡é’ˆ\nåªè¯»æŒ‡é’ˆ\nåªè¯»æŒ‡é’ˆæŒ‡å‘åªè¯»å˜é‡\nå¸¸é‡å¼•ç”¨\n\n\nä¿®é¥°æˆå‘˜å‡½æ•°\nå½“ const ä¿®é¥°æˆå‘˜å‡½æ•°æ—¶ï¼Œè¡¨ç¤ºè¯¥å‡½æ•°ä¸ä¼šä¿®æ”¹å¯¹è±¡çš„çŠ¶æ€ï¼ˆå°±æ˜¯ä¸ä¼šä¿®æ”¹æˆå‘˜å˜é‡ï¼‰\n\n\n\nå­—ç¬¦ä¸²æ‹·è´å‡½æ•°çš„å½¢å¼æ˜¯ char* strcpy(char* dst, const char* src) è¯·ç¼–å†™é€»è¾‘å®ç°ï¼Œå¹¶è¯´æ˜ä¸ºä»€ä¹ˆè¦è¿”å› char* ç±»å‹char* strcpy(char* dst, const char* src){    assert((dst != nullptr) &amp;&amp; src != nullptr);    char* res = dst;    while ((&amp;dst++ = *src++ != '\\0'))    {    }    return res;}\n\nä¸ºäº†å®ç°é“¾å¼è¡¨è¾¾å¼int length = strlen(strcpy(dst, \"xxxxx\"));\nc++ å·¥ç¨‹ä½¿ç”¨åŠ¨æ€é“¾æ¥åº“ï¼Œæœ€åä¸€æ­¥è¿æ¥çš„æ—¶å€™æç¤ºæ‰¾ä¸åˆ°ç¬¦å·\né“¾æ¥æ—¶ç¼ºå¤±äº†ç›¸å…³ç›®æ ‡æ–‡ä»¶ï¼ˆ.oï¼‰\né“¾æ¥æ—¶ç¼ºå°‘ç›¸å…³çš„åº“æ–‡ä»¶ï¼ˆ.a/.soï¼‰\né“¾æ¥çš„åº“æ–‡ä»¶ä¸­åˆä½¿ç”¨äº†å¦ä¸€ä¸ªåº“æ–‡ä»¶\nå¤šä¸ªåº“æ–‡ä»¶é“¾æ¥é¡ºåºé—®é¢˜\nå®šä¹‰ä¸å®ç°ä¸ä¸€è‡´\nåœ¨ c++ ä»£ç ä¸­é“¾æ¥ c è¯­è¨€çš„åº“\nC++ ä¸­ç±»ä¸­é™æ€å˜é‡æ²¡æœ‰åœ¨ç±»å¤–åˆå§‹åŒ–\ninlineå‡½æ•°\nGCC çš„ visibility å±æ€§éšè—\n\nå¼‚å¸¸ä¼šè·¨çº¿ç¨‹å—C++ ä¸»çº¿ç¨‹æ— æ³•æ•è·å­çº¿ç¨‹å¼‚å¸¸\n\nåœ¨ä¸»çº¿ç¨‹ä¸­å£°æ˜ä¸€ä¸ªå˜é‡ï¼Œå°†è¯¥å˜é‡ä¼ é€’åˆ°å­çº¿ç¨‹ä¸­\nåœ¨å­çº¿ç¨‹æŠ›å‡ºå¼‚å¸¸çš„æ—¶å€™ï¼Œä¿®æ”¹å˜é‡çš„å€¼ä¸ºå¼‚å¸¸å€¼\nç„¶ååœ¨ä¸»çº¿ç¨‹ä¸­æ•è·å¼‚å¸¸\n\nåœ¨ä¸»çº¿ç¨‹ä¸­å£°æ˜äº†ä¸€ä¸ª std::promiss&lt;void&gt; ç±»å‹çš„å˜é‡ï¼Œå¹¶ä¼ é€’åˆ°å­çº¿ç¨‹ä¸­ï¼Œç„¶ååœ¨å­çº¿ç¨‹ä¸­ä½¿ç”¨ try catch è¯­å¥æ•è·å¼‚å¸¸ç„¶åè®¾ç½®ç»™ std::promise&lt;void&gt; å˜é‡ï¼›è€Œåœ¨ä¸»çº¿ç¨‹ä¸­æˆ‘ä»¬ä½¿ç”¨ std::future è·å–åˆ° std::promise çš„futureï¼Œç„¶åä½¿ç”¨ try catch æˆåŠŸæ•æ‰åˆ°è®¾ç½®åˆ° std::promise&lt;void&gt; å˜é‡ä¸­çš„å¼‚å¸¸\nä»¥ä¸‹ä»£ç æœ‰ä»€ä¹ˆé—®é¢˜void getMemory(char** p, int num) {    *p = (char*)malloc(num);}void testMethod() {    char* src=NULL;    getMemory(&amp;src, 100);    strcpy(src, \"hello\");    print(src);}\n\nvoid func() {    std::vector&lt;int&gt; arr = {1,2,3,4,5,6};    for (auto it = arr.begin(); it!=arr.end(); ++it) {        if (*it &gt; 2) {            arr.erase(it);        }    }    for (auto it = arr.begin(); it!=arr.end(); ++it) {        std::cout &lt;&lt;*it &lt;&lt;std::endl;    }}\n\n\nä»¥ä¸Šä»£ç æœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿ\nåº”è¯¥æ€ä¹ˆä¿®æ”¹ï¼Ÿ\nè¿˜æœ‰å…¶ä»–ç±»å‹æ•°æ®ç»“æ„ä¼šå‡ºæ­¤ç±»é—®é¢˜å—ï¼Ÿ\nå‡ºç°ä¸Šè¿°é—®é¢˜çš„æœ¬è´¨æ˜¯ä»€ä¹ˆï¼Ÿ\n\nvector è¿­ä»£å™¨å¤±æ•ˆ\nå½“å®¹å™¨è°ƒç”¨ erase() æ–¹æ³•åï¼Œå½“å‰ä½ç½®åˆ°å®¹å™¨æœ«å°¾å…ƒç´ çš„æ‰€æœ‰è¿­ä»£å™¨å…¨éƒ¨å¤±æ•ˆã€‚\nå½“å®¹å™¨è°ƒç”¨ insert() æ–¹æ³•åï¼Œå½“å‰ä½ç½®åˆ°å®¹å™¨æœ«å°¾å…ƒç´ çš„æ‰€æœ‰è¿­ä»£å™¨å…¨éƒ¨å¤±æ•ˆã€‚\nå¦‚æœå®¹å™¨æ‰©å®¹ï¼Œåœ¨å…¶ä»–åœ°æ–¹é‡æ–°åˆå¼€è¾Ÿäº†ä¸€å—å†…å­˜ã€‚åŸæ¥å®¹å™¨åº•å±‚çš„å†…å­˜ä¸Šæ‰€ä¿å­˜çš„è¿­ä»£å™¨å…¨éƒ½å¤±æ•ˆäº†ã€‚\n\nç¼–è¯‘  ç¼–è¯‘æµç¨‹  é¢„å¤„ç† Preprocessingåœ¨ç¼–è¯‘å™¨å¼€å§‹ç¼–è¯‘ä¹‹å‰ï¼Œä¼šå…ˆè¿›è¡Œé¢„å¤„ç†ã€‚é¢„å¤„ç†å™¨ä¼šå¤„ç†ä»£ç ä¸­çš„æ‰€æœ‰é¢„å¤„ç†æŒ‡ä»¤ï¼Œä¾‹å¦‚ #include å’Œ #define ç­‰ã€‚å®ƒä¼šå°†è¿™äº›æŒ‡ä»¤æ›¿æ¢æˆå¯¹åº”çš„ä»£ç ï¼Œç”Ÿæˆä¸€ä¸ªæ–°çš„æ–‡æœ¬æ–‡ä»¶ã€‚è¿™ä¸ªæ–°çš„æ–‡æœ¬æ–‡ä»¶å°±æ˜¯ç¼–è¯‘å™¨çš„è¾“å…¥ã€‚åœ¨é¢„å¤„ç†çš„è¿‡ç¨‹ä¸­ï¼Œè¿˜ä¼šè¿›è¡Œæ¡ä»¶ç¼–è¯‘ï¼Œå³æ ¹æ®æ¡ä»¶æ¥é€‰æ‹©æ˜¯å¦ç¼–è¯‘æŸäº›ä»£ç å—ã€‚é¢„å¤„ç†å®Œæˆåï¼Œä¼šç”Ÿæˆä¸€ä¸ªæ²¡æœ‰å®å®šä¹‰å’Œæ¡ä»¶ç¼–è¯‘çš„ä¸­é—´æ–‡ä»¶\né¢„å¤„ç†å™¨çš„ä¸»è¦ä½œç”¨æ˜¯è§£å†³ä»£ç ä¸­çš„å®å®šä¹‰ï¼Œå®ƒä¼šå°†å®å®šä¹‰å±•å¼€æˆå¯¹åº”çš„ä»£ç ã€‚æ­¤å¤–ï¼Œé¢„å¤„ç†å™¨è¿˜ä¼šå¤„ç† #include æŒ‡ä»¤ï¼Œå°†æŒ‡å®šçš„å¤´æ–‡ä»¶æ’å…¥åˆ°æºæ–‡ä»¶ä¸­ï¼Œä»¥ä¾¿è®©ç¼–è¯‘å™¨èƒ½å¤Ÿå¯¹å¤´æ–‡ä»¶ä¸­çš„å‡½æ•°å’Œå˜é‡è¿›è¡Œç¼–è¯‘\n\né¢„å¤„ç†å™¨è¿˜ä¼šåœ¨ä»£ç ä¸­æ’å…¥è®°å·ï¼Œä½¿ç¼–è¯‘å™¨èƒ½åˆ†è¾¨å‡ºæ¯ä¸€è¡Œæ¥è‡ªå“ªä¸ªæ–‡ä»¶ï¼Œä»¥ä¾¿åœ¨è°ƒè¯•è¿‡ç¨‹ä¸­èƒ½ç”Ÿæˆå¯¹åº”çš„é”™è¯¯ä¿¡æ¯\n\nç¼–è¯‘ Compilationç¼–è¯‘å™¨å°†é¢„å¤„ç†åçš„æ–‡ä»¶ä½œä¸ºè¾“å…¥ï¼Œå¯¹å…¶è¿›è¡Œè¯æ³•åˆ†æã€è¯­æ³•åˆ†æå’Œè¯­ä¹‰åˆ†æç­‰å¤„ç†ã€‚è¿™äº›å¤„ç†ä¼šå°†ä»£ç è½¬åŒ–æˆä¸­é—´ä»£ç ï¼Œä¸­é—´ä»£ç æ˜¯ä¸€ç§ç±»ä¼¼äº  æ±‡ç¼–è¯­è¨€  çš„ä½çº§ä»£ç ã€‚ç¼–è¯‘å™¨å°†ä»£ç åˆ†æˆå¤šä¸ªæ¨¡å—ï¼Œæ¯ä¸ªæ¨¡å—ç¼–è¯‘æˆä¸€ä¸ªå¯¹è±¡æ–‡ä»¶ã€‚åœ¨ç¼–è¯‘çš„è¿‡ç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šå¯¹ä»£ç è¿›è¡Œä¼˜åŒ–ï¼Œä»¥æé«˜ç¨‹åºçš„è¿è¡Œæ•ˆç‡å’ŒèŠ‚çœå†…å­˜ç©ºé—´\næ±‡ç¼– Assemblyä¸­é—´ä»£ç ä¼šè¢«æ±‡ç¼–å™¨è½¬åŒ–æˆæœºå™¨è¯­è¨€æŒ‡ä»¤ï¼Œè¿™äº›æŒ‡ä»¤å¯ä»¥è¢«è®¡ç®—æœºç›´æ¥æ‰§è¡Œã€‚æ±‡ç¼–çš„è¿‡ç¨‹å°†æ¯ä¸ªå¯¹è±¡æ–‡ä»¶è½¬æ¢æˆæœºå™¨è¯­è¨€çš„ç›®æ ‡æ–‡ä»¶ã€‚æ¯ä¸ªç›®æ ‡æ–‡ä»¶åŒ…å«æœºå™¨æŒ‡ä»¤å’Œæ•°æ®ï¼Œä»¥åŠå…¶ä»–çš„æ§åˆ¶ä¿¡æ¯ã€‚ç›®æ ‡æ–‡ä»¶å¯ä»¥è¢«é“¾æ¥å™¨ç”¨äºæ„å»ºå¯æ‰§è¡Œæ–‡ä»¶\né“¾æ¥ Linkingåœ¨ç¼–è¯‘è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½ä¼šç”¨åˆ°å…¶ä»–çš„åº“æ–‡ä»¶å’Œå¯¹è±¡æ–‡ä»¶ã€‚é“¾æ¥å™¨ä¼šå°†è¿™äº›æ–‡ä»¶ä¸ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶è¿›è¡Œé“¾æ¥ï¼Œç”Ÿæˆæœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚é“¾æ¥å™¨çš„ä¸»è¦ä»»åŠ¡æ˜¯è§£å†³ç¬¦å·å¼•ç”¨é—®é¢˜ï¼Œå³é€šè¿‡åœ¨ä¸åŒçš„ç›®æ ‡æ–‡ä»¶ä¸­æŸ¥æ‰¾ç¬¦å·çš„å®šä¹‰ï¼Œä½¿å¾—æ‰€æœ‰çš„ç¬¦å·éƒ½èƒ½å¤Ÿæ­£ç¡®åœ°è¢«è§£æå’Œé“¾æ¥ã€‚é“¾æ¥å™¨è¿˜ä¼šå¯¹ä»£ç è¿›è¡Œä¼˜åŒ–å’Œå‹ç¼©ï¼Œä»¥å‡å°å¯æ‰§è¡Œæ–‡ä»¶çš„ä½“ç§¯ï¼Œå¹¶æé«˜ç¨‹åºçš„è¿è¡Œæ•ˆç‡\né™æ€é“¾æ¥å’ŒåŠ¨æ€é“¾æ¥  é“¾æ¥è¿‡ç¨‹ä¸»è¦åŒ…å«äº†ä¸‰ä¸ªæ­¥éª¤\n\nåœ°å€ä¸ç©ºé—´åˆ†é… Address and Storage Allocation\nç¬¦å·è§£æ Symbol Resolution\né‡å®šä½ Relocation\n\nä¸¤æ­¥é“¾æ¥ï¼ˆTwo-pass Linkingï¼‰çš„æ–¹æ³•\n\nåœ°å€ä¸ç©ºé—´åˆ†é…\næ‰«ææ‰€æœ‰çš„è¾“å…¥ç›®æ ‡æ–‡ä»¶ï¼Œè·å¾—å®ƒä»¬çš„å„ä¸ªèŠ‚çš„é•¿åº¦ã€å±æ€§ã€ä½ç½®ï¼Œå¹¶å°†è¾“å…¥ç›®æ ‡æ–‡ä»¶ä¸­çš„ç¬¦å·è¡¨ä¸­æ‰€æœ‰çš„ç¬¦å·å®šä¹‰å’Œç¬¦å·å¼•ç”¨æ”¶é›†èµ·æ¥ï¼Œç»Ÿä¸€æ”¾åˆ°ä¸€ä¸ªå…¨å±€çš„ç¬¦å·è¡¨ã€‚è¿™ä¸€æ­¥ï¼Œé“¾æ¥å™¨èƒ½å¤Ÿè·å¾—æ‰€æœ‰è¾“å…¥ç›®æ ‡æ–‡ä»¶çš„èŠ‚çš„é•¿åº¦ï¼Œå¹¶å°†å®ƒä»¬åˆå¹¶ï¼Œè®¡ç®—å‡ºè¾“å‡ºæ–‡ä»¶ä¸­å„ä¸ªèŠ‚åˆå¹¶åçš„é•¿åº¦ä¸ä½ç½®ï¼Œå¹¶å»ºç«‹æ˜ å°„å…³ç³»\n\n\nç¬¦å·è§£æä¸é‡å®šä½\nä½¿ç”¨å‰ä¸€æ­¥ä¸­æ”¶é›†åˆ°çš„æ‰€æœ‰ä¿¡æ¯ï¼Œè¯»å–è¾“å…¥æ–‡ä»¶ä¸­èŠ‚çš„è¾“æ•°æ®ã€é‡å®šä½ä¿¡æ¯ï¼Œå¹¶ä¸”è¿›è¡Œç¬¦å·è§£æä¸é‡å®šä½ã€è°ƒæ•´ä»£ç ã€è°ƒæ•´ä»£ç ä¸­çš„åœ°å€ç­‰ã€‚äº‹å®ä¸Šï¼Œç¬¬äºŒæ­¥æ˜¯é“¾æ¥è¿‡ç¨‹çš„æ ¸å¿ƒï¼Œå°¤å…¶æ˜¯é‡å®šä½\n\n\n\n\n    \n\n\nåœ°å€ä¸ç©ºé—´åˆ†é…  å¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ segment æ˜¯ç”±ç›®æ ‡æ–‡ä»¶ä¸­çš„ section åˆå¹¶è€Œæ¥çš„ï¼Œå¯¹äºå¤šä¸ªè¾“å…¥ç›®æ ‡æ–‡ä»¶ï¼Œé“¾æ¥å™¨å¦‚ä½•å°†å®ƒä»¬çš„å„ä¸ª section åˆå¹¶åˆ°è¾“å‡ºæ–‡ä»¶å‘¢ï¼Ÿæˆ–è€…è¯´ï¼Œè¾“å‡ºæ–‡ä»¶ä¸­çš„ç©ºé—´å¦‚ä½•åˆ†é…ç»™è¾“å…¥æ–‡ä»¶\næŒ‰åºå åŠ \n    \n\n\n\nç„¶è¿™ç§æ–¹æ³•éå¸¸ç®€å•ï¼Œä½†æ˜¯å®ƒå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼šåœ¨æœ‰å¾ˆå¤šè¾“å…¥æ–‡ä»¶çš„æƒ…å†µä¸‹ï¼Œè¾“å‡ºæ–‡ä»¶ä¼šæœ‰å¾ˆå¤šé›¶æ•£çš„èŠ‚ã€‚è¿™ç§åšæ³•éå¸¸æµªè´¹ç©ºé—´ï¼Œå› ä¸ºæ¯ä¸ªèŠ‚éƒ½éœ€è¦æœ‰ä¸€å®šçš„åœ°å€å’Œç©ºé—´å¯¹é½è¦æ±‚ã€‚x86 ç¡¬ä»¶çš„å¯¹é½è¦æ±‚æ˜¯ 4KBã€‚å¦‚æœä¸€ä¸ªèŠ‚çš„å¤§å°åªæœ‰ 1 ä¸ªå­—èŠ‚ï¼Œå®ƒä¹Ÿè¦åœ¨å†…å­˜åœ¨é‡ç”¨ 4KBã€‚è¿™æ ·ä¼šé€ æˆå¤§é‡å†…éƒ¨ç¢ç‰‡ã€‚æ‰€ä»¥ä¸æ˜¯ä¸€ä¸ªå¥½çš„æ–¹æ¡ˆ\n\nåˆå¹¶ç›¸ä¼¼èŠ‚  ä¸€ä¸ªæ›´åŠ å®é™…çš„æ–¹æ³•ä¾¿æ˜¯åˆå¹¶ç›¸åŒæ€§è´¨çš„ sectionï¼Œæ¯”å¦‚ï¼šå°†æ‰€æœ‰è¾“å…¥æ–‡ä»¶çš„.text section åˆå¹¶åˆ°è¾“å‡ºæ–‡ä»¶çš„ text segment\n\n    \n\n\nå…¶ä¸­ .bss èŠ‚åœ¨ç›®æ ‡æ–‡ä»¶å’Œå¯æ‰§è¡Œæ–‡ä»¶ä¸­ä¸å ç”¨æ–‡ä»¶çš„ç©ºé—´ï¼Œä½†æ˜¯å®ƒåœ¨è£…è½½æ—¶å ç”¨åœ°å€ç©ºé—´ã€‚äº‹å®ä¸Šï¼Œè¿™é‡Œçš„ç©ºé—´å’Œåœ°å€æœ‰ä¸¤å±‚å«ä¹‰ï¼š\n\nåœ¨è¾“å‡ºçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­çš„ç©ºé—´\nåœ¨è£…è½½åçš„è™šæ‹Ÿåœ°å€ä¸­çš„ç©ºé—´\n\nå¯¹äºæœ‰å®é™…æ•°æ®çš„èŠ‚ï¼Œå¦‚ .text å’Œ.dataï¼Œå®ƒä»¬åœ¨æ–‡ä»¶ä¸­å’Œè™šæ‹Ÿåœ°å€ä¸­éƒ½è¦åˆ†é…ç©ºé—´ï¼Œå› ä¸ºå®ƒä»¬åœ¨è¿™ä¸¤è€…ä¸­éƒ½å­˜åœ¨ï¼›å¯¹äº .bss æ¥ï¼Œåˆ†é…ç©ºé—´çš„æ„ä¹‰åªå±€é™äºè™šæ‹Ÿåœ°å€ç©ºé—´ï¼Œå› ä¸ºå®ƒåœ¨æ–‡ä»¶ä¸­å¹¶æ²¡æœ‰å†…å®¹ã€‚è¿™é‡Œçš„ç©ºé—´åˆ†é…åªå…³æ³¨äºè™šæ‹Ÿåœ°å€ç©ºé—´çš„åˆ†é…ï¼Œå› ä¸ºè¿™å…³ç³»åˆ°é“¾æ¥å™¨åé¢çš„å…³äºåœ°å€è®¡ç®—çš„æ­¥éª¤ï¼Œè€Œå¯æ‰§è¡Œæ–‡ä»¶æœ¬èº«çš„ç©ºé—´åˆ†é…ä¸é“¾æ¥çš„å…³ç³»å¹¶ä¸å¤§\nåœ¨åœ°å€ä¸ç©ºé—´åˆ†é…æ­¥éª¤å®Œæˆä¹‹åï¼Œç›¸ä¼¼æƒé™çš„èŠ‚ä¼šè¢«åˆå¹¶æˆæ®µï¼Œå¹¶ç”Ÿæˆäº†ç¨‹åºå¤´è¡¨ï¼ˆProgram Header Tableï¼‰ç»“æ„\n\n    \n\n\né“¾æ¥å‰ç›®æ ‡æ–‡ä»¶ä¸­æ‰€æœ‰èŠ‚çš„ VMAï¼ˆVirtual Memory Addressï¼‰éƒ½æ˜¯ 0ï¼Œå› ä¸ºè™šæ‹Ÿç©ºé—´è¿˜æ²¡æœ‰åˆ†é…ã€‚é“¾æ¥åï¼Œå¯æ‰§è¡Œæ–‡ä»¶ä¸­å„ä¸ª section è¢«åˆ†é…åˆ°äº†ç›¸åº”çš„è™šæ‹Ÿåœ°å€ã€‚åœ¨ Linux x86-64 ç³»ç»Ÿä¸­ï¼Œä»£ç æ®µæ€»æ˜¯ä» 0x0000000000400000 å¼€å§‹çš„ï¼Œå¦å¤– .text section ä¹‹å‰è¿˜æœ‰ELF Headerã€Program Header Tableã€.init ç­‰å ç”¨äº†ä¸€å®šçš„ç©ºé—´ï¼Œæ‰€ä»¥ä»£ç æ®µçš„åœ°å€ä¸æ˜¯ä» 0x0000000000400000 å¼€å§‹çš„\nç¬¦å·è§£æ  é“¾æ¥å™¨è§£æç¬¦å·å¼•ç”¨çš„æ–¹æ³•æ˜¯å°†æ¯ä¸ªå¼•ç”¨ä¸å®ƒè¾“å…¥çš„å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶çš„ç¬¦å·è¡¨ä¸­çš„ä¸€ä¸ªç¡®å®šçš„ç¬¦å·å®šä¹‰å…³è”èµ·æ¥ã€‚å¯¹é‚£äº›å’Œå¼•ç”¨å®šä¹‰åœ¨ç›¸åŒæ¨¡å—çš„å±€éƒ¨ç¬¦å·çš„å¼•ç”¨ï¼Œç¬¦å·è§£ææ˜¯éå¸¸ç®€å•çš„ã€‚ç¼–è¯‘å™¨åªå…è®¸æ¯ä¸ªæ¨¡å—ä¸­æ¯ä¸ªå±€éƒ¨ç¬¦å·æœ‰ä¸€ä¸ªå®šä¹‰ã€‚é™æ€å±€éƒ¨å˜é‡ä¹Ÿä¼šæœ‰æœ¬åœ°é“¾æ¥å™¨ç¬¦å·ï¼Œç¼–è¯‘å™¨è¿˜è¦ç¡®ä¿å®ƒä»¬æ‹¥æœ‰å”¯ä¸€çš„åå­—\nç„¶è€Œï¼Œå¯¹äºå…¨å±€ç¬¦å·çš„è§£æè¦å¤æ‚å¾—å¤šã€‚å½“ç¼–è¯‘å™¨é‡åˆ°ä¸€ä¸ªä¸æ˜¯åœ¨å½“å‰æ¨¡å—ä¸­å®šä¹‰çš„ç¬¦å·ï¼ˆå˜é‡æˆ–å‡½æ•°åï¼‰æ—¶ï¼Œä¼šå‡è®¾è¯¥ç¬¦å·æ˜¯åœ¨å…¶ä»–æŸä¸ªæ¨¡å—ä¸­å®šä¹‰çš„ï¼Œç”Ÿæˆä¸€ä¸ªé“¾æ¥å™¨ç¬¦å·è¡¨æ¡ç›®ï¼Œå¹¶æŠŠå®ƒäº¤ç»™é“¾æ¥å™¨å¤„ç†ã€‚å¦‚æœé“¾æ¥å™¨åœ¨å®ƒçš„ä»»ä½•è¾“å…¥æ¨¡å—ä¸­éƒ½æ‰¾ä¸åˆ°è¿™ä¸ªè¢«å¼•ç”¨ç¬¦å·çš„å®šä¹‰ï¼Œå°±è¾“å‡ºä¸€æ¡é”™è¯¯ä¿¡æ¯å¹¶ç»ˆæ­¢\nå¦ä¸€æ–¹é¢ï¼Œå¯¹å…¨å±€ç¬¦å·çš„è§£æï¼Œç»å¸¸ä¼šé¢ä¸´å¤šä¸ªç›®æ ‡æ–‡ä»¶å¯èƒ½ä¼šå®šä¹‰ç›¸åŒåå­—çš„å…¨å±€ç¬¦å·ã€‚è¿™ç§æƒ…å†µä¸‹ï¼Œé“¾æ¥å™¨å¿…é¡»è¦ä¹ˆæ ‡å¿—ä¸€ä¸ªé”™è¯¯ï¼Œè¦ä¹ˆä»¥æŸç§æ–¹æ³•é€‰å‡ºä¸€ä¸ªå®šä¹‰å¹¶æŠ›å¼ƒå…¶ä»–å®šä¹‰\nå¤šé‡å®šä¹‰çš„å…¨å±€ç¬¦å·è§£æ  é“¾æ¥å™¨çš„è¾“å…¥æ˜¯ä¸€ç»„å¯é‡å®šä½ç›®æ ‡æ¨¡å—ã€‚æ¯ä¸ªæ¨¡å—å®šä¹‰ä¸€ç»„ç¬¦å·ï¼Œæœ‰äº›æ˜¯å±€éƒ¨ç¬¦å·ï¼ˆåªå¯¹å®šä¹‰è¯¥ç¬¦å·çš„æ¨¡å—å¯è§ï¼‰ï¼Œæœ‰äº›æ˜¯å…¨å±€ç¬¦å·ï¼ˆå¯¹å…¶ä»–æ¨¡å—ä¹Ÿå¯è§ï¼‰ã€‚å¦‚æœå¤šä¸ªæ¨¡å—å®šä¹‰åŒåçš„å…¨å±€ç¬¦å·ï¼Œè¯¥å¦‚ä½•è¿›è¡Œå–èˆï¼Ÿ\nLinux ç¼–è¯‘ç³»ç»Ÿé‡‡ç”¨å¦‚ä¸‹çš„æ–¹æ³•è§£å†³å¤šé‡å®šä¹‰çš„å…¨å±€ç¬¦å·è§£æï¼š\nåœ¨ç¼–è¯‘æ—¶ï¼Œç¼–è¯‘å™¨æƒ³æ±‡ç¼–å™¨è¾“å‡ºæ¯ä¸ªå…¨å±€ç¬¦å·ï¼Œæˆ–è€…æ˜¯å¼ºï¼ˆstrongï¼‰æˆ–è€…æ˜¯å¼±ï¼ˆweakï¼‰ï¼Œè€Œæ±‡ç¼–å™¨æŠŠè¿™ä¸ªä¿¡æ¯éšå«åœ°ç¼–ç åœ¨å¯é‡å®šä½ç›®æ ‡æ–‡ä»¶çš„ç¬¦å·è¡¨ä¸­ã€‚\næ ¹æ®å¼ºå¼±ç¬¦å·çš„å®šä¹‰ï¼ŒLinux é“¾æ¥å™¨ä½¿ç”¨ä¸‹é¢çš„è§„åˆ™æ¥å¤„ç†å¤šé‡å®šä¹‰çš„ç¬¦å·åï¼š\n\nè§„åˆ™ 1ï¼šä¸å…è®¸æœ‰å¤šä¸ªåŒåçš„å¼ºç¬¦å·\nè§„åˆ™ 2ï¼šå¦‚æœæœ‰ä¸€ä¸ªå¼ºç¬¦å·å’Œå¤šä¸ªå¼±ç¬¦å·åŒåï¼Œåˆ™é€‰æ‹©å¼ºç¬¦å·\nè§„åˆ™ 3ï¼šå¦‚æœæœ‰å¤šä¸ªå¼±ç¬¦å·åŒåï¼Œåˆ™ä»è¿™äº›å¼±ç¬¦å·ä¸­ä»»æ„é€‰æ‹©ä¸€ä¸ª\n\nå¦ä¸€æ–¹é¢ï¼Œç”±äºå…è®¸ä¸€ä¸ªç¬¦å·å®šä¹‰åœ¨å¤šä¸ªæ–‡ä»¶ä¸­ï¼Œæ‰€ä»¥å¯èƒ½ä¼šå¯¼è‡´ä¸€ä¸ªé—®é¢˜ï¼šå¦‚æœä¸€ä¸ªå¼±ç¬¦å·å®šä¹‰åœ¨å¤šä¸ªç›®æ ‡æ–‡ä»¶ä¸­ï¼Œè€Œå®ƒä»¬çš„ç±»å‹ä¸åŒï¼Œæ€ä¹ˆåŠï¼Ÿè¿™ç§æƒ…å†µä¸»è¦æœ‰ä¸‰ç§ï¼š\n\næƒ…å†µ 1ï¼šä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„å¼ºç¬¦å·ç±»å‹ä¸ä¸€è‡´\næƒ…å†µ 2ï¼šæœ‰ä¸€ä¸ªå¼ºç¬¦å·ï¼Œå…¶ä»–éƒ½æ˜¯å¼±ç¬¦å·ï¼Œå‡ºç°ç±»å‹ä¸ä¸€è‡´\næƒ…å†µ 3ï¼šä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šå¼±ç¬¦å·ç±»å‹ä¸ä¸€è‡´\n\nå…¶ä¸­ï¼Œæƒ…å†µ 1 ç”±äºå¤šä¸ªå¼ºç¬¦å·å®šä¹‰æœ¬èº«å°±æ˜¯éæ³•çš„ï¼Œæ‰€ä»¥é“¾æ¥å™¨å°±ä¼šæŠ¥é”™ã€‚å¯¹äºåä¸¤ç§æƒ…å†µï¼Œç¼–è¯‘å™¨å’Œé“¾æ¥å™¨é‡‡ç”¨ä¸€ç§å« COMMON å—ï¼ˆCommon Blockï¼‰çš„æœºåˆ¶æ¥å¤„ç†ã€‚å…¶è¿‡ç¨‹å¦‚ä¸‹ï¼š\né¦–å…ˆï¼Œç¼–è¯‘å™¨å°†æœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡å®šä¹‰ä¸ºå¼±ç¬¦å·å¤„ç†ã€‚å¯¹äºæƒ…å†µ 3ï¼Œæœ€ç»ˆé“¾æ¥æ—¶é€‰æ‹©æœ€å¤§çš„ç±»å‹ã€‚å¯¹äºæƒ…å†µ 2ï¼Œæœ€ç»ˆè¾“å‡ºç»“æœä¸­çš„ç¬¦å·æ‰€å ç©ºé—´ä¸å¼ºç¬¦å·ç›¸åŒï¼Œå¦‚æœé“¾æ¥è¿‡ç¨‹ä¸­æœ‰å¼±ç¬¦å·å¤§äºå¼ºç¬¦å·ï¼Œé“¾æ¥å™¨ä¼šå‘å‡ºè­¦å‘Š\né‡å®šä½  äº‹å®ä¸Šï¼Œé‡å®šä½è¿‡ç¨‹ä¹Ÿä¼´éšç€ç¬¦å·çš„è§£æè¿‡ç¨‹ã€‚é“¾æ¥çš„å‰ä¸¤æ­¥å®Œæˆä¹‹åï¼Œé“¾æ¥å™¨å°±å·²ç»ç¡®å®šæ‰€æœ‰ç¬¦å·çš„è™šæ‹Ÿåœ°å€äº†ï¼Œé‚£ä¹ˆé“¾æ¥å™¨å°±å¯ä»¥æ ¹æ®ç¬¦å·çš„åœ°å€å¯¹æ¯ä¸ªéœ€è¦é‡å®šä½çš„æŒ‡ä»¤è¿›è¡Œåœ°å€ä¿®æ­£ã€‚é“¾æ¥å™¨é€šè¿‡é‡å®šä½è¡¨ï¼ˆRelocation Tableï¼‰ç”¨æ¥å¤„ç†é‡å®šä½ç›¸å…³çš„ä¿¡æ¯\nå¯¹äºå¯é‡å®šä½çš„ ELF æ–‡ä»¶æ¥è¯´ï¼Œå®ƒå¿…é¡»åŒ…å«é‡å®šä½è¡¨ï¼Œç”¨æ¥æè¿°å¦‚ä½•ä¿®æ”¹ç›¸åº”çš„ section çš„å†…å®¹ã€‚å¯¹äºæ¯ä¸ªè¦è¢«é‡å®šä½çš„ ELF section éƒ½æœ‰ä¸€ä¸ªå¯¹åº”çš„é‡å®šä½è¡¨ã€‚å¦‚æœ .text section éœ€è¦è¢«é‡å®šä½ï¼Œåˆ™ä¼šæœ‰ä¸€ä¸ªç›¸å¯¹åº”å«.rel.text çš„ section ä¿å­˜äº†ä»£ç  section çš„é‡å®šä½è¡¨ï¼›å¦‚æœ .data section éœ€è¦è¢«é‡å®šä½ï¼Œåˆ™ä¼šæœ‰ä¸€ä¸ªç›¸å¯¹åº”çš„.rel.tdata çš„ section ä¿å­˜äº†æ•°æ® section çš„é‡å®šä½è¡¨\né™æ€é“¾æ¥  é™æ€é“¾æ¥å°±æ˜¯åœ¨ç¨‹åºè¿è¡Œå‰ï¼Œé“¾æ¥å™¨é€šè¿‡å¯¹è±¡æ–‡ä»¶ä¸­åŒ…å«çš„é‡å®šä½è¡¨ï¼Œå®Œæˆæ‰€æœ‰é‡å®šä½æ“ä½œï¼Œå¹¶æœ€ç»ˆå½¢æˆä¸€ä¸ªåœ¨è¿è¡Œæ—¶ä¸éœ€è¦å†æ¬¡è¿›è¡Œä¾èµ–åº“çš„åŠ è½½å’Œé‡å®šä½æ“ä½œï¼ˆå› ä¸ºæ‰€æœ‰çš„ä¾èµ–åº“åœ¨è¿è¡Œå‰éƒ½è¢«é“¾æ¥åˆ°ç¨‹åºä¸­äº†ï¼‰\nåŠ¨æ€é“¾æ¥  é™æ€é“¾æ¥ä½¿å¾—è¿›è¡Œæ¨¡å—åŒ–å¼€å‘ï¼Œå¤§å¤§æä¾›äº†ç¨‹åºçš„å¼€å‘æ•ˆç‡ã€‚éšç€ï¼Œç¨‹åºè§„æ¨¡çš„æ‰©å¤§ï¼Œé™æ€é“¾æ¥çš„è¯¸å¤šç¼ºç‚¹ä¹Ÿé€æ¸æš´éœ²å‡ºæ¥ï¼Œå¦‚ï¼šæµªè´¹å†…å­˜å’Œç£ç›˜ç©ºé—´ã€æ¨¡å—æ›´æ–°å›°éš¾ç­‰ï¼›å…³äºæ¨¡å—æ›´æ–°ï¼Œé™æ€é“¾æ¥çš„ç¨‹åºæœ‰ä»»ä½•æ›´æ–°ï¼Œéƒ½å¿…é¡»é‡æ–°ç¼–è¯‘é“¾æ¥ï¼Œç”¨æˆ·åˆ™éœ€è¦é‡æ–°ä¸‹è½½å®‰è£…è¯¥ç¨‹åº\nåŠ¨æ€é“¾æ¥æŒ‡çš„æ˜¯ä¸»ç¨‹åºå¯¹åŠ¨æ€å…±äº«åº“æˆ–å¯¹è±¡ä¸­ç¬¦å·çš„å¼•ç”¨ï¼Œæ˜¯ç­‰åˆ°ç¨‹åºè¿è¡Œåå†åŠ è½½å¹¶è¿›è¡Œé‡å®šä½æ“ä½œã€‚ç¨‹åºçš„ä¸»ä½“éƒ¨åˆ†ä¹Ÿç§°ä¸ºä¸»ç¨‹åºè¿˜æ˜¯é™æ€é“¾æ¥çš„ï¼Œè¿™éƒ¨åˆ†é“¾æ¥æ˜¯ä¸ä¼šå°†ä¾èµ–çš„åŠ¨æ€å…±äº«åº“æˆ–å¯¹è±¡é“¾æ¥è¿›ä¸»ç¨‹åºçš„\nåŠ¨æ€é“¾æ¥çš„åŸºæœ¬å®ç°  åŠ¨æ€é“¾æ¥æ¶‰åŠè¿è¡Œæ—¶çš„é“¾æ¥ä»¥åŠå¤šä¸ªæ–‡ä»¶çš„è£…è½½ï¼Œå¿…éœ€è¦æœ‰æ“ä½œç³»ç»Ÿçš„æ”¯æŒã€‚å› ä¸ºåŠ¨æ€é“¾æ¥çš„æƒ…å†µä¸‹ï¼Œè¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´çš„åˆ†å¸ƒä¼šæ¯”é™æ€é“¾æ¥æƒ…å†µä¸‹æ›´ä¸ºå¤æ‚ï¼Œè¿˜æœ‰ä¸€äº›å­˜å‚¨ç®¡ç†ã€å†…å­˜å…±äº«ã€è¿›ç¨‹çº¿ç¨‹ç­‰æœºåˆ¶åœ¨åŠ¨æ€é“¾æ¥ä¸‹ä¹Ÿä¼šæœ‰ä¸€äº›å¾®å¦™çš„å˜åŒ–\nç›®å‰ï¼Œä¸»æµæ“ä½œç³»ç»Ÿéƒ½æ”¯æŒåŠ¨æ€é“¾æ¥ã€‚åœ¨ Linux ä¸­ï¼ŒELF åŠ¨æ€é“¾æ¥æ–‡ä»¶è¢«ç§°ä¸º åŠ¨æ€å…±äº«å¯¹è±¡ï¼ˆDSOï¼ŒDynamic Shared Objectsï¼‰ï¼Œä¸€èˆ¬ä»¥ .so ä¸ºåç¼€ï¼›åœ¨ Windows ä¸­ï¼ŒåŠ¨æ€é“¾æ¥æ–‡ä»¶è¢«ç§°ä¸º åŠ¨æ€é“¾æ¥åº“ï¼ˆDynamic Linking Libraryï¼‰ï¼Œä¸€èˆ¬ä»¥ .dll ä¸ºåç¼€\nåŠ¨æ€é“¾æ¥ç¨‹åºè¿è¡Œæ—¶åœ°å€ç©ºé—´åˆ†å¸ƒ  å¯¹äºé™æ€é“¾æ¥çš„å¯æ‰§è¡Œæ–‡ä»¶æ¥è¯´ï¼Œæ•´ä¸ªè¿›ç¨‹åªæœ‰ä¸€ä¸ªæ–‡ä»¶è¦è¢«æ˜ å°„ï¼Œå³å¯æ‰§è¡Œæ–‡ä»¶ã€‚è€Œå¯¹äºåŠ¨æ€é“¾æ¥ï¼Œé™¤äº†å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¿˜æœ‰å®ƒæ‰€ä¾èµ–çš„å…±äº«ç›®æ ‡æ–‡ä»¶ã€‚\nå…³äºå…±äº«ç›®æ ‡æ–‡ä»¶åœ¨å†…å­˜ä¸­çš„åœ°å€åˆ†é…ï¼Œä¸»è¦æœ‰ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼Œåˆ†åˆ«æ˜¯ï¼š\n\né™æ€å…±äº«åº“ Static Shared Library\nåœ°å€å›ºå®š\né™æ€å…±äº«åº“çš„åšæ³•æ˜¯å°†ç¨‹åºçš„å„ä¸ªæ¨¡å—ç»Ÿä¸€äº¤ç»™æ“ä½œç³»ç»Ÿè¿›è¡Œç®¡ç†ï¼Œæ“ä½œç³»ç»Ÿåœ¨æŸä¸ªç‰¹å®šçš„åœ°å€åˆ’åˆ†å‡ºä¸€äº›åœ°å€å—ï¼Œä¸ºé‚£äº›å·²çŸ¥çš„æ¨¡å—é¢„ç•™è¶³å¤Ÿçš„ç©ºé—´\nå› ä¸ºè¿™ä¸ªåœ°å€å¯¹äºä¸åŒçš„åº”ç”¨ç¨‹åºæ¥è¯´ï¼Œéƒ½æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥ç§°ä¹‹ä¸ºé™æ€\n\n\nåŠ¨æ€å…±äº«åº“ Dynamic Shared Libary\nåœ°å€ä¸å›ºå®š\n\né‡‡ç”¨åŠ¨æ€å…±äº«åº“çš„æ–¹å¼ï¼Œä¹Ÿç§°ä¸ºè£…è½½æ—¶é‡å®šä½ï¼ˆLoad Time Relocationï¼‰\n\nåœ¨é“¾æ¥æ—¶ï¼Œå¯¹æ‰€æœ‰ç»å¯¹åœ°å€çš„å¼•ç”¨éƒ½ä¸ä½œé‡å®šä½ï¼Œè€ŒæŠŠè¿™ä¸€æ­¥æ¨è¿Ÿåˆ°è£…è½½æ—¶å†å®Œæˆ\nä¸€æ—¦æ¨¡å—è£…è½½åœ°å€ç¡®å®šï¼Œå³ç›®æ ‡åœ°å€ç¡®å®šï¼Œé‚£ä¹ˆç³»ç»Ÿå°±å¯¹ç¨‹åºä¸­æ‰€æœ‰çš„ç»å¯¹åœ°å€å¼•ç”¨è¿›è¡Œé‡å®šä½\n\n\nä½†æ˜¯è¿™ç§æ–¹å¼ä¹Ÿå­˜åœ¨ä¸€äº›é—®é¢˜\n\næ€é“¾æ¥æ¨¡å—è¢«è£…è½½æ˜ å°„è‡³è™šæ‹Ÿç©ºé—´åï¼ŒæŒ‡ä»¤éƒ¨åˆ†æ˜¯åœ¨å¤šä¸ªè¿›ç¨‹é—´å…±äº«çš„ï¼Œç”±äºè£…è½½æ—¶é‡å®šä½çš„æ–¹æ³•éœ€è¦ä¿®æ”¹æŒ‡ä»¤ï¼Œæ‰€ä»¥æ²¡æœ‰åŠæ³•åšåˆ°åŒä¸€ä»½æŒ‡ä»¤è¢«å¤šä¸ªè¿›ç¨‹å…±äº«ï¼Œå› ä¸ºæŒ‡ä»¤è¢«é‡å®šä½åå¯¹äºæ¯ä¸ªè¿›ç¨‹æ¥è¯´éƒ½æ˜¯ä¸åŒçš„\n\n\nåœ°å€æ— å…³ä»£ç \n\næŠŠæŒ‡ä»¤ä¸­é‚£äº›éœ€è¦è¢«ä¿®æ”¹çš„éƒ¨åˆ†åˆ†ç¦»å‡ºæ¥ï¼Œè·Ÿæ•°æ®éƒ¨åˆ†æ”¾åœ¨ä¸€èµ·ï¼Œè¿™æ ·æŒ‡ä»¤éƒ¨åˆ†å°±å¯ä»¥ä¿æŒä¸å˜ï¼Œè€Œæ•°æ®éƒ¨åˆ†å¯ä»¥åœ¨æ¯ä¸ªè¿›ç¨‹ä¸­æ‹¥æœ‰ä¸€ä¸ªå‰¯æœ¬\n\nå…±äº«å¯¹è±¡æ¨¡å—ä¸­çš„åœ°å€å¼•ç”¨æŒ‰ç…§æ˜¯å¦ä¸ºè·¨æ¨¡å—åˆ†ä¸ºä¸¤ç±»ï¼šæ¨¡å—å†…éƒ¨å¼•ç”¨ã€æ¨¡å—å¤–éƒ¨å¼•ç”¨ã€‚æŒ‰ç…§ä¸ç”¨çš„å¼•ç”¨æ–¹å¼åˆå¯åˆ†ä¸ºï¼šæŒ‡ä»¤å¼•ç”¨ã€æ•°æ®å¼•ç”¨\n\nç±»å‹ 1ï¼šæ¨¡å—å†…éƒ¨çš„å‡½æ•°è°ƒç”¨\nç”±äºè¢«è°ƒç”¨çš„å‡½æ•°ä¸è°ƒç”¨è€…éƒ½å¤„äºåŒä¸€æ¨¡å—ï¼Œå®ƒä»¬ä¹‹é—´çš„ç›¸å¯¹ä½ç½®æ˜¯å›ºå®šçš„ã€‚å¯¹äºç°ä»£çš„ç³»ç»Ÿæ¥è¯´ï¼Œæ¨¡å—å†…éƒ¨çš„è°ƒç”¨éƒ½å¯ä»¥æ˜¯ç›¸å¯¹åœ°å€è°ƒç”¨ï¼Œæˆ–è€…æ˜¯åŸºäºå¯„å­˜å™¨çš„ç›¸å¯¹è°ƒç”¨ï¼Œæ‰€ä»¥å¯¹äºè¿™ç§æŒ‡ä»¤æ˜¯ä¸éœ€è¦é‡å®šä½çš„\n\n\nç±»å‹ 2ï¼šæ¨¡å—å†…éƒ¨çš„æ•°æ®è®¿é—®ï¼Œå¦‚æ¨¡å—ä¸­å®šä¹‰çš„å…¨å±€å˜é‡ã€é™æ€å˜é‡\nä¸€ä¸ªæ¨¡å—å‰é¢ä¸€èˆ¬æ˜¯è‹¥å¹²ä¸ªé¡µçš„ä»£ç ï¼Œåé¢ç´§è·Ÿç€è‹¥å¹²ä¸ªé¡µçš„æ•°æ®ï¼Œè¿™äº›é¡µä¹‹é—´çš„ç›¸å¯¹ä½ç½®æ˜¯å›ºå®šçš„ï¼Œå³ä»»ä½•ä¸€æ¡æŒ‡ä»¤ä¸å®ƒéœ€è¦è®¿é—®çš„æ¨¡å—å†…éƒ¨æ•°æ®ä¹‹é—´çš„ç›¸å¯¹ä½ç½®æ˜¯å›ºå®šçš„ï¼Œæ‰€ä»¥åªéœ€è¦ç›¸å¯¹äºå½“å‰æŒ‡ä»¤åŠ ä¸Šå›ºå®šçš„åç§»é‡å°±å¯ä»¥è®¿é—®æ¨¡å—å†…éƒ¨æ•°æ®äº†\n\n\nç±»å‹ 3ï¼šæ¨¡å—å¤–éƒ¨çš„å‡½æ•°è°ƒç”¨\næ¨¡å—é—´çš„æ•°æ®è®¿é—®æ¯”æ¨¡å—å†…éƒ¨ç¨å¾®éº»çƒ¦ä¸€äº›ï¼Œå› ä¸ºæ¨¡å—é—´çš„æ•°æ®è®¿é—®ç›®æ ‡åœ°å€è¦ç­‰åˆ°è£…è½½æ—¶æ‰å†³å®šã€‚æ­¤æ—¶ï¼ŒåŠ¨æ€é“¾æ¥éœ€è¦ä½¿ç”¨ä»£ç æ— å…³åœ°å€æŠ€æœ¯ï¼Œå…¶åŸºæœ¬æ€æƒ³æ˜¯æŠŠåœ°å€ç›¸å…³çš„éƒ¨åˆ†æ”¾åˆ°æ•°æ®æ®µã€‚ELF çš„å®ç°æ–¹æ³•æ˜¯ï¼šåœ¨æ•°æ®æ®µä¸­å»ºç«‹ä¸€ä¸ªæŒ‡å‘è¿™äº›å˜é‡çš„æŒ‡é’ˆæ•°ç»„ï¼Œä¹Ÿç§°ä¸ºå…¨å±€åç§»è¡¨ï¼ˆGlobal Offset Tableï¼ŒGOTï¼‰ï¼Œå½“ä»£ç éœ€è¦å¼•ç”¨è¯¥å…¨å±€å˜é‡æ—¶ï¼Œå¯ä»¥é€šè¿‡ GOT ä¸­ç›¸å¯¹åº”çš„é¡¹é—´æ¥å¼•ç”¨\n\n\nç±»å‹ 4ï¼šæ¨¡å—å¤–éƒ¨çš„æ•°æ®è®¿é—®ï¼Œå¦‚å…¶ä»–æ¨¡å—ä¸­å®šä¹‰çš„å…¨å±€å˜é‡\nå¯¹äºæ¨¡å—é—´å‡½æ•°è°ƒç”¨ï¼ŒåŒæ ·å¯ä»¥é‡‡ç”¨ç±»å‹ 3 çš„æ–¹æ³•æ¥è§£å†³ã€‚ä¸ä¸Šé¢çš„ç±»å‹æœ‰æ‰€ä¸åŒçš„æ˜¯ï¼ŒGOT ä¸­å“åº”çš„é¡¹ä¿å­˜çš„æ˜¯ç›®æ ‡å‡½æ•°çš„åœ°å€ï¼Œå½“æ¨¡å—éœ€è¦è°ƒç”¨ç›®æ ‡å‡½æ•°æ—¶ï¼Œå¯ä»¥é€šè¿‡ GOT ä¸­çš„é¡¹è¿›è¡Œé—´æ¥è·³è½¬\n\n\n\nstatic int a;extern int b;extern void ext();void bar() {    a = 1;      // ç±»å‹ 2ï¼šæ¨¡å—å†…éƒ¨æ•°æ®è®¿é—®    b = 2;      // ç±»å‹ 4ï¼šæ¨¡å—å¤–éƒ¨æ•°æ®è®¿é—®}void foo() {    bar();      // ç±»å‹ 1ï¼šæ¨¡å—å†…éƒ¨å‡½æ•°è°ƒç”¨    ext();      // ç±»å‹ 4ï¼šæ¨¡å—å¤–éƒ¨å‡½æ•°è°ƒç”¨}\n\n\n\n\n\né™æ€é“¾æ¥æ˜¯å¦å°†æ‰€æœ‰å‡½æ•°éƒ½é“¾æ¥åˆ°å¯æ‰§è¡Œæ–‡ä»¶ä¸­\nåŠ¨æ€é“¾æ¥æ˜¯æŒ‡åœ¨ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶æ—¶ä¸å°†æ‰€æœ‰ç¨‹åºç”¨åˆ°çš„å‡½æ•°é“¾æ¥åˆ°ä¸€ä¸ªæ–‡ä»¶ï¼Œå› ä¸ºæœ‰è®¸å¤šå‡½æ•°åœ¨æ“ä½œç³»ç»Ÿçš„ dll æ–‡ä»¶ä¸­ï¼Œå½“ç¨‹åºè¿è¡Œæ—¶ç›´æ¥ä»æ“ä½œç³»ç»Ÿä¸­æ‰¾\né™æ€é“¾æ¥å°±æ˜¯æŠŠæ‰€æœ‰ç”¨åˆ°çš„å‡½æ•°å…¨éƒ¨é“¾æ¥åˆ° exe æ–‡ä»¶ä¸­\nåŠ¨æ€é“¾æ¥æ˜¯åªå»ºç«‹ä¸€ä¸ªå¼•ç”¨çš„æ¥å£ï¼Œè€ŒçœŸæ­£çš„ä»£ç å’Œæ•°æ®å­˜æ”¾åœ¨å¦å¤–çš„å¯æ‰§è¡Œæ¨¡å—ä¸­ï¼Œåœ¨è¿è¡Œæ—¶å†è£…å…¥\nè€Œé™æ€é“¾æ¥æ˜¯æŠŠæ‰€æœ‰çš„ä»£ç å’Œæ•°æ®éƒ½å¤åˆ¶åˆ°æœ¬æ¨¡å—ä¸­ï¼Œè¿è¡Œæ—¶å°±ä¸å†éœ€è¦åº“äº†\n\nåŠ¨æ€åº“æŠ›å‡ºå¼‚å¸¸å¯ä»¥æ•è·åˆ°å—  åŒä¸€ä¸ªç¼–è¯‘å™¨ç¼–è¯‘å‡ºæ¥çš„ dll å’Œ exe æ˜¯å¯ä»¥çš„\nå…³é”®å­—å’Œæ“ä½œç¬¦ extern å…³é”®å­—å«ä¹‰\nå½“å®ƒä¸ \"C\" ä¸€èµ·è¿ç”¨æ—¶ï¼Œå¦‚extern \"C\" void fun(int a, int b);ï¼Œåˆ™ç¼–è¯‘å™¨åœ¨ç¼–è¯‘ fun è¿™ä¸ªå‡½æ•°åæ—¶æŒ‰ C çš„è§„åˆ™å»ç¿»è¯‘ç›¸åº”çš„å‡½æ•°åè€Œä¸æ˜¯ C++ çš„\nå½“å®ƒä¸ä¸ \"C\" åœ¨ä¸€èµ·ä¿®é¥°å˜é‡æˆ–å‡½æ•°æ—¶ï¼Œå¦‚åœ¨å¤´æ–‡ä»¶ä¸­ï¼Œextern int a;ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯å£°æ˜å‡½æ•°æˆ–å˜é‡çš„ä½œç”¨èŒƒå›´çš„å…³é”®å­—ï¼Œå…¶å£°æ˜çš„å‡½æ•°å’Œå˜é‡å¯ä»¥åœ¨æœ¬ç¼–è¯‘å•å…ƒæˆ–å…¶ä»–ç¼–è¯‘å•å…ƒä¸­ä½¿ç”¨\n\né™æ€å…¨å±€å˜é‡\næ³¨æ„ä½¿ç”¨ static ä¿®é¥°å˜é‡ï¼Œå°±ä¸èƒ½ä½¿ç”¨ extern æ¥ä¿®é¥°ï¼Œå³ static å’Œexternä¸å¯åŒæ—¶å‡ºç°\n\nstaticä¿®é¥°çš„å…¨å±€å˜é‡çš„å£°æ˜ä¸å®šä¹‰åŒæ—¶è¿›è¡Œï¼Œå³å½“åœ¨å¤´æ–‡ä»¶ä¸­ä½¿ç”¨ static å£°æ˜äº†å…¨å±€å˜é‡ï¼ŒåŒæ—¶å®ƒä¹Ÿè¢«å®šä¹‰äº†ã€‚staticä¿®é¥°çš„å…¨å±€å˜é‡çš„ä½œç”¨åŸŸåªèƒ½æ˜¯æœ¬èº«çš„ç¼–è¯‘å•å…ƒã€‚åœ¨å…¶ä»–ç¼–è¯‘å•å…ƒä½¿ç”¨å®ƒæ—¶ï¼Œåªæ˜¯ç®€å•çš„æŠŠå…¶å€¼å¤åˆ¶ç»™äº†å…¶ä»–ç¼–è¯‘å•å…ƒï¼Œå…¶ä»–ç¼–è¯‘å•å…ƒä¼šå¦å¤–å¼€ä¸ªå†…å­˜ä¿å­˜å®ƒï¼Œåœ¨å…¶ä»–ç¼–è¯‘å•å…ƒå¯¹å®ƒçš„ä¿®æ”¹å¹¶ä¸å½±å“æœ¬èº«åœ¨å®šä¹‰æ—¶çš„å€¼\nå¤šä¸ªåœ°æ–¹å¼•ç”¨é™æ€å…¨å±€å˜é‡æ‰€åœ¨çš„å¤´æ–‡ä»¶ï¼Œä¸ä¼šå‡ºç°é‡å®šä¹‰é”™è¯¯ï¼Œå› ä¸ºåœ¨æ¯ä¸ªç¼–è¯‘å•å…ƒéƒ½å¯¹å®ƒå¼€è¾Ÿäº†é¢å¤–çš„ç©ºé—´è¿›è¡Œå­˜å‚¨\n\nä¸€èˆ¬å®šä¹‰ static å…¨å±€å˜é‡æ—¶ï¼Œéƒ½æŠŠå®ƒæ”¾åœ¨ã€‚cpp æ–‡ä»¶ä¸­è€Œä¸æ˜¯ã€‚h æ–‡ä»¶ä¸­ï¼Œè¿™æ ·å°±ä¸ä¼šç»™å…¶ä»–ç¼–è¯‘å•å…ƒé€ æˆä¸å¿…è¦çš„ä¿¡æ¯æ±¡æŸ“\n\nå¦‚ä½•ä½¿ç”¨å…¨å±€å˜é‡\nåœ¨åŒä¸€æ–‡ä»¶ä¸­å®šä¹‰äº†å…¨å±€å˜é‡ï¼Œéœ€è¦åœ¨å‰é¢ä½¿ç”¨ï¼Œè¿™æ—¶åœ¨å®šä¹‰ä¹‹å‰ç”¨ extern å…³é”®å­—å¯¹å…¶è¿›è¡Œå£°æ˜\n\n// a.cppextern int a;void SetA(){    a = 100;}int a;int main(){    ...}\n\n\nåœ¨ä¸€ä¸ªæºæ–‡ä»¶æ–‡ä»¶ä¸­å®šä¹‰äº†å…¨å±€å˜é‡ï¼Œéœ€è¦åœ¨å…¶ä»–æ–‡ä»¶ä¸­ä½¿ç”¨ï¼Œè¿™æ—¶éœ€è¦åœ¨å…¶ä»–æ–‡ä»¶ä¸­éœ€è¦ä½¿ç”¨çš„åœ°æ–¹ä¹‹å‰ç”¨ extern å£°æ˜ä¸‹\n\n// a.cpp æ–‡ä»¶ï¼Œa çš„å®šä¹‰æ–‡ä»¶int a;  // å…¨å±€å˜é‡ a çš„å®šä¹‰int main(){    ...}\n\n// b.cpp æ–‡ä»¶extern int a;  // å£°æ˜void setA(){    a = 100;}\n\nå¦‚ä½•æ›´æ”¹å˜é‡çš„ const å±æ€§\nå¼ºåˆ¶ç±»å‹è½¬æ¢\n\nC++ ä¸­çš„å¼ºåˆ¶ç±»å‹è½¬æ¢å¯ä»¥å°† const ç±»å‹è½¬æ¢ä¸ºé const ç±»å‹\nint main() {    const int a = 10;    int &amp;b = const_cast&lt;int &amp;&gt;(a);    b = 20;    cout &lt;&lt; a &lt;&lt; endl; // output: 20    return 0;}\n\nconst_caståªèƒ½åœ¨ç±»å‹ä¸Šè¿›è¡Œå¼ºåˆ¶è½¬æ¢ï¼Œä½†ä¸èƒ½å»æ‰å˜é‡çš„å®é™…é™å®šç¬¦ã€‚å› æ­¤ï¼Œå¦‚æœè¦å»æ‰æŒ‡å‘ const å¯¹è±¡çš„æŒ‡é’ˆæˆ–å¼•ç”¨çš„ const é™å®šç¬¦ï¼Œå¿…é¡»å…ˆè§£é™¤æŒ‡é’ˆæˆ–å¼•ç”¨çš„ const å±æ€§ï¼Œç„¶åå†è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢\n\nä½¿ç”¨ mutable å…³é”®å­—\n\nclass Foo{public:    mutable int count = 0;    void bar() const    {        count++;    }};int main() {    Foo foo;    foo.bar(); // count = 1    return 0;}\n\nå¦‚ä½•åˆå§‹åŒ– const æˆå‘˜å˜é‡\nconstæˆå‘˜å˜é‡åˆå§‹åŒ–åœ¨æ„é€ å‡½æ•°çš„åˆå§‹åŒ–åˆ—è¡¨é‡Œè¿›è¡Œï¼Œä¸å¯ä»¥é€šè¿‡èµ‹å€¼æ¥åˆå§‹åŒ–\nè‹¥æœ‰å¤šä¸ªæ„é€ å‡½æ•°ï¼Œåˆ™å¿…é¡»æ¯ä¸ªæ„é€ å‡½æ•°éƒ½å¿…é¡»è¦ä¸º const æˆå‘˜å˜é‡èµ‹åˆå€¼\n\nnewå’Œ delete è¿ç®—ç¬¦\nnew\nè°ƒç”¨ operator new å‡½æ•°ç”³è¯·ç©ºé—´\nåœ¨ç”³è¯·çš„ç©ºé—´ä¸Šæ‰§è¡Œæ„é€ å‡½æ•°ï¼Œå®Œæˆå¯¹è±¡çš„æ„é€ \n\n\ndelete\nåœ¨ç©ºé—´ä¸Šæ‰§è¡Œææ„å‡½æ•°ï¼Œå®Œæˆå¯¹è±¡ä¸­èµ„æºçš„æ¸…ç†å·¥ä½œ\nè°ƒç”¨ operator delete å‡½æ•°é‡Šæ”¾å¯¹è±¡çš„ç©ºé—´\n\n\n\nPlacement æŠ€æœ¯  ç³»ç»Ÿé»˜è®¤çš„ new å…³é”®å­—é™¤äº†åˆ†é…å †å†…å­˜å¤–è¿˜è¿›è¡Œæ„é€ å‡½æ•°çš„è°ƒç”¨ã€‚è€Œå®é™…ä¸­å¯èƒ½æœ‰ä¸€äº›å·²ç»é¢„å…ˆåˆ†é…å¥½çš„å†…å­˜åŒºåŸŸï¼Œæƒ³åœ¨è¿™äº›å·²ç»åˆ†é…å¥½çš„å†…å­˜ä¸­æ¥æ„å»ºä¸€ä¸ªå¯¹è±¡ã€‚è¿˜æœ‰ä¸€ç§æƒ…å†µæ˜¯ä¸å¸Œæœ›è¿›è¡Œé¢‘ç¹çš„å †å†…å­˜åˆ†é…å’Œé‡Šæ”¾è€Œåªæ˜¯å¯¹åŒä¸€å—å†…å­˜è¿›è¡Œé‡å¤çš„å¯¹è±¡æ„å»ºå’Œé”€æ¯\né¢å‘å¯¹è±¡  å¤šç»§æ‰¿æƒ…å†µä¸‹æˆå‘˜å˜é‡å’Œå‡½æ•°çš„å†…å­˜åˆ†å¸ƒ  å•ç»§æ‰¿class Base {public:    int a;    int b;    virtual void func1();    void func2();};class Derive: public Base {public:    int c;    virtual void func3();};\n\nåœ¨ msvc ç¯å¢ƒä¸‹ï¼Œé¦–å…ˆç¼–è¯‘æºæ–‡ä»¶ cl /EHsc main.cppï¼Œç”Ÿæˆ.obj æ–‡ä»¶\nåŸºç±»çš„å†…å­˜åˆ†å¸ƒcl /d1 reportSingleClassLayoutBase main.cpp\n\nclass _s__RTTIBaseClassDescriptor       size(28):        +--- 0      | pTypeDescriptor 4      | numContainedBases 8      | _PMD where20      | attributes24      | pClassDescriptor        +---class _s__RTTIBaseClassArray    size(1):        +--- 0      | arrayOfBaseClassDescriptors        +---class Base      size(12):        +--- 0      | {vfptr} // å­˜åœ¨è™šå‡½æ•°ï¼Œéœ€è¦åˆ†é…è™šè¡¨æŒ‡é’ˆçš„å†…å­˜å¤§å°æ˜¯ 4 ä¸ªå­—èŠ‚ 4      | a 8      | b        +---Base::$vftable@:        | &amp;Base_meta        |  0 0      | &amp;Base::func1Base::func1 this adjustor: 0\n\n\n    \n\n\næ´¾ç”Ÿç±»çš„å†…å­˜åˆ†å¸ƒclass Derive    size(16):        +--- 0      | +--- (base class Base) 0      | | {vfptr} 4      | | a 8      | | b        | +---12      | c        +---Derive::$vftable@:        | &amp;Derive_meta        |  0 // åœ°å€åç§»é‡ 0      | &amp;Base::func1 1      | &amp;Derive::func3Derive::func3 this adjustor: 0\n\n\n    \n\n\nå¤šç»§æ‰¿class Base1 {public:    int a;    int b;    virtual void func1();};class Base2 {public:    int c;    virtual void func2();};class Derive: public Base1, Base2 {public:    int d;    virtual void func3();};\n\nclass Derive    size(24):        +--- 0      | +--- (base class Base1) 0      | | {vfptr} 4      | | a 8      | | b        | +---12      | +--- (base class Base2)12      | | {vfptr}16      | | c        | +---20      | d        +---Derive::$vftable@Base1@:        | &amp;Derive_meta        |  0 0      | &amp;Base1::func1 1      | &amp;Derive::func3Derive::$vftable@Base2@:        | -12 // åœ°å€åç§»é‡ï¼Œæœ‰çš„æ˜¯ -8ï¼Œæœ‰çš„æ˜¯ -12ï¼›å½“ç»§æ‰¿ç¬¬ä¸‰ä¸ªç±»çš„æ—¶å€™æ˜¯ -24 0      | &amp;Base2::func2Derive::func3 this adjustor: 0\n\n\n\nç‹¬æœ‰çš„è™šå‡½æ•°æ”¾åˆ°ç¬¬ä¸€ä¸ªè™šå‡½æ•°è¡¨ä¸­\nåªæœ‰ç¬¬ä¸€ä¸ªè™šå‡½æ•°è¡¨åŒ…å«å…ƒæ•°æ®è¡Œ\nç»§æ‰¿åæ´¾ç”Ÿç±»è‡ªå·±æ²¡æœ‰è™šå‡½æ•°æŒ‡é’ˆ\n\n\nè™šç»§æ‰¿class Base {public:    int a;    int b;    virtual void func1();};class Derive: virtual Base {public:    int c;    virtual void func2();};\n\nclass Derive    size(24):        +--- 0      | {vfptr} 4      | {vbptr} 8      | c        +---        +--- (virtual base Base)12      | {vfptr}16      | a20      | b        +---Derive::$vftable@Derive@:        | &amp;Derive_meta        |  0 0      | &amp;Derive::func2Derive::$vbtable@: 0      | -4 1      | 8 (Derived(Derive+4)Base)Derive::$vftable@Base@:        | -12 0      | &amp;Base::func1Derive::func2 this adjustor: 0vbi:       class  offset o.vbptr  o.vbte fVtorDisp            Base      12       4       4 0\n\n\n    \n\n\nè™šåŸºç±»è¡¨æŒ‡é’ˆï¼ˆvbptrï¼‰ï¼Œè¯¥æŒ‡é’ˆæŒ‡å‘äº†ä¸€ä¸ªè™šåŸºç±»è¡¨ï¼Œè™šè¡¨ä¸­è®°å½•äº†è™šåŸºç±»ä¸æœ¬ç±»çš„åç§»åœ°å€ã€‚é€šè¿‡åç§»åœ°å€ï¼Œè¿™æ ·å°±å¯ä»¥æ‰¾åˆ°è™šåŸºç±»æˆå‘˜ï¼Œè€Œè™šç»§æ‰¿ä¹Ÿä¸ç”¨åƒæ™®é€šå¤šç»§æ‰¿é‚£æ ·ç»´æŒç€å…¬å…±åŸºç±»ï¼ˆè™šåŸºç±»ï¼‰çš„ä¸¤ä»½åŒæ ·çš„æ‹·è´ï¼Œä»è€ŒèŠ‚çœäº†å­˜å‚¨ç©ºé—´\nåŸºç±»å’Œæ´¾ç”Ÿç±»æŒ‡é’ˆç›¸äº’èµ‹å€¼\nåœ¨å…¬æœ‰æ´¾ç”Ÿçš„æƒ…å†µä¸‹ï¼Œæ´¾ç”Ÿç±»çš„æŒ‡é’ˆå¯ä»¥ç›´æ¥èµ‹å€¼ç»™åŸºç±»æŒ‡é’ˆ\nå³ä¾¿åŸºç±»æŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä¸€ä¸ªæ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä¹Ÿä¸èƒ½é€šè¿‡åŸºç±»æŒ‡é’ˆè®¿é—®åŸºç±»æ²¡æœ‰è€Œæ´¾ç”Ÿç±»ä¸­æœ‰çš„æˆå‘˜\n\n\nåŸºç±»çš„æŒ‡é’ˆä¸èƒ½èµ‹å€¼ç»™æ´¾ç”Ÿç±»çš„æŒ‡é’ˆ\nä½†æ˜¯é€šè¿‡å¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œä¹Ÿå¯ä»¥å°†åŸºç±»æŒ‡é’ˆå¼ºåˆ¶è½¬æ¢æˆæ´¾ç”Ÿç±»æŒ‡é’ˆåå†èµ‹å€¼ç»™æ´¾ç”Ÿç±»æŒ‡é’ˆ\nåªæ˜¯åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œéœ€è¦ä¿è¯è¢«è½¬æ¢çš„åŸºç±»æŒ‡é’ˆæœ¬æ¥å°±æŒ‡å‘ä¸€ä¸ªæ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œè¿™æ ·æ‰æ˜¯å®‰å…¨çš„ï¼Œå¦åˆ™å¾ˆå®¹æ˜“å‡ºé”™\n\n\n\n#include &lt;iostream&gt;using namespace std;class CBase{protected:    int n;public:    CBase(int i) :n(i) {}    void Print() {cout &lt;&lt; \"CBase:n=\" &lt;&lt; n &lt;&lt; endl; }};class CDerived :public CBase{public:    int v;    CDerived(int i) :CBase(i), v(2 * i) {}    void Func() {};    void Print()    {        cout &lt;&lt; \"CDerived:n=\" &lt;&lt; n &lt;&lt; endl;        cout &lt;&lt; \"CDerived:v=\" &lt;&lt; v &lt;&lt; endl;    }};int main(){    CDerived objDerived(3);    CBase objBase(5);    // ä½¿å¾—åŸºç±»æŒ‡é’ˆæŒ‡å‘æ´¾ç”Ÿç±»å¯¹è±¡    // pBase-&gt;Func(); // é”™ï¼ŒCBase ç±»æ²¡æœ‰ Func() æˆå‘˜å‡½æ•°    // pBase-&gt;v = 5;  // é”™ CBase ç±»æ²¡æœ‰ v æˆå‘˜å˜é‡    CBase * pBase = &amp;objDerived;     pBase-&gt;Print();    cout &lt;&lt; \"1)------------\" &lt;&lt; endl;    //CDerived * pDerived = &amp; objBase; // é”™ï¼Œä¸èƒ½å°†åŸºç±»æŒ‡é’ˆèµ‹å€¼ç»™æ´¾ç”Ÿç±»æŒ‡é’ˆ    CDerived * pDerived = (CDerived *)(&amp;objBase);    pDerived-&gt;Print();  // æ…ç”¨ï¼Œå¯èƒ½å‡ºç°ä¸å¯é¢„æœŸçš„é”™è¯¯    cout &lt;&lt; \"2)------------\" &lt;&lt; endl;    objDerived.Print();    cout &lt;&lt; \"3)------------\" &lt;&lt; endl;    pDerived-&gt;v = 128;  // å¾€åˆ«äººçš„ç©ºé—´é‡Œå†™å…¥æ•°æ®ï¼Œä¼šæœ‰é—®é¢˜    objDerived.Print();    return 0;}\n\nåœ¨å‡½æ•°å‚æ•°ä¸­ä½¿ç”¨æœªå®šä¹‰çš„ç±»\nå‰å‘å£°æ˜ï¼šå¯ä»¥å£°æ˜ä¸€ä¸ªç±»è€Œä¸å®šä¹‰å®ƒï¼Œè¿™ä¸ªå£°æ˜è¢«ç§°ä¸ºå‰å‘å£°æ˜ (forward declaration)\nå£°æ˜åçš„ç±»æ˜¯ä¸€ä¸ªä¸å®Œå…¨ç±»å‹ï¼ˆincompete typeï¼‰ï¼Œä¸å®Œå…¨ç±»å‹åªèƒ½ä»¥æœ‰é™æ–¹å¼ä½¿ç”¨\nä¸èƒ½å®šä¹‰è¯¥ç±»å‹çš„å¯¹è±¡\nåªèƒ½ç”¨äºå®šä¹‰æŒ‡å‘è¯¥ç±»å‹çš„æŒ‡é’ˆåŠå¼•ç”¨\nç”¨äºå£°æ˜ï¼ˆè€Œä¸æ˜¯å®šä¹‰ï¼‰ä½¿ç”¨è¯¥ç±»å‹ä½œä¸ºå½¢å‚ç±»å‹æˆ–è¿”å›ç±»å‹çš„å‡½æ•°\n\n\nç±»çš„å‰å‘å£°æ˜åªé€‚ç”¨äºæŒ‡é’ˆå’Œå¼•ç”¨çš„å®šä¹‰ï¼Œå¦‚æœæ˜¯æ™®é€šç±»çš„ç±»å‹å°±å¾—ä½¿ç”¨include\n\nå¦‚ä½•å®ç°æ¥å£  é¦–å…ˆç»™æ¥å£ç±»ä¸‹äº†å®šä¹‰\n\næ¥å£ç±»åº”è¯¥æ˜¯åªæä¾›æ–¹æ³•å£°æ˜ï¼Œè€Œè‡ªèº«ä¸æä¾›æ–¹æ³•å®šä¹‰çš„æŠ½è±¡ç±»\næ¥å£ç±»è‡ªèº«ä¸èƒ½å®ä¾‹åŒ–ï¼Œæ¥å£ç±»çš„æ–¹æ³•å®šä¹‰ / å®ç°åªèƒ½ç”±æ¥å£ç±»çš„å­ç±»æ¥å®Œæˆ\n\nè€Œå¯¹äº C++ï¼Œå…¶æ¥å£ç±»ä¸€èˆ¬å…·æœ‰ä»¥ä¸‹ç‰¹å¾ï¼š\n\næœ€å¥½ä¸è¦æœ‰æˆå‘˜å˜é‡ï¼Œä½†å¯ä»¥æœ‰é™æ€å¸¸é‡ static constæˆ–enum\nè¦æœ‰çº¯è™šæ¥å£æ–¹æ³•\nè¦æœ‰è™šææ„å‡½æ•°ï¼Œå¹¶æä¾›é»˜è®¤å®ç°\nä¸è¦å£°æ˜æ„é€ å‡½æ•°\n\nclass InterfaceTest{public:    static const int START = 1;    static const int STOP = 2;     virtual void test() = 0;     virtual ~InterfaceTest() = default;}\n\nstructå¯ä»¥å®šä¹‰è™šå‡½æ•°å—  å°±ç¼–è¯‘å™¨è€Œè¨€ï¼Œé™¤äº†é»˜è®¤çš„å¯è®¿é—®æ€§å¤–ï¼Œstructå’Œ class ä¹‹é—´æ²¡æœ‰åŒºåˆ«ã€‚å®ƒä»¬åªæ˜¯å®šä¹‰åŒä¸€äº‹ç‰©çš„ä¸¤ä¸ªä¸åŒå…³é”®å­—ã€‚æ‰€ä»¥ï¼Œç»“æ„å¯ä»¥æœ‰æ„é€ å‡½æ•°ã€ææ„å‡½æ•°ã€åŸºç±»ã€è™šå‡½æ•°ç­‰ç­‰\nä½¿ç”¨ struct æ¥å¤„ç†æ²¡æœ‰è¿™äº›ä¸œè¥¿çš„ç±»ï¼ˆç‰¹åˆ«æ˜¯ POD ) æ˜¯ä¸€ä¸ªå¸¸è§çš„çº¦å®šï¼Œæˆ–è€…æ›´è¿›ä¸€æ­¥ä½¿ç”¨ struct ä»…é€‚ç”¨äºæ ¹æœ¬æ²¡æœ‰ç”¨æˆ·å®šä¹‰çš„æˆå‘˜å‡½æ•°ï¼Œåªæœ‰ public æ•°æ®æˆå‘˜çš„ç±»\n\nPOD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.\n\nç”Ÿå‘½å‘¨æœŸ  å£°æ˜å˜é‡ä¼šåˆ†é…å†…å­˜å—\nå‡½æ•°æˆ–å˜é‡åœ¨å£°æ˜æ—¶ï¼Œå¹¶æ²¡æœ‰ç»™å®ƒå®é™…çš„ç‰©ç†å†…å­˜ç©ºé—´\nå‡½æ•°æˆ–å˜é‡åœ¨å®šä¹‰æ—¶ï¼Œå®ƒå°±åœ¨å†…å­˜ä¸­æœ‰äº†å®é™…çš„ç‰©ç†ç©ºé—´\nå‡½æ•°æˆ–å˜é‡å¯ä»¥å£°æ˜å¤šæ¬¡ï¼Œä½†å®šä¹‰åªèƒ½æœ‰ä¸€æ¬¡\n\nå‡½æ•°æ ˆä¸­åŒ…å«çš„å†…å®¹  å‡½æ•°æ ˆ  å½“è¿›ç¨‹è¢«åŠ è½½åˆ°å†…å­˜æ—¶ï¼Œä¼šè¢«åˆ†æˆå¾ˆå¤šæ®µ\n\nä»£ç æ®µï¼šä¿å­˜ç¨‹åºæ–‡æœ¬ï¼ŒæŒ‡ä»¤æŒ‡é’ˆ EIP å°±æ˜¯æŒ‡å‘ä»£ç æ®µï¼Œå¯è¯»å¯æ‰§è¡Œä¸å¯å†™ï¼Œå¦‚æœå‘ç”Ÿå†™æ“ä½œåˆ™ä¼šæç¤º segmentation fault\næ•°æ®æ®µï¼šä¿å­˜åˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡ï¼Œå¯è¯»å¯å†™ä¸å¯æ‰§è¡Œ\nBSSï¼šæœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡\nå † (Heap)ï¼šåŠ¨æ€åˆ†é…å†…å­˜ï¼Œå‘åœ°å€å¢å¤§çš„æ–¹å‘å¢é•¿ï¼Œå¯è¯»å¯å†™å¯æ‰§è¡Œ\næ ˆ (Stack)ï¼šå­˜æ”¾å±€éƒ¨å˜é‡ï¼Œå‡½æ•°å‚æ•°ï¼Œå½“å‰çŠ¶æ€ï¼Œå‡½æ•°è°ƒç”¨ä¿¡æ¯ç­‰ï¼Œå‘åœ°å€å‡å°çš„æ–¹å‘å¢é•¿ï¼Œå¯è¯»å¯å†™å¯æ‰§è¡Œ\nç¯å¢ƒ / å‚æ•°æ®µï¼ˆenvironment/argumentssectionï¼‰ï¼šç”¨æ¥å­˜å‚¨ç³»ç»Ÿç¯å¢ƒå˜é‡çš„ä¸€ä»½å¤åˆ¶æ–‡ä»¶ï¼Œè¿›ç¨‹åœ¨è¿è¡Œæ—¶å¯èƒ½éœ€è¦ã€‚ä¾‹å¦‚ï¼Œè¿è¡Œä¸­çš„è¿›ç¨‹ï¼Œå¯ä»¥é€šè¿‡ç¯å¢ƒå˜é‡æ¥è®¿é—®è·¯å¾„ã€shell åç§°ã€ä¸»æœºåç­‰ä¿¡æ¯ã€‚è¯¥èŠ‚æ˜¯å¯å†™çš„ï¼Œå› æ­¤åœ¨ç¼“å†²åŒºæº¢å‡ºï¼ˆbuffer overflowï¼‰æ”»å‡»ä¸­éƒ½å¯ä»¥ä½¿ç”¨è¯¥æ®µ\n\nå¯„å­˜å™¨\nEAXï¼šç´¯åŠ ï¼ˆAccumulatorï¼‰å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºå‡½æ•°è¿”å›å€¼\nEBXï¼šåŸºå€ï¼ˆBaseï¼‰å¯„å­˜å™¨ï¼Œä»¥å®ƒä¸ºåŸºå€è®¿é—®å†…å­˜\nECXï¼šè®¡æ•°å™¨ï¼ˆCounterï¼‰å¯„å­˜å™¨ï¼Œå¸¸ç”¨ä½œå­—ç¬¦ä¸²å’Œå¾ªç¯æ“ä½œä¸­çš„è®¡æ•°å™¨\nEDXï¼šæ•°æ®ï¼ˆDataï¼‰å¯„å­˜å™¨ï¼Œå¸¸ç”¨äºä¹˜é™¤æ³•å’Œ I/O æŒ‡é’ˆ\nESIï¼šæºå˜å€å¯„å­˜å™¨\nDSIï¼šç›®çš„å˜å€å¯„å­˜å™¨\nESPï¼šå †æ ˆï¼ˆStackï¼‰æŒ‡é’ˆå¯„å­˜å™¨ï¼ŒæŒ‡å‘å †æ ˆé¡¶éƒ¨\nEBPï¼šåŸºå€æŒ‡é’ˆå¯„å­˜å™¨ï¼ŒæŒ‡å‘å½“å‰å †æ ˆåº•éƒ¨\nEIPï¼šæŒ‡ä»¤å¯„å­˜å™¨ï¼ŒæŒ‡å‘ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€\n\næ ˆå¸§ Stack Frameå…¶æœ¬è´¨å°±æ˜¯ä¸€ç§æ ˆï¼Œåªæ˜¯è¿™ç§æ ˆä¸“é—¨ç”¨äºä¿å­˜å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­çš„å„ç§ä¿¡æ¯ï¼ˆå‚æ•°ï¼Œè¿”å›åœ°å€ï¼Œå±€éƒ¨å˜é‡ç­‰ï¼‰ã€‚æ ˆå¸§æœ‰æ ˆé¡¶å’Œæ ˆåº•ä¹‹åˆ†ï¼Œå…¶ä¸­æ ˆé¡¶çš„åœ°å€æœ€ä½ï¼Œæ ˆåº•çš„åœ°å€æœ€é«˜ï¼ŒSPï¼ˆæ ˆæŒ‡é’ˆï¼‰å°±æ˜¯ä¸€ç›´æŒ‡å‘æ ˆé¡¶çš„ã€‚ç”¨ %ebp æŒ‡å‘æ ˆåº•ï¼Œä¹Ÿå°±æ˜¯åŸºå€æŒ‡é’ˆï¼›ç”¨ %esp æŒ‡å‘æ ˆé¡¶ï¼Œä¹Ÿå°±æ˜¯æ ˆæŒ‡é’ˆ\n\n    \n\n\nä¸€èˆ¬æ¥è¯´ï¼Œå°† %ebp åˆ°%espä¹‹é—´åŒºåŸŸå½“åšæ ˆå¸§ï¼ˆä¹Ÿæœ‰äººè®¤ä¸ºè¯¥ä»å‡½æ•°å‚æ•°å¼€å§‹ï¼Œä¸è¿‡è¿™ä¸å½±å“åˆ†æï¼‰ã€‚å¹¶ä¸æ˜¯æ•´ä¸ªæ ˆç©ºé—´åªæœ‰ä¸€ä¸ªæ ˆå¸§ï¼Œæ¯è°ƒç”¨ä¸€ä¸ªå‡½æ•°ï¼Œå°±ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„æ ˆå¸§ ã€‚åœ¨å‡½æ•°è°ƒç”¨è¿‡ç¨‹ä¸­ï¼Œå°†è°ƒç”¨å‡½æ•°çš„å‡½æ•°ç§°ä¸º è°ƒç”¨è€…ï¼ˆcallerï¼‰ï¼Œå°†è¢«è°ƒç”¨çš„å‡½æ•°ç§°ä¸º  è¢«è°ƒç”¨è€…ï¼ˆcalleeï¼‰ã€‚\n\nè°ƒç”¨è€…  éœ€è¦çŸ¥é“åœ¨å“ªé‡Œè·å–  è¢«è°ƒç”¨è€…  è¿”å›çš„å€¼\nè¢«è°ƒç”¨è€…  éœ€è¦çŸ¥é“ä¼ å…¥çš„å‚æ•°åœ¨å“ªé‡Œï¼Œè¿”å›çš„åœ°å€åœ¨å“ªé‡Œ\néœ€è¦ä¿è¯åœ¨  è¢«è°ƒç”¨è€…  è¿”å›åï¼Œ%ebpã€%espç­‰å¯„å­˜å™¨çš„å€¼åº”è¯¥å’Œè°ƒç”¨å‰ä¸€è‡´ï¼Œéœ€è¦ä½¿ç”¨æ ˆæ¥ä¿å­˜è¿™äº›æ•°æ®\n\nçº¿ç¨‹ä¸ªæ•°ç”±ä»€ä¹ˆå†³å®š  çº¿ç¨‹æ•°å’Œ CPU æ ¸å¿ƒæ•°å¯ä»¥æ²¡æœ‰ä»»ä½•å…³è”ï¼Œä½†å½“éœ€è¦åˆ©ç”¨çº¿ç¨‹å……åˆ†å‘æŒ¥å¤šæ ¸å¨åŠ›æ—¶ï¼Œé€šå¸¸æƒ…å†µä¸‹åˆ›å»ºçš„çº¿ç¨‹æ•°ä¸æ ¸æ•°è¦ä¿æŒä¸€ç§çº¿æ€§å…³ç³»ï¼Œæœ€ä½³ç³»æ•°é€šå¸¸éœ€è¦æµ‹è¯•æ‰èƒ½å¾—åˆ°\nRAII çš„ç”¨é€”RAIIRAII æ˜¯ Resource Acquisition Is Initialization çš„ç¼©å†™ï¼Œå³â€œèµ„æºè·å–å³åˆå§‹åŒ–â€ã€‚å®ƒæ˜¯ C++ è¯­è¨€çš„ä¸€ç§ç®¡ç†èµ„æºã€é¿å…èµ„æºæ³„æ¼çš„æƒ¯ç”¨æ³•ï¼Œåˆ©ç”¨æ ˆå¯¹è±¡è‡ªåŠ¨é”€æ¯çš„ç‰¹ç‚¹æ¥å®ç°ï¼Œå¯ä»¥é€šè¿‡æ„é€ å‡½æ•°è·å–èµ„æºï¼Œé€šè¿‡ææ„å‡½æ•°é‡Šæ”¾èµ„æº\n\nå°†æ¯ä¸€ç§èµ„æºå°è£…åœ¨ä¸€ä¸ª RAII ç±»ä¸­\næ‰€æœ‰èµ„æºåœ¨æ„é€ å‡½æ•°ä¸­è·å–ï¼Œä¾‹å¦‚ï¼šåˆ†é…å†…å­˜ã€æ‰“å¼€æ–‡ä»¶ã€å»ºç«‹æ•°æ®åº“è¿æ¥ç­‰ï¼›å¦‚æœæ— æ³•å®Œæˆåˆ™åœ¨æ„é€ å‡½æ•°ä¸­æŠ›å‡ºå¼‚å¸¸\næ‰€æœ‰èµ„æºåœ¨ææ„å‡½æ•°ä¸­é‡Šæ”¾ï¼Œä¾‹å¦‚ï¼šé‡Šæ”¾å†…å­˜ã€å…³é—­æ–‡ä»¶ã€é”€æ¯æ•°æ®åº“è¿æ¥ç­‰ï¼›ä¸åº”è¯¥æŠ›å‡ºä»»ä½•å¼‚å¸¸\n\n\né€šè¿‡ RAII ç±»å®ä¾‹è·å–èµ„æº\nå…·æœ‰è‡ªåŠ¨ç”Ÿå‘½ç®¡ç†å‘¨æœŸæˆ–ä¸´æ—¶å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ\nå…¶ç”Ÿå‘½å‘¨æœŸä¸ç¬¬ä¸€ç§ç»‘å®š\n\n\n\nä¸ºä»€ä¹ˆè¦ä½¿ç”¨ RAIIåœ¨ C++ ä¸­ï¼Œé€šè¿‡ new è¿ç®—ç¬¦åŠ¨æ€ç”³è¯·å†…å­˜ï¼Œä¾‹å¦‚ï¼š\nFoo* ptr = new Foo(1);// ...delete ptr;\n\nåœ¨è¿™æ®µä»£ç ä¸­ï¼Œnewè¿ç®—ç¬¦åœ¨è®¡ç®—æœºå†…å­˜çš„å †ä¸Šç”³è¯·äº†ä¸€å— Foo ç±»å‹çš„å†…å­˜ï¼Œç„¶åå°†å…¶åœ°å€èµ‹å€¼ç»™å­˜å‚¨åœ¨æ ˆä¸Šçš„æŒ‡é’ˆ ptrã€‚ä¸ºäº†èƒ½å¤Ÿé‡Šæ”¾å†…å­˜èµ„æºï¼Œéœ€è¦ä½¿ç”¨å®Œnew è¿ç®—ç¬¦ç”³è¯·çš„å†…å­˜åï¼Œæ‰‹åŠ¨è°ƒç”¨ delete è¿ç®—ç¬¦é‡Šæ”¾å†…å­˜ã€‚ä½†æ˜¯ï¼Œæƒ…å†µå¹¶ä¸æ€»æ˜¯å¦‚æ­¤ç®€å•\nFoo* ptr = new Foo(1);f(ptr);  // --&gt;â‘  may throw exceptionif(ptr-&gt;g()) {    // ... --&gt; â‘¡ may forget to delete ptr    return;}// ...delete ptr;\n\n\nå¿˜è®° delete é‡Šæ”¾å†…å­˜ã€‚æ¯”å¦‚é‡Šæ”¾åŸæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜å‰å°±æ”¹å˜äº†æŒ‡é’ˆçš„æŒ‡å‘\nç¨‹åºæŠ›å‡ºå¼‚å¸¸åå¯¼è‡´æ— æ³• deleteã€‚æ¯”å¦‚ä¸Šé¢çš„â‘ å¤„ï¼Œå¦‚æœf å‡½æ•°æŠ›å‡ºå¼‚å¸¸ï¼Œæ²¡æœ‰æœºä¼šè¿è¡Œdeleteï¼Œä»è€Œå¯¼è‡´å†…å­˜æ³„æ¼\néœ€æ±‚å˜æ›´åï¼Œä¿®æ”¹äº†å‡½æ•°ï¼Œæ–°å¢äº†åˆ†æ”¯ï¼Œæå‰è¿”å›ï¼Œâ‘¡å¤„å´æ²¡æœ‰delete\nç°å®æƒ…å†µä»£ç å¤æ‚çš„è¯å¯èƒ½æ²¡æœ‰è¿™ä¹ˆæ˜¾è€Œæ˜“è§\nè€Œé€šè¿‡ RAII è¿™æ ·ä¸€ç§æœºåˆ¶ï¼Œå¯ä»¥ä½¿å…¶è‡ªåŠ¨é‡Šæ”¾å†…å­˜\n\nC++ STL ä¸­ RAII çš„åº”ç”¨  æ™ºèƒ½æŒ‡é’ˆ  æ™ºèƒ½æŒ‡é’ˆæ˜¯ RAII çš„ä¸€ç§å®ç°ï¼Œå®ƒæ˜¯ä¸€ç§æ¨¡æ¿ç±»ï¼Œç”¨äºç®¡ç†åŠ¨æ€åˆ†é…çš„å¯¹è±¡ã€‚æ™ºèƒ½æŒ‡é’ˆçš„ä¸»è¦ä½œç”¨æ˜¯è‡ªåŠ¨é‡Šæ”¾å†…å­˜ï¼Œä»è€Œé¿å…å†…å­˜æ³„æ¼ã€‚C++ 11 ä¸­æä¾›äº†ä¸‰ç§æ™ºèƒ½æŒ‡é’ˆï¼šunique_ptrã€shared_ptrå’Œ weak_ptrã€‚ä»¥unique_ptr ä¸ºä¾‹ï¼Œå®ƒçš„æ„é€ å‡½æ•°å¦‚ä¸‹ï¼š\ntemplate&lt; class T, class Deleter = std::default_delete&lt;T&gt; &gt; class unique_ptr;\n\nunique_ptrçš„ææ„å‡½æ•°ä¼šè‡ªåŠ¨é‡Šæ”¾å†…å­˜ï¼Œå› æ­¤ï¼Œå¯ä»¥é€šè¿‡ unique_ptr æ¥ç®¡ç†åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œä»è€Œé¿å…å†…å­˜æ³„æ¼\n// release memory when ptr is out of scopestd::unique_ptr&lt;int&gt; ptr = std::make_unique&lt;int&gt;(1);\n\näº’æ–¥é”  åœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œstd::lock_guard, std::unique_lock, std::shared_lockç­‰ä¹Ÿåˆ©ç”¨äº† RAII çš„åŸç†ï¼Œç”¨äºç®¡ç†äº’æ–¥é”ã€‚å½“è¿™äº›ç±»çš„ç­‰å¯¹è±¡åˆ›å»ºæ—¶ï¼Œä¼šè‡ªåŠ¨è·å–äº’æ–¥é”ï¼›å½“å¯¹è±¡é”€æ¯æ—¶ï¼Œä¼šè‡ªåŠ¨é‡Šæ”¾äº’æ–¥é”\nstd::lock_guardçš„æ„é€ å‡½æ•°å¦‚ä¸‹ï¼š\ntemplate&lt; class Mutex &gt; class lock_guard;\n\nstd::lock_guardçš„ææ„å‡½æ•°ä¼šè‡ªåŠ¨é‡Šæ”¾äº’æ–¥é”ï¼Œå› æ­¤ï¼Œå¯ä»¥é€šè¿‡ std::lock_guard æ¥ç®¡ç†äº’æ–¥é”ï¼Œä»è€Œé¿å…å¿˜è®°é‡Šæ”¾äº’æ–¥é”\nstd::mutex mtx;std::lock_guard&lt;std::mutex&gt; lock(mtx); // unlock when lock is out of scope\n\nä¸ä½¿ç”¨ RAII çš„æƒ…å†µä¸‹ï¼Œéœ€è¦æ‰‹åŠ¨é‡Šæ”¾äº’æ–¥é”ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š\nstd::mutex mtx;mtx.lock();// ...mtx.unlock();\n\næ–‡ä»¶æ“ä½œ std::ifstream, std::ofstream ç­‰ C++ æ ‡å‡†åº“çš„ IO æ“ä½œéƒ½æ˜¯ RAII çš„å®ç°\näº‹åŠ¡å¤„ç†  æ•°æ®åº“äº‹åŠ¡å¤„ç†ä¸­ï¼Œå¦‚æœåœ¨äº‹åŠ¡ç»“æŸæ—¶æ²¡æœ‰æäº¤æˆ–å›æ»šï¼Œå°±ä¼šå¯¼è‡´æ•°æ®åº“è¿æ¥ä¸€ç›´è¢«å ç”¨ï¼Œä»è€Œå¯¼è‡´æ•°æ®åº“è¿æ¥æ± è€—å°½ã€‚å› æ­¤ï¼Œéœ€è¦åœ¨äº‹åŠ¡ç»“æŸæ—¶è‡ªåŠ¨æäº¤æˆ–å›æ»šï¼Œä»è€Œé‡Šæ”¾æ•°æ®åº“è¿æ¥ã€‚è¿™ä¸€è¿‡ç¨‹ä¹Ÿå¯ä»¥é€šè¿‡ RAII æ¥å®ç°\nC++ æ–°ç‰¹æ€§  æ™ºèƒ½æŒ‡é’ˆ  æ¨¡æ¿ typename å’Œclassçš„åŒºåˆ« typename ç‹¬æœ‰çš„åŠŸèƒ½  ç”±äº C++ å…è®¸åœ¨ç±»å†…å®šä¹‰ç±»å‹åˆ«åï¼Œä¸”å…¶ä½¿ç”¨æ–¹æ³•ä¸é€šè¿‡ç±»å‹åè®¿é—®ç±»æˆå‘˜çš„æ–¹æ³•ç›¸åŒã€‚æ•…è€Œï¼Œåœ¨ç±»å®šä¹‰ä¸å¯çŸ¥çš„æ—¶å€™ï¼Œç¼–è¯‘å™¨æ— æ³•çŸ¥æ™“ç±»ä¼¼ Type::foo çš„å†™æ³•å…·ä½“æŒ‡çš„æ˜¯ä¸€ä¸ªç±»å‹è¿˜æ˜¯ç±»å†…æˆå‘˜\nä¾‹å¦‚åœ¨ä»¥ä¸‹ä»£ç ä¸­ï¼Œç±»æ¨¡æ¿ Bar çš„åŸæ„æ˜¯ä½¿ç”¨ç±» Foo å®ä¾‹åŒ–ï¼Œè€Œåå¼•ç”¨å…¶ä¸­çš„ bar_type å®šä¹‰åä¸º bar çš„ç±»å†…æˆå‘˜ã€‚ç„¶è€Œï¼Œå°± T::bar_type è€Œè¨€ï¼Œç¼–è¯‘å™¨åœ¨ç¼–è¯‘æœŸæ— æ³•ç¡®å®šå®ƒç©¶ç«Ÿæ˜¯ä¸æ˜¯ä¸€ä¸ªç±»å‹ã€‚æ­¤æ—¶å°±éœ€è¦ typename å…³é”®å­—æ¥è¾…åŠ©ç¼–è¯‘å™¨çš„åˆ¤æ–­\nclass Foo {public:    typedef int bar_type;};template&lt;typename T&gt;class Bar{    /* typename */    T::bar_type bar;};\n\nclassç‹¬æœ‰çš„åŠŸèƒ½ C++ çš„æ ‡å‡†æ¨¡æ¿åº“ä¸­æœ‰åä¸ºstd::stack çš„å®¹å™¨é€‚é…å™¨ï¼Œå®ƒèƒ½é€‚é…è®¸å¤šå®¹å™¨ä½œä¸ºåº•å±‚ï¼Œå®ç°æ ˆçš„åŠŸèƒ½ã€‚å…¶å£°æ˜ä¸º\ntemplate &lt;typename T, typename Containter = std::deque&lt;T&gt; &gt;class stack;\n\nå› æ­¤ï¼Œåœ¨ä½¿ç”¨ä¸­ï¼Œå¯ä»¥ä½¿ç”¨ std::stack&lt;int&gt; æ¥å£°æ˜ä¸€ä¸ªä»¥ std::deque&lt;int&gt; ä¿å­˜æ•´å‹å˜é‡çš„æ ˆï¼›ä¹Ÿå¯ä»¥ä½¿ç”¨ std::stack&lt;int, std::vector&lt;int&gt; &gt;æ¥å£°æ˜ä¸€ä¸ªä»¥ std::vector&lt;int&gt; ä¿å­˜æ•´å‹å˜é‡çš„æ ˆã€‚æ˜¯å¦æœ‰å¯èƒ½ä»¥ç±»ä¼¼ Stack&lt;int, std::vector&gt;çš„å½¢å¼ï¼Œæ¥è¾¾åˆ°åŒæ ·çš„ç›®çš„ï¼Ÿéœ€è¦æœ‰ç±»ä¼¼è¿™æ ·çš„å£°æ˜\ntemplate &lt;typename T,    template &lt;typename E, typename = std::allocater&lt;E&gt; &gt; class Container = std::deque&gt;class Stack;\n\nç”±äº Container å¿…é¡»æ˜¯ä¸€ä¸ªå®¹å™¨ç±»æ¨¡æ¿ï¼Œæ‰€ä»¥ï¼Œå¦‚æœä¸é€‚ç”¨å…·ä½“çš„æ¨¡æ¿å‚æ•°å®ä¾‹åŒ–ï¼Œå°±å¿…é¡»å°†å…¶å£°æ˜ä¸ºä¸€ä¸ªç±»æ¨¡æ¿ã€‚æ•…æ­¤ï¼ŒContainerä¹‹å‰éœ€è¦ä¿ç•™æ ‡å‡†åº“ä¸­å®¹å™¨ç±»æ¨¡æ¿çš„æ¨¡æ¿å‚æ•°ã€‚æ³¨æ„æ­¤å¤„ä½¿ç”¨äº†æ ‡å‡†åº“æä¾›çš„å†…å­˜åˆ†é…å™¨\næ­¤å¤„ class ç‰¹æœ‰çš„åŠŸèƒ½ï¼Œä½“ç°åœ¨ class Container ä¹‹å¤„ã€‚æ­¤å¤„è™½ç„¶æ˜¯åœ¨å£°æ˜ Stack è¿™ä¸ªç±»æ¨¡æ¿ï¼Œä½†æ˜¯æ­¤å¤„çš„ class ä¸èƒ½æ›¿æ¢ä¸ºtypenameï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šæŠ¥é”™\n\næŒ‡å®š  æ¨¡æ¿æ¨¡æ¿  æ—¶ï¼Œå¿…é¡»ä½¿ç”¨ class å…³é”®å­—ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®ƒä¸èƒ½ä¸ typename äº’æ¢\n\næ¨¡æ¿æ³›åŒ–ã€ç‰¹åŒ–ã€åç‰¹åŒ–\næ¨¡æ¿ç‰¹åŒ–æŒ‰å¯¹è±¡ç±»å‹å¯åˆ†ä¸ºç±»æ¨¡æ¿ç‰¹åŒ–å’Œå…¨å±€æ¨¡æ¿å‡½æ•°å‡½æ•°ç‰¹åŒ–\næŒ‰ç‰¹åŒ–ç±»å‹å¯åˆ†ä¸ºå…¨ç‰¹åŒ–å’Œåç‰¹åŒ–\nåç‰¹åŒ–åŒ…æ‹¬èŒƒå›´åç‰¹åŒ–å’Œå‚æ•°æ•°é‡åç‰¹åŒ–\nå…¨å±€æ¨¡æ¿å‡½æ•°ä¸æ”¯æŒåç‰¹åŒ–ï¼Œå› ä¸ºå‡½æ•°æœ‰é‡è½½ï¼Œæ‰€ä»¥å‡½æ•°åç‰¹åŒ–éƒ½æ˜¯é‡è½½\n\n\nç‰¹åŒ–çš„ä¼˜å…ˆçº§é«˜äºæ³›åŒ–\nç¼–è¯‘å™¨ä¼šå…ˆå»åŒ¹é…ç‰¹åŒ–å’Œåç‰¹åŒ–ï¼Œåå»åŒ¹é…æ³›åŒ–\n\n\n\nç±»æ¨¡æ¿ç‰¹åŒ–template &lt;typename T1, typename T2&gt;class testFun {public:    testFun(T1 t1, T2 t2) : a(t1), b(t2)     {        cout &lt;&lt; \"ç±»æ¨¡æ¿\" &lt;&lt; endl;    }private:    T1 a;    T2 b;};// å…¨ç‰¹åŒ–template &lt;&gt;class testFun&lt;int, string&gt;{public:    testFun(int t1, string t2) : a(t1), b(t2)    {        cout &lt;&lt; \"å…¨ç‰¹åŒ–\" &lt;&lt; endl;    }private:    int a;    string b;};// å‚æ•°æ•°é‡åç‰¹åŒ–template &lt;typename T2&gt;class testFun&lt;int, T2&gt;{public:    testFun(int t1, T2 t2) : a(t1), b(t2)    {        cout &lt;&lt; \"å‚æ•°æ•°é‡åç‰¹åŒ–\" &lt;&lt; endl;    }private:    int a;    T2 b;}; template &lt;typename T1, typename T2&gt;class testFun&lt;T1*, T2*&gt;{public:    testFun(T1* t1, T2* t2) : a(t1), b(t2)    {        cout &lt;&lt; \"èŒƒå›´åç‰¹åŒ–ï¼ŒæŒ‡é’ˆåç‰¹åŒ–\" &lt;&lt; endl;    }private:    T1* a;    T2* b;}; template &lt;typename T1, typename T2&gt;class testFun&lt;T1 const, T2 const&gt;{public:    testFun(T1 t1, T2 t2) : a(t1), b(t2)    {        cout &lt;&lt; \"èŒƒå›´åç‰¹åŒ–ï¼Œconst åç‰¹åŒ–\" &lt;&lt; endl;    }private:    T1 a;    T2 b;};\n\nå‡½æ•°æ¨¡æ¿ç‰¹åŒ–// å‡½æ•°æ¨¡æ¿template&lt;typename T1, typename T2&gt;void testfun(T1 ta, T2 t2) {    cout &lt;&lt; \"æ¨¡æ¿å‡½æ•°\" &lt;&lt; endl;}// å…¨ç‰¹åŒ– 1ï¼Œä¼šè¢«é‡è½½ï¼Œé€€åŒ–ä¸ºåç‰¹åŒ–template&lt;&gt;void testfun(char ta, string t2) {    cout &lt;&lt; \"å…¨ç‰¹åŒ–\" &lt;&lt; endl;}// å…¨ç‰¹åŒ– 2ï¼Œä¸ä¼šè¢«é‡è½½template&lt;&gt;void testfun(int ta, string t2) {    cout &lt;&lt; \"å…¨ç‰¹åŒ–\" &lt;&lt; endl;}// åç‰¹åŒ–ï¼ˆé‡è½½ï¼‰template&lt;typename T2&gt;void testfun(int t1, T2 t2) {    cout &lt;&lt; \"åç‰¹åŒ–\" &lt;&lt; endl;}/* ä¸æ”¯æŒ const èŒƒå›´åç‰¹åŒ–template&lt;typename T1, typename T2&gt;void testfun(T1 const t1, T2 const t2) {    cout &lt;&lt; \"const åç‰¹åŒ–\" &lt;&lt; endl;}*/template&lt;typename T1, typename T2&gt;void testfun(T1* t1, T2* t2) {    cout &lt;&lt; \"æŒ‡é’ˆåç‰¹åŒ–\" &lt;&lt; endl;}\n","categories":["é¢è¯•"],"tags":["Unity","C#"]},{"title":"DIY æ‘†æ”¾","url":"/2024/05/31/52/","content":"åˆ†æ\n    \n\n\nç›¸å…³ç»†èŠ‚  è‡ªå®šä¹‰ç½‘æ ¼  åŸºç¡€ç½‘æ ¼\npublic class Grid&lt;T&gt;&#123;    public T[,] grids;    public Vector3 rotation; // ä¸º 0 æ—¶è¡¨ç¤ºåœ°é¢ï¼Œ63ï¼ˆarctan2ï¼‰æ—¶è¡¨ç¤ºå¢™é¢    public int width;    public int height;    private Vector3 cellSize; // ç½‘æ ¼å¤§å°ï¼Œç±»ä¼¼ unity ä¸­ tilemapï¼Œlayout è®¾ç½®ä¸º `isometric` ç±»å‹ï¼Œ(2, 1, 1) è¡¨ç¤ºæ¯ä¸ª cell çš„ width:height ä¸º 2:1    private Vector3 origin;&#125;\n\nç½‘æ ¼ç‰©ä»¶\npublic class GridObject&#123;    public int x, y;    private Grid&lt;GridObject&gt; grid;    public PlaceableObject PlaceableObject;    public bool CanBuild;    public GridObject(Grid&lt;GridObject&gt; grid, int x, int y)    &#123;        this.grid = grid;        this.x = x;        this.y = y;    &#125;&#125;\n\n\n    \n    \n\n\nå¯æ”¾ç½®ç‰©ä»¶public class PlaceableObject&#123;    public int depth; // è®°å½•ç‰©ä»¶çš„æ·±åº¦ï¼Œæ¯æœ‰ä¸€ä¸ªç‰©ä»¶è¢«æ”¾ç½®æ·±åº¦åŠ ä¸€    public Vector2Int offset; // ç›¸å¯¹äºç½‘æ ¼åŸç‚¹çš„åç§»    public Transform placedObjectTransform; // è´´å›¾ transform    public List&lt;Vector2Int&gt; GridPositions; // å æ®çš„ç½‘æ ¼å¤§å°    private List&lt;Grid&lt;GridObject&gt;&gt; grids; // ç‰©ä»¶ä¹Ÿæœ‰ç½‘æ ¼ï¼Œç”¨äºå †å &#125;\n\né®æŒ¡å’Œæ’åº\næ·±åº¦å€¼è¶Šå¤§çš„ï¼ˆå³è¢«æ”¾ç½®åˆ°å…¶ä»–ç‰©ä»¶ä¹‹ä¸Šï¼‰ï¼Œè¶Šé å‰\nç½‘æ ¼ç´¢å¼• (x, 0, z) è¶Šå°æ’åºè¶Šé å‰\nåœ°é¢çš„å¯ä»¥é®æŒ¡å¢™é¢çš„\n\nå·¥å…·\nå®šä¹‰å¯ç¼–è¾‘åœºæ™¯ï¼Œå¯¼å…¥ç›¸å…³èµ„æº\nç¼–è¾‘æ¨¡å¼\nç¼–è¾‘ç‰©ä»¶çš„ Placeable éƒ¨åˆ†\nç¼–è¾‘ç‰©ä»¶çš„ Grid éƒ¨åˆ†\nåˆ é™¤åŒºåŸŸ\n\n\nå“åº”åˆ©ç”¨å°„çº¿æ£€æµ‹é¼ æ ‡ä½ç½®ï¼Œåœ¨ä¸åŒç¼–è¾‘æ¨¡å¼ä¸‹ï¼Œå°†å±å¹•åæ ‡è½¬æˆä¸–ç•Œåæ ‡ï¼Œå†è½¬æ¢åˆ°ç½‘æ ¼åæ ‡\nå­˜å‚¨ç¼–è¾‘ç»“æœ\nåˆ©ç”¨ScriptableObjectã€Jsonã€äºŒè¿›åˆ¶ç­‰å­˜å‚¨æ–¹å¼è¿›è¡Œä¿å­˜\nåŠ è½½\n\n\n\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Unity","C#"]},{"title":"ProtoBuf çš„åŸºæœ¬åŸç†","url":"/2024/06/04/54/","content":"\nğŸ”— åŸæ–‡é“¾æ¥\n\nProtobuf æ˜¯ç”± Google è®¾è®¡çš„ä¸€ç§é«˜æ•ˆã€è½»é‡çº§çš„ä¿¡æ¯æè¿°æ ¼å¼ï¼Œèµ·åˆæ˜¯åœ¨ Google å†…éƒ¨ä½¿ç”¨ï¼Œåæ¥è¢«å¼€æ”¾å‡ºæ¥ï¼Œå®ƒå…·æœ‰è¯­è¨€ä¸­ç«‹ã€å¹³å°ä¸­ç«‹ã€é«˜æ•ˆã€å¯æ‰©å±•ç­‰ç‰¹æ€§ï¼Œå®ƒéå¸¸é€‚åˆç”¨æ¥åšæ•°æ®å­˜å‚¨ã€RPC æ•°æ®äº¤æ¢ç­‰ã€‚ä¸ jsonã€xml ç›¸æ¯”ï¼ŒProtobuf çš„ç¼–ç é•¿åº¦æ›´çŸ­ã€ä¼ è¾“æ•ˆç‡æ›´é«˜ï¼Œå…¶å®ä¸¥æ ¼æ„ä¹‰ä¸Šè®²ï¼Œjsonã€xml å¹¶éæ˜¯ä¸€ç§ã€Œç¼–ç ã€, è€Œåªèƒ½ç§°ä¹‹ä¸ºã€Œæ ¼å¼ã€, jsonã€xml çš„å†…å®¹æœ¬èº«éƒ½æ˜¯å­—ç¬¦å½¢å¼ï¼Œå®ƒä»¬çš„ç¼–ç é‡‡ç”¨çš„æ˜¯ ASCII ç¼–ç ï¼Œæœ¬æ–‡è®²è¿° Protobuf çš„åº•å±‚ç¼–ç åŸç†ï¼Œä»¥ä¾¿äºäº†è§£ Protobuf ä¸ºä»€ä¹ˆç¼–ç é•¿åº¦çŸ­å¹¶ä¸”æ‰©å±•æ€§å¼ºï¼Œä¸æ­¤åŒæ—¶æˆ‘ä»¬ä¹Ÿå°†äº†è§£åˆ°å®ƒæœ‰å“ªäº›ä¸è¶³Protobuf çš„ä¸€ä¸ªå…¸å‹åº”ç”¨åœºæ™¯ä¾¿æ˜¯åšé€šä¿¡çš„æ•°æ®äº¤æ¢æ ¼å¼ï¼Œå®ƒåœ¨é€šä¿¡ç®¡é“ä¸Šæ˜¯ä»¥çº¯äºŒè¿›åˆ¶çš„å½¢å¼è¿›è¡Œä¼ è¾“ï¼Œå‘é€ç«¯ä½¿ç”¨ç¼–ç å™¨å°†æ•°æ®åºåˆ—åŒ–ä¸ºäºŒè¿›åˆ¶ï¼Œæ¥æ”¶ç«¯ä½¿ç”¨è§£ç å™¨å°†æ”¶åˆ°çš„äºŒè¿›åˆ¶æµè¿›è¡Œååºåˆ—åŒ–ä»è€Œå–å¾—åŸå§‹ä¿¡æ¯ï¼Œå› æ­¤å½“å¯¹é€šä¿¡ç®¡é“è¿›è¡ŒæŠ“åŒ…æ—¶æ— æ³•è·çŸ¥æ•°æ®çš„è¯¦ç»†å†…å®¹ï¼Œäº‹å®ä¸Šï¼ŒåŒä¸€æ®µ Protobuf çš„äºŒè¿›åˆ¶æ•°æ®æµï¼Œåœ¨æ¥æ”¶ç«¯ä½¿ç”¨ä¸åŒçš„è§£ç æ ¼å¼è¿›è¡Œè§£ç ï¼Œå¯èƒ½å¾—åˆ°å®Œå…¨ä¸åŒçš„ä¿¡æ¯ã€‚åœ¨äº†è§£ Protobuf çš„åº•å±‚ç¼–ç ç»†èŠ‚ä¹‹å‰ï¼Œéœ€è¦é¦–å…ˆäº†è§£ Protobuf æ‰€ç”¨åˆ°çš„ä¸¤ç§ä¸»è¦çš„ç¼–ç æ–¹å¼ï¼Œå®ƒä»¬åˆ†åˆ«æ˜¯ Varints ç¼–ç å’Œ Zigzag ç¼–ç \n1.1 Varints ç¼–ç   é€šå¸¸æ¥è¯´ï¼Œæ™®é€šçš„ int æ•°æ®ç±»å‹ï¼Œæ— è®ºå…¶å€¼çš„å¤§å°ï¼Œæ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œè¿™ç‚¹å¯ä»¥å¼•èµ·äººä»¬çš„æ€è€ƒï¼Œæ˜¯å¦å¯ä»¥æ ¹æ®æ•°å€¼çš„å¤§å°æ¥åŠ¨æ€åœ°å ç”¨å­˜å‚¨ç©ºé—´ï¼Œä½¿å¾—å€¼æ¯”è¾ƒå°çš„æ•°å­—å ç”¨è¾ƒå°‘çš„å­—èŠ‚æ•°ï¼Œå€¼ç›¸å¯¹æ¯”è¾ƒå¤§çš„æ•°å­—å ç”¨è¾ƒå¤šçš„å­—èŠ‚æ•°ï¼Œè¿™ä¾¿æ˜¯å˜é•¿æ•´å‹ç¼–ç çš„åŸºæœ¬æ€æƒ³ï¼Œé‡‡ç”¨å˜é•¿æ•´å‹ç¼–ç çš„æ•°å­—ï¼Œå…¶å ç”¨çš„å­—èŠ‚æ•°ä¸æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œä¸ºäº†è¾¾åˆ°è¿™ä¸€ç‚¹ï¼ŒVarints ç¼–ç ä½¿ç”¨æ¯ä¸ªå­—èŠ‚çš„æœ€é«˜æœ‰æ•ˆä½ä½œä¸ºæ ‡å¿—ä½ï¼Œè€Œå‰©ä½™çš„ 7 ä½ä»¥äºŒè¿›åˆ¶è¡¥ç çš„å½¢å¼æ¥å­˜å‚¨æ•°å­—å€¼æœ¬èº«ï¼Œå½“æœ€é«˜æœ‰æ•ˆä½ä¸º 1 æ—¶ï¼Œä»£è¡¨å…¶åè¿˜è·Ÿæœ‰å­—èŠ‚ï¼Œå½“æœ€é«˜æœ‰æ•ˆä½ä¸º 0 æ—¶ï¼Œä»£è¡¨å·²ç»æ˜¯è¯¥æ•°å­—çš„æœ€åçš„ä¸€ä¸ªå­—èŠ‚ï¼Œåœ¨ Protobuf ä¸­ï¼Œä½¿ç”¨çš„æ˜¯ Base128 Varints ç¼–ç ï¼Œä¹‹æ‰€ä»¥å«è¿™ä¸ªåå­—åŸå› å³æ˜¯åœ¨è¿™ç§æ–¹å¼ä¸­ï¼Œä½¿ç”¨ 7 bit æ¥å­˜å‚¨æ•°å­—ï¼Œåœ¨ Protobuf ä¸­ï¼ŒBase128 Varints é‡‡ç”¨çš„æ˜¯å°ç«¯åºï¼Œå³æ•°å­—çš„ä½ä½å­˜æ”¾åœ¨é«˜åœ°å€ï¼Œä¸¾ä¾‹æ¥çœ‹ï¼Œå¯¹äºæ•°å­— 1, æˆ‘ä»¬å‡è®¾ int ç±»å‹å  4 ä¸ªå­—èŠ‚ï¼Œä»¥æ ‡å‡†çš„æ•´å‹å­˜å‚¨ï¼Œå…¶äºŒè¿›åˆ¶è¡¨ç¤ºåº”ä¸º\n00000000 00000000 00000000 00000001\nå¯è§ï¼Œåªæœ‰æœ€åä¸€ä¸ªå­—èŠ‚å­˜å‚¨äº†æœ‰æ•ˆæ•°å€¼ï¼Œå‰ 3 ä¸ªå­—èŠ‚éƒ½æ˜¯ 0, è‹¥é‡‡ç”¨ Varints ç¼–ç ï¼Œå…¶äºŒè¿›åˆ¶å½¢å¼ä¸º\n00000001\nå› ä¸ºå…¶æ²¡æœ‰åç»­å­—èŠ‚ï¼Œå› æ­¤å…¶æœ€é«˜æœ‰æ•ˆä½ä¸º 0, å…¶ä½™çš„ 7 ä½ä»¥è¡¥ç å½¢å¼å­˜æ”¾ 1, å†æ¯”å¦‚æ•°å­— 666, å…¶ä»¥æ ‡å‡†çš„æ•´å‹å­˜å‚¨ï¼Œå…¶äºŒè¿›åˆ¶è¡¨ç¤ºä¸º\n00000000 00000000 00000010 10011010\nè€Œé‡‡ç”¨ Varints ç¼–ç ï¼Œå…¶äºŒè¿›åˆ¶å½¢å¼ä¸º\n10011010 00000101\næˆ‘ä»¬å¯ä»¥å°è¯•æ¥å¤åŸä¸€ä¸‹ä¸Šé¢è¿™ä¸ª Base128 Varints ç¼–ç çš„äºŒè¿›åˆ¶ä¸²ï¼Œé¦–å…ˆçœ‹æœ€é«˜æœ‰æ•ˆä½ï¼Œé«˜ 8 ä½çš„æœ€é«˜æœ‰æ•ˆä½ä¸º 1, ä»£è¡¨å…¶åè¿˜è·Ÿæœ‰æœ‰æ•ˆå­—èŠ‚ï¼Œä½ 8 ä½çš„æœ€é«˜æœ‰æ•ˆä½ä¸º 0, ä»£è¡¨å…¶å·²æ˜¯æœ€åä¸€ä¸ªå­—èŠ‚ï¼Œç”±äº Protobuf é‡‡ç”¨å°ç«¯å­—èŠ‚åºå­˜å‚¨æ•°æ®ï¼Œå› æ­¤æˆ‘ä»¬ç§»é™¤ä¸¤ä¸ªå­—èŠ‚çš„æœ€é«˜æœ‰æ•ˆä½ï¼Œå¹¶äº¤æ¢å­—èŠ‚åºä¾¿å¾—åˆ°\n1010011010\nè½¬æ¢ä¸ºåè¿›åˆ¶ï¼Œå³æ˜¯æ•°å­— 666\nä»ä¸Šé¢çš„ç¼–ç è§£ç è¿‡ç¨‹å¯ä»¥çœ‹å‡ºï¼Œå¯å˜é•¿æ•´å‹ç¼–ç å¯¹äºä¸åŒå¤§å°çš„æ•°å­—ï¼Œå…¶æ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´æ˜¯ä¸åŒçš„ï¼Œç¼–ç æ€æƒ³ä¸ CPU çš„é—´æ¥å¯»å€åŸç†ç›¸ä¼¼ï¼Œéƒ½æ˜¯ç”¨ä¸€æ¯”ç‰¹æ¥æ ‡è¯†æ˜¯å¦èµ°åˆ°æœ«å°¾ï¼Œä½†é‡‡ç”¨è¿™ç§æ–¹å¼å­˜å‚¨æ•°å­—ï¼Œä¹Ÿæœ‰ä¸€ä¸ªç›¸å¯¹ä¸å¥½çš„ç‚¹ä¾¿æ˜¯ï¼Œæ— æ³•å¯¹ä¸€ä¸ªåºåˆ—çš„æ•°å€¼è¿›è¡ŒéšæœºæŸ¥æ‰¾ï¼Œå› ä¸ºæ¯ä¸ªæ•°å­—æ‰€å ç”¨çš„å­˜å‚¨ç©ºé—´ä¸æ˜¯ç­‰é•¿çš„ï¼Œå› æ­¤è‹¥è¦è·å¾—åºåˆ—ä¸­çš„ç¬¬ N ä¸ªæ•°å­—ï¼Œæ— æ³•åƒç­‰é•¿å­˜å‚¨é‚£æ ·åœ¨æŸ¥æ‰¾ä¹‹å‰ç›´æ¥è®¡ç®—å‡º Offset, åªèƒ½ä»å¤´å¼€å§‹é¡ºåºæŸ¥æ‰¾\n1.2 Zigzag ç¼–ç Varints ç¼–ç çš„å®è´¨åœ¨äºå»æ‰æ•°å­—å¼€å¤´çš„ 0, å› æ­¤å¯ç¼©çŸ­æ•°å­—æ‰€å çš„å­˜å‚¨å­—èŠ‚æ•°ï¼Œåœ¨ä¸Šé¢çš„ä¾‹å­ä¸­ï¼Œæˆ‘ä»¬åªä¸¾ä¾‹è¯´æ˜äº†æ­£æ•°çš„ Varints ç¼–ç ï¼Œä½†å¦‚æœæ•°å­—ä¸ºè´Ÿæ•°ï¼Œåˆ™é‡‡ç”¨ Varints ç¼–ç ä¼šæ’å®šå ç”¨ 10 ä¸ªå­—èŠ‚ï¼ŒåŸå› åœ¨äºè´Ÿæ•°çš„ç¬¦å·ä½ä¸º 1, å¯¹äºè´Ÿæ•°å…¶ä»ç¬¦å·ä½å¼€å§‹çš„é«˜ä½å‡ä¸º 1, åœ¨ Protobuf çš„å…·ä½“å®ç°ä¸­ï¼Œä¼šå°†æ­¤è§†ä¸ºä¸€ä¸ªå¾ˆå¤§çš„æ— ç¬¦å·æ•°ï¼Œä»¥ Go è¯­è¨€çš„å®ç°ä¸ºä¾‹ï¼Œå¯¹äº int32 ç±»å‹çš„ pb å­—æ®µï¼Œå¯¹äºå¦‚ä¸‹å®šä¹‰çš„ proto\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 a = 1;&#125;\nRequest ä¸­åŒ…å«ç±»å‹ä¸º int32 ç±»å‹çš„å­—æ®µï¼Œå½“ a ä¸ºè´Ÿæ•°æ—¶ï¼Œå…¶åºåˆ—åŒ–ä¹‹åå°†æ’å®šå ç”¨ 10 ä¸ªå­—èŠ‚ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¦‚ä¸‹çš„æµ‹è¯•ä»£ç \nfunc main() &#123;    a := pbTest.Request&#123;        A: -5,    &#125;    bytes, err := proto.Marshal(&amp;a)    if err != nil &#123;        fmt.Println(err)        return    &#125;    fmt.Println(fmt.Sprintf(&quot;%08b&quot;, bytes))&#125;\nå¯¹äº int32 ç±»å‹çš„æ•°å­— -5, å…¶åºåˆ—åŒ–ä¹‹åçš„äºŒè¿›åˆ¶ä¸º\n\n    \n\n\nç©¶å…¶åŸå› åœ¨äº Protobuf çš„å†…éƒ¨å°† int32 ç±»å‹çš„è´Ÿæ•°è½¬æ¢ä¸º uint64 æ¥å¤„ç†ï¼Œè½¬æ¢åçš„ uint64 æ•°å€¼çš„é«˜ä½å…¨ä¸º 1, ç›¸å½“äºæ˜¯ä¸€ä¸ª 8 å­—èŠ‚çš„å¾ˆå¤§çš„æ— ç¬¦å·æ•°ï¼Œå› æ­¤é‡‡ç”¨ Base128 Varints ç¼–ç åå°†æ’å®šå ç”¨ 10 ä¸ªå­—èŠ‚çš„ç©ºé—´ï¼Œå¯è§ Varints ç¼–ç å¯¹äºè¡¨ç¤ºè´Ÿæ•°æ¯«æ— ä¼˜åŠ¿ï¼Œç”šè‡³æ¯”æ™®é€šçš„å›ºå®š 32 ä½å­˜å‚¨è¿˜è¦å¤šå  4 ä¸ªå­—èŠ‚ã€‚Varints ç¼–ç çš„å®è´¨åœ¨äºè®¾æ³•ç§»é™¤æ•°å­—å¼€å¤´çš„ 0 æ¯”ç‰¹ï¼Œè€Œå¯¹äºè´Ÿæ•°ï¼Œç”±äºå…¶æ•°å­—é«˜ä½éƒ½æ˜¯ 1, å› æ­¤ Varints ç¼–ç åœ¨æ­¤åœºæ™¯ä¸‹å¤±æ•ˆï¼ŒZigzag ç¼–ç ä¾¿æ˜¯ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒZigzag ç¼–ç çš„å¤§è‡´æ€æƒ³æ˜¯é¦–å…ˆå¯¹è´Ÿæ•°åšä¸€æ¬¡å˜æ¢ï¼Œå°†å…¶æ˜ å°„ä¸ºä¸€ä¸ªæ­£æ•°ï¼Œå˜æ¢ä»¥åä¾¿å¯ä»¥ä½¿ç”¨ Varints ç¼–ç è¿›è¡Œå‹ç¼©ï¼Œè¿™é‡Œå…³é”®çš„ä¸€ç‚¹åœ¨äºå˜æ¢çš„ç®—æ³•ï¼Œé¦–å…ˆç®—æ³•å¿…é¡»æ˜¯å¯é€†çš„ï¼Œå³å¯ä»¥æ ¹æ®å˜æ¢åçš„å€¼è®¡ç®—å‡ºåŸå§‹å€¼ï¼Œå¦åˆ™å°±æ— æ³•è§£ç ï¼ŒåŒæ—¶è¦æ±‚å˜æ¢ç®—æ³•è¦å°½å¯èƒ½ç®€å•ï¼Œä»¥é¿å…å½±å“ Protobuf ç¼–ç ã€è§£ç çš„é€Ÿåº¦ï¼Œæˆ‘ä»¬å‡è®¾ n æ˜¯ä¸€ä¸ª 32 ä½ç±»å‹çš„æ•°å­—ï¼Œåˆ™ Zigzag ç¼–ç çš„è®¡ç®—æ–¹å¼ä¸º\n(n &lt;&lt; 1) ^ (n &gt;&gt; 31)\nè¦æ³¨æ„è¿™é‡Œå·¦è¾¹æ˜¯é€»è¾‘ç§»ä½ï¼Œå³è¾¹æ˜¯ç®—æœ¯ç§»ä½ï¼Œå³è¾¹çš„å«ä¹‰å®é™…æ˜¯å¾—åˆ°ä¸€ä¸ªå…¨ 1 ï¼ˆå¯¹äºè´Ÿæ•°ï¼‰ æˆ–å…¨ 0 ï¼ˆå¯¹äºæ­£æ•°ï¼‰çš„æ¯”ç‰¹åºåˆ—ï¼Œå› ä¸ºå¯¹äºä»»æ„ä¸€ä¸ªä½æ•°ä¸º Î· çš„æœ‰ç¬¦å·æ•° n, å…¶æœ€é«˜ä½ä¸ºç¬¦å·ä½ï¼Œå‰©ä¸‹çš„ Î· - 1 ä½ä¸ºæ•°å­—ä½ï¼Œå°†å…¶ç®—æœ¯å³ç§» Î· - 1 ä½ï¼Œç”±äºæ˜¯ç®—æœ¯ç§»ä½ï¼Œå› æ­¤å³ç§»æ—¶å·¦è¾¹äº§ç”Ÿçš„ç©ºä½å°†ç”±ç¬¦å·ä½æ¥å¡«å……ï¼Œè¿›è¡Œ Î· - 1 æ¬¡ç®—æœ¯å³ç§»ä¹‹åä¾¿å¾—åˆ° Î· ä½ä¸åŸå…ˆçš„ç¬¦å·ä½ç›¸ç­‰çš„åºåˆ—ï¼Œç„¶åå¯¹ä¸¤è¾¹æŒ‰ä½å¼‚æˆ–ä¾¿å¾—åˆ° Zigzag ç¼–ç ï¼Œæˆ‘ä»¬ç”¨ä¸€ä¸ªå›¾ç¤ºæ¥ç›´è§‚åœ°è¯´æ˜ Zigzag ç¼–ç çš„è®¾è®¡æ€æƒ³ï¼Œä¸ºäº†ç®€åŒ–ï¼Œæˆ‘ä»¬å‡å®šæ•°å­—æ˜¯ 16 ä½çš„ï¼Œå…ˆæ¥çœ‹è´Ÿæ•°çš„æƒ…å½¢ï¼Œå‡è®¾æ•°å­—ä¸º -5, å…¶åœ¨å†…å­˜ä¸­çš„å½¢å¼ä¸º\n11111111 11111011\né¦–å…ˆå¯¹å…¶è¿›è¡Œä¸€æ¬¡é€»è¾‘å·¦ç§»ï¼Œç§»ä½åç©ºå‡ºçš„æ¯”ç‰¹ä½ç”± 0 å¡«å……\n11111111 11110110\nç„¶åå¯¹åŸæ•°å­—è¿›è¡Œ 15 æ¬¡ç®—æœ¯å³ç§»ï¼Œå¾—åˆ° 16 ä½å…¨ä¸ºåŸç¬¦å·ä½ï¼ˆå³ 1) çš„æ•°å­—\n11111111 11111111\nç„¶åå¯¹é€»è¾‘ç§»ä½å’Œç®—æœ¯ç§»ä½çš„ç»“æœæŒ‰ä½å¼‚æˆ–ï¼Œä¾¿å¾—åˆ°æœ€ç»ˆçš„ Zigzag ç¼–ç \n00000000 00001001\nå¯ä»¥çœ‹åˆ°ï¼Œå¯¹è´Ÿæ•°ä½¿ç”¨ Zigzag ç¼–ç ä»¥åï¼Œå…¶é«˜ä½çš„ 1 å…¨éƒ¨å˜æˆäº† 0, è¿™æ ·ä»¥æ¥æˆ‘ä»¬ä¾¿å¯ä»¥ä½¿ç”¨ Varints ç¼–ç è¿›è¡Œè¿›ä¸€æ­¥åœ°å‹ç¼©ï¼Œå†æ¥çœ‹æ­£æ•°çš„æƒ…å½¢ï¼Œå¯¹äº 16 ä½çš„æ­£æ•° 5, å…¶åœ¨å†…å­˜ä¸­çš„å­˜å‚¨å½¢å¼ä¸º\n00000000 00000101\næˆ‘ä»¬æŒ‰ç…§ä¸è´Ÿæ•°ç›¸åŒçš„å¤„ç†æ–¹æ³•ï¼Œå¯ä»¥å¾—åˆ°å…¶ Zigzag ç¼–ç ä¸º\n00000000 00001010\nä»ä¸Šé¢çš„ç»“æœæ¥çœ‹ï¼Œæ— è®ºæ˜¯æ­£æ•°è¿˜æ˜¯è´Ÿæ•°ï¼Œç»è¿‡ Zigzag ç¼–ç ä»¥åï¼Œæ•°å­—é«˜ä½éƒ½æ˜¯ 0, è¿™æ ·ä»¥æ¥ï¼Œä¾¿å¯ä»¥è¿›ä¸€æ­¥ä½¿ç”¨ Varints ç¼–ç è¿›è¡Œæ•°æ®å‹ç¼©ï¼Œå³ Zigzag ç¼–ç åœ¨ Protobuf ä¸­å¹¶ä¸å•ç‹¬ä½¿ç”¨ï¼Œè€Œæ˜¯é…åˆ Varints ç¼–ç å…±åŒæ¥è¿›è¡Œæ•°æ®å‹ç¼©ï¼ŒGoogle åœ¨ Protobuf çš„å®˜æ–¹æ–‡æ¡£ä¸­å†™é“ï¼šGoogle ProtobufIf you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long â€“ it is, effectively, treated like a very large unsigned integer. If you use one of the signed types, the resulting varint uses ZigZag encoding, which is much more efficient.\nåœ¨ä¸Šé¢çš„è®¨è®ºä¸­ï¼Œæˆ‘ä»¬äº†è§£äº† Protobuf æ‰€ä½¿ç”¨çš„ Varints ç¼–ç å’Œ Zigzag ç¼–ç çš„ç¼–ç åŸç†ï¼Œæœ¬èŠ‚æˆ‘ä»¬æ¥è®¨è®º Protobuf çš„æ•°æ®ç»„ç»‡æ–¹å¼ï¼Œé¦–å…ˆæ¥çœ‹ä¸€ä¸ªä¾‹å­ï¼Œå‡è®¾å®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯ä½¿ç”¨ protobuf ä½œä¸ºæ•°æ®äº¤æ¢æ ¼å¼ï¼Œproto çš„å…·ä½“å®šä¹‰ä¸º\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 age = 1;&#125;\nRequest ä¸­åŒ…å«äº†ä¸€ä¸ªåç§°ä¸º name çš„å­—æ®µï¼Œå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯åŒæ–¹éƒ½ç”¨åŒä¸€ä»½ç›¸åŒçš„ proto æ–‡ä»¶æ˜¯æ²¡æœ‰ä»»ä½•é—®é¢˜çš„ï¼Œå‡è®¾å®¢æˆ·ç«¯è‡ªå·±å°† proto æ–‡ä»¶åšäº†ä¿®æ”¹ï¼Œä¿®æ”¹åçš„ proto æ–‡ä»¶å¦‚ä¸‹\nsyntax = &quot;proto3&quot;;package pbTest;message Request &#123;    int32 age_test = 1;&#125;\nåœ¨è¿™ç§æƒ…å½¢ä¸‹ï¼ŒæœåŠ¡ç«¯ä¸ä¿®æ”¹åº”ç”¨ç¨‹åºä»èƒ½å¤Ÿæ­£ç¡®åœ°è§£ç ï¼ŒåŸå› åœ¨äºåºåˆ—åŒ–åçš„ Protobuf æ²¡æœ‰ä½¿ç”¨å­—æ®µåç§°ï¼Œè€Œä»…ä»…é‡‡ç”¨äº†å­—æ®µç¼–å·ï¼Œä¸ json xml ç­‰ç›¸æ¯”ï¼ŒProtobuf ä¸æ˜¯ä¸€ç§å®Œå…¨è‡ªæè¿°çš„åè®®æ ¼å¼ï¼Œå³æ¥æ”¶ç«¯åœ¨æ²¡æœ‰ proto æ–‡ä»¶å®šä¹‰çš„å‰æä¸‹æ˜¯æ— æ³•è§£ç ä¸€ä¸ª protobuf æ¶ˆæ¯ä½“çš„ï¼Œä¸æ­¤ç›¸å¯¹çš„ï¼Œjson xml ç­‰åè®®æ ¼å¼æ˜¯å®Œå…¨è‡ªæè¿°çš„ï¼Œæ‹¿åˆ°äº† json æ¶ˆæ¯ä½“ï¼Œä¾¿å¯ä»¥çŸ¥é“è¿™æ®µæ¶ˆæ¯ä½“ä¸­æœ‰å“ªäº›å­—æ®µï¼Œæ¯ä¸ªå­—æ®µçš„å€¼åˆ†åˆ«æ˜¯ä»€ä¹ˆï¼Œå…¶å®å¯¹äºå®¢æˆ·ç«¯å’ŒæœåŠ¡ç«¯é€šä¿¡åŒæ–¹æ¥è¯´ï¼Œçº¦å®šå¥½äº†æ¶ˆæ¯æ ¼å¼ä¹‹åå®Œå…¨æ²¡æœ‰å¿…è¦åœ¨æ¯ä¸€æ¡æ¶ˆæ¯ä¸­éƒ½æºå¸¦å­—æ®µåç§°ï¼ŒProtobuf åœ¨é€šä¿¡æ•°æ®ä¸­ç§»é™¤å­—æ®µåç§°ï¼Œè¿™å¯ä»¥å¤§å¤§é™ä½æ¶ˆæ¯çš„é•¿åº¦ï¼Œæé«˜é€šä¿¡æ•ˆç‡ï¼ŒProtobuf è¿›ä¸€æ­¥å°†é€šä¿¡çº¿è·¯ä¸Šæ¶ˆæ¯ç±»å‹åšäº†åˆ’åˆ†ï¼Œå¦‚ä¸‹è¡¨æ‰€ç¤º\n\n    \n\n\nå¯¹äº int32, int64, uint32 ç­‰æ•°æ®ç±»å‹åœ¨åºåˆ—åŒ–ä¹‹åéƒ½ä¼šè½¬ä¸º Varints ç¼–ç ï¼Œé™¤å»ä¸¤ç§å·²æ ‡è®°ä¸º deprecated çš„ç±»å‹ï¼Œç›®å‰ Protobuf åœ¨åºåˆ—åŒ–ä¹‹åçš„æ¶ˆæ¯ç±»å‹ (wire-type) æ€»å…±æœ‰ 4 ç§ï¼ŒProtobuf é™¤äº†å­˜å‚¨å­—æ®µçš„å€¼ä¹‹å¤–ï¼Œè¿˜å­˜å‚¨äº†å­—æ®µçš„ç¼–å·ä»¥åŠå­—æ®µåœ¨é€šä¿¡çº¿è·¯ä¸Šçš„æ ¼å¼ç±»å‹ (wire-type), å…·ä½“çš„å­˜å‚¨æ–¹å¼ä¸º\nfield_num &lt;&lt; 3 | wire type\nå³å°†å­—æ®µæ ‡å·é€»è¾‘å·¦ç§» 3 ä½ï¼Œç„¶åä¸è¯¥å­—æ®µçš„ wire type çš„ç¼–å·æŒ‰ä½æˆ–ï¼Œåœ¨ä¸Šè¡¨ä¸­å¯ä»¥çœ‹åˆ°ï¼Œwire type æ€»å…±æœ‰ 6 ç§ç±»å‹ï¼Œå› æ­¤å¯ä»¥ç”¨ 3 ä½äºŒè¿›åˆ¶æ¥æ ‡è¯†ï¼Œæ‰€ä»¥ä½ 3 ä½å®é™…ä¸Šå­˜å‚¨äº†å…¶åæ‰€è·Ÿçš„æ•°æ®çš„ wire type, æ¥æ”¶ç«¯å¯ä»¥åˆ©ç”¨è¿™äº›ä¿¡æ¯ï¼Œç»“åˆ proto æ–‡ä»¶æ¥è§£ç æ¶ˆæ¯ç»“æ„ä½“ï¼Œæˆ‘ä»¬ä»¥ä¸Šé¢ proto ä¸ºä¾‹æ¥çœ‹ä¸€æ®µ Protobuf å®é™…åºåˆ—åŒ–ä¹‹åçš„å®Œæ•´äºŒè¿›åˆ¶æ•°æ®ï¼Œå‡è®¾ age ä¸º 5, ç”±äº age åœ¨ proto æ–‡ä»¶ä¸­å®šä¹‰çš„æ˜¯ int32 ç±»å‹ï¼Œå› æ­¤åºåˆ—åŒ–ä¹‹åå®ƒçš„ wire type ä¸º 0, å…¶å­—æ®µç¼–å·ä¸º 1, å› æ­¤æŒ‰ç…§ä¸Šé¢çš„è®¡ç®—æ–¹å¼ï¼Œå³ 1 &lt;&lt; 3 | 0, æ‰€ä»¥å…¶ç±»å‹å’Œå­—æ®µç¼–å·çš„ä¿¡æ¯åªå  1 ä¸ªå­—èŠ‚ï¼Œå³ 00001000, åé¢è·Ÿä¸Šå­—æ®µå€¼ 5 çš„ Varints ç¼–ç ï¼Œæ‰€ä»¥æ•´ä¸ªç»“æ„ä½“åºåˆ—åŒ–ä¹‹åä¸º\n\n    \n\n\næœ‰äº†å­—æ®µç¼–å·å’Œ wire type, å…¶åæ‰€è·Ÿçš„æ•°æ®çš„é•¿åº¦ä¾¿æ˜¯ç¡®å®šçš„ï¼Œå› æ­¤ Protobuf æ˜¯ä¸€ç§éå¸¸ç´§å¯†çš„æ•°æ®ç»„ç»‡æ ¼å¼ï¼Œå…¶ä¸éœ€è¦ç‰¹åˆ«åœ°åŠ å…¥é¢å¤–çš„åˆ†éš”ç¬¦æ¥åˆ†å‰²ä¸€ä¸ªæ¶ˆæ¯å­—æ®µï¼Œè¿™å¯å¤§å¤§æå‡é€šä¿¡çš„æ•ˆç‡ï¼Œè§„é¿å†—ä½™çš„æ•°æ®ä¼ è¾“\n1.4 æ€»ç»“\nProtobuf æ˜¯ä¸€ç§é«˜æ•ˆçš„æ•°æ®æè¿°æ ¼å¼ï¼Œå…·æœ‰å¹³å°æ— å…³ã€è¯­è¨€æ— å…³ã€å¯æ‰©å±•ç­‰ç‰¹ç‚¹ï¼Œé€‚åˆåšæ•°æ®å­˜å‚¨ã€RPC çš„é€šä¿¡åè®®ç­‰åœºæ™¯\nProtobuf é‡‡ç”¨ Varints ç¼–ç å’Œ Zigzag ç¼–ç æ¥ç¼–ç æ•°æ®ï¼Œå…¶ä¸­ Varints ç¼–ç çš„æ€æƒ³æ˜¯ç§»é™¤æ•°å­—é«˜ä½çš„ 0, ç”¨å˜é•¿çš„äºŒè¿›åˆ¶ä½æ¥æè¿°ä¸€ä¸ªæ•°å­—ï¼Œå¯¹äºå°æ•°å­—ï¼Œå…¶ç¼–ç é•¿åº¦çŸ­ï¼Œå¯æé«˜æ•°æ®ä¼ è¾“æ•ˆç‡ï¼Œä½†ç”±äºå®ƒåœ¨æ¯ä¸ªå­—èŠ‚çš„æœ€é«˜ä½é¢å¤–é‡‡ç”¨äº†ä¸€ä¸ªæ ‡å¿—ä½æ¥æ ‡è®°å…¶åæ˜¯å¦è¿˜è·Ÿæœ‰æœ‰æ•ˆå­—èŠ‚ï¼Œå› æ­¤å¯¹äºå¤§çš„æ­£æ•°ï¼Œå®ƒä¼šæ¯”ä½¿ç”¨æ™®é€šçš„å®šé•¿æ ¼å¼å ç”¨æ›´å¤šçš„ç©ºé—´ï¼Œå¦å¤–å¯¹äºè´Ÿæ•°ï¼Œç›´æ¥é‡‡ç”¨ Varints ç¼–ç å°†æ’å®šå ç”¨ 10 ä¸ªå­—èŠ‚ï¼ŒZigzag ç¼–ç å¯å°†è´Ÿæ•°æ˜ å°„ä¸ºæ— ç¬¦å·çš„æ­£æ•°ï¼Œç„¶åé‡‡ç”¨ Varints ç¼–ç è¿›è¡Œæ•°æ®å‹ç¼©ï¼Œåœ¨å„ç§è¯­è¨€çš„ Protobuf å®ç°ä¸­ï¼Œå¯¹äº int32 ç±»å‹çš„æ•°æ®ï¼ŒProtobuf éƒ½ä¼šè½¬ä¸º uint64 è€Œåä½¿ç”¨ Varints ç¼–ç æ¥å¤„ç†ï¼Œå› æ­¤å½“å­—æ®µå¯èƒ½ä¸ºè´Ÿæ•°æ—¶ï¼Œæˆ‘ä»¬åº”ä½¿ç”¨ sint32 æˆ– sint64, è¿™æ · Protobuf ä¼šæŒ‰ç…§ Zigzag ç¼–ç å°†æ•°æ®å˜æ¢åå†é‡‡ç”¨ Varints ç¼–ç è¿›è¡Œå‹ç¼©ï¼Œä»è€Œç¼©çŸ­æ•°æ®çš„äºŒè¿›åˆ¶ä½æ•°\nProtobuf ä¸æ˜¯å®Œå…¨è‡ªæè¿°çš„ä¿¡æ¯æè¿°æ ¼å¼ï¼Œæ¥æ”¶ç«¯éœ€è¦æœ‰ç›¸åº”çš„è§£ç å™¨ï¼ˆå³ proto å®šä¹‰ï¼‰æ‰å¯è§£ææ•°æ®æ ¼å¼ï¼Œåºåˆ—åŒ–åçš„ Protobuf æ•°æ®ä¸æºå¸¦å­—æ®µåï¼Œåªä½¿ç”¨å­—æ®µç¼–å·æ¥æ ‡è¯†ä¸€ä¸ªå­—æ®µï¼Œå› æ­¤æ›´æ”¹ proto çš„å­—æ®µåä¸ä¼šå½±å“æ•°æ®è§£æï¼ˆä½†è¿™æ˜¾ç„¶ä¸æ˜¯ä¸€ç§å¥½çš„è¡Œä¸ºï¼‰, å­—æ®µç¼–å·ä¼šè¢«ç¼–ç è¿›äºŒè¿›åˆ¶çš„æ¶ˆæ¯ç»“æ„ä¸­ï¼Œå› æ­¤æˆ‘ä»¬åº”å°½å¯èƒ½åœ°ä½¿ç”¨å°å­—æ®µç¼–å·\nProtobuf æ˜¯ä¸€ç§ç´§å¯†çš„æ¶ˆæ¯ç»“æ„ï¼Œç¼–ç åå­—æ®µä¹‹é—´æ²¡æœ‰é—´éš”ï¼Œæ¯ä¸ªå­—æ®µå¤´ç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šå­—æ®µç¼–å·å’Œ wire type, å­—æ®µå¤´å¯ç¡®å®šæ•°æ®æ®µçš„é•¿åº¦ï¼Œå› æ­¤å…¶å­—æ®µä¹‹å‰æ— éœ€åŠ å…¥é—´éš”ï¼Œä¹Ÿæ— éœ€å¼•å…¥ç‰¹å®šçš„æ•°æ®æ¥æ ‡è®°å­—æ®µæœ«å°¾ï¼Œå› æ­¤ Protobuf çš„ç¼–ç é•¿åº¦çŸ­ï¼Œä¼ è¾“æ•ˆç‡é«˜\n\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["proto"]},{"title":"Unreal åŸºç¡€","url":"/2024/06/10/56/","content":"UPROPERTY()å’ŒUFUNCTION()UPROPERTY()\nBlueprintCallableï¼šå¯ä»¥åœ¨è“å›¾ä¸­è¢«è°ƒç”¨\nBlueprintReadOnlyï¼šå¯ä»¥è¢«è“å›¾è¯»å–ï¼Œä½†æ˜¯ä¸å¯è¢«ä¿®æ”¹\nBlueprintReadWriteï¼šå¯ä»¥è¢«è“å›¾è¯»å–å’Œä¿®æ”¹\nCategoryï¼šä¸ºå±æ€§æ·»åŠ åˆ†ç±»æ ‡ç­¾\nEditAnywhereï¼šè¯¥å±æ€§å¯ä»¥åœ¨å±æ€§çª—å£ä¸­ä¿®æ”¹\nEditDefaultOnlyï¼šå¯ä»¥åœ¨å±æ€§çª—å£ä¸­ä¿®æ”¹ï¼Œä½†æ˜¯åªèƒ½åœ¨åŸºç±»çš„å±æ€§çª—å£ä¿®æ”¹\nVisibleAnywhereï¼šå¯ä»¥åœ¨å±æ€§çª—å£çœ‹è§ï¼Œä½†æ˜¯ä¸å¯ä¿®æ”¹\nVisibleDefaultsOnlyï¼šè¯¥å±æ€§åªå¯åœ¨åŸºç±»çš„å±æ€§çª—å£ä¸­çœ‹è§è€Œä¸”ä¸å¯ä¿®æ”¹\nMetaï¼šå¯ä»¥ç”¨æ¥è®¾ç½®ä¸€äº›å…ƒæ•°æ®ï¼Œå¦‚æ–‡æ¡£ã€å…³é”®å­—ç­‰ï¼Œmeta=(AllowPrivateAccess=&quot;true&quot;) å…è®¸ç§æœ‰å±æ€§åœ¨ç¼–è¾‘å™¨ä¸­è¿›è¡Œç¼–è¾‘\nTransientï¼šè¯¥å±æ€§ä¸ä¼šè¢«åºåˆ—åŒ–ä¿å­˜ï¼Œé€šå¸¸ç”¨äºä¸´æ—¶æ•°æ®æˆ–ä¸å¸Œæœ›è¢«ä¿å­˜çš„æ•°æ®\nReplicatedï¼šå±æ€§åœ¨ç½‘ç»œä¸­è¿›è¡Œå¤åˆ¶\n\nUFUNCTIONUFUNCTIONæ˜¯ Unreal Engine ä¸­ç¥åŠŸå‡½æ•°çš„å®ï¼Œå®ƒç”¨äºæ ‡è®°æŸä¸ªå‡½æ•°æ˜¯ä¸€ä¸ª Unreal Engine æ‰˜ç®¡çš„å‡½æ•°ï¼Œå¹¶ä¸”å¯ä»¥åœ¨ç¼–è¾‘å™¨ä¸­æƒŠé†’è®¿é—®å’Œæ“ä½œ\nUFUNCTIONå®æä¾›äº†ä¸€ç³»åˆ—å‚æ•°ï¼Œç”¨äºå®šä¹‰å‡½æ•°çš„å±æ€§å’Œè¡Œä¸ºï¼Œä¾‹å¦‚æ˜¯å¦æ˜¯é˜‘å…¥å¯è°ƒç”¨çš„ï¼Œæ˜¯å¦å¯åœ¨ç½‘ç»œä¸­å¤åˆ¶ç­‰\n\nBlueprintCallableï¼šå¯ä»¥åœ¨è“å›¾æˆ–è€…å…³å¡è“å›¾ä¸­è°ƒç”¨\nBlueprintPureï¼šç”Ÿå‘½è¯¥å‡½æ•°ä¸ºçº¯å‡½æ•°ï¼Œå³ä¸ä¼šä¿®æ”¹å¯¹è±¡çš„çŠ¶æ€\nBlueprintImplementableEventï¼šè¿™ä¸ªå‡½æ•°åœ¨å¤´æ–‡ä»¶å£°æ˜ä½†æ˜¯åº”è¯¥åœ¨ç±»è“å›¾æˆ–å…³å¡è“å›¾ä¸­é‡å†™ï¼Œåº”è¯¥å’Œ BlueprintCallable ä¸€èµ·ä½¿ç”¨ï¼Œè¿™æ ·è“å›¾å°±å¯ä»¥è°ƒç”¨å®ƒã€‚\nCategoryï¼šæŒ‡å®šåœ¨ç¼–è¾‘å™¨ä¸­ç°å®çš„è¯¥å‡½æ•°æ‰€å±çš„åˆ†ç±»\nMetaï¼šå¯ä»¥ç”¨æ¥è®¾ç½®ä¸€äº›å…ƒæ•°æ®ï¼Œå¦‚æ–‡æ¡£ã€å…³é”®å­—ç­‰\nServer**ã€Clientã€Reliableï¼šç”¨äºç½‘ç»œåŠŸèƒ½ï¼ŒæŒ‡å®šè¯¥å‡½æ•°åœ¨æœåŠ¡ç«¯ã€å®¢æˆ·ç«¯æ‰§è¡Œï¼Œä»¥åŠæŒ‡å®šè¯¥å‡½æ•°æ˜¯å¦å¯é ä¼ è¾“\nBlueprintNativeEventï¼šè¿™ä¸ªå‡½æ•°å¯ä»¥åœ¨è“å›¾ç±»ä¸­é‡å†™ï¼ŒåŒæ—¶æ‹¥æœ‰ C++ å®ç°ï¼Œå‡½æ•°åä¸ºFuncName_Implementtation\n\n#includeå¼•å…¥å¤´æ–‡ä»¶ä¸ä¸å®Œå…¨å£°æ˜  å»ºè®®åœ¨æºæ–‡ä»¶ä¸­å¼•å…¥å…¶ä»–å¤´æ–‡ä»¶ï¼Œè€Œä¸æ˜¯åœ¨å¤´æ–‡ä»¶ä¸­å¼•å…¥å…¶ä»–å¤´æ–‡ä»¶\n\nå‡å°‘ç¼–è¯‘æ—¶é—´\næ¯”ç§’å¾ªç¯ä¾èµ–\nå¢å¼ºå¯ç»´æŠ¤æ€§\n\næ‰“å° LOG\nUE_LOG\n\nUE_Logå®æ˜¯ Unreal Engine é‡ç”¨æ—¥å¿—è®°å½•çš„æ ‡å‡†æ–¹å¼ã€‚å®ƒå¯ä»¥è¾“å‡ºæ—¥å¿—ä¿¡æ¯åˆ°æ§åˆ¶å°å’Œæ—¥å¿—æ–‡ä»¶ï¼Œæ”¯æŒå¤šç§æ—¥å¿—çº§åˆ«ï¼ˆå¦‚Logï¼ŒWarningï¼ŒErrorï¼‰\nUE_LOG(LogCategory, LogVerbosity, Format, ...)\n\n\nGEngine-&gt;AddOnScreenDebugMessage\n\nGEngine-&gt;AddOnScreenDebugMessageå¯ä»¥åœ¨æ¸¸æˆå±å¹•ä¸Šç°å®è°ƒè¯•ä¿¡æ¯ï¼Œé€šå¸¸ç”¨äºå¿«é€ŸæŸ¥çœ‹å’Œè°ƒè¯•\nGEngine-&gt;AddOnScreenDebugMessage(Key TimeToDisplay, Color, Message)\n\n\n\næ§åˆ¶è¾“å…¥\nInput Mapping Context\nå®šä¹‰äº†é‚£äº›è¾“å…¥é”®è§¦å‘é‚£äº›è¾“å…¥åŠ¨ä½œçš„è§„åˆ™é›†åˆ\n\n\nInput Action\nä»£è¡¨äº†ç©å®¶å¯ä»¥æ‰§è¡Œçš„æŸç§åŠ¨ä½œ\n\n\nEnhancedInputComponent\næ›´çµæ´»\nè¾“å…¥ç»‘å®šä¼˜åŒ–\nè¾“å…¥å¤„ç†æµç¨‹çš„æ”¹è¿›\n\n\n\nAnim Instnce ä¸åŠ¨ç”» AActorã€APawn å’ŒACharactor\nUObjectï¼šåŸºç¡€ç±» UObject æ˜¯æ‰€æœ‰é Actor ç±»çš„åŸºç±»ï¼Œå‡ ä¹æ‰€æœ‰çš„ Unreal Engine å¯¹è±¡éƒ½ç»§æ‰¿è‡ªUObject\nAActorï¼šç»§æ‰¿è‡ªUObjectï¼Œå¹¶ä¸”æ˜¯æ‰€æœ‰åœºæ™¯ä¸­å¯¹è±¡ï¼ˆè§’è‰²ã€é“å…·ã€ç¯å…‰ç­‰ï¼‰çš„åŸºç±»\nAPawnï¼šå¯ä»¥è¢«ç©å®¶æˆ– AI æ§åˆ¶çš„å¯¹è±¡ï¼Œä¸¹æ–¯ä¸éœ€è¦å¤æ‚çš„è¿åŠ¨å’ŒåŠ¨ç”»ç³»ç»Ÿ\nå¯æ§åˆ¶æ€§\næ§åˆ¶å™¨ï¼šAPawné€šå¸¸ä¸ AController æˆ–APlayerControllerå…³è”ï¼Œä»¥å®ç°ç§»åŠ¨å’Œäº¤äº’\nä¸åŒ…å«éª¨éª¼ç½‘æ ¼å’ŒåŠ¨ç”»\n\n\nACharacteræ˜¯ä¸€ç§ç‰¹æ®Šç±»å‹çš„APawnï¼Œå®ƒåŒ…å«ç”¨äºè¡Œèµ°ã€è·³è·ƒã€æ¸¸æ³³ç­‰è¿åŠ¨åŠŸèƒ½ã€‚å®ƒæ˜¯å¸¦æœ‰éª¨éª¼åŠ¨ç”»å’ŒåŠ¨ç”»ç³»ç»Ÿçš„é«˜çº§è§’è‰²ç±»\néª¨éª¼ç½‘æ ¼å’ŒåŠ¨ç”»ï¼šACharacteråŒ…å« ``USkeletallMeshComponent å’ŒåŠ¨ç”»è“å›¾ï¼Œç”¨äºè§’è‰²çš„å¤–è§‚å’ŒåŠ¨ç”»\nè§’è‰²è¿åŠ¨ï¼šåŒ…å«UCharacterMovementComponentï¼Œæ”¯æŒå¤æ‚çš„è§’è‰²è¿åŠ¨\nç¢°æ’å’Œèƒ¶å›Šä½“ï¼šé»˜è®¤åŒ…å«ä¸€ä¸ªèƒ¶å›Šç¢°æ’ä½“ï¼Œç”¨äºè§’è‰²çš„ç¢°æ’æ£€æµ‹\n\n\n\næ¸¸æˆæ˜¯æ€æ ·è¿è¡Œçš„\nAGameModeBase\nè¿™æ˜¯æ¸¸æˆæ¨¡å¼çš„åŸºç±»ï¼Œå®ƒå®šä¹‰äº†æ¸¸æˆçš„è§„åˆ™ã€é€»è¾‘å’Œè¡Œä¸º\nå¯ä»¥é€šè¿‡åˆ›å»ºè‡ªå®šä¹‰çš„æ¸¸æˆæ¨¡å¼ç±»æ¥æ‰©å±•å®ƒï¼Œå¹¶é‡å†™å…¶ä¸­çš„æ–¹æ³•æ¥å®ç°ç‰¹å®šçš„æ¸¸æˆçš„é€»è¾‘\n\n\nAGameMode\nAGameModeç±»æ˜¯ AGameModeBase çš„ä¸€ä¸ªå­ç±»ï¼Œå®ƒæä¾›äº†æ›´å¤šçš„åŠŸèƒ½å’Œæ§åˆ¶æƒï¼Œä¾‹å¦‚ç©å®¶æ§åˆ¶ã€å›¢é˜Ÿç®¡ç†ã€ç§¯åˆ†ç³»ç»Ÿç­‰\nå¯ä»¥ä½¿ç”¨ AGameMode ç±»æ¥å®ç°æ›´å¤æ‚çš„æ¸¸æˆé€»è¾‘å’Œè§„åˆ™\n\n\nGame Session\nGame State\nPlayer State\nDefault Pawn Class\nAPlayerController\nAHUD\n\n","categories":["æ¸¸æˆå¼€å‘"],"tags":["Unreal","è“å›¾"]},{"title":"Lua é—®é¢˜","url":"/2024/06/19/57/","content":"int64ä¹˜æ³•é—®é¢˜local a = int64.new(1000)local b = 0.01print(a + b) -- 1000print(a * b) -- 0\n\nåŸå› ï¼š\n\nint64ä¹˜æ³•ä¼šè§¦å‘å…ƒæ–¹æ³•__mul\n\nlua_pushstring(L, &quot;__mul&quot;),lua_pushcfunction(L, _int64mul);lua_rawset(L, -3); // æŒ‡å‘æ ˆé¡¶static int _int64mul(lua_State* L)&#123;    int64_t lhs = toluas_checkint64(L, 1);        int64_t rhs = toluas_checkint64(L, 2);    toluas_pushint64(L, lhs * rhs);    return 1;    &#125;\n\n\nè§¦å‘å…ƒæ–¹æ³•åè°ƒç”¨ toluas_checkint64 æ£€æŸ¥æ ˆä¸­çš„æ•°å€¼ç±»å‹å¹¶åšç±»å‹è½¬æ¢ï¼Œå½“ int64 ç±»å‹å’Œ number ç±»å‹ç›¸ä¹˜æ—¶ï¼Œä¼šå°†å…¶è½¬æ¢æˆæ•´å‹â€”â€”(int64_t)0.01ï¼Œæ‰€ä»¥ç›¸ä¹˜çš„ç»“æœæ˜¯0\n\nstatic int64_t toluas_checkint64(lua_State* L, int pos)&#123;    int64_t n = 0;    int type = lua_type(L, pos);        switch(type)    &#123;        case LUA_TNUMBER:            n = (int64_t)lua_tonumber(L, pos);            break;        case LUA_TSTRING:            n = _long(L, pos);            break;        case LUA_TUSERDATA:            if (_isint64(L, pos))            &#123;                n = *(int64_t*)lua_touserdata(L, pos);            &#125;            break;        default:            return luaL_typerror(L, pos, &quot;long&quot;);    &#125;        return n;&#125;\n\næ­£ç¡®åšæ³•ï¼š\nlocal a = int64.new(1000)local b = 0.01print(a:toDouble() + b) -- 1000.01print(a:toDouble() * b) -- 10\n\nstatic int _int64todouble(lua_State* L)&#123;    if (!toluas_isint64(L, 1))    &#123;        return luaL_typerror(L, 1, &quot;long&quot;);    &#125;    int64_t n = toluas_toint64(L, 1);    lua_pushnumber(L, (double)n);    return 1;&#125;\n","categories":["Lua"],"tags":["Lua","bug"]},{"title":"XLua å¦‚ä½•ä¸ C# è¿›è¡Œäº¤äº’","url":"/2024/06/04/55/","content":"\nğŸ”— æ·±å…¥ xLua å®ç°åŸç†ä¹‹ Lua å¦‚ä½•è°ƒç”¨ C#\n\nxLua æ˜¯è…¾è®¯çš„ä¸€ä¸ªå¼€æºé¡¹ç›®ï¼Œä¸º Unityã€ .Netã€ Mono ç­‰ C# ç¯å¢ƒå¢åŠ  Lua è„šæœ¬ç¼–ç¨‹çš„èƒ½åŠ›ã€‚æœ¬æ–‡ä¸»è¦æ˜¯æ¢è®¨ xLua ä¸‹ Lua è°ƒç”¨ C# çš„å®ç°åŸç†\nLua ä¸ C# æ•°æ®é€šä¿¡æœºåˆ¶  æ— è®ºæ˜¯ Lua è°ƒç”¨ C#ï¼Œè¿˜æ˜¯ C# è°ƒç”¨ Luaï¼Œéƒ½éœ€è¦ä¸€ä¸ªé€šä¿¡æœºåˆ¶ï¼Œæ¥å®Œæˆæ•°æ®çš„ä¼ é€’ã€‚è€Œ Lua æœ¬èº«å°±æ˜¯ç”± C è¯­è¨€ç¼–å†™çš„ï¼Œæ‰€ä»¥å®ƒå‡ºç”Ÿè‡ªå¸¦ä¸€ä¸ªå’Œ C/C++ çš„é€šä¿¡æœºåˆ¶\nLua å’Œ C/C++ çš„æ•°æ®äº¤äº’é€šè¿‡æ ˆè¿›è¡Œï¼Œæ“ä½œæ•°æ®æ—¶ï¼Œé¦–å…ˆå°†æ•°æ®æ‹·è´åˆ°â€æ ˆâ€ä¸Šï¼Œç„¶åè·å–æ•°æ®ï¼Œæ ˆä¸­çš„æ¯ä¸ªæ•°æ®é€šè¿‡ç´¢å¼•å€¼è¿›è¡Œå®šä½ï¼Œç´¢å¼•å€¼ä¸ºæ­£æ—¶è¡¨ç¤ºç›¸å¯¹äºæ ˆåº•çš„åç§»ç´¢å¼•ï¼Œç´¢å¼•å€¼ä¸ºè´Ÿæ—¶è¡¨ç¤ºç›¸å¯¹äºæ ˆé¡¶çš„åç§»ç´¢å¼•ï¼Œç´¢å¼•å€¼ä»¥ 1 æˆ– -1 ä¸ºèµ·å§‹å€¼ï¼Œå› æ­¤æ ˆé¡¶ç´¢å¼•å€¼æ°¸è¿œä¸º -1ï¼Œ æ ˆåº•ç´¢å¼•å€¼æ°¸è¿œä¸º 1 ã€‚ â€œæ ˆâ€ç›¸å½“äºæ•°æ®åœ¨ Lua å’Œ C/C++ ä¹‹é—´çš„ä¸­è½¬åœ°ã€‚æ¯ç§æ•°æ®éƒ½æœ‰ç›¸åº”çš„å­˜å–æ¥å£\nè€Œ C# å¯ä»¥é€šè¿‡ P/Invoke æ–¹å¼è°ƒç”¨ Lua çš„ dllï¼Œé€šè¿‡è¿™ä¸ª dll æ‰§è¡Œ Lua çš„ C APIã€‚æ¢è¨€ä¹‹ C# å¯ä»¥å€ŸåŠ© C/C++ æ¥ä¸ Lua è¿›è¡Œæ•°æ®é€šä¿¡ã€‚åœ¨ xLua çš„ LuaDLL.cs æ–‡ä»¶ä¸­å¯ä»¥æ‰¾åˆ°è®¸å¤š DllImport ä¿®é¥°çš„æ•°æ®å…¥æ ˆä¸è·å–çš„æ¥å£\n// LuaDLL.cs[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern void lua_pushnumber(IntPtr L, double number);[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern void lua_pushboolean(IntPtr L, bool value);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern void xlua_pushinteger(IntPtr L, int value);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern double lua_tonumber(IntPtr L, int index);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern int xlua_tointeger(IntPtr L, int index);[DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)]public static extern uint xlua_touint(IntPtr L, int index);[DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)]public static extern bool lua_toboolean(IntPtr L, int index);\n\nä¼ é€’ C# å¯¹è±¡åˆ° Luaå¯¹äº boolï¼Œint è¿™æ ·ç®€å•çš„å€¼ç±»å‹å¯ä»¥ç›´æ¥é€šè¿‡ C API ä¼ é€’ã€‚ä½†å¯¹äº C# å¯¹è±¡å°±ä¸åŒäº†ï¼ŒLua è¿™è¾¹æ²¡æœ‰èƒ½ä¸ä¹‹å¯¹åº”çš„ç±»å‹ï¼Œå› æ­¤ä¼ é€’åˆ° Lua çš„åªæ˜¯ C# å¯¹è±¡çš„ä¸€ä¸ªç´¢å¼•ï¼Œå…·ä½“å®ç°è¯·çœ‹ä¸‹é¢çš„ä»£ç \n// ObjectTranslator.cspublic void Push(RealStatePtr L, object o)&#123;    // ...    int index = -1;    Type type = o.GetType();#if !UNITY_WSA || UNITY_EDITOR    bool is_enum = type.IsEnum;    bool is_valuetype = type.IsValueType;#else    bool is_enum = type.GetTypeInfo().IsEnum;    bool is_valuetype = type.GetTypeInfo().IsValueType;#endif    bool needcache = !is_valuetype || is_enum;  // å¦‚æœæ˜¯å¼•ç”¨æˆ–æšä¸¾ï¼Œä¼šè¿›è¡Œç¼“å­˜    if (needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index)))  // å¦‚æœæœ‰ç¼“å­˜    &#123;        if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)          &#123;            return;        &#125;        // è¿™é‡Œå®åœ¨å¤ªç»å…¸äº†ï¼Œweaktable å…ˆåˆ é™¤ï¼Œç„¶å GC ä¼šå»¶è¿Ÿè°ƒç”¨ï¼Œå½“ index ä¼šå¾ªç¯åˆ©ç”¨çš„æ—¶å€™ï¼Œä¸æ³¨é‡Šè¿™è¡Œå°†ä¼šå¯¼è‡´é‡å¤é‡Šæ”¾        //collectObject(index);    &#125;    bool is_first;    int type_id = getTypeId(L, type, out is_first);    // å¦‚æœä¸€ä¸ª type çš„å®šä¹‰å«æœ¬èº«é™æ€ readonly å®ä¾‹æ—¶ï¼ŒgetTypeId ä¼š push ä¸€ä¸ªå®ä¾‹ï¼Œè¿™æ—¶å€™åº”è¯¥ç”¨è¿™ä¸ªå®ä¾‹    if (is_first &amp;&amp; needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, out index) : reverseMap.TryGetValue(o, out index)))     &#123;        if (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == 1)           &#123;            return;        &#125;    &#125;    // C# ä¾§è¿›è¡Œç¼“å­˜    index = addObject(o, is_valuetype, is_enum);    // å°†ä»£è¡¨å¯¹è±¡çš„ç´¢å¼• push åˆ° lua    LuaAPI.xlua_pushcsobj(L, index, type_id, needcache, cacheRef);&#125;\n\nä»£ç ä¸­çš„ä¸¤ä¸ª if è¯­å¥ä¸»è¦æ˜¯å¯¹ç¼“å­˜çš„åˆ¤æ–­ï¼Œå¦‚æœè¦ä¼ é€’çš„å¯¹è±¡å·²ç»è¢«ç¼“å­˜è¿‡äº†å°±ç›´æ¥ä½¿ç”¨ç¼“å­˜çš„ã€‚å¦‚æœè¿™ä¸ªå¯¹è±¡æ˜¯è¢«ç¬¬ä¸€æ¬¡ä¼ é€’ï¼Œåˆ™è¿›è¡Œä»¥ä¸‹ä¸¤æ­¥æ“ä½œ\n\né€šè¿‡ addObject å°†å¯¹è±¡ç¼“å­˜åœ¨ objects å¯¹è±¡æ± ä¸­ï¼Œå¹¶å¾—åˆ°ä¸€ä¸ªç´¢å¼•ï¼ˆé€šè¿‡è¿™ä¸ªç´¢å¼•å¯ä»¥è·å–åˆ°è¯¥å¯¹è±¡ï¼‰// ObjectTranslator.csint addObject(object obj, bool is_valuetype, bool is_enum)&#123;    int index = objects.Add(obj);    if (is_enum)    &#123;        enumMap[obj] = index;    &#125;    else if (!is_valuetype)    &#123;        reverseMap[obj] = index;    &#125;        return index;&#125;\né€šè¿‡ xlua_pushcsobj å°†ä»£è¡¨å¯¹è±¡çš„ç´¢å¼•ä¼ é€’åˆ° Lua\n\nå‚æ•° key è¡¨ç¤ºä»£è¡¨å¯¹è±¡çš„ç´¢å¼•ï¼Œå‚æ•° meta_ref è¡¨ç¤ºä»£è¡¨å¯¹è±¡ç±»å‹çš„è¡¨çš„ç´¢å¼•ï¼Œå®ƒçš„å€¼æ˜¯é€šè¿‡ getTypeId å‡½æ•°è·å¾—çš„ï¼Œåé¢ä¼šè¯¦ç»†è®²åˆ°ã€‚å‚æ•° need_cache è¡¨ç¤ºæ˜¯å¦éœ€è¦åœ¨ Lua ä¾§è¿›è¡Œç¼“å­˜ï¼Œå‚æ•° cache_ref è¡¨ç¤º Lua ä¾§ç¼“å­˜è¡¨çš„ç´¢å¼•\n// xlua.cLUA_API void xlua_pushcsobj(lua_State *L, int key, int meta_ref, int need_cache, int cache_ref) &#123;    int* pointer = (int*)lua_newuserdata(L, sizeof(int));    *pointer = key;        if (need_cache) cacheud(L, key, cache_ref);  // Lua ä¾§ç¼“å­˜    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);    lua_setmetatable(L, -2);  // ä¸º userdata è®¾ç½®å…ƒè¡¨&#125;// å°† key = userdata å­˜å…¥ç¼“å­˜è¡¨static void cacheud(lua_State *L, int key, int cache_ref) &#123;    lua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);    lua_pushvalue(L, -2);    lua_rawseti(L, -2, key);    lua_pop(L, 1);&#125;\n\nxlua_pushcsobjçš„ä¸»è¦é€»è¾‘æ˜¯ï¼Œä»£è¡¨å¯¹è±¡çš„ç´¢å¼•è¢« push åˆ° Lua åï¼ŒLua ä¼šä¸ºå…¶åˆ›å»ºä¸€ä¸ª userdataï¼Œå¹¶å°†è¿™ä¸ªuserdata æŒ‡å‘å¯¹è±¡ç´¢å¼•ï¼Œå¦‚æœéœ€è¦ç¼“å­˜åˆ™å°† userdata ä¿å­˜åˆ°ç¼“å­˜è¡¨ä¸­ï¼Œ æœ€åä¸º userdata è®¾ç½®äº†å…ƒè¡¨ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒC# å¯¹è±¡åœ¨ Lua è¿™è¾¹å¯¹åº”çš„å°±æ˜¯ä¸€ä¸ªuserdataï¼Œåˆ©ç”¨å¯¹è±¡ç´¢å¼•ä¿æŒä¸ C# å¯¹è±¡çš„è”ç³»ã€‚\næ³¨å†Œ C# ç±»å‹ä¿¡æ¯åˆ° Luaä¸º userdataï¼ˆç‰¹æŒ‡ C# å¯¹è±¡åœ¨ Lua è¿™è¾¹å¯¹åº”çš„ä»£ç†userdataï¼Œåé¢å†å‡ºç°çš„userdata ä¹Ÿæ˜¯åŒæ ·çš„å«ä¹‰ï¼Œå°±ä¸å†èµ˜è¿°äº†ï¼‰è®¾ç½®çš„å…ƒè¡¨ï¼Œè¡¨ç¤ºçš„å®é™…æ˜¯å¯¹è±¡çš„ç±»å‹ä¿¡æ¯ã€‚åœ¨å°† C# å¯¹è±¡ä¼ é€’åˆ° Lua ä»¥åï¼Œè¿˜éœ€è¦å‘ŠçŸ¥ Lua è¯¥å¯¹è±¡çš„ç±»å‹ä¿¡æ¯ï¼Œæ¯”å¦‚å¯¹è±¡ç±»å‹æœ‰å“ªäº›æˆå‘˜æ–¹æ³•ï¼Œå±æ€§æˆ–æ˜¯é™æ€æ–¹æ³•ç­‰ã€‚å°†è¿™äº›éƒ½æ³¨å†Œåˆ° Lua åï¼ŒLua æ‰èƒ½æ­£ç¡®çš„è°ƒç”¨ã€‚è¿™ä¸ªå…ƒè¡¨æ˜¯é€šè¿‡ getTypeId å‡½æ•°ç”Ÿæˆçš„\n// ObjectTranslator.csinternal int getTypeId(RealStatePtr L, Type type, out bool is_first, LOGLEVEL log_level = LOGLEVEL.WARN)&#123;    int type_id;    is_first = false;    if (!typeIdMap.TryGetValue(type, out type_id)) // no reference    &#123;        // ...        is_first = true;        Type alias_type = null;        aliasCfg.TryGetValue(type, out alias_type);        LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);        if (LuaAPI.lua_isnil(L, -1)) //no meta yet, try to use reflection meta        &#123;            LuaAPI.lua_pop(L, 1);            if (TryDelayWrapLoader(L, alias_type == null ? type : alias_type))            &#123;                LuaAPI.luaL_getmetatable(L, alias_type == null ? type.FullName : alias_type.FullName);            &#125;            else            &#123;                throw new Exception(&quot;Fatal: can not load metatable of type:&quot; + type);            &#125;        &#125;        // å¾ªç¯ä¾èµ–ï¼Œè‡ªèº«ä¾èµ–è‡ªå·±çš„ classï¼Œæ¯”å¦‚æœ‰ä¸ªè‡ªèº«ç±»å‹çš„é™æ€ readonly å¯¹è±¡ã€‚        if (typeIdMap.TryGetValue(type, out type_id))        &#123;            LuaAPI.lua_pop(L, 1);        &#125;        else        &#123;            // ...            LuaAPI.lua_pushvalue(L, -1);            type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);  // å°†å…ƒè¡¨æ·»åŠ åˆ°æ³¨å†Œè¡¨ä¸­            LuaAPI.lua_pushnumber(L, type_id);            LuaAPI.xlua_rawseti(L, -2, 1);   // å…ƒè¡¨ [1] = type_id            LuaAPI.lua_pop(L, 1);            if (type.IsValueType())            &#123;                typeMap.Add(type_id, type);            &#125;            typeIdMap.Add(type, type_id);        &#125;    &#125;    return type_id;&#125;\n\nå‡½æ•°ä¸»è¦é€»è¾‘æ˜¯ä»¥ç±»çš„åç§°ä¸º key é€šè¿‡ luaL_getmetatable è·å–ç±»å¯¹åº”çš„å…ƒè¡¨ï¼Œå¦‚æœè·å–ä¸åˆ°ï¼Œåˆ™é€šè¿‡ TryDelayWrapLoaderå‡½æ•°ç”Ÿæˆã€‚ç„¶åè°ƒç”¨ luaL_ref å°†è·å–åˆ°çš„å…ƒè¡¨æ·»åŠ åˆ° Lua æ³¨å†Œè¡¨ä¸­ï¼Œå¹¶è¿”å› type_idã€‚type_id è¡¨ç¤ºçš„å°±æ˜¯å…ƒè¡¨åœ¨ Lua æ³¨å†Œè¡¨ä¸­çš„ç´¢å¼•ï¼Œé€šè¿‡è¿™ä¸ªç´¢å¼•å¯ä»¥åœ¨ Lua æ³¨å†Œè¡¨ä¸­å–å›å…ƒè¡¨ã€‚å‰é¢æåˆ°çš„ xlua_pushcsobjå‡½æ•°å°±æ˜¯åˆ©ç”¨ type_id å³meta_refï¼Œè·å–åˆ°å…ƒè¡¨ï¼Œç„¶åä¸º userdata è®¾ç½®çš„å…ƒè¡¨ã€‚ä¸‹é¢æ¥çœ‹å…ƒè¡¨å…·ä½“æ˜¯æ€æ ·ç”Ÿæˆçš„\n// ObjectTranslator.cspublic bool TryDelayWrapLoader(RealStatePtr L, Type type)&#123;    // ...    LuaAPI.luaL_newmetatable(L, type.FullName); // å…ˆå»ºä¸€ä¸ª metatableï¼Œå› ä¸ºåŠ è½½è¿‡ç¨‹å¯èƒ½ä¼šéœ€è¦ç”¨åˆ°    LuaAPI.lua_pop(L, 1);    Action&lt;RealStatePtr&gt; loader;    int top = LuaAPI.lua_gettop(L);    if (delayWrap.TryGetValue(type, out loader))  // å¦‚æœæœ‰é¢„å…ˆæ³¨å†Œçš„ç±»å‹å…ƒè¡¨ç”Ÿæˆå™¨ï¼Œåˆ™ç›´æ¥ä½¿ç”¨    &#123;        delayWrap.Remove(type);        loader(L);    &#125;    else    &#123;#if !GEN_CODE_MINIMIZE &amp;&amp; !ENABLE_IL2CPP &amp;&amp; (UNITY_EDITOR || XLUA_GENERAL) &amp;&amp; !FORCE_REFLECTION &amp;&amp; !NET_STANDARD_2_0        if (!DelegateBridge.Gen_Flag &amp;&amp; !type.IsEnum() &amp;&amp; !typeof(Delegate).IsAssignableFrom(type) &amp;&amp; Utils.IsPublic(type))        &#123;            Type wrap = ce.EmitTypeWrap(type);            MethodInfo method = wrap.GetMethod(&quot;__Register&quot;, BindingFlags.Static | BindingFlags.Public);            method.Invoke(null, new object[] &#123; L &#125;);        &#125;        else        &#123;            Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));        &#125;#else        Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));#endif        // ...    &#125;    if (top != LuaAPI.lua_gettop(L))    &#123;        throw new Exception(&quot;top change, before:&quot; + top + &quot;, after:&quot; + LuaAPI.lua_gettop(L));    &#125;    foreach (var nested_type in type.GetNestedTypes(BindingFlags.Public))    &#123;        if (nested_type.IsGenericTypeDefinition())  // è¿‡æ»¤æ³›å‹ç±»å‹å®šä¹‰        &#123;            continue;        &#125;        GetTypeId(L, nested_type);    &#125;        return true;&#125;\n\nTryDelayWrapLoader ä¸»è¦ç”¨æ¥å¤„ç†ä¸¤ç§æƒ…å†µ\né€šè¿‡ delayWrap åˆ¤æ–­ï¼Œæ˜¯å¦æœ‰ä¸ºè¯¥ç±»ç”Ÿæˆä»£ç ï¼Œå¦‚æœæœ‰ï¼Œç›´æ¥ä½¿ç”¨ç”Ÿæˆå‡½æ•°è¿›è¡Œå¡«å……å…ƒè¡¨ï¼ˆloaderæ–¹æ³•ï¼‰ã€‚åœ¨ xLua çš„ç”Ÿæˆä»£ç ä¸­æœ‰ä¸€ä¸ª XLuaGenAutoRegister.cs æ–‡ä»¶ï¼Œåœ¨è¿™ä¸ªæ–‡ä»¶ä¸­ä¼šä¸ºå¯¹åº”çš„ç±»æ³¨å†Œåˆå§‹åŒ–å™¨ï¼Œè€Œè¿™ä¸ªåˆå§‹åŒ–å™¨è´Ÿè´£å°†ç±»å¯¹åº”çš„å…ƒè¡¨ç”Ÿæˆå‡½æ•°æ·»åŠ åˆ° delayWrap ä¸­ã€‚\n\n// XLuaGenAutoRegister.cspublic class XLua_Gen_Initer_Register__&#123;    static void wrapInit0(LuaEnv luaenv, ObjectTranslator translator)    &#123;        // ...        translator.DelayWrapLoader(typeof(TestXLua), TestXLuaWrap.__Register);  // å°†ç±»å‹å¯¹åº”çš„å…ƒè¡¨å¡«å……å‡½æ•°__Register æ·»åŠ åˆ° delayWrap ä¸­        // ...    &#125;        static void Init(LuaEnv luaenv, ObjectTranslator translator)    &#123;        wrapInit0(luaenv, translator);        translator.AddInterfaceBridgeCreator(typeof(System.Collections.IEnumerator), SystemCollectionsIEnumeratorBridge.__Create);    &#125;        static XLua_Gen_Initer_Register__()    &#123;            XLua.LuaEnv.AddIniter(Init);  // æ³¨å†Œåˆå§‹åŒ–å™¨        &#125;&#125;\n\n\nå¦‚æœæ²¡æœ‰ç”Ÿæˆä»£ç ï¼Œé€šè¿‡åå°„å¡«å……å…ƒè¡¨ï¼ˆReflectionWrapæ–¹æ³•ï¼‰\n\nä½¿ç”¨ç”Ÿæˆå‡½æ•°å¡«å……å…ƒè¡¨  ä»¥LuaCallCSharpä¿®é¥°çš„ TestXLua ç±»ä¸ºä¾‹æ¥æŸ¥çœ‹ç”Ÿæˆå‡½æ•°æ˜¯å¦‚ä½•ç”Ÿæˆçš„\n// TestXLua.cs[LuaCallCSharp]public class TestXLua&#123;    public string Name;    public void Test1(int a)&#123;    &#125;    public static void Test2(int a, bool b, string c)    &#123;    &#125;&#125;\n\nGenerate Code ä¹‹åç”Ÿæˆçš„ TestXLuaWrap.cs å¦‚ä¸‹æ‰€ç¤º\npublic class TestXLuaWrap &#123;    public static void __Register(RealStatePtr L)    &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        System.Type type = typeof(TestXLua);        Utils.BeginObjectRegister(type, L, translator, 0, 1, 1, 1);        Utils.RegisterFunc(L, Utils.METHOD_IDX, &quot;Test1&quot;, _m_Test1);        Utils.RegisterFunc(L, Utils.GETTER_IDX, &quot;Name&quot;, _g_get_Name);        Utils.RegisterFunc(L, Utils.SETTER_IDX, &quot;Name&quot;, _s_set_Name);        Utils.EndObjectRegister(type, L, translator, null, null,            null, null, null);        Utils.BeginClassRegister(type, L, __CreateInstance, 2, 0, 0);        Utils.RegisterFunc(L, Utils.CLS_IDX, &quot;Test2&quot;, _m_Test2_xlua_st_);        Utils.EndClassRegister(type, L, translator);    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int __CreateInstance(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            if(LuaAPI.lua_gettop(L) == 1)            &#123;                TestXLua gen_ret = new TestXLua();                translator.Push(L, gen_ret);                return 1;            &#125;        &#125;        catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return LuaAPI.luaL_error(L, &quot;invalid arguments to TestXLua constructor!&quot;);            &#125;    [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _m_Test1(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            &#123;                int _a = LuaAPI.xlua_tointeger(L, 2);                gen_to_be_invoked.Test1(_a);                return 0;            &#125;        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _m_Test2_xlua_st_(RealStatePtr L)    &#123;        try &#123;            &#123;                int _a = LuaAPI.xlua_tointeger(L, 1);                bool _b = LuaAPI.lua_toboolean(L, 2);                string _c = LuaAPI.lua_tostring(L, 3);                TestXLua.Test2(_a, _b, _c);                return 0;            &#125;        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _g_get_Name(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);                    TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            LuaAPI.lua_pushstring(L, gen_to_be_invoked.Name);        &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return 1;    &#125;        [MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]    static int _s_set_Name(RealStatePtr L)    &#123;        try &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);                    TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);            gen_to_be_invoked.Name = LuaAPI.lua_tostring(L, 2);                &#125; catch(System.Exception gen_e) &#123;            return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);        &#125;        return 0;    &#125;&#125;\n\nç”Ÿæˆå‡½æ•° __Register ä¸»è¦æ˜¯è¿™æ ·ä¸€ä¸ªæ¡†æ¶\nUtils.BeginObjectRegisterï¼Œåœ¨å¯¹ç±»çš„éé™æ€å€¼ï¼ˆä¾‹å¦‚æˆå‘˜å˜é‡ï¼Œæˆå‘˜æ–¹æ³•ç­‰ï¼‰è¿›è¡Œæ³¨å†Œå‰åšä¸€äº›å‡†å¤‡å·¥ä½œã€‚ä¸»è¦æ˜¯ä¸ºå…ƒè¡¨æ·»åŠ  __gc å’Œ__tostringå…ƒæ–¹æ³•ï¼Œä»¥åŠå‡†å¤‡å¥½ method è¡¨ã€getterè¡¨ã€setterè¡¨ï¼Œåé¢è°ƒç”¨ RegisterFunc æ—¶ï¼Œå¯ä»¥é€‰æ‹©æ’å…¥åˆ°å¯¹åº”çš„è¡¨ä¸­\n\n// Utils.cspublic static void BeginObjectRegister(Type type, RealStatePtr L, ObjectTranslator translator, int meta_count, int method_count, int getter_count,    int setter_count, int type_id = -1)&#123;    if (type == null)    &#123;        if (type_id == -1) throw new Exception(&quot;Fatal: must provide a type of type_id&quot;);        LuaAPI.xlua_rawgeti(L, LuaIndexes.LUA_REGISTRYINDEX, type_id);    &#125;    else    &#123;        LuaAPI.luaL_getmetatable(L, type.FullName);        // å¦‚æœ type.FullName å¯¹åº”çš„å…ƒè¡¨æ˜¯ç©ºï¼Œåˆ™åˆ›å»ºä¸€ä¸ªæ–°çš„å…ƒè¡¨ï¼Œå¹¶è®¾ç½®åˆ°æ³¨å†Œè¡¨ä¸­        if (LuaAPI.lua_isnil(L, -1))        &#123;            LuaAPI.lua_pop(L, 1);            LuaAPI.luaL_newmetatable(L, type.FullName);        &#125;    &#125;    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());    LuaAPI.lua_pushnumber(L, 1);    LuaAPI.lua_rawset(L, -3);  // ä¸ºå…ƒè¡¨è®¾ç½®æ ‡å¿—    if ((type == null || !translator.HasCustomOp(type)) &amp;&amp; type != typeof(decimal))    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);        LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);        LuaAPI.lua_rawset(L, -3);  // ä¸ºå…ƒè¡¨è®¾ç½®__gc æ–¹æ³•    &#125;    LuaAPI.xlua_pushasciistring(L, &quot;__tostring&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);    LuaAPI.lua_rawset(L, -3);  // ä¸ºå…ƒè¡¨è®¾ç½®__tostring æ–¹æ³•    if (method_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, method_count);  // åˆ›å»º method è¡¨    &#125;    if (getter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, getter_count);  // åˆ›å»º getter è¡¨    &#125;    if (setter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, setter_count);  // åˆ›å»º setter è¡¨    &#125;&#125;\n\nå¤šä¸ª Utils.RegisterFuncï¼Œå°†ç±»çš„æ¯ä¸ªéé™æ€å€¼å¯¹åº”çš„åŒ…è£¹æ–¹æ³•æ³¨å†Œåˆ°ä¸åŒçš„ Lua è¡¨ä¸­ã€‚åŒ…è£¹æ–¹æ³•æ˜¯ Generate Code æ—¶åŠ¨æ€ç”Ÿæˆçš„ï¼Œå¯¹äºç±»çš„å±æ€§ä¼šç”Ÿæˆä¸¤ä¸ªåŒ…è£¹æ–¹æ³•ï¼Œåˆ†åˆ«æ˜¯get å’ŒsetåŒ…è£¹æ–¹æ³•\n\nä¾‹å¦‚æˆå‘˜æ–¹æ³• Test1 å¯¹åº”çš„åŒ…è£¹æ–¹æ³•æ˜¯ _m_Test1ï¼Œå¹¶è¢«æ³¨å†Œåˆ°äº†method è¡¨ä¸­ã€‚Nameå˜é‡çš„ _g_get_Name åŒ…è£¹æ–¹æ³•è¢«æ³¨å†Œåˆ°getter è¡¨ï¼Œè€Œ _s_set_Name åŒ…è£¹æ–¹æ³•è¢«æ³¨å†Œåˆ° setter è¡¨ã€‚è¿™ä¸ªåŒ…è£¹æ–¹æ³•åªæ˜¯å¯¹åŸæ¥æ–¹æ³•çš„ä¸€å±‚åŒ…è£¹ï¼Œè°ƒç”¨è¿™ä¸ªåŒ…è£¹æ–¹æ³•æœ¬è´¨ä¸Šå°±æ˜¯è°ƒç”¨åŸæ¥çš„æ–¹æ³•ã€‚è‡³äºä¸ºä»€ä¹ˆéœ€è¦ç”ŸæˆåŒ…è£¹æ–¹æ³•ï¼Œåé¢ä¼šå†è®²åˆ°\n// Utils.cs RegisterFunc æ ¹æ®ä¸åŒçš„å®å®šä¹‰ä¼šæœ‰ä¸åŒçš„ç‰ˆæœ¬ï¼Œä½†å¤§åŒå°å¼‚public static void RegisterFunc(RealStatePtr L, int idx, string name, LuaCSFunction func)&#123;    idx = abs_idx(LuaAPI.lua_gettop(L), idx);    LuaAPI.xlua_pushasciistring(L, name);    LuaAPI.lua_pushstdcallcfunction(L, func);    LuaAPI.lua_rawset(L, idx);  // å°† idx æŒ‡å‘çš„è¡¨ä¸­æ·»åŠ é”®å€¼å¯¹ name = func&#125;\n\n\nUtils.EndObjectRegisterï¼Œç»“æŸå¯¹ç±»çš„éé™æ€å€¼çš„æ³¨å†Œã€‚ä¸»è¦é€»è¾‘æ˜¯ä¸ºå…ƒè¡¨ç”Ÿæˆ __index å…ƒæ–¹æ³•å’Œ __newindex å…ƒæ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯ Lua è°ƒç”¨ C# çš„æ ¸å¿ƒæ‰€åœ¨\n\n// Utils.cspublic static void EndObjectRegister(Type type, RealStatePtr L, ObjectTranslator translator, LuaCSFunction csIndexer,    LuaCSFunction csNewIndexer, Type base_type, LuaCSFunction arrayIndexer, LuaCSFunction arrayNewIndexer)&#123;    int top = LuaAPI.lua_gettop(L);    int meta_idx = abs_idx(top, OBJ_META_IDX);    int method_idx = abs_idx(top, METHOD_IDX);    int getter_idx = abs_idx(top, GETTER_IDX);    int setter_idx = abs_idx(top, SETTER_IDX);    //begin index gen    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, method_idx);  // 1. å‹å…¥ methods è¡¨    LuaAPI.lua_pushvalue(L, getter_idx);  // 2. å‹å…¥ getters è¡¨    if (csIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, csIndexer);  // 3. å‹å…¥ csindexer        // ...    &#125;    translator.Push(L, type == null ? base_type : type.BaseType());  // 4. å‹å…¥ base    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  // 5. å‹å…¥ indexfuncs    if (arrayIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, arrayIndexer);  // 6. å‹å…¥ arrayindexer        // ...    &#125;    LuaAPI.gen_obj_indexer(L);  // ç”Ÿæˆ__index å…ƒæ–¹æ³•    if (type != null)    &#123;        LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua indexs function tables        translator.Push(L, type);        LuaAPI.lua_pushvalue(L, -3);        LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaIndexs][type] = __index å‡½æ•°        LuaAPI.lua_pop(L, 1);    &#125;    LuaAPI.lua_rawset(L, meta_idx);    //end index gen    //begin newindex gen    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, setter_idx);    if (csNewIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, csNewIndexer);        // ...    &#125;    translator.Push(L, type == null ? base_type : type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    if (arrayNewIndexer == null)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        // ...        LuaAPI.lua_pushstdcallcfunction(L, arrayNewIndexer);        // ...    &#125;    LuaAPI.gen_obj_newindexer(L);  // ç”Ÿæˆ__newindex å…ƒæ–¹æ³•    if (type != null)    &#123;        LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua newindexs function tables        translator.Push(L, type);        LuaAPI.lua_pushvalue(L, -3);        LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaNewIndexs][type] = __newindex å‡½æ•°        LuaAPI.lua_pop(L, 1);    &#125;    LuaAPI.lua_rawset(L, meta_idx);    //end new index gen    LuaAPI.lua_pop(L, 4);&#125;\n\n__indexå…ƒæ–¹æ³•æ˜¯é€šè¿‡è°ƒç”¨ gen_obj_indexer è·å¾—çš„ï¼Œåœ¨è°ƒç”¨è¯¥æ–¹æ³•å‰ä¼šä¾æ¬¡å‹å…¥ 6 ä¸ªå‚æ•°ï¼ˆä»£ç æ³¨é‡Šä¸­æœ‰æ ‡æ³¨ï¼‰ï¼Œgen_obj_indexerå†…éƒ¨åˆä¼šå†å‹å…¥ä¸€ä¸ª nil å€¼ï¼Œç”¨äºä¸º baseindex æå‰å ä½ã€‚å…± 7 ä¸ªå‚æ•°ä¼šä½œä¸º upvalue å…³è”åˆ°é—­åŒ… obj_indexerã€‚obj_indexer å‡½æ•°å°±æ˜¯ __index å…ƒæ–¹æ³•ï¼Œå®ƒçš„é€»è¾‘æ˜¯å½“è®¿é—® userdata[key] æ—¶ï¼Œå…ˆä¾æ¬¡æŸ¥è¯¢ä¹‹å‰é€šè¿‡ RegisterFunc å¡«å……çš„ methodsï¼Œgetters ç­‰è¡¨ä¸­æ˜¯å¦å­˜æœ‰å¯¹åº” key çš„åŒ…è£¹æ–¹æ³•ï¼Œå¦‚æœæœ‰åˆ™ç›´æ¥ä½¿ç”¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™é€’å½’åœ¨çˆ¶ç±»ä¸­æŸ¥æ‰¾ã€‚__newindexå…ƒæ–¹æ³•æ˜¯é€šè¿‡è°ƒç”¨ gen_obj_newindexer è·å¾—çš„ï¼Œä¸__index çš„è·å¾—åŸç†ç±»ä¼¼ï¼Œè¿™é‡Œå°±ä¸å†åˆ—å‡ºäº†\n// xlua.cLUA_API int gen_obj_indexer(lua_State *L) &#123;    lua_pushnil(L);    lua_pushcclosure(L, obj_indexer, 7);    return 0;&#125;//upvalue --- [1]: methods, [2]:getters, [3]:csindexer, [4]:base, [5]:indexfuncs, [6]:arrayindexer, [7]:baseindex//param   --- [1]: obj, [2]: keyLUA_API int obj_indexer(lua_State *L) &#123;            if (!lua_isnil(L, lua_upvalueindex(1))) &#123;  // å¦‚æœ methods ä¸­æœ‰ keyï¼Œåˆ™ä½¿ç”¨ methods[key]        lua_pushvalue(L, 2);        lua_gettable(L, lua_upvalueindex(1));        if (!lua_isnil(L, -1)) &#123;//has method            return 1;        &#125;        lua_pop(L, 1);    &#125;        if (!lua_isnil(L, lua_upvalueindex(2))) &#123;  // å¦‚æœ getters ä¸­ keyï¼Œåˆ™è°ƒç”¨ getters[key]        lua_pushvalue(L, 2);        lua_gettable(L, lua_upvalueindex(2));        if (!lua_isnil(L, -1)) &#123;//has getter            lua_pushvalue(L, 1);            lua_call(L, 1, 1);            return 1;        &#125;        lua_pop(L, 1);    &#125;        if (!lua_isnil(L, lua_upvalueindex(6)) &amp;&amp; lua_type(L, 2) == LUA_TNUMBER) &#123;  // å¦‚æœ arrayindexer ä¸­æœ‰ key ä¸” key æ˜¯æ•°å­—ï¼Œåˆ™è°ƒç”¨ arrayindexer[key]        lua_pushvalue(L, lua_upvalueindex(6));        lua_pushvalue(L, 1);        lua_pushvalue(L, 2);        lua_call(L, 2, 1);        return 1;    &#125;        if (!lua_isnil(L, lua_upvalueindex(3))) &#123;  // å¦‚æœ csindexer ä¸­æœ‰ keyï¼Œåˆ™è°ƒç”¨ csindexer[key]        lua_pushvalue(L, lua_upvalueindex(3));        lua_pushvalue(L, 1);        lua_pushvalue(L, 2);        lua_call(L, 2, 2);        if (lua_toboolean(L, -2)) &#123;            return 1;        &#125;        lua_pop(L, 2);    &#125;        if (!lua_isnil(L, lua_upvalueindex(4))) &#123;  // é€’å½’å‘ä¸Šåœ¨ base ä¸­æŸ¥æ‰¾        lua_pushvalue(L, lua_upvalueindex(4));        while(!lua_isnil(L, -1)) &#123;            lua_pushvalue(L, -1);            lua_gettable(L, lua_upvalueindex(5));            if (!lua_isnil(L, -1)) // found            &#123;                lua_replace(L, lua_upvalueindex(7)); //baseindex = indexfuncs[base]                lua_pop(L, 1);                break;            &#125;            lua_pop(L, 1);            lua_getfield(L, -1, &quot;BaseType&quot;);            lua_remove(L, -2);        &#125;        lua_pushnil(L);        lua_replace(L, lua_upvalueindex(4));//base = nil    &#125;        if (!lua_isnil(L, lua_upvalueindex(7))) &#123;          lua_settop(L, 2);        lua_pushvalue(L, lua_upvalueindex(7));          lua_insert(L, 1);        lua_call(L, 2, 1);  // è°ƒç”¨çˆ¶ç±»çš„__indexï¼Œindexfuncs[base](obj, key)        return 1;    &#125; else &#123;        return 0;    &#125;&#125;\n\n\nUtils.BeginClassRegisterï¼Œåœ¨å¯¹ç±»çš„é™æ€å€¼ï¼ˆä¾‹å¦‚é™æ€å˜é‡ï¼Œé™æ€æ–¹æ³•ç­‰ï¼‰è¿›è¡Œæ³¨å†Œå‰åšä¸€äº›å‡†å¤‡å·¥ä½œã€‚ä¸»è¦æ˜¯ä¸ºç±»ç”Ÿæˆå¯¹åº”çš„ cls_table è¡¨ï¼Œä»¥åŠæå‰åˆ›å»ºå¥½ static_getter è¡¨ä¸ static_setter è¡¨ï¼Œåç»­ç”¨æ¥å­˜æ”¾é™æ€å­—æ®µå¯¹åº”çš„ get å’ŒsetåŒ…è£¹æ–¹æ³•ã€‚æ³¨æ„è¿™é‡Œè¿˜ä¼šä¸º cls_table è®¾ç½®å…ƒè¡¨meta_table\n\n// Utils.cspublic static void BeginClassRegister(Type type, RealStatePtr L, LuaCSFunction creator, int class_field_count,    int static_getter_count, int static_setter_count)&#123;    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);    LuaAPI.lua_createtable(L, 0, class_field_count);    LuaAPI.xlua_pushasciistring(L, &quot;UnderlyingSystemType&quot;);    translator.PushAny(L, type);    LuaAPI.lua_rawset(L, -3);    int cls_table = LuaAPI.lua_gettop(L);    SetCSTable(L, type, cls_table);    LuaAPI.lua_createtable(L, 0, 3);    int meta_table = LuaAPI.lua_gettop(L);    if (creator != null)    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__call&quot;);#if GEN_CODE_MINIMIZE        translator.PushCSharpWrapper(L, creator);#else        LuaAPI.lua_pushstdcallcfunction(L, creator);#endif        LuaAPI.lua_rawset(L, -3);    &#125;    if (static_getter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, static_getter_count);   // åˆ›å»ºå¥½ static_getter è¡¨    &#125;    if (static_setter_count == 0)    &#123;        LuaAPI.lua_pushnil(L);    &#125;    else    &#123;        LuaAPI.lua_createtable(L, 0, static_setter_count);  // åˆ›å»ºå¥½ static_setter è¡¨    &#125;    LuaAPI.lua_pushvalue(L, meta_table);    LuaAPI.lua_setmetatable(L, cls_table);  // è®¾ç½®å…ƒè¡¨&#125;\n\ncls_table è¡¨æ˜¯æ ¹æ®ç±»çš„å‘½åç©ºé—´åé€å±‚æ·»åŠ åˆ°æ³¨å†Œè¡¨ä¸­çš„ï¼Œä¸»è¦æ˜¯é€šè¿‡ SetCSTable å®ç°\n// Utils.cspublic static void SetCSTable(RealStatePtr L, Type type, int cls_table)&#123;    int oldTop = LuaAPI.lua_gettop(L);    cls_table = abs_idx(oldTop, cls_table);    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    List&lt;string&gt; path = getPathOfType(type);    // å¯¹äº A.B.C æ¥è¯´    // for å¾ªç¯å¤„ç† A.B    // 1. æ³¨å†Œè¡¨ [xlua_csharp_namespace][A] = &#123;&#125; ä¸”å‡ºæ ˆ æ³¨å†Œè¡¨ [xlua_csharp_namespace]    // 2. æ³¨å†Œè¡¨ [xlua_csharp_namespace][A][B] = &#123;&#125; ä¸”å‡ºæ ˆ æ³¨å†Œè¡¨ [xlua_csharp_namespace][A]    for (int i = 0; i &lt; path.Count - 1; ++i)    &#123;        LuaAPI.xlua_pushasciistring(L, path[i]);        if (0 != LuaAPI.xlua_pgettable(L, -2))        &#123;            var err = LuaAPI.lua_tostring(L, -1);            LuaAPI.lua_settop(L, oldTop);            throw new Exception(&quot;SetCSTable for [&quot; + type + &quot;] error: &quot; + err);        &#125;        if (LuaAPI.lua_isnil(L, -1))  // å¦‚æœ æ³¨å†Œè¡¨ [xlua_csharp_namespace] ä¸­æ²¡æœ‰ key path[i] , åˆ™æ·»åŠ ä¸€ä¸ª path[i] = &#123;&#125; é”®å€¼å¯¹        &#123;            LuaAPI.lua_pop(L, 1);            LuaAPI.lua_createtable(L, 0, 0);            LuaAPI.xlua_pushasciistring(L, path[i]);            LuaAPI.lua_pushvalue(L, -2);            LuaAPI.lua_rawset(L, -4);        &#125;        else if (!LuaAPI.lua_istable(L, -1))        &#123;            LuaAPI.lua_settop(L, oldTop);            throw new Exception(&quot;SetCSTable for [&quot; + type + &quot;] error: ancestors is not a table!&quot;);        &#125;        LuaAPI.lua_remove(L, -2);    &#125;    // å¤„ç† C    // æ³¨å†Œè¡¨ [xlua_csharp_namespace][A][B][C] = cls_table ä¸”å‡ºæ ˆ [xlua_csharp_namespace][A][B][C]    LuaAPI.xlua_pushasciistring(L, path[path.Count - 1]);    LuaAPI.lua_pushvalue(L, cls_table);    LuaAPI.lua_rawset(L, -3);      LuaAPI.lua_pop(L, 1);    // åœ¨ æ³¨å†Œè¡¨ [xlua_csharp_namespace] ä¸­æ·»åŠ é”®å€¼å¯¹ [type å¯¹åº”çš„ lua ä»£ç† userdata] = cls_table    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    ObjectTranslatorPool.Instance.Find(L).PushAny(L, type);    LuaAPI.lua_pushvalue(L, cls_table);    LuaAPI.lua_rawset(L, -3);    LuaAPI.lua_pop(L, 1);&#125;\n\nä»¥ A.B.C ç±»ä¸ºä¾‹ï¼Œå°†åœ¨ Lua æ³¨å†Œè¡¨ä¸­æ·»åŠ ä»¥ä¸‹è¡¨ç»“æ„ï¼Œè€Œ Lua æ³¨å†Œè¡¨ xlua_csharp_namespace å®é™…ä¸Šå¯¹åº”çš„å°±æ˜¯ CS å…¨å±€è¡¨ï¼Œæ‰€ä»¥è¦åœ¨ xLua ä¸­è®¿é—® C# ç±»æ—¶æ‰å¯ä»¥ç›´æ¥ä½¿ç”¨ CS.A.B.C è¿™æ ·çš„å½¢å¼\nLua æ³¨å†Œè¡¨ = &#123;    xlua_csharp_namespace = &#123;  -- å°±æ˜¯ CS å…¨å±€è¡¨        A = &#123;            B = &#123;                C = cls_table            &#125;        &#125;,    &#125;,&#125;\n\n\nå¤šä¸ª Utils.RegisterFuncï¼Œä¸BeginObjectRegister åˆ°EndObjectRegisterä¹‹é—´çš„ RegisterFunc ä½œç”¨ç›¸åŒï¼Œå°†ç±»çš„æ¯ä¸ªé™æ€å€¼å¯¹åº”çš„åŒ…è£¹æ–¹æ³•æ³¨å†Œåˆ°å¯¹åº”çš„ Lua è¡¨ä¸­ã€‚é™æ€å˜é‡å¯¹åº”çš„ get å’Œ set åŒ…è£¹æ–¹æ³•ä¼šè¢«åˆ†åˆ«æ³¨å†Œåˆ° static_getter è¡¨å’Œ static_setter è¡¨ï¼ˆåªè¯»çš„é™æ€å˜é‡é™¤å¤–ï¼‰\nUtils.EndClassRegisterï¼Œç»“æŸå¯¹ç±»çš„é™æ€å€¼çš„æ³¨å†Œã€‚ä¸ EndObjectRegister ç±»ä¼¼ï¼Œä½†å®ƒæ˜¯ä¸º cls_table çš„å…ƒè¡¨ meta_tabl è®¾ç½® __index å…ƒæ–¹æ³•å’Œ __newindex å…ƒæ–¹æ³•\n\n// Utils.cspublic static void EndClassRegister(Type type, RealStatePtr L, ObjectTranslator translator)&#123;    int top = LuaAPI.lua_gettop(L);    int cls_idx = abs_idx(top, CLS_IDX);    int cls_getter_idx = abs_idx(top, CLS_GETTER_IDX);    int cls_setter_idx = abs_idx(top, CLS_SETTER_IDX);    int cls_meta_idx = abs_idx(top, CLS_META_IDX);    //begin cls index    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, cls_getter_idx);    LuaAPI.lua_pushvalue(L, cls_idx);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);      LuaAPI.gen_cls_indexer(L);    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua indexs function tables      translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaClassIndexs][type] = __index å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta_idx);    //end cls index    //begin cls newindex    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, cls_setter_idx);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_newindexer(L);    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);//store in lua newindexs function tables    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaClassNewIndexs][type] = __newindex å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta_idx);    //end cls newindex    LuaAPI.lua_pop(L, 4);&#125;\n\nä¸Šè¿° 6 ä¸ªéƒ¨åˆ†çš„ä»£ç é‡æ¯”è¾ƒå¤§ï¼Œé€»è¾‘ä¹Ÿæ¯”è¾ƒå¤æ‚ï¼Œåˆ°è¿™é‡Œæœ‰å¿…è¦åšä¸€ä¸ªæ€»ç»“\nç”Ÿæˆä»£ç ä¼šä¸ºç±»çš„éé™æ€å€¼éƒ½ç”Ÿæˆå¯¹åº”çš„åŒ…è£¹æ–¹æ³•ï¼Œå¹¶å°†åŒ…è£¹æ–¹æ³•ä»¥ key = func çš„å½¢å¼æ³¨å†Œåˆ°ä¸åŒçš„è¡¨ä¸­ã€‚userdataå…ƒè¡¨çš„ __index å’Œ__newindexè´Ÿè´£ä»è¿™ä¸åŒçš„è¡¨ä¸­æ‰¾åˆ°å¯¹åº” key çš„åŒ…è£¹æ–¹æ³•ï¼Œæœ€ç»ˆé€šè¿‡è°ƒç”¨åŒ…è£¹æ–¹æ³•å®ç°å¯¹ C# å¯¹è±¡çš„æ§åˆ¶\n-- lua æµ‹è¯•ä»£ç local obj = CS.TestXLua()obj.Name = &quot;test&quot;  -- èµ‹å€¼æ“ä½œå°†è§¦å‘ obj å…ƒè¡¨çš„__newindexï¼Œ__newindex åœ¨ setter è¡¨ä¸­æ‰¾åˆ° Name å¯¹åº”çš„ set åŒ…è£¹æ–¹æ³•_s_set_Nameï¼Œç„¶åé€šè¿‡è°ƒç”¨_s_set_Name æ–¹æ³•è®¾ç½®äº† TestXLua å¯¹è±¡çš„ Name å±æ€§ä¸º &quot;test&quot;\n\nç”Ÿæˆä»£ç è¿˜ä¼šä¸ºæ¯ä¸ªç±»ä»¥å‘½åç©ºé—´ä¸ºå±‚æ¬¡ç»“æ„ç”Ÿæˆ cls_table è¡¨ã€‚ä¸ç±»çš„éé™æ€å€¼ç›¸åŒï¼Œç”Ÿæˆä»£ç ä¹Ÿä¼šä¸ºç±»çš„é™æ€å€¼éƒ½ç”Ÿæˆå¯¹åº”çš„åŒ…è£¹æ–¹æ³•å¹¶æ³¨å†Œåˆ°ä¸åŒçš„è¡¨ä¸­ï¼ˆæ³¨æ„è¿™é‡Œæœ‰äº›åŒºåˆ«ï¼Œç±»çš„é™æ€æ–¹æ³•ä¼šè¢«ç›´æ¥æ³¨å†Œåˆ° cls_table è¡¨ä¸­ï¼‰ã€‚è€Œ cls_table å…ƒè¡¨çš„ __index å’Œ__newindexè´Ÿè´£ä»è¿™ä¸åŒçš„è¡¨ä¸­æ‰¾åˆ°å¯¹åº” key çš„åŒ…è£¹æ–¹æ³•ï¼Œæœ€ç»ˆé€šè¿‡è°ƒç”¨åŒ…è£¹æ–¹æ³•å®ç°å¯¹ C# ç±»çš„æ§åˆ¶\n-- lua æµ‹è¯•ä»£ç CS.TestXLua.Test2()  -- CS.TestXLua è·å–åˆ° TestXLua ç±»å¯¹åº”çš„ cls_tableï¼Œç”±äº Test2 æ˜¯é™æ€æ–¹æ³•ï¼Œåœ¨ cls_table ä¸­å¯ä»¥ç›´æ¥æ‹¿åˆ°å…¶å¯¹åº”çš„åŒ…è£¹æ–¹æ³•_m_Test2_xlua_st_ï¼Œç„¶åé€šè¿‡è°ƒç”¨_m_Test2_xlua_st_è€Œé—´æ¥è°ƒç”¨äº† TestXLua ç±»çš„ Test2 æ–¹æ³•\n\nä½¿ç”¨åå°„å¡«å……å…ƒè¡¨  å½“æ²¡æœ‰ç”Ÿæˆä»£ç æ—¶ï¼Œä¼šä½¿ç”¨åå°„è¿›è¡Œæ³¨å†Œï¼Œä¸ç”Ÿæˆä»£ç è¿›è¡Œæ³¨å†Œçš„é€»è¾‘åŸºæœ¬ç›¸åŒã€‚é€šè¿‡åå°„è·å–åˆ°ç±»çš„å„ä¸ªé™æ€å€¼å’Œéé™æ€å€¼ï¼Œç„¶ååˆ†åˆ«æ³¨å†Œåˆ°ä¸åŒçš„è¡¨ä¸­ï¼Œä»¥åŠå¡«å…… __index å’Œ__newindexå…ƒæ–¹æ³•\n// Utils.cspublic static void ReflectionWrap(RealStatePtr L, Type type, bool privateAccessible)&#123;    LuaAPI.lua_checkstack(L, 20);    int top_enter = LuaAPI.lua_gettop(L);    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);    //create obj meta table    LuaAPI.luaL_getmetatable(L, type.FullName);    if (LuaAPI.lua_isnil(L, -1))    &#123;        LuaAPI.lua_pop(L, 1);        LuaAPI.luaL_newmetatable(L, type.FullName);    &#125;    // ä¸ºå…ƒè¡¨æ·»åŠ  xlua_tag æ ‡å¿—    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());    LuaAPI.lua_pushnumber(L, 1);    LuaAPI.lua_rawset(L, -3);  // å…ƒè¡¨ [xlua_tag] = 1    int obj_meta = LuaAPI.lua_gettop(L);      LuaAPI.lua_newtable(L);    int cls_meta = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_field = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_getter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int obj_setter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int cls_field = LuaAPI.lua_gettop(L);    //set cls_field to namespace    SetCSTable(L, type, cls_field);    //finish set cls_field to namespace    LuaAPI.lua_newtable(L);    int cls_getter = LuaAPI.lua_gettop(L);    LuaAPI.lua_newtable(L);    int cls_setter = LuaAPI.lua_gettop(L);    LuaCSFunction item_getter;    LuaCSFunction item_setter;    makeReflectionWrap(L, type, cls_field, cls_getter, cls_setter, obj_field, obj_getter, obj_setter, obj_meta,        out item_getter, out item_setter, privateAccessible ? (BindingFlags.Public | BindingFlags.NonPublic) : BindingFlags.Public);    // init obj metatable    LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);    LuaAPI.lua_rawset(L, obj_meta);    LuaAPI.xlua_pushasciistring(L, &quot;__tostring&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);    LuaAPI.lua_rawset(L, obj_meta);    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, obj_field);  // 1.upvalue methods = obj_field    LuaAPI.lua_pushvalue(L, obj_getter);  // 2.upvalue getters = obj_getter    translator.PushFixCSFunction(L, item_getter);  // 3.upvalue csindexer = item_getter    translator.PushAny(L, type.BaseType());  // å‹å…¥ BaseTypeï¼Œ4.upvalue base    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  // 5.upvalue indexfuncs = æ³¨å†Œè¡¨ [LuaIndexs]    LuaAPI.lua_pushnil(L);  // 6.upvalue arrayindexer = nil    LuaAPI.gen_obj_indexer(L);  // ç”Ÿæˆ__index å‡½æ•°    //store in lua indexs function tables    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);      translator.Push(L, type);  // å‹å…¥ type    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaIndexs][type] = __index å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, obj_meta); // set __index  å³ obj_meta[&quot;__index&quot;] = ç”Ÿæˆçš„__index å‡½æ•°    LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, obj_setter);    translator.PushFixCSFunction(L, item_setter);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.lua_pushnil(L);    LuaAPI.gen_obj_newindexer(L);    //store in lua newindexs function tables    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaNewIndexs][type] = __newindex å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, obj_meta); // set __newindex                                    //finish init obj metatable    LuaAPI.xlua_pushasciistring(L, &quot;UnderlyingSystemType&quot;);    translator.PushAny(L, type);    LuaAPI.lua_rawset(L, cls_field);  // cls_field[&quot;UnderlyingSystemType&quot;] = type  ï¼Œ è®°å½•ç±»çš„åŸºç¡€ç±»å‹    if (type != null &amp;&amp; type.IsEnum())    &#123;        LuaAPI.xlua_pushasciistring(L, &quot;__CastFrom&quot;);        translator.PushFixCSFunction(L, genEnumCastFrom(type));        LuaAPI.lua_rawset(L, cls_field);    &#125;    //init class meta    LuaAPI.xlua_pushasciistring(L, &quot;__index&quot;);    LuaAPI.lua_pushvalue(L, cls_getter);    LuaAPI.lua_pushvalue(L, cls_field);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_indexer(L);    //store in lua indexs function tables    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // æ³¨å†Œè¡¨ [LuaClassIndexs][type] = __index å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta); // set __index     LuaAPI.xlua_pushasciistring(L, &quot;__newindex&quot;);    LuaAPI.lua_pushvalue(L, cls_setter);    translator.Push(L, type.BaseType());    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    LuaAPI.gen_cls_newindexer(L);    //store in lua newindexs function tables    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);    translator.Push(L, type);    LuaAPI.lua_pushvalue(L, -3);    LuaAPI.lua_rawset(L, -3);  // // æ³¨å†Œè¡¨ [LuaClassNewIndexs][type] = __newindex å‡½æ•°    LuaAPI.lua_pop(L, 1);    LuaAPI.lua_rawset(L, cls_meta); // set __newindex    // ...&#125;\n\nè°ƒç”¨ C# æ–¹æ³•æ—¶å‚æ•°çš„ä¼ é€’  å…ˆæ¥è§£å†³å‰é¢é—ç•™çš„ä¸€ä¸ªé—®é¢˜ï¼Œå¯¹äºç±»çš„é™æ€å€¼æˆ–æ˜¯éé™æ€å€¼ä¸ºä»€ä¹ˆéƒ½éœ€è¦ç”Ÿæˆå¯¹åº”çš„åŒ…è£¹æ–¹æ³•ï¼Ÿå…¶å®åŒ…è£¹æ–¹æ³•å°±æ˜¯ç”¨æ¥å¤„ç†å‚æ•°ä¼ é€’é—®é¢˜çš„ã€‚\nä¸ºäº†æ­£ç¡®çš„å’Œ Lua é€šè®¯ï¼ŒC å‡½æ•°å·²ç»å®šä¹‰å¥½äº†åè®®ã€‚è¿™ä¸ªåè®®å®šä¹‰äº†å‚æ•°ä»¥åŠè¿”å›å€¼ä¼ é€’æ–¹æ³•ï¼šC å‡½æ•°é€šè¿‡ Lua ä¸­çš„æ ˆæ¥æ¥å—å‚æ•°ï¼Œå‚æ•°ä»¥æ­£åºå…¥æ ˆï¼ˆç¬¬ä¸€ä¸ªå‚æ•°é¦–å…ˆå…¥æ ˆï¼‰ã€‚å› æ­¤ï¼Œå½“å‡½æ•°å¼€å§‹çš„æ—¶å€™ï¼Œlua_gettop(L)å¯ä»¥è¿”å›å‡½æ•°æ”¶åˆ°çš„å‚æ•°ä¸ªæ•°ã€‚ç¬¬ä¸€ä¸ªå‚æ•°ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰åœ¨ç´¢å¼• 1 çš„åœ°æ–¹ï¼Œè€Œæœ€åä¸€ä¸ªå‚æ•°åœ¨ç´¢å¼• lua_gettop(L) å¤„ã€‚å½“éœ€è¦å‘ Lua è¿”å›å€¼çš„æ—¶å€™ï¼ŒC å‡½æ•°åªéœ€è¦æŠŠå®ƒä»¬ä»¥æ­£åºå‹åˆ°å †æ ˆä¸Šï¼ˆç¬¬ä¸€ä¸ªè¿”å›å€¼æœ€å…ˆå‹å…¥ï¼‰ï¼Œç„¶åè¿”å›è¿™äº›è¿”å›å€¼çš„ä¸ªæ•°ã€‚åœ¨è¿™äº›è¿”å›å€¼ä¹‹ä¸‹çš„ï¼Œå †æ ˆä¸Šçš„ä¸œè¥¿éƒ½ä¼šè¢« Lua ä¸¢æ‰ã€‚å’Œ Lua å‡½æ•°ä¸€æ ·ï¼Œä» Lua ä¸­è°ƒç”¨ C å‡½æ•°å¯ä»¥æœ‰å¾ˆå¤šè¿”å›å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒLua è¿™è¾¹è°ƒç”¨ C å‡½æ•°æ—¶çš„å‚æ•°ä¼šè¢«è‡ªåŠ¨çš„å‹æ ˆï¼Œè¿™å¥—æœºåˆ¶ Lua å†…éƒ¨å·²ç»å®ç°å¥½äº†ã€‚æ–‡ç« å¼€å¤´ä¹Ÿæåˆ°ï¼ŒC# å¯ä»¥å€ŸåŠ© C/C++ æ¥ä¸ Lua è¿›è¡Œæ•°æ®é€šä¿¡ï¼Œæ‰€ä»¥ C# éœ€è¦é€šè¿‡ C API è·å–åˆ° Lua ä¼ é€’è¿‡æ¥çš„å‚æ•°ï¼Œè€Œè¿™ä¸ªé€»è¾‘å°±è¢«å°è£…åœ¨äº†åŒ…è£¹æ–¹æ³•ä¸­ã€‚ä»¥ TestXLua çš„Test1æ–¹æ³•ä¸ºä¾‹ï¼Œå®ƒéœ€è¦ä¸€ä¸ª int å‚æ•°ã€‚æ‰€ä»¥å®ƒçš„åŒ…è£¹æ–¹æ³•éœ€è¦é€šè¿‡ C API è·å–åˆ°ä¸€ä¸ª int å‚æ•°ï¼Œç„¶åå†ä½¿ç”¨è¿™ä¸ªå‚æ•°å»è°ƒç”¨çœŸæ­£çš„æ–¹æ³•\n[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static int _m_Test1(RealStatePtr L)&#123;    try &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);        &#123;            int _a = LuaAPI.xlua_tointeger(L, 2);  // è·å–åˆ° int å‚æ•°            gen_to_be_invoked.Test1(_a);  // è°ƒç”¨çœŸæ­£çš„ Test1 æ–¹æ³•            return 0;        &#125;    &#125; catch(System.Exception gen_e) &#123;        return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);    &#125;&#125;\n\nè¿™ä¹Ÿè§£é‡Šäº†ä¸ºä»€ä¹ˆéœ€è¦ä¸ºç±»çš„å±æ€§ç”Ÿæˆå¯¹åº”çš„ get å’Œsetæ–¹æ³•ï¼Œå› ä¸ºåªæœ‰å°† Lua çš„è®¿é—®æˆ–èµ‹å€¼æ“ä½œè½¬æ¢æˆå‡½æ•°è°ƒç”¨å½¢å¼æ—¶ï¼Œå‚æ•°æ‰èƒ½åˆ©ç”¨å‡½æ•°è°ƒç”¨æœºåˆ¶è¢«è‡ªåŠ¨çš„å‹æ ˆï¼Œä»è€Œä¼ é€’ç»™ C#\n-- lua æµ‹è¯•ä»£ç obj.Name = &quot;test&quot;  -- èµ‹å€¼æ“ä½œsetter[&quot;Name&quot;](&quot;test&quot;)  -- å‡½æ•°è°ƒç”¨å½¢å¼\n\nè¿™é‡Œå†æä¸€ä¸‹å‡½æ•°é‡è½½çš„é—®é¢˜ï¼Œå› ä¸º C# æ˜¯æ”¯æŒé‡è½½çš„ï¼Œæ‰€ä»¥ä¼šå­˜åœ¨å¤šä¸ªåŒåå‡½æ•°ï¼Œä½†å‚æ•°ä¸åŒçš„æƒ…å†µã€‚å¯¹äºè¿™ç§æƒ…å†µï¼Œåªèƒ½é€šè¿‡åŒåå‡½æ•°è¢«è°ƒç”¨æ—¶ä¼ é€’çš„å‚æ•°æƒ…å†µæ¥åˆ¤æ–­åˆ°åº•åº”è¯¥è°ƒç”¨å“ªä¸ªå‡½æ•°\n[LuaCallCSharp]public class TestXLua&#123;    // å‡½æ•°é‡è½½ Test1    public void Test1(int a)&#123;    &#125;    // å‡½æ•°é‡è½½ Test1    public void Test1(bool b)&#123;    &#125;&#125;// ä¸º Test1 ç”Ÿæˆçš„åŒ…è£¹æ–¹æ³•[MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))]static int _m_Test1(RealStatePtr L)&#123;    try &#123;        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, 1);        int gen_param_count = LuaAPI.lua_gettop(L);        if(gen_param_count == 2&amp;&amp; LuaTypes.LUA_TNUMBER == LuaAPI.lua_type(L, 2))  // æ ¹æ®å‚æ•°æ•°é‡ä¸ç±»å‹åˆ¤æ–­è°ƒç”¨å“ªä¸ªæ–¹æ³•        &#123;            int _a = LuaAPI.xlua_tointeger(L, 2);            gen_to_be_invoked.Test1(_a);            return 0;        &#125;        if(gen_param_count == 2&amp;&amp; LuaTypes.LUA_TBOOLEAN == LuaAPI.lua_type(L, 2))  // æ ¹æ®å‚æ•°æ•°é‡ä¸ç±»å‹åˆ¤æ–­è°ƒç”¨å“ªä¸ªæ–¹æ³•        &#123;             bool _b = LuaAPI.lua_toboolean(L, 2);            gen_to_be_invoked.Test1(_b);            return 0;        &#125;    &#125; catch(System.Exception gen_e) &#123;        return LuaAPI.luaL_error(L, &quot;c# exception:&quot; + gen_e);    &#125;    return LuaAPI.luaL_error(L, &quot;invalid arguments to TestXLua.Test1!&quot;);&#125;\n\nGCC# å’Œ Lua éƒ½æ˜¯æœ‰è‡ªåŠ¨åƒåœ¾å›æ”¶æœºåˆ¶çš„ï¼Œå¹¶ä¸”ç›¸äº’æ˜¯æ— æ„ŸçŸ¥çš„ã€‚å¦‚æœä¼ é€’åˆ° Lua çš„ C# å¯¹è±¡è¢« C# è‡ªåŠ¨å›æ”¶æ‰äº†ï¼Œè€Œ Lua è¿™è¾¹ä»æ¯«ä¸çŸ¥æƒ…ç»§ç»­ä½¿ç”¨ï¼Œåˆ™å¿…ç„¶ä¼šå¯¼è‡´æ— æ³•é¢„çŸ¥çš„é”™è¯¯ã€‚æ‰€ä»¥åŸºæœ¬åŸåˆ™æ˜¯ä¼ é€’åˆ° Lua çš„ C#å¯¹è±¡ï¼ŒC# ä¸èƒ½è‡ªåŠ¨å›æ”¶ï¼Œåªèƒ½ Lua åœ¨ç¡®å®šä¸å†ä½¿ç”¨åé€šçŸ¥ C# è¿›è¡Œå›æ”¶  ä¸ºäº†ä¿è¯ C# ä¸ä¼šè‡ªåŠ¨å›æ”¶å¯¹è±¡ï¼Œæ‰€æœ‰ä¼ é€’ç»™ Lua çš„å¯¹è±¡éƒ½ä¼šè¢« objects ä¿æŒå¼•ç”¨ã€‚çœŸå®ä¼ é€’ç»™ Lua çš„å¯¹è±¡ç´¢å¼•å°±æ˜¯å¯¹è±¡åœ¨ objects ä¸­çš„ç´¢å¼• Lua è¿™è¾¹ä¸ºå¯¹è±¡ç´¢å¼•å»ºç«‹çš„userdata ä¼šè¢«ä¿å­˜åœ¨ç¼“å­˜è¡¨ä¸­ï¼Œè€Œç¼“å­˜è¡¨çš„å¼•ç”¨æ¨¡å¼è¢«è®¾ç½®ä¸ºå¼±å¼•ç”¨\n// ObjectTranslator.csLuaAPI.lua_newtable(L);  // åˆ›å»ºç¼“å­˜è¡¨LuaAPI.lua_newtable(L);  // åˆ›å»ºå…ƒè¡¨LuaAPI.xlua_pushasciistring(L, &quot;__mode&quot;);LuaAPI.xlua_pushasciistring(L, &quot;v&quot;);LuaAPI.lua_rawset(L, -3);  // å…ƒè¡¨ [__mode] = vï¼Œè¡¨ç¤ºè¿™å¼ è¡¨çš„æ‰€æœ‰å€¼çš†ä¸ºå¼±å¼•ç”¨LuaAPI.lua_setmetatable(L, -2);  // ä¸ºç¼“å­˜è¡¨è®¾ç½®å…ƒè¡¨cacheRef = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);\n\nå½“ Lua è¿™è¾¹ä¸å†å¼•ç”¨è¿™ä¸ª userdata æ—¶ï¼Œuserdataä¼šè¢«ä»ç¼“å­˜è¡¨ä¸­ç§»é™¤ï¼ŒLua GC æ—¶ä¼šå›æ”¶è¿™ä¸ª userdataï¼Œå›æ”¶ä¹‹å‰åˆä¼šè°ƒç”¨ userdata å…ƒè¡¨çš„ __gc æ–¹æ³•ï¼Œä»¥æ­¤æ¥é€šçŸ¥ C#ï¼Œâ€æˆ‘ Lua è¿™è¾¹ä¸å†ä½¿ç”¨è¿™ä¸ªå¯¹è±¡äº†ï¼Œä½ è¯¥å›æ”¶å¯ä»¥å›æ”¶äº†â€ã€‚åœ¨ BeginObjectRegisteræ–¹æ³•å†…éƒ¨ï¼Œä¼šä¸º userdata çš„å…ƒè¡¨æ·»åŠ  __gc æ–¹æ³•\n// Utils.cs BeginObjectRegister æ–¹æ³•if ((type == null || !translator.HasCustomOp(type)) &amp;&amp; type != typeof(decimal))&#123;    LuaAPI.xlua_pushasciistring(L, &quot;__gc&quot;);    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);    LuaAPI.lua_rawset(L, -3);  // ä¸ºå…ƒè¡¨è®¾ç½®__gc æ–¹æ³•&#125;\n\ntranslator.metaFunctions.GcMetaå®é™…ä¸Šå°±æ˜¯ StaticLuaCallbacks çš„LuaGCæ–¹æ³•\n// StaticLuaCallbacks.cs[MonoPInvokeCallback(typeof(LuaCSFunction))]public static int LuaGC(RealStatePtr L)&#123;    try    &#123;        int udata = LuaAPI.xlua_tocsobj_safe(L, 1);        if (udata != -1)        &#123;            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);            if (translator != null )            &#123;                translator.collectObject(udata);            &#125;        &#125;        return 0;    &#125;    catch (Exception e)    &#123;        return LuaAPI.luaL_error(L, &quot;c# exception in LuaGC:&quot; + e);    &#125;&#125;\n\nLuaGCæ–¹æ³•åˆä¼šè°ƒç”¨ collectObject æ–¹æ³•ã€‚åœ¨ collectObject æ–¹æ³•å†…éƒ¨ä¼šå°†å¯¹è±¡ä» objects ç§»é™¤ï¼Œä»è€Œä½¿å¯¹è±¡ä¸å†è¢«å›ºå®šå¼•ç”¨ï¼Œèƒ½å¤Ÿè¢« C# GC æ­£å¸¸å›æ”¶\n// ObjectTranslator.csinternal void collectObject(int obj_index_to_collect)&#123;    object o;        if (objects.TryGetValue(obj_index_to_collect, out o))    &#123;        objects.Remove(obj_index_to_collect);                if (o != null)        &#123;            int obj_index;            //lua gc æ˜¯å…ˆæŠŠ weak table ç§»é™¤åå†è°ƒç”¨__gcï¼Œè¿™æœŸé—´åŒä¸€ä¸ªå¯¹è±¡å¯èƒ½å†æ¬¡ push åˆ° luaï¼Œå…³è”åˆ°æ–°çš„ index            bool is_enum = o.GetType().IsEnum();            if ((is_enum ? enumMap.TryGetValue(o, out obj_index) : reverseMap.TryGetValue(o, out obj_index))                &amp;&amp; obj_index == obj_index_to_collect)            &#123;                if (is_enum)                &#123;                    enumMap.Remove(o);                &#125;                else                &#123;                    reverseMap.Remove(o);                &#125;            &#125;        &#125;    &#125;&#125;","categories":["æ¸¸æˆå¼€å‘"],"tags":["C#","xLua"]},{"title":"ç°ä»£ C++ åŸºç¡€","url":"/2024/06/03/53/","content":"Basics ReviewArray Type\nMultidimensional array å¤šç»´æ•°ç»„\né™¤äº†ç¬¬ä¸€ç»´å…¶å®ƒç»´å¿…é¡»æ˜ç¡®æŒ‡å‡ºå¤§å°ï¼ˆexplicit sizeï¼‰\nä¸å¯ä»¥å…¨éƒ¨ decay\nDynamic allocation\nmalloc in C and new/new [] in C++\nnewå’Œ malloc è¿”å›éƒ½æ˜¯æŒ‡é’ˆ\né‡Šæ”¾\n\n\n\n\n\nFunction\nå‡½æ•°è¿”å›ç±»å‹ä¸èƒ½æ˜¯å‡½æ•°æˆ–è€…æ•°ç»„ï¼ˆä½†æ˜¯å¯ä»¥æ˜¯å®ƒä»¬çš„å¼•ç”¨ï¼‰\n\nä¸åº”è¯¥è¿”å›å±€éƒ¨å˜é‡çš„æŒ‡é’ˆæˆ–è€…å¼•ç”¨ï¼ˆè¶…å‡ºäº†å±€éƒ¨å˜é‡ç”Ÿå‘½å‘¨æœŸçš„èŒƒå›´ï¼‰\ne.g. int&amp; Test() { int a = 1; return &amp;a;}\n\n\nå£°æ˜ä¸º static çš„å±€éƒ¨å˜é‡å…·æœ‰å…¨å±€æ€§\n\n\nFunction pointers å‡½æ•°æŒ‡é’ˆ\n\nvoid(*)(int)\n\nclockwise/spiral rule\n\nType alias ç”¨ C++ 11 ä¸­çš„using\nusing MyFuncType1 = int(*)(float);using MyFuncType2 = int(*)(int);using MyFuncType3 = int(*)(MyFuncType1);\nC è¯­è¨€ä¸­å¯ä»¥ç”¨ typedefï¼Œä½†æ˜¯æ²¡æœ‰using å¼ºå¤§\n\n\n\n\nAttribute\n[[attribute]] C++ 11ï¼Œ[[attribute(\"reason\")]] C++ 20\n[[deprecated]]å’Œ[[deprecated(\"reason\")]] C++ 14\n[[noreturn]] C++ 11\n[[maybe_unused]] C++ 17\n\ne.g.\n[[nodiscard]] int Add(int a, int b) {return a + b; }int main(){    Add(1, 2); // int res = Add(1, 2);    return 0}\n\nwarning: æ”¾å¼ƒå…·æœ‰ [[nodiscard]] å±æ€§å‡½æ•°çš„è¿”å›å€¼\nEnumeration\nä¸€ä¸ªè¢«é™åˆ¶å–å€¼çš„ç±»\n\n\næ¯”è¾ƒåƒä½¿ç”¨å…¨å±€å˜é‡\nåŒæ—¶è¿›è¡Œæ•´å½¢è¿ç®—ä¹Ÿæ²¡æœ‰å®‰å…¨æ£€æŸ¥\nC++ 11 å¼•å…¥äº† scoped enumeration æé«˜å®‰å…¨æ€§\n\ne.g.\n// enum Day {Monday};enum class Day {Monday};int main(){    // int a = Monday;    Day a = Day::Monday    return 0;}\n\n\nå¯ä»¥ä½¿ç”¨ std::underlying_type&lt;Day&gt;::type æˆ–è€…std::underlying_type_t&lt;Day&gt; C++ 14 è½¬æˆæ•´æ•°ç±»å‹\nC++ 23 ä¸­ä¹Ÿå¯ä»¥ä½¿ç”¨std::to_underlying&lt;Day&gt;(day)\n\n\nå¯ä»¥ä½¿ç”¨ Day day{1}; åˆå§‹åŒ– C++ 17ï¼Œä½†æ˜¯ä¸èƒ½ç›´æ¥èµ‹å€¼Day day = 1; æˆ–day = 1;\nå¯ä»¥ä½¿ç”¨ä½æ“ä½œç¬¦\n\nExpression\nè¿ç®—ç¬¦å’Œè¡¨è¾¾å¼ä¸‰ä¸ªé‡è¦æ¦‚å¿µ\nPrecedence ä¼˜å…ˆçº§\nAssociativity ç»“åˆæ€§\nOrder é¡ºåº\n\n\nFrom the view of compiler, an expression is in fact a tree, determined by associativity and precedence. e.g. 9 / 3 / 2 + 2 * 3\nPrecedence is used to split terms first.\nAssociativity determines how the tree will grow.\nThen, itâ€™s order of expression evaluation that computes the whole tree. ä½†æ˜¯é¡ºåºæ˜¯ä¸ç¡®å®šçš„\nf1() + f2() + f3()ï¼Œf1()ï¼Œf1()ï¼Œf1()å“ªä¸€ä¸ªå…ˆè¢« evaluated æ˜¯ä¸ç¡®å®šçš„\n\n\n\n\nThere are some rules\nFor &amp;&amp; and ||, since they have short-circuit property, the first part will be fully evaluated.\nFor a function call, all parameters (including a for e.g. a.Func() or a-&gt;Func()) are fully evaluated before entering the function.\nä¸‰ç›®è¿ç®—\né€—å·è¡¨è¾¾å¼\nC++ 17\nParameters in function are evaluated indeterminately, i.e. every sub-tree represented by te parameter is fully evaluated in a non-overlap way ä¸ä¼šä»¥äº¤å çš„å½¢å¼ evaluated\nè¿ç®—ç¬¦é‡è½½ï¼Œå’Œ build-in è¿ç®—ç¬¦çš„ evaluated é¡ºåºä¸€è‡´ï¼Œè€Œä¸æ˜¯è¢«å½“ä½œæ™®é€šå‡½æ•°\nMore useful examples: chained call\n\n\n\n\n\nstd::string s = \"I have it even works if you don't believe\";s.replace(0, 8, \"\").replace(s.find(\"even\"), 4, \"sometimes\").replace(s.find(\"you don't\"), 9, \"I\");\n\nclassCtor &amp; Dtor\næ‹·è´æ„é€ å‡½æ•°\nèµ‹å€¼æ„é€ å‡½æ•°\nThe recommended way is member initializer list:\nmember1{...}, member2{...}, ... {/* function body */}\n{} is used since C++ 11\n\n\né»˜è®¤æ„é€ å‡½æ•°å»ºè®®ä½¿ç”¨Class() = default;\nå¦‚æœæˆå‘˜å˜é‡æœ‰é»˜è®¤å€¼ï¼Œå°±ä¸å»ºè®®ä½¿ç”¨ä¸Šé¢çš„æ„é€ å‡½æ•°çš„å½¢å¼ï¼Œè€Œæ˜¯ç›´æ¥ç”¨é»˜è®¤å€¼åˆå§‹åŒ–\n\nInitialization of Object\nSince C++ 11, Uniform Initialization is introduced\næ‰€æœ‰çš„åˆå§‹åŒ–éƒ½å¯ä»¥ç”¨{}\nç›¸æ¯”äº () æ›´å®‰å…¨ Narrowing Conversion ç¼©çª„å˜æ¢æ£€æŸ¥\nthe converted type cannot represent all values\nuint32_tç±»å‹ç”¨ uint16_t åˆå§‹åŒ–ï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™\n\n\nthe facilitates type safety\n\n\n\n\nValue initialization: No parameter for initialization T a()ï¼Œ T a{}ï¼Œ new T{}ï¼Œ new T()\nDirect initialization: T a(x, y, ...)ï¼ŒT(x, y, ...)ï¼Œnew T(x, y, ...)ï¼ŒT a{x, y, ...}\nCopy initialization: T a = xx;ï¼ŒT a[] = { xx, ...};\nCtors that use explicit cannot use this way\nBefore C++ 17, this also requires available copy ctor.\n\n\n\nclass A {public: explicit A(int a) {}};void Func(A a) {}int main(){    A a = 1;    // error    A a = A(1);    Func(1);    // error    Func(A(1));     return 0}\n\n\nList initialization\nAggregate initialization\n\nMember Functions\næ‰€æœ‰çš„æˆå‘˜å‡½æ•°éƒ½éšå¼æœ‰ä¸€ä¸ª this æŒ‡é’ˆ\nå¦‚æœæœŸæœ›å‡½æ•°ä¸èƒ½æ›´æ”¹æˆå‘˜å˜é‡ï¼Œå¯ä»¥ä½¿ç”¨ const å…³é”®å­— make this to be const\né™æ€æˆå‘˜å‡½æ•°\næ²¡æœ‰ this æŒ‡é’ˆ\n\n\n\nAccess Control\nprivateã€protectedã€publicï¼Œé»˜è®¤æ˜¯private\nprotectedç”¨åœ¨ç»§æ‰¿ä¸­\nå‹å…ƒ\n\nInheritance\nå­ç±» / æ´¾ç”Ÿç±»ã€çˆ¶ç±» / åŸºç±»\nå­ç±» / æ´¾ç”Ÿç±»å¯ä»¥è®¿é—®çˆ¶ç±»ä¸­æ‰€æœ‰ public å’Œprotectedæˆå‘˜\nç»§æ‰¿å’Œç»„åˆ\næ´¾ç”Ÿç±»å¯ä»¥éšå¼çš„è½¬åŒ–æˆåŸºç±»\n\nSlicing Problemint main(){    Student student1{...}, student2{...};    Person&amp; student1Ref = student1;    student1Ref = student2;    return 0;}\n\n\nThere exists implicit conversion in student1Ref = student2 so actually it calls Person::operator=(const Person&amp;)\nCan decorating operator= with virtual help\nPerson::operator= needs const Person&amp; but Student::operator= accepts const Student&amp; å‚æ•°éƒ½ä¸ä¸€æ ·ï¼Œè™šå‡½æ•°éƒ½ä¸ç”Ÿæ•ˆ\n\n\nThis is called â€œslicingâ€ because such operation will only affect the base slice but not the initial object as whole åªå½±å“äº†ä¸€å°ç‰‡\nPolymorphic base class should hide their copy &amp; move functions if it has data member, otherwise deleting them å¯¹äºå…·æœ‰å¤šæ€å±æ€§çš„åŸºç±»ï¼Œåº”è¯¥éšè—å®ƒä»¬çš„æ‹·è´å’Œç§»åŠ¨å‡½æ•°\nMake copy &amp; move functions protected so derived class can call them\n\nMultiple Inheritanceclass Elephant {};class Seal {};class ElephantSeal : public Elephant, public Seal {};\n\n\nDreaded diamond\nC++ introduces virtual inheritance\nAll virtual bases will be merged and seen as the same\n\n\n\nclass Animal {public: int weight; };class Elephant : public virtual Animal {};class Seal : virtual public Animal {}; // virtual å’Œ public é¡ºåºæ˜¯ä¸é‡è¦çš„class ElephantSeat : public Elephant, public Seal {};\n\n\nThat is, you define many ABCs, which tries to reduce data members and non-pure-virtual member functions as much as you can å®šä¹‰å¾ˆå¤šæŠ½è±¡ç±»ï¼Œå°½å¯èƒ½å‡å°‘æˆå‘˜å˜é‡å’Œéçº¯è™šå‡½æ•°çš„æ•°é‡ï¼Œæœ€å¥½æ˜¯æ²¡æœ‰\nThey usually denote â€œ-ableâ€ functionality è¿™æ ·å±•ç°å‡ºæ¥çš„å°±æ˜¯å°±æœ‰æŸç§èƒ½åŠ›\n\nPolymorphism å¤šæ€\nyou can use the base class to load the derived object and call its own methods ä½¿ç”¨åŸºç±»çš„æŒ‡é’ˆ / å¼•ç”¨ï¼Œæ‰¿è½½æ´¾ç”Ÿç±»çš„å¯¹è±¡ï¼Œä»è€Œè°ƒç”¨æ´¾ç”Ÿç±»çš„æ–¹æ³•\nvirtual pointer and virtual table\nEvery object whose class has a virtual method will have a virtual pointer, which points to virtual table of its class æ¯ä¸ªç±»ä¸­éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘è™šè¡¨çš„æŒ‡é’ˆï¼Œè™šè¡¨å†…å®¹å°±æ˜¯å£°æ˜ä¸º virtual å‡½æ•°çš„åœ°å€\nIn C++ 11, itâ€™s recommended to use override å­ç±»æ²¡æœ‰ override ç¼–è¯‘å™¨ä¼šæŠ¥é”™\nfinal It means override, and the derived class cannot override again ç»§æ‰¿é“¾ä¸­çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹\nclass A final {...}; è®©ç±»ä¸èƒ½è¢«ç»§æ‰¿\nå»è™šåŒ–ï¼Œç¼–è¯‘ä¼˜åŒ–\n\n\nabstract class æŠ½è±¡ç±»\næŠ½è±¡ç±»ä¸èƒ½è¢«å®ä¾‹åŒ–\nå¯ä»¥æ˜¯ä½¿ç”¨æŠ½è±¡ç±»çš„æŒ‡é’ˆï¼ŒæŒ‡å‘çš„éƒ½æ˜¯æ´¾ç”Ÿç±»çš„å¯¹è±¡\nC++ é€šè¿‡çº¯è™šå‡½æ•°å®ç°æŠ½è±¡ç±» virtual void PrintInfo() const = 0;\næ´¾ç”Ÿç±»ç»§æ‰¿è‡ªæŠ½è±¡ç±»å¿…é¡»å®ç°çº¯è™šå‡½æ•°ï¼Œå¦åˆ™ä»ç„¶æ˜¯æŠ½è±¡ç±»\nDonâ€™t call any virtual function and any function that calls virtual function in ctor &amp; dtor åœ¨æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¸­ä¸è¦è°ƒç”¨ä»»ä½•è™šå‡½æ•°ï¼Œä¹Ÿä¸è¦æ‰è°ƒç”¨ä»»ä½•å¯èƒ½è°ƒç”¨è™šå‡½æ•°çš„å‡½æ•°\nYou should usually make dtor of base class virtual é€šå¸¸å°†ææ„å‡½æ•°å£°æ˜ä¸ºè™šå‡½æ•°\ndeleting Base* that cast from Derived* will lead to correct dtor æ´¾ç”Ÿç±»æŒ‡é’ˆèµ‹ç»™åŸºç±»ï¼Œå½“è°ƒç”¨ delete æ—¶ï¼Œå¦‚æœä¸åŸºç±»ä¸æ˜¯è™šææ„å‡½æ•°ï¼Œå°±ä¼šè°ƒç”¨åŸºç±»çš„ææ„å‡½æ•°\n\n\næ„é€ å‡½æ•°ä¸èƒ½æ˜¯çº¯è™šå‡½æ•°\n\n\n\nSome Covert Facts in Inheritance\noverrideä¸æ­¢è¡¨ç¤ºå¤å†™è™šå‡½æ•°çš„å«ä¹‰ï¼Œå¯¹äºéè™šå‡½æ•°çš„å¤å†™ä¹Ÿå«â€œoverrideâ€\nprivate inheritance usually denotes the relation of has-a\nè™šå‡½æ•°çš„è¿”å›ç±»å‹å¯ä»¥æœ‰äº›è®¸æ”¹å˜ï¼šyou can use Base* to both accept Base* and Derived* å¤å†™è™šå‡½æ•°çš„è¿”å›å€¼å¯ä»¥æ˜¯æŒ‡å‘åŸºç±»çš„æŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥æ˜¯æŒ‡å‘æ´¾ç”Ÿç±»çš„æŒ‡é’ˆ\næ™ºèƒ½æŒ‡é’ˆä¸èƒ½æœ‰â€œåå˜â€\n\n\nå½“è™šæ–¹æ³•æœ‰é»˜è®¤å‚æ•°çš„æ—¶å€™ï¼Œç”¨ä»€ä¹ˆç±»å‹çš„æŒ‡é’ˆè°ƒç”¨æ—¶ï¼Œå°±ä¼šè¿”å›è¯¥ç±»å‹å†…çš„é»˜è®¤å€¼\né»˜è®¤çš„å‚æ•°åœ¨ç¼–è¯‘æœŸé—´è¢«è¯†åˆ«ï¼Œè™šè¡¨æ˜¯åœ¨è¿è¡Œæ—¶è·³è½¬çš„\n\n\n\ne.g.\nvoid Parent::Go(int i = 2) {std::cout &lt;&lt; \"Base's go with i = \" &lt;&lt; i &lt;&lt; \"\\n\"; }void Child::Go(int i = 4) {std::cout &lt;&lt; \"Derived's go with i =\" &lt;&lt; i &lt;&lt; \"\\n\"; }Child child;child.Go(); // Derived's go with i = 4Parent&amp; childRef = child;childRef.Go();  // Base's go with i = 2\n\n\nå¯ä»¥æ›´æ”¹è™šæ–¹æ³•çš„è®¿é—®å±æ€§ï¼ˆä½†æ˜¯ä¸å»ºè®®ï¼‰\n\nstruct\nå’Œ class åŸºæœ¬ä¸Šä¸€æ ·ï¼Œé™¤äº† struct é»˜è®¤çš„è®¿é—®æ§åˆ¶æ˜¯public\nä¸åº”è¯¥æœ‰æˆå‘˜å‡½æ•°ï¼Œæœ€å¤šæœ‰ ctorã€dtor å’Œè¿ç®—ç¬¦é‡è½½\nWith these constraints (except for ctor), struct will be an aggregate, which can use aggregate initialization\nSince C++ 20, aggregate can also use designated initialization æŒ‡å®šåˆå§‹åŒ–\n\n\n\n\n\ne.g.\nstruct Priority {int cal; }struct Point{    int x, y;    Priority priority[2];}int main(){    Point p{.x = 1, .y = 2, .priority = {{ .val = 1}, {.val = 2 } } };    return 0;}\n\nFunction Overloading å‡½æ•°é‡è½½\nC++ ä¸­å°±æ˜¯ç›¸åŒçš„å‡½æ•°åä¸åŒçš„å‚æ•°\nC ä¸­æ˜¯ç¦æ­¢çš„\n\n\nThis is done by compilers using a technique called name mangling\nOperator Overloading è¿ç®—ç¬¦é‡è½½\n+ï¼Œ-ï¼Œ*ï¼Œ/ï¼Œ%ï¼Œ|ï¼Œ&amp;ï¼Œ^ï¼Œ&lt;&lt;ï¼Œ&gt;&gt;ï¼šæ¨èä½¿ç”¨åœ¨å…¨å±€å‡½æ•°ä¸­\n+=ï¼Œ-=ï¼Œ*=ï¼Œ/=ï¼Œ|=ï¼Œ&amp;=ï¼Œ^=ï¼Œ&lt;&lt;=ï¼Œ&gt;&gt;=ï¼šå¿…é¡»æ˜¯æˆå‘˜å‡½æ•° since the first operand must be a â€œnamedâ€ object; return reference (i.e. *this)\nPrefix++ &amp; Prefix--ï¼šå¿…é¡»æ˜¯æˆå‘˜å‡½æ•° return *this\nPostfix++ &amp; Postfix-- have an unused parameter int, which is used to distinguish the prefix and postfix\n*ï¼Œ-&gt;ï¼šusually used in e.g. some wrapper of pointers\n&amp;&amp;ï¼Œ||ï¼šshort-circuit ç‰¹æ€§ä¼šå¤±æ•ˆ\n&lt;=&gt;ï¼šä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦\n()\n[]\nSince C++ 23, you can use multidimensional subscript in operator[]\n\n\n\n\n\nLambda Expression\næœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåŒ¿åçš„ structï¼Œé‡è½½äº†operator() const æ–¹æ³•\nBasic format: auto func = [captures](params) -&gt; ReturnType {function body;};\nCaptures are actually members of the struct\nReturnType, params and function are for operator()\nEvery lambda expression has its unique type\nä¸ä¼ ä»»ä½•å‚æ•° () å¯ä»¥çœç•¥æ‰\n\n\nå»ºè®®å°† Lambda è¡¨è¾¾å¼ä¸­çš„æ•è·çš„ä¸œè¥¿æ˜ç¡®å†™å‡ºæ¥\nstatic å’Œ global å˜é‡æ˜¯ä¸éœ€è¦è¢«æ•è·çš„\næ•è· this æŒ‡é’ˆ\nthis by reference, since only copy pointer\n*this really copy all members\nåŒ…æ‹¬ç§æœ‰æˆå‘˜ä¹Ÿå¯ä»¥æ•è·\n\n\nYou may add specifiers after ()\nmutable: since C++ 17, remove const in operator()\nstatic: since C++ 23, same as static operator()\nconstexprã€constevalã€noexcept\n\n\n\nint main(){    int i = 0;    auto m = [i] {i = 1; return 0; }; // ä¸å…è®¸ä¿®æ”¹ i = 1ï¼Œå› ä¸ºé‡è½½çš„ operator() æ˜¯ const    auto m = [i]() mutable {i = 1; return 0; }; // ä¿®æ”¹çš„ä¸æ˜¯å¤–é¢å®šä¹‰çš„å˜é‡ï¼Œæœ¬è´¨ä¸Šä¿®æ”¹çš„æ˜¯ i çš„æ‹·è´}\n\n\nItâ€™s also legal to add attributes between [] and ()\nå‡½æ•°ä¹Ÿå¯ä»¥å†™æˆ Lambda è¡¨è¾¾å¼çš„å½¢å¼ auto Foo(params) -&gt; ReturnType {function body;}\n\nCode Block With Initializer\nauto it = table.find(1);if (it == table.end())    //else    //\n\n\nitä¼šæ³„éœ²å‡ºå»ï¼Œä¸‹é¢å¦‚æœç»§ç»­åˆ¤æ–­ä¼šå†å®šä¹‰è¿­ä»£å™¨ç±»å‹çš„å˜é‡\nSince C++ 17, you mey code like\n\nif (auto it = table.find(1); it == table.end())    //else    //\n\n\nSince C++ 20, range-based for loop can also add an additional initializer, e.g. for (auto vec = GetVec(); auto&amp; m : vec);\nSince C++ 23, type alias declaration can also be initializer, e.g. if (using T = xx; ...)\n\nTemplate\nSince C++ 17, CATD(class template argument deduction) is introduced, meaning that the argument of ctor can deduce the template parameter of class. e.g. std::vector v{1, 2, 3, 4}\nLambda expression can also use template\n\nContainer\nstd::size_t: the type of sizeof() æ„å‘³ç€å¯¹è±¡çš„å¤§å°ä¸èƒ½è¶…è¿‡ std::size_t æ‰€è¡¨ç¤ºçš„èŒƒå›´\nä¹Ÿæ„å‘³ç€æ•°ç»„çš„å¤§å°ä¸èƒ½è¶…è¿‡ std::size_t æ‰€è¡¨ç¤ºçš„èŒƒå›´\nå®¹å™¨çš„å¤§å°ä¹Ÿä¸èƒ½è¶…è¿‡std::size_t\n\n\nstd::ptrdiff_tï¼šä¸¤ä¸ªæŒ‡é’ˆç›¸å‡å¾—åˆ°çš„ç±»å‹\n\nIterators\nInput/Output iterator\nFor output *it = val, it++, ++it, â€˜it1 = it2â€™\nFor input ==, !=, -&gt;\n\n\nForward iterator: e.g. linked list\nBidirectional iterator: --it, it-- e.g. double linked list, map\nRandom access iterator: +, -, +=, -=, [], &lt;, &gt;, &lt;=, &gt;=, != e.g. deque\nContiguous iterator (since C++ 17): ä¿è¯åœ°å€ç©ºé—´æ˜¯è¿ç»­çš„\nIMPORTANT: Iterator are as unsafe as pointers çº¿ç¨‹ä¸å®‰å…¨çš„\nAll containers can get their iterators by:\n.begin(), .end()\n.cbegin(), cend() read-only access\n\n\nåŒå‘é“¾è¡¨ç­‰è¿˜æä¾›äº†å€’åºçš„éå†è¿­ä»£å™¨\n.rbegin(), .rend(), .crbegin(), crend()\n\n\nè¿˜å¯ä»¥ä½¿ç”¨å…¨å±€çš„æ–¹æ³•å¾—åˆ°è¿­ä»£å™¨\nstd::begin(vec), std::end(vec)\nC++ 20 å»ºè®®ä½¿ç”¨std::ranges::begin\nåªæœ‰ç±»ä¼¼ int arr[5] ä¼ å…¥åˆ° std::begin() æˆ–std::end()ä¸­æ‰æœ‰æ•ˆï¼ŒæŒ‡é’ˆä¼ å…¥è¿›æ¥æ˜¯æ— æ•ˆçš„\n\n\nThere are also general methods of iterator operations, defined in &lt;iterator&gt;\nstd::advance(InputIt&amp; it, n): it += n\nstd::next(InputIt it, n = 1): return it + n\nstd::prev(InputIt it, n = 1): return it - n\nstd::distance(InputIt it1, InputIt it2): return it2 - it1 ä¸åŒçš„å®¹å™¨æ—¶é—´å¤æ‚åº¦ä¸ä¸€æ ·\n\n\n\nIterator traitsï¼ˆæ˜¾è‘—çš„ç‰¹ç‚¹ï¼Œç‰¹å¾ï¼‰\nIterators provide some types to show their information:\nvalue_type: The type of elements referred to\ndifference_type: The type that can be used to represent the distance between elements (usually ptrdiff_t) è¿­ä»£å™¨ä¹‹é—´çš„è·ç¦»æ‰€è¡¨ç¤ºçš„ç±»å‹ï¼Œä¸€èˆ¬å°±æ˜¯ptrdiff_t\niterator_category: e.g. input_iterator_tag, continuous_iterator_tag\npointer &amp; reference: only available in container iterators åªæœ‰åœ¨å®¹å™¨ä¸­æ‰ä¼šæœ‰çš„ç‰¹æ€§\nå¯ä»¥ä½¿ç”¨ std::iterator_traits&lt;IteratorType&gt;::xxx è·å–\n\n\n\n\n\nStream iterator\nstd::istream_iterator&lt;T&gt; &amp; std:ostream_iterator&lt;T&gt;\nThe default constructed istream_iterator is end() é»˜è®¤çš„æ„é€ å‡½æ•°è¡¨ç¤ºç»ˆæ­¢çš„è¿­ä»£å™¨\n\nIterator adaptoræœ‰ä¸¤ç§ç±»å‹çš„è¿­ä»£å™¨é€‚é…å™¨\n\nOne is created from iterators to preform different utilities:\nE.g. reversed iterators åå‘è¿­ä»£å™¨ï¼Œ++ çš„æœ¬è´¨ä¸Šæ˜¯ â€“ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ begin() åˆå§‹åŒ–ï¼Œå³std:::reverse_iterator r{p.begin() }\nYou can get the underlying iterator by .base(), which actually returns the iterator that points to the elements after the referred one è°ƒç”¨ .base() å®é™…ä¸Šæ˜¯æŒ‡å‘å½“å‰æŒ‡å‘ä½ç½®çš„ä¸‹ä¸€ä¸ªå…ƒç´ \nrbegin().base() == end()\n\n\n\n\nAnother is created from containers to work more than â€œiterateâ€\nstd::back_insert_iterator{container}: *it = val will call push_back(val) to insert\nstd:front_insert_iterator{container}: call push_front(val) to insert\nstd::insert_iterator{container, pos}: call insert(pos, val) to insert\n\n\nNotice that inserting/assigning a range directly is usually better than inserting one by one for vector or deque\n\nSequential ContainerArray\nE.g. int a[5] will decay to int* when passing to function, and the size information is dropped ä»¥å‚æ•°çš„æ–¹å¼ä¼ é€’åˆ°å‡½æ•°ä¸­ä¼šé€€åŒ–æˆæŒ‡é’ˆï¼Œå¹¶ä¸”å¤§å°ä¹Ÿè¢«èˆå¼ƒäº†\nstd::array&lt;T, size&gt; the same as T[size]. It always preserves size, can copy from another array, and can do more things like bound check\nItâ€™s allocated on stack\nBut if you new std::array, then it;s still allocated on heap\n\n\nç‰¹æ®Šçš„æ„é€ å‡½æ•°éœ€è¦é¢å¤–çš„ {} e.g. struct S {int i; int j;} åˆå§‹åŒ–æ—¶æ˜¯std::array&lt;S, 2&gt; arr{{{1, 2}, {3, 4}}}\nç¬¬ä¸€ä¸ª {} æ˜¯arrayæœ¬èº«åˆå§‹åŒ–çš„{}\nç¬¬äºŒä¸ª {} æ˜¯æ•°ç»„åˆå§‹åŒ–çš„{}\n\n\nFor member accessing æˆå‘˜è®¿é—®\noperator[]\nat() will check the bound\nfront(), back(): get the first/last element of vector é¦–å…ˆè¦ä¿è¯éç©º\nIf you want to get the raw pointer of array content, you can use .data()\n\n\nAdditional methods\n.swap()\noperator=, operator&lt;=&gt; ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦\n.fill() å°†æ•´ä¸ªæ•°ç»„å¡«å……ä¸ºæŸä¸ªç‰¹å®šå€¼\nstd::to_array(C-style array)\n\n\nSize operations\n.size(): return size_t\nempty()\n.max_size(): get maximum possible size in this system(usually useless)\n\n\n\nvector\nåŠ¨æ€æ•°ç»„\næ”¯æŒéšæœºè®¿é—®ï¼Œå æ®è¿ç»­ç©ºé—´\nWhen inserting and removing elements at the end (i.e. pushing/poping back), the complexity is amortizedï¼ˆå‡æ‘Šï¼‰ \nIf not at end, itâ€™ll be \n\n\nåœ¨ cache ä¸Šçš„æ•ˆæœéå¸¸ä¸é”™ï¼Œå¯¹ cache åˆ©ç”¨ç‡éå¸¸æ˜¾è‘—\nå®ç°æ€è·¯\nå‡†å¤‡ä¸€éƒ¨åˆ†ç©ºé—´ï¼Œè¿™æ ·åœ¨ pushing æˆ–è€… poping çš„æ—¶å€™æ—¶é—´å¤æ‚åº¦æ‰æ˜¯\nå½“å®¹é‡ä¸å¤Ÿçš„æ—¶å€™åœ¨é‡æ–°åˆ†é…ï¼ˆreallocationï¼‰ï¼Œé‡åˆ†é…çš„å‡æ‘Šå¤æ‚åº¦ä¹Ÿè¦æ±‚æ˜¯\nThe element number is called size; total space is called capacity\né‡åˆ†é…çš„ç­–ç•¥\nThe easiest strategy is increasing space linearly\nE.g. 0 -&gt; 4 -&gt; 8 -&gt; 12 -&gt; 16 -&gt; â€¦\nEvery  operations will trigger reallocation an copy  elements\nSo, the amortized complexity is \nConsidering that  is an constant, this is still \n\n\n\n\nSo, what about exponentiallyï¼ˆæŒ‡æ•°ï¼‰?\nE.g. 1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 16 -&gt; 32 -&gt; â€¦\nEvery  operations will trigger reallocation an copy  elements\nSo, the amortized complexity is \n\n\n\n\nFinally, why is the exponent 2?\nå¯ä»¥è¯æ˜ä»»ä½•å¤§äº 1 çš„æŒ‡æ•°æœ€åçš„å‡æ‘Šå¤æ‚åº¦éƒ½æ˜¯\nThis is a trade-off between space and time ç©ºé—´å’Œæ—¶é—´çš„æƒè¡¡\nIn MSï¼ˆå¾®è½¯ï¼‰, itâ€™s 1.5\n\n\n\n\nvector ä¸ä¼šè‡ªåŠ¨çš„è¿›è¡Œç¼©å®¹ï¼ˆshrinkï¼‰ï¼Œä½†æ˜¯ä¼šæš´éœ²å‡ºæ¥å£æ‰‹åŠ¨ç¼©å®¹\nInsert æ˜¯ä»åå‘å‰çš„ï¼ˆmove backwardsï¼‰\nRemoval is similar, but move forwards from the end of deletion to the deletion point, and finally destruct the last several elements\nstd::initializer_list\nFor member accessing (same as array)\noperator[],at(): accessing by index;at()will check th bound, i.e. if the index is greater than size,std::out_of_range` will be thrown\nfront(), back(): get the first/last element of vector\nIf you want to get the raw pointer of array content, you can use .data()\n\n\nFor capacity operations (i.e. adjust memory)\n.capacity(): get capacity (return size_t)\n.reserve(n): ç›´æ¥åˆ†é… n å¤§å°çš„å†…å­˜ï¼Œå¦‚æœæ¯”å½“å‰ capacity å°å°±ä»€ä¹ˆéƒ½ä¸åšï¼Œsize æ˜¯ä¸ä¼šæ”¹å˜çš„\nä½œç”¨æ˜¯å‰æçŸ¥é“éœ€è¦åˆ†é…çš„æ•°é‡ï¼Œä¸€æ¬¡æ€§åˆ†é…ï¼Œå°±ä¸éœ€è¦æœ‰æ‰©å®¹çš„æ“ä½œäº†\n\n\n.shrink_to_fit: request to shrink the capacity so that capacity == size\n\n\nFor size operations\n.size()\n.empty()\n.resize(n, obj = Object{})\n.clear(): remove all things; size will be 0 after this\n\n\n.push_back(obj)\n.emplace_back(params): insert an element constructed by params at the end å°±åœ°æ ¹æ® params æ„é€ å…ƒç´ \nSince C++ 17, it returns reference of inserted element (before itâ€™s void)\n\n\n.pop_back()\n.insert(const_iterator pos, xxx)\n.erase(const_iterator pos), .erase(const_iterator first, const_iterator last): erase a single element/elements from [first, last)\ninsert/erase will return next valid iterator of inserted/erase elements\n\n\nInteract with another vector\n.assign\n.swap(vec)\n\n\nSince C++ 23, ranges-related methods are added\n.assign_range(Range)\ninsert_range(const_iterator pos, Range)\nappend_range(Range)\n\n\n\n\n\nIterator Invalidation\nè¿­ä»£å™¨å°±æ˜¯æŒ‡é’ˆçš„åŒ…è£…ï¼Œä½†æ˜¯æŒ‡é’ˆæ˜¯ä¸å®‰å…¨çš„\n\nå¯¼è‡´ä¸å®‰å…¨çš„æƒ…å†µ\n\nreallocation é‡åˆ†é…ï¼Œé€ æˆåŸæ¥ä¿å­˜çš„æŒ‡é’ˆæ‚¬å‚\nInsertion &amp; removal æ’å…¥å’Œåˆ é™¤\n\n\nFor vector\n\nIf the capacity changes, all iterators are invalid\n#include&lt;vector&gt;int main(){    std::vector{1, 2, 3, 4};    auto it = v.begin();    v.reserve(10086); // ä¼šå¯¼è‡´ä¸Šä¸€è¡Œçš„ `it` å¤±æ•ˆ    it = v.begin(); // å¿…é¡»è¿›è¡Œé‡æ–°è·å–}\nIf the capacity doesnâ€™t change, but some elements are moved, iterators after the changed points are invalid\n\n\n\n\nSpan\nè§†å›¾ View means that it doesnâ€™t actually hold the data; it observes the data\nSpan is a view for contiguous memory (e.g. vector, array, string, C-style array initializer list, etc.)\nå¯ä»¥åƒ array ä¸€æ ·æ“æ§ span\n.first(N)/.last(N)\n.subspan(beginPos(, size))\nspan is just a pointer with a size\n\nDequeue Double-Ended Queue åŒç«¯é˜Ÿåˆ—\næœ€ä¸»è¦çš„ç‰¹ç‚¹å°±æ˜¯\n on insertion &amp; removal of elements at the front or the back\nRandom access\n\n\nOther properties are just like vector\npush_front\nemplace_front\npop_front\nprepend_range C++ 23\n\n\nCircular queue\nWhen enqueue, tail moves forward\nWhen dequeue, head moves forward\nIf tail == head i.e. the queue is full, overwrite the element at head, both tail and head move forward\n\n\nDequeue ç›¸å½“äºåŠ¨æ€çš„å¾ªç¯é˜Ÿåˆ—ï¼Œå½“é˜Ÿåˆ—æ»¡çš„æ—¶å€™éœ€è¦è¿›è¡Œæ‰©å®¹\næ‰©å®¹æ˜¯åšåˆ°å‡æ‘Šå¤æ‚åº¦æ˜¯\nå¯ä»¥åšåˆ°éšæœºè®¿é—®çš„åŸç†æ˜¯ e.g. deque[i] is just vec[(head + i) % size]\n\n\nå®ç°æ–¹å¼\né™ä½æ‹·è´çš„ä»£ä»·\né€šå¸¸çš„å®ç°æ–¹å¼æ˜¯ä½¿ç”¨åŠ¨æ€å¾ªç¯é˜Ÿåˆ—ï¼ˆcalled mapï¼‰ï¼Œé‡Œé¢çš„å…ƒç´ æ˜¯æŒ‡é’ˆ\næŒ‡é’ˆæŒ‡å‘ä¸€ä¸ª blockï¼Œblock ä¸­å­˜å‚¨å¯¹è±¡\nblock çš„å¤§å°æ˜¯å›ºå®šçš„\n\n\nDequeue ä¸­çš„æ•°æ®ç»“æ„\nThe map and its size\nThe block size\nThe global offset of the first element off\nWe can use off / block_size to know the position of head\n\n\nElement numbers\n\n\né‡æ–°åˆ†é…çš„æ—¶å€™åªéœ€è¦æ‹·è´æŒ‡é’ˆ\nMap reallocation in dequeue\nå‡è®¾æ–°åŠ çš„ block çš„å¤§å°æ˜¯count\néœ€è¦ä½¿å¾—å¾ªç¯é˜Ÿåˆ—ä»ç„¶æ˜¯è¿ç»­çš„\nFirst, copy all elements from vec[head, vecEnd] to newVec[head, currEnd]\nThen, if head &lt;= count, copy [0, head) to [currEnd, ...)\nElse, copy after currEnd as mush as possible, and the rest is arranged to the newVecBegin\nFinally, set all the rest to nullptr\n\n\n\n\n\n\nDequeue iterator invalidation\nAll iterators are seen as invalid after insertion æ’å…¥ä¹‹åæ‰€æœ‰çš„è¿­ä»£å™¨éƒ½æ˜¯å¤±æ•ˆçš„ï¼Œè¿˜åŒ…æ‹¬\nresize\nshrink_to_fit\nclear\n\n\n\n\n\nList\nDouble linked list\nProperties\n insertion and removal\n splice èåˆå¦ä¸€ä¸ª list çš„ä¸€éƒ¨åˆ†å…ƒç´ \nä¸æ”¯æŒéšæœºè®¿é—®\n\n\næ¯ä¸ªèŠ‚ç‚¹éƒ½å·²ä¸€ä¸ªæ•°æ® T dataã€prevã€nextï¼Œå¹¶ä¸”ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„prev æŒ‡å‘ nullptrï¼Œæœ€åä¸€ä¸ªèŠ‚ç‚¹çš„next æŒ‡å‘nullptr\nå¾®è½¯ç”¨å¾ªç¯ list å®ç°çš„\nå¼•å…¥äº†å“¨å…µèŠ‚ç‚¹ sentinel nodeï¼Œæ˜¯ prev æŒ‡é’ˆçš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼ŒnextæŒ‡é’ˆçš„åä¸€ä¸ªèŠ‚ç‚¹\nä¸éœ€è¦ç‰¹åˆ¤ nullptr`\n\n\nThere are two methods to move nodes from another list\nå’Œ insert(pos, it1, it2) æœ‰åŒºåˆ«ï¼Œinsertåªæ˜¯æ‹·è´ï¼Œæ²¡æœ‰æ¸…é™¤æ“ä½œ\n.merge(list2)/.merge(list2, cmp)ï¼Œé€šå¸¸ç”¨åœ¨å·²æ’åºçš„ list ä¸­\n.splice(pos, list2, ...)\n(): insert the total list2 to pos\n(it2): insert it2 to pos (and remove it from list2)\n(first, last): insert [first, last) to pos (abd remove them from list2)\n\n\n\n\n\nFroward list\nSingle linked list\nForward list çš„ç›®çš„æ˜¯ä¸ºäº†å‡å°‘å­˜å‚¨ç©ºé—´ï¼Œæ‰€ä»¥ä¸æä¾› .size() å‡½æ•°\nåªå­˜å‚¨å¤´éƒ¨èŠ‚ç‚¹\n\nContainer adaptors\nå®¹å™¨é€‚é…å™¨æ˜¯å¯¹å·²ç»å­˜åœ¨çš„å®¹å™¨è¿›è¡ŒåŒ…è£…ï¼Œé€šå¸¸æƒ…å†µä¸‹ä¸æä¾›è¿­ä»£å™¨\n\nStack\nStack is a LIFO data structure\nThe provide container show have push_back, emplace_back, pop_back, so vector, deque and list are all OK\nAPIs\n.pop()\n.push(val), .emplace(params)\n.push_range(params) C++ 23\n.top()\n.empty(), .size()\n.swap(s2)\noperator=\noperator&lt;=&gt;\n\n\n\nQueue\nQueue is a FIFO data structure\n.front()\n.end()\n\nPriority queue\nItâ€™s defined in &lt;queue&gt;\nItâ€™s in fact max heap\næ’å…¥æˆ–è€…å¼¹å‡ºå…ƒç´ çš„æ—¶é—´å¤æ‚åº¦æ˜¯\nå»ºå †çš„æ—¶é—´å¤æ‚åº¦æ˜¯\nPercolation is the core algorithm\næ’å…¥çš„æ—¶å€™è¿›è¡Œä¸Šæ»¤ percolate up\nåˆ é™¤çš„æ—¶å€™è¿›è¡Œä¸‹æ»¤ percolate down\n\n\n\n\n\nFlat containers\nThe only defect of map/unordered_map/â€¦ is that theyâ€™re really cache-unfriendly\nFlat containers å¯¹ç¼“å­˜åˆ©ç”¨ç‡æ›´é«˜\nThe functionality is same as set/map\nBut itâ€™s in fact an ordered â€œvectorâ€\næ²¡æœ‰å†—ä½™çš„æ•°æ®ï¼Œå¯¹ cache æ›´å‹å¥½\næœ¬è´¨ä¸Šæ˜¯ä¸¤ä¸ª â€œvectorâ€\n\n\n\n\nThe whole definition is std::flat_map&lt;Key, Value, Compare = std::less&lt;Key&gt;, ContainerForKey = std::vector&lt;Key&gt;, ContainerForValue = std::vector&lt;Value&gt;&gt;\nä¹Ÿå¯ä»¥ä½¿ç”¨ deque ä½œä¸ºå®¹å™¨\nThe complexity\nFor lookup,  äºŒåˆ†æŸ¥æ‰¾\nFor insertion/removal, \nFor iterator++, \n\n\n\nAssociative containers\nTheyâ€™re called associative because they associate key with value\nThe value can also be omitted\n\n\nThere exist ordered one and unordered one\næœ‰åºçš„éœ€è¦æ¯”è¾ƒå‡½æ•° less than\nBBST (balanced binary search tree) æŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯\nRB tree\nAVL\n\n\n\n\næ— åºçš„éœ€è¦æä¾›å“ˆå¸Œå‡½æ•°å’Œåˆ¤æ–­æ˜¯å¦ç›¸ç­‰çš„å‡½æ•°\næŸ¥æ‰¾ã€æ’å…¥ã€åˆ é™¤çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯\n\n\n\n\n\nMap\nThe key is unique; a single key cannot be mapped to multiple values\nstd::map&lt;Key, Value, CMPForKey = std::less&lt;Key&gt;&gt;\né»˜è®¤æ˜¯å°äºå·\nCMPForKey should be able to accept const key\n\n\nFor member accessing\noperator[], at()\nBidirectional iterators\nNotice that the worst complexity of ++/-- is \nå¯¹ BBST è¿›è¡Œä¸­åºéå†å°±èƒ½å¾—åˆ°æœ‰åºçš„åºåˆ—\n.begin() is just the leftmost node and .rbegin() is just the rightmost node\n\n\n\n\n\n\nNote\noperator[] will insert a default-constructed value if the key doesnâ€™t exits\nå¦‚æœ key ä¸å­˜åœ¨å¹¶ä¸”é»˜è®¤æ„é€ çš„å€¼ä¹Ÿä¸æ˜¯çœŸæ­£éœ€è¦çš„ï¼Œç”¨ insert_xxx æ•ˆç‡æ›´é«˜\nconst mapä¸èƒ½ç”¨operator[]\nå¦‚æœ value æ˜¯ä¸èƒ½è¢«é»˜è®¤æ„é€ çš„ï¼ˆä¾‹å¦‚æ²¡æœ‰é»˜è®¤æ„é€ å‡½æ•°ï¼‰ä¹Ÿæ˜¯ä¸èƒ½ç”¨operator[]\n\n\nKey-value pair is stored in RB tree, so iterator also points to the pair\nYou can use structured binding to facilitate iteration\n\n\n\nstd::map&lt;string::string, int&gt; scoreTable{    {\"Li\", 99 },    {\"God Liu\", 99 },    {\"Saint Liu\", 99 },    {\"Liang\", 99 },};for (auto&amp; [name, score] : scoreTable)    std::cout &lt;&lt; name &lt;&lt; '' &lt;&lt; score &lt;&lt; '\\n';\n\n\nAPIs\n\n.lower_bound(key): find it that prev(it)-&gt;key &lt; key &lt;= it-&gt;key\n\nUse key as a lower bound to make [it, end) &gt;= key\n\n\n.lower_bound(key): find it that prev(it)-&gt;key &lt;= key &lt; it-&gt;key\n\nUse key as a lower bound to make [begin, it) &lt;= key\n\n\n.equal_range(key): find it pair with the same key as key in range\n\nInsertion\n\nå› ä¸ºé”®æ˜¯å”¯ä¸€çš„ï¼Œæ’å…¥çš„æ—¶å€™å¦‚æœ key å­˜åœ¨ä¼šå¤±è´¥ï¼›æ— è®ºå¤±è´¥æˆåŠŸéƒ½è¿”å›pair&lt;iterator, bool&gt;\n\nIf succeed, iterator refers to inserted element and bool is true\nIf fail, iterator refers to the element with the same key and bool is false`\n\n\næ’å…¥å¤±è´¥ä¼šæœ‰å¤šä¸ªå¤„ç†æ–¹å¼\n\nLeave it unchanged\n.insert({key, value})\n.emplace(params)\n\n\nOverwrite it (C++ 17)\n.insert_or_assign(key, value): return pair&lt;iterator, bool&gt;\n\n\nLeave it unchanged and even not construct the inserted value (C++ 17)\n.try_emplace(key, params): same as emplace, except that the params are used to construct value, and emplace is not forbidden to construct the pair in failure æ„é€  value éå¸¸æ˜‚è´µçš„æ—¶å€™ä½¿ç”¨\n\n\n\n\nYou can also provide a hint iterator for insertion\n\nhint iterator åœ¨è¢«æ’å…¥å…ƒç´ åé¢çš„æ—¶å€™ä¼šæœ‰æ•ˆç‡æå‡ï¼Œåœ¨å‰é¢çš„è¯ä¼šä½¿æ•ˆç‡é™ä½\n\nHint is often used in idiom blow\nauto pLoc = someMap.lower_bound(someKey);if (pLoc != someMap.end() &amp;&amp; !(someMap.Key_comp()(someKey, pLoc-&gt;first)))    return pLoc-&gt;second;else {    auto newValue = expensiveCalculation();    someMap.insert(pLoc, make_pair(someKey, new Value));    return newValue;}\n\n\n\n\nErasure\n\n.erase(...)\n(key)\n(iterator pos)\n(iterator first, iterator last)\n\n\n\n\n.extract(key), extract(iterator pos): extract out the node from the map\n\n.insert(node_type&amp;&amp;): insert the node to the map\n\n.merge(another map/multimap)\n\n\n\n\n\nStructured binding\n\nStructured binding is just auto&amp; [...]{xx}\n\n{xx} can be (xx) or =xx\n\nauto&amp; can be anything\n\nxx can be a pair; it can also be\n\nAn object with all public data members, which will be bound on them\nA C-style array or std::array, which will be bound on elements arr[i]\nA tuple-like thing, which will be bound on every element\n\n\nNote\n\npair and std::array is also somewhat tuple-like thing and can use some tuple methods, e.g. std::get pair å’Œ std::array ä¹Ÿå¯ä»¥åƒ tuple ä¸€æ ·ï¼Œè®¿é—®çš„æ—¶å€™ä¹Ÿå¯ä»¥ä½¿ç”¨è®¿é—® tuple çš„æ–¹æ³•\n\nç»“æ„åŒ–ç»‘å®šæ—¶ä¸€ä¸ªæ–°çš„å£°æ˜ï¼Œä¸èƒ½ç»‘å®šå·²ç»å­˜åœ¨çš„å˜é‡ï¼Œå¦‚æœæƒ³ç»‘å®šå·²å­˜åœ¨çš„å˜é‡å¯ä»¥ä½¿ç”¨std::tie(name, score) = pair\n\nç»“æ„åŒ–ç»‘å®šçš„æœ¬è´¨æ˜¯åŒ¿åç»“æ„ä½“ï¼Œç»“æ„ä½“ä¸­çš„å˜é‡æ˜¯åˆ«å\n  std::tuple&lt;int, float&gt; a{1, 1.0f };const auto&amp; [b, c] = a;decltype(b) m = 0; // const int m  = 0;\nStructured binding is usually more efficient than novice/careless programmers å»ºè®®ä½¿ç”¨ç»“æ„åŒ–ç»‘å®š\n\n\n\n\n\n\nTuple\n\nstd::tuple&lt;int, float, double&gt; t{1, 2.0f, 3.0};\nIt can only be accessed by an index that can be determined in compile time ä¸‹æ ‡è®¿é—®çš„ä¸‹æ ‡åªèƒ½åœ¨ç¼–è¯‘æ—¶ç¡®å®š\nstd::get&lt;0&gt;(tuple) to get the int 1\nC++ 14 å¯ä»¥ä½¿ç”¨ç±»å‹è·å–ç›¸åº”çš„å€¼ï¼Œå‰ææ˜¯ç±»å‹ä¸èƒ½é‡å¤ e.g. std::get&lt;int&gt;(tuple)\nstd::tuple_cat\n\n\n\n\nSet\nSet is just a map without value\nThe only difference with amp is that it doesnâ€™t have operator[] and .at()\nThe iterator points to only key instead of key-value pair\n\nMultimap\næŠŠ key çš„å”¯ä¸€æ€§å–æ¶ˆäº†\nä¸èƒ½ä½¿ç”¨ operator[] å’Œ.at()\nç›¸ç­‰çš„å€¼çš„é¡ºåºå–å†³äºæ’å…¥æ—¶çš„é¡ºåº\næ’å…¥æ°¸è¿œéƒ½æ˜¯æˆåŠŸçš„\nNodes of multimap and map can be exchanged ä¸¤ä¸ªå®¹å™¨çš„èŠ‚ç‚¹æ˜¯å¯ä»¥ç›¸äº’æ›¿æ¢çš„\n\nMultiset\nExcept for only key and no value, same as multimap\nYou can also exchange nodes of multiset and set\n\nUnordered map\nstd::unordered_map&lt;Key, Value, Hash = std::hash&lt;key&gt;, Equal = std::equal_to&lt;Key&gt;&gt;\nMany types have std::hash&lt;Type&gt;, e.g. std::string, float, etc.\nThe hash value of different keys may be same, so we need Equal to judge which key is wanted\nå¾®è½¯çš„å®ç°åœ¨è§£å†³å†²çªçš„æ—¶å€™ç”¨åŒå‘é“¾è¡¨ï¼Œå¹¶ä¸”é“¾æ¥ç›¸é‚»çš„ Bucket å»¶ç”³å‡ºæ¥çš„åŒå‘é“¾è¡¨ï¼Œå¹¶æ·»åŠ ä¸€ä¸ªå“¨å…µèŠ‚ç‚¹\nå½“æ’å…¥æ•°æ®å¤ªå¤šçš„æ—¶å€™ï¼Œæ¯ä¸ª bucket ä¹Ÿä¼šé“¾æ¥å¾ˆå¤šæ•°æ®\nè¿™æ ·ä¼šå¢åŠ æŸ¥æ‰¾çš„å¤æ‚åº¦\n is called load factor è£…è½½å› å­\nè£…è½½å› å­è¿‡å¤§æ—¶ï¼Œéœ€è¦å¯¹ bucket array è¿›è¡Œæ‰©å®¹\nRehash é‡å“ˆå¸Œ\n\n\nAPIs\n.bucket_count(): size of bucket array\n.load_factor(): size() / bucket_count()\n.max_load_factor(): when load factor exceeds this limit, refresh will happen\n.rehash(n): make bucket_count() = max(n, ceil(size() / max_load_factor())) and rehash\n.reserve(n)\n.bucket(key): get the bucket index of the key\n.begin(index), .cbegin(index), .end(index), .cend(index): get the iterator of the bucket at index\n.bucket_size(index): get the size of bucket at index\n\n\nYou can also extract nodes and insert them\n\nRanges\nUsing ranges is very like functional programming\n\nThere are three important components in ranges:\n\nRange: A type provides a begin iterator and end sentinel, so that it can be iterated over\nView: A range that can be moved in , copied in  (or cannot be copied) and destructed in \nRange adaptor\n\n\nNote\n\nRange å¯ä»¥æŒ‰ç…§è¿­ä»£å™¨è¿›è¡Œåˆ†ç±»\nè®¡ç®—æ˜¯æƒ°æ€§è®¡ç®—\n\n\nTheyâ€™re all defined in &lt;range&gt;; all views are defines as std::ranges::xx_view, and all range adaptors are defined as std::views::xx\n\nä¸€èˆ¬ç”¨åˆ«åæ¥ç®€åŒ–å®šä¹‰ namespace stdr = std::ranges å’Œnamespace stdv = std::views\nstdr::iota_view{lower, upper = INF}, stdv::iota(lower, upper = INF): å’Œ python ä¸­çš„ range(a, b) ç±»ä¼¼\n\nfor (const auto oddNum : stdv::iota(1, 10)  | stdv::filter([](int num) {return num % 2 == 1; })  | stdv::take(3)){    std::cout &lt;&lt; oddNum &lt;&lt; '';}\nWritable\n\nstdv::filter(Pred): drop the element if the predicate function Pred returns false\nstdv::take(x): take first x elements (but not exceed end)\nstdv::take_while(Pred): take elements until Pred return false (or end)\nstdv::drop(x): drop first x elements\nstdv::drop_while(Pred): drop elements until Pred returns false\nstdv::reverse\nstdv::keys: get the first element from a tuple-like thing\nstdv::values\nstdv::elements&lt;i&gt;: get the ith element from a tuple-like thing\nstdv::stride(k): use k as stride to iterate\ne.g. stdv::iota(1, 0) | stdv::stride(2) gets {1, 3, 5, 7, 9}\n\n\nstdv::join: flattens the ranges to a single range éœ€è¦ç”¨ | è¿æ¥\nstdv::join_with(xx): fill the interval with xx éœ€è¦ç”¨ | è¿æ¥\nstdv::zip(r1, r2, ...): zip values from ranges to a tuple\nstdv::cartesian_product(r1, r2, ...): return a tuple of elements from the cartesian product of these ranges\nstdv::enumerate: return std::tuple&lt;Integer, T&amp;&gt;; Integer is index whose tpe is diff type of iterator\nstdv::slide(width): slide the range in a sliding window of width\ne.g. std::vector v{1, 2, 3, 4, 5}; v | stdv::slide(3) gets {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}\n\n\nstdv::adjacent&lt;width&gt;: same as stdv::slide(width)\nstdv::pairwise: i.e. stdv::adjacent&lt;2&gt;\nstdv::chunk(width): partition the range by width\nstdv::chunk_by(pred2): partition the range by pred2, i.e. a view sill stop when pred2(*it, *next(it)) return false\nstdv::split(xx)\nstdv::lazy_split(xx)\n\n\nRead-only\n\nEither make the view const, i.e. std::as_const; this will return const T&amp; or tuple&lt;const T&amp;, ...&gt;\n\nOr return value, i.e. transform-related, which will return T or tuple&lt;T, ...&gt;\n\nstdv::zip_transform(TransformN, r1, r2, ...): return a view of TransformN(ele1, ele2, ...)\n\nstdv::adjacent_transform&lt;N&gt;(TransformN): return a view of TransformN(...), where ... is the elements of the sliding windows\n\nstdv::transform(Transform): transform element to another element\nstd::vector&lt;int&gt; v{1, 2, 3, 4, 5 };int cnt = 0;auto r = v | stdv::transform([&amp;cnt](const int ele) {    std::cout &lt;&lt; std::format(\"cnt={}, ele={}\\n\", cnt, ele);    cnt++;    return cnt + ele;}) | stdv::take_while([](const int ele) {return ele &lt; 10; });for (const auto&amp; i : r);// output:// cnt=0, ele=1// cnt=1, ele=1// cnt=2, ele=2// cnt=3, ele=2// cnt=4, ele=3// cnt=5, ele=3// cnt=6, ele=4\n\n\n++ will trigger transform since take_while needs the transformed value to advance the iterator (i.e. by Pred(*it))\nconst auto&amp; ele = *it will trigger it again\nThatâ€™s because the result doesnâ€™t reference some existing elements, but generate from temporary; every time you need it, lazy evaluation generate it again å¤ª lazy äº†\nSometimes, you may want to convert a range to a e.g. container, which needs to eagerly evaluate all\nstdr::to, e.g. stdr::to&lt;std::vector&gt;()\n\n\n\n\n\n\n\n\nThere are also some naÃ¯ve range factories\n\nstdv::single(obj): make a view that copies/moves an object, i.e. the view owns only a single element\nstdv::empty&lt;T&gt;: create an empty view\nstdv::repeat(r, k = INF): repeat a range r for k times, i.e. like a range [r, r, r, ...]\nstdv::istream&lt;xxx&gt;(stream): similar to istream_iterator; it caches value\nstdr::subrange(first, last)\n\n\n\nGeneratordef func(end):    begin = 0    while begin != end:        yield begin        begin += 1generator = func(10)for num in generator:    print(num)\n\nWhen the function reaches yield, it will pause and return the number; when iterator moves forward, the function will resume and continue to execute until the next yield or real return\n\nSince C++ 23, generator is also supported by coroutine\nCoroutines cooperates with each other and yield their execution flow themselves åç¨‹ä¹‹é—´æ˜¯ç›¸äº’é…åˆçš„æ§åˆ¶æµ\nBy contrast, for threads, they usually compete with each other and are interrupted by OS to give other threads chances to execute çº¿ç¨‹åˆ™æ˜¯æŠ¢å å¼çš„\n\n\n\n\nGenerator is just the same; when you need the next value , you just yield your execution flow to the generator function; when the generator function completes its task, it will give back the right of execution\nGenerator is also an input_range and view; it provides begin() and end() to iterate, and ++ the iterator will resume the function\nNOTICE: Call .begin() will start the coroutine\n\n\n\ne.g.\nstd::generator&lt;int&gt; func(int end){    std::cout &lt;&lt; \"Ahh...\";    for (int begin = 0; begin &lt; end; begin++)        co_yield begin;    co_return;}auto generator = func(3);for (auto it = generator.begin(); it != generator.end(); it++)    std::cout &lt;&lt; *it;// orfor (auto&amp; num : generator)    std::cout &lt;&lt; num;\n\n\nSome notes\nOne generator can only be used once åªèƒ½ä½¿ç”¨ä¸€æ¬¡\nGenerator has operator=\nco_return can be omitted\nSaving contexts also needs memory, so an allocator can also be provided as the last template parameter\n\n\n\nFunction å‡½æ•°Pointer to member functions\nMember functions can be static or non-static\nStatic ones are just normal functions with some Class::, their pointers are same as normal ones\nNon-static ones are always bound to some specific objects, i.e. there is a this pointer as a parameter\n\n\n\ne.g.\nclass Person{    public: unsigned int age;    void AddAge(unsigned int n) {        age += n;    }}using FuncPtr = void (Person::*)(unsigned int);int main(){    Person p{0 }, *pointer = &amp;p;    FuncPtr ptr = &amp;Person::AddAge;    (p.*ptr)(5);    (pointer-&gt;*ptr)(5);    // C++ 17    std::invoke(ptr, p, 5);    std::invoke(ptr, pointer, 5);    return 0;}\n\n\nDefine a pointer to member function is Ret (Class::*)(params)\nstd::invoke define in &lt;functional&gt; since C++ 17\nSince C++ 23, std::invoke_r&lt;Result&gt; is provided\n\nCallable parameterFunction as parameter\nå‡½æ•°æŒ‡é’ˆä¹Ÿå¯ä»¥å®ç°å°†å‡½æ•°è§†ä¸ºå‚æ•°æ¥ä¼ é€’ï¼Œä½†æ˜¯æœ‰ä¸¤ä¸ªé—®é¢˜\næœ‰æ—¶å€™å‡½æ•°æŒ‡é’ˆçš„å‚æ•°ç±»å‹æœ‰ä¸¥æ ¼çš„é™åˆ¶ï¼Œä¾‹å¦‚ int can be converted to double, func(double) is also acceptable\nIn C++, usually what you need is just â€œsomething callableâ€, i.e. a functor is allowed æœ‰æ—¶å€™åªæ˜¯æƒ³ä¼ å…¥ä¸€ä¸ªå¯è°ƒç”¨çš„ç±»å‹\n\n\næœ‰ä¸¤ç§æ–¹å¼è§£å†³\nUse a template parameter &lt;algorithm&gt;å¸¸ç”¨çš„æ–¹æ³•é‡‡ç”¨æ¨¡æ¿å‚æ•°æ¥å—å¯è°ƒç”¨çš„å‚æ•°\nUse a std::function defined in &lt;functional&gt;\nstd::function&lt;RetType(Args...)&gt; can adopt almost all callable that have the return type convertible to RetType and accept Args\nThe member function even preserves polymorphism\nAfter getting the std::function, you can just use operator() to call it\nEven more powerful, you can bind some parameters to get new functors\nE.g. you can use std::bind(any_callable, params) to get a std::function std::bindå·²ç»æ²¡æœ‰ç”¨äº†ï¼Œå®Œå…¨å¯ä»¥ç”¨ Lambda è¡¨è¾¾å¼ç»‘å®š\n\n\nThere are two defects\nPerformance: It roughly causes 10% - 20% performance loss compared with direct function call\næœ‰å¯èƒ½ä¼šç”¨ new/delete è‡ªå®šä¹‰ctor/dtor\nè§£å†³æ–¹å¼æ˜¯ä½¿ç”¨ SOO(small object optimization)ï¼Œåœ¨æ ˆä¸Šå‡†å¤‡ä¸€å—å°çš„ buffer ç”¨äºåˆ†é…å‡½æ•°ç©ºé—´\nå¦‚æœç»‘å®šçš„ Lambda è¡¨è¾¾æ˜¯å¤ªå¤§å¯ä»¥ä½¿ç”¨ auto lambda = xx;ï¼Œç„¶åå†é€šè¿‡std::ref(lambda) ä¼ ç»™ std::function çš„æ„é€ å‡½æ•°ï¼ˆä½†æ˜¯è¦æ³¨æ„å£°æ˜å‘¨æœŸï¼‰ï¼Œä½†æ˜¯ä¸å¯ä»¥ä½¿ç”¨std::ref(&amp;&amp;xx)(){...}ï¼Œlambda è¡¨è¾¾å¼ä¼šç«‹é©¬å¤±æ•ˆ\n\n\nThe second defect of std::function is that it cannot really accept all functors å¹¶ä¸æ˜¯æ”¯æŒæ‰€æœ‰çš„å¯è°ƒç”¨ç±»å‹\nWhen the functor is not copiable (e.g. move-only, like std::unique_ptr) ä»¿å‡½æ•°ä¸èƒ½æ‹·è´çš„å°±ä¸èƒ½æ¥å—\nThus, since C++ 23, std::move_only_function is introduced\n\n\n\n\n\n\n\n\nReference wrapper\nstd::(c)ref() in fact create std::reference_wrapper&lt;(const) T&gt;, which can be seen as an instantiated reference\nä¾‹å¦‚å®¹å™¨ä¸­ä¸å¯èƒ½å­˜å‚¨å¼•ç”¨ç±»å‹çš„ï¼Œå¦‚æœæƒ³å‚¨å­˜å¼•ç”¨ç±»å‹å¯ä»¥ä½¿ç”¨std::vector&lt;std::reference_wrapper&lt;T&gt;&gt;\nItâ€™s in fact a wrapper of pointer, but it cannot be null, just like reference\nDifferent from reference, it can be bound to another object by operator=, just like pointer å¼•ç”¨æ˜¯ä¸å¯ä»¥æ¢ç»‘çš„ï¼Œä½†æ˜¯ std::ref() å¯ä»¥\n\n\nItâ€™s also used to denote â€œit should be a referenceâ€ explicitly in some methods in standard library, e.g. std::bind_back or std::bind_front\n\n\n\n\nThere are also some predefined template functors in &lt;functional&gt;\nArithmetic functors: plus, minus, multiplies, divides, modulus, negate\nComparison functors: equal_to, not_equal_to, greater, less, greater_equal, less_equal, compare_three_way\nLogical functors: logical_and, logical_or, logical_not\nBitwise functors: bit_and, bit_or, bit_xor, bit_not\nThese Functor&lt;T&gt; all have auto operator()(const T&amp;, const T&amp;) const\n\n\n\nLambda expression\nWe call lambda expression without capture stateless lambda; otherwise stateful lambda\nå¯ä»¥ä½¿ç”¨ decltype(...) å»æ¨æ–­ lambda è¡¨è¾¾å¼çš„ç±»å‹\nç†è®ºä¸Šå¯ä»¥ä½¿ç”¨æ¨æ–­å‡ºæ¥çš„ä»¿å‡½æ•°çš„ç±»å‹è¿›è¡Œå£°æ˜ï¼Œä½†æ˜¯åªæœ‰å† C++ 20 ä¹‹åæ‰æ˜¯åˆæ³•çš„\nE.g. auto l = [](int a, int b) {return a + b;}; using T = decltype(l); T l2{};\nåªé€‚ç”¨ stateless lambda\n\n\n\nAlgorithmsAlgorithmsâ€™ Consist\nIterator pairs è¿­ä»£å™¨å¯¹ï¼Œæˆ–è€…ç›´æ¥ä¼ å…¥ ranges\nPredicate function / transform function åˆ¤åˆ«å‡½æ•°æˆ–è€…å˜æ¢å‡½æ•°ï¼Œé€šå¸¸æƒ…å†µä¸‹å˜æ¢éƒ½æ˜¯const&amp;ï¼Œæˆ–è€…å¯¹äºæ¯”è¾ƒå°çš„ç±»å‹ä¼ å…¥æ‹·è´\nå¤§éƒ¨åˆ†ç®—æ³•éƒ½è¿”å›ä¸€ä¸ªèŒƒå›´è¿­ä»£å™¨\nä»æ¥éƒ½ä¸ä¼šæ”¹å˜åºåˆ—çš„å¤§å°\nCallables of algorithm are of value type instead of reference type åˆ¤åˆ«å‡½æ•°æˆ–è€…å˜æ¢å‡½æ•°éƒ½æ˜¯ä¼ é€’å€¼ç±»å‹ï¼Œä¸æ˜¯å¼•ç”¨ç±»å‹\n\nSearch\nä¸¤ç§æœç´¢ç®—æ³•\nLinear search\nFind single value\nstd::find\nstd::find_if\n\n\nFind one of values in a range\nstd::find_first_of\n\n\nFind a sub-sequence in a sequence (Pattern matching)\nstd::search\nstd::find_end\n\n\nOthers\nstd::adjacent_find(begin, end[, Pred2]): ç›¸é‚»å…ƒç´ ç›¸ç­‰çš„ä½ç½®\nstd::search_n(begin, end, count, value, [, Pred2])\n\n\n\n\nBinary search, which is applied on sorted sequence\nstd::binary_search: return bool, denoting whether value exists in [begin, end)\nstd::lower_bound: return it so that value is the lower bound of [it, end)\nstd::upper_bound: return it so that value is the lower upper of [begin, end)\nstd::equal_range: return an iterator pair (it1, it2) so that value is equal to [it1, it2)\n\n\n\n\n\nComparison\nstd::equal(begin1, end1, ..., [, Pred2]): return a bool\nstd::lexicographical_compare(begin1, end1, begin2, end2[, Pred2]): return bool; Pred2acts asoperator&lt;&gt;`\nCompare until ele1 &lt; ele2 || ele2 &lt; ele1\n\n\nstd::lexicographical_compare_three_way(begin1, end1, begin2, end2[, Pred2]): return an ordering; Pred2 acts as operator&lt;=&gt;\nstd::mismatch(begin1, end1, ...[, Pred2]):  return an iterator pair (it1, it2) denoting the first occurrence of mismatching\nThese algorithms are all \n\nCounting\nstd::all_of/any_of/none_of(begin, end, Pred)\nstd::count(begin, end, value)\nstd::count_if(begin, end, Pred)\nThese algorithms are all \n\nGenerating and Transforming\nstd::fill(begin, end, value)\nstd::fill_n(begin, count, value)\nstd::generate(begin, end, Gen): for each element in [begin, end), ele = Gen()\nstd::for_each(begin, end, Transform): for each element in [begin, end), call Transform(ele)\nstd::transform: There are unary/binary transforms\n(begin, end, dstBegin, Transform): unary ä¸€å…ƒ\n(begin, end, begin2, dstBeing, Transform): binary, the transformation is Transform(*it1, *it2)\n\n\n\nModifying\nstd::remove(begin, end, value)/std::remove_if(begin, end, Pred): return the iterator so that [begin, it) has no element that is equal to value or make Pred return true\nä¸ä¼šçœŸçš„æ“¦é™¤è¿­ä»£å™¨\nSince C++ 20, theyâ€™re integrated as methods std::erase/std::erase_if\n\n\nstd::unique(begin, end[, Pred2]): return the iterator so that [begin, it) has not adjacent equal element; Pred2 acts as operator== ä½¿å¾—åœ¨ [begin, it) åŒºé—´å†…æ²¡æœ‰ç›¸é‚»ä¸”ç›¸ç­‰çš„å…ƒç´ \nThese algorithms are all , by the technique of dual pointers ç®—æ³•ç”¨åŒæŒ‡é’ˆå®ç°\nå®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆ before å’Œafter\nä¸¤ä¸ªæŒ‡é’ˆä¸€å¼€å§‹éƒ½æŒ‡å‘begin\nå…ˆå‰è¿›after\nåˆ¤æ–­ *before == *afterï¼›ç›¸ç­‰åªå‰è¿›afterï¼Œä¸ç›¸ç­‰åˆ™å‰è¿›beforeï¼Œå¹¶å°†after æŒ‡å‘çš„å€¼å’Œ before äº¤æ¢ï¼Œå‰è¿›after\nç›´åˆ°after == end\néœ€è¦è€ƒè™‘ begin == end å’Œæ•´ä¸ªåºåˆ—å°±æ˜¯ unique çš„æƒ…å†µ\n\n\nstd::replace(begin, end, oldValue, newValue)/std::replace_if(begin, end, Pred, newValue)\nstd::swap(x, y)\nstd::iter_swap(it1, it2)\nstd::swap_range(begin1, end1, begin2)\nstd::reverse(begin, end)\nstd::rotate(begin, mid, end): left rotate [begin, mid)\n2, 3, 4, 4, 5 -&gt; 4, 5, 2, 3, 4 ç›¸å½“äºå·¦ç§»\nRotate is also \nbrute-force method: swap each element ot its position (just like bubble sort). This will be  ä¸€ä¸ªä¸€ä¸ªçš„äº¤æ¢ï¼Œéœ€è¦ä¸¤å±‚å¾ªç¯\nå¯ä»¥è€ƒè™‘å°†ç¬¬ä¸€ä¸ªå…ƒç´ æ‹¿å‡ºæ¥ï¼Œå†ç¡®å®šåºåˆ—ä¸­å“ªä¸€ä¸ªå…ƒç´ ä¼šå†ä¸‹ä¸€æ­¥å‡ºç°åœ¨ç¬¬ä¸€ä¸ªä½ç½®ï¼Œç„¶åè¿›è¡Œæ›¿æ¢ï¼Œä»¥æ­¤ç±»æ¨å®Œæˆæ—‹è½¬\nä½†æ˜¯è¿™ç§æ–¹å¼å¯¹ cache ä¸å‹å¥½\n\n\nswap all groups together\nThe complexity is \n    \n\n\n\nreverse\nIn fact, reverse is the basis of many algorithms\n[begin, mid - 1]``[mid, end - 1]\nReverse two sub-sequences, get [mid - 1, being]``[end - 1, mid]\nReverse the total sequence, get [mid, end - 1]``[begin, mid - 1]\nThe complexity is \n\n\n\n\n\n\nstd::shift_left/right(begin, end, n): the dropped elements are permanently dropped (invalid)\n\nCopying\nstd::copy(begin1, end1, dstBegin)\nstd::copy_if(begin1, end1, dstBegin[, Pred])\nstd::copy_n(begin1, n, dstBegin)\nstd::copy_backward(begin1, end1, dstBegin)\n\nPartition and SortPartitionPartition denotes that a range is divide into two parts; assuming predicate function Pred, then there exists an iterator it (i.e. partition point è½´ç‚¹ï¼‰ so that all elements in [begin, it) make Pred return true while [it, end) make Pred return false å·¦è¾¹çš„éƒ½å°äºè½´ç‚¹ï¼ˆä½¿å¾— Pred å‡½æ•°è¿”å› trueï¼‰ï¼Œå³è¾¹çš„éƒ½å¤§äºè½´ç‚¹ï¼ˆä½¿å¾—Pred å‡½æ•°è¿”å›falseï¼‰\n\nstd::is_partitioned(begin, end, Pred)\nstd::partition(begin, end, Pred)\nstd::stable_partition(begin, end, Pred): each sub-partition preserves the original order ä¿è¯ partition åçš„ç»“æœå’ŒåŸåºåˆ—çš„é¡ºåºä¸€è‡´\nåŸåºåˆ— {0, 1, 9, 4, 5, 2, 7, 8}, Predä¸º [](const int ele) {return ele % 2;} å·¦è¾¹æ˜¯å¥‡æ•°å³è¾¹æ˜¯å¶æ•°\nstd::partition: {7, 1, 9, 5, 4, 2, 0, 8}\nstd::stable_partition: {1, 9, 5, 7, 0, 4, 2, 8}\nImplementation:\nWhen the memory is enough ï¼ˆå†…å­˜è¶³å¤Ÿï¼‰, prepare a buffer; move the false range to the buffer and move the true range to be consecutive (just like preform std::remove_if(), with removed range saved in buffer). Then move the buffer elements back\nWhen the memory is not enough ï¼ˆå†…å­˜ä¸å¤Ÿï¼‰, divide the sequence into two halves and stable partition each half\nThis will from [true, false], [true, false] sequence æœ€ç»ˆéƒ½ä¼šå˜æˆè¿™æ ·çš„åºåˆ—\nRotate the middle [false, true] so that the final result is totally partitioned\n, to itâ€™s overall \n\n\n\n\n\n\nstd::partition_point(begin, end, Pred): assume the range is a partition å‰ææ˜¯åºåˆ—å·²ç»æ˜¯ partition\n\nSort\nstd::is_sorted(begin, end[, Pred2]) \nstd::is_sorted_until(begin, end[, Pred2]) \nstd::sort(begin, end[, Pred2]) \nstd::stable_sort(begin, end[, Pred2])\n space complexity,  time complexity\nIf space is insufficient,  time complexity\n\n\nSince std::sort requires the complexity exactly , quick sort is not enough å¿«æ’åªæ˜¯å¹³å‡æ„ä¹‰ä¸Šçš„ï¼Œæœ€åçš„æƒ…å†µæ˜¯\nC++ æ ‡å‡†åº“å¹¿æ³›ä½¿ç”¨çš„æ’åºç®—æ³•æ˜¯ Introspective Sort(IntroSort)\nIt integrates insertion sort, heap sort and quick sort ç»“åˆäº†æ’å…¥æ’åºï¼Œå †æ’åºå’Œå¿«æ’\nWhen the element number is low enough, insertion sort is used\nWhen the recursion is too deep, heap sort is used\né¿å…å¿«æ’çš„æœ€åæƒ…å†µ\nå †æ’åºæ˜¯ç¨³å®š\nå †æ’åºé€Ÿåº¦ä¸æ˜¯å¾ˆå¿«ï¼Œå¯¹ cache ä¹Ÿä¸æ˜¯å¾ˆå‹å¥½\n\n\n\n\nstd::partial_sort(begin, mid, end)\nstd::nth_element(begin, mid, end): rearrange [begin, end) so that *mid is sorted (i.e. same as the *mid in the full sorted range) and the whole range is partitioned by it åœ¨æ’å¥½åºçš„ä¸­ç¬¬ n ä¸ªä½ç½®çš„å…ƒç´ \nstd::merge(begin1, end1, begin2, end2, dstBegin[, Pred2])\nstd::inplace_merge(begin, mid, end)\n\nHeap\nstd::is_heap(_until)(begin, end[, Pred2])\nstd::make_heap(begin, end[, Pred2]): Floyd algorithm \nstd::push_heap(begin, end[, Pred2])\nstd::pop_heap(begin, end[, Pred2])\nstd::sort_heap(begin, end[, Pred2])\n\nSet OperationsSet operations are used on sorted range, including set\n\nstd::includes(begin1, end1, begin2, end2[, Pred2]): check whether th second range is subset of the first range\n    \n    \n\nstd::set_intersection(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_union(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_symmetric_difference(begin1, end1, begin2, end2, dstBegin[, Pred2]): \nstd::set_difference(begin1, end1, begin2, end2, dstBegin[, Pred2]): \n\nMinMax\nstd::min/max/minmax(a, b[, Pred2]): return (pair of) reference of the smaller/bigger element\nstd::min_element/max_element/minmax_element(begin, end[, Pred2]): return the iterator of the minimum/maximum value in the range\nstd::clamp(value, low, high)\n\nPermutationPermutation means that two sequence are unorderly equal\n\nstd::is_permutation(begin, end1, begin2[, Pred2])\n\n\n\nstd::prev/next_permutation(begin, end[, Pred2]): return the sequence to the previous/next permutation\n\nNumeric AlgorithmsThey are all \n\nFor the most basic ones:\nstd::iota(begin, end, beginVal): fill in [begin, end) with {beginVal, ++beginVal, ...}\nstd::adjacent_difference(begin, end, dstBegin, Op = std::minus): as its name, output {val[0], val[1] - val[0], val[2] - val[1], ...}\nstd::accumulate(begin, end, initVal, Op = std::plus): accumulate all values, return \nstd::partial_sum(begin, end, dstBegin, Op = std::plus): output {val[0], val[0] + val[1], val[0] + val[1] + val[2], ...}\nstd::inner_product(begin1, end1, begin2, initVal, Op1 = std::plus, Op2 = std::multiplies): finally get initVal + a[0] * b[0] + a[1] * b[1] + ...\nstd::reduce(begin, end, initVal, Op = std::plus): same as accumulate\nstd::inclusive_scan(begin, end, dstBegin, Op = std::plus[, initVal]): same as partial sum\nstd::transform_reduce(begin1, end1, begin2, initVal, ReduceOp = std::plus, BiTransformOp = std::multiplies): same as inner product\nstd::exclusive_scan(begin, end, dstBegin, initVal, Op = std::plus): similar to partial, but exclude the element itself, i.e. the sequence is {initVal, initVal + val[0], ..., initVal + val[0] + ... + val[n - 2]}\nstd::transform_inclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])\nstd::transform_exclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])\n\n\nstd::gcd(a, b): æœ€å¤§å…¬çº¦æ•°\nstd::lcm(a, b): æœ€å°å…¬å€æ•°\nstd::midpoint(a, b): since C++ 20, return a + (b - a) / 2\n\nParallel Algorithm\nThere are two kinds of parallelism\nSIMD: single instruction multiple data å•æŒ‡ä»¤å¤šæ•°æ®\nSIMT: single instruction multiple threads\n\n\nSince C++ 17, parallel-version algorithms are added\nDefined in &lt;execution&gt;\nThere are four execution policies defined in std::execution\nseq: sequenced policy å®Œå…¨ä¸å¹¶è¡Œ\npar: parallel policy å¹¶è¡Œ\nunseq: unsequenced policy (since C++ 20) ç®—æ³•å¯ä»¥é€‚åº” SIMD\npar_unseq: parallel and unsequenced policy\n\n\n\n\nThere are four kinds of data dependencies\nRAR: read after read å¯ä»¥ä½¿ç”¨par_unseq\nE.g. std::adjacent_find\n\n\nRAW: read after write, e.g. a[j] = a[j - 1] + 1\nWAR: write after read, e.g. a[j - 1] = a[j] + 1\nWAW: write after write\n\n\nParallel algorithms\nstd::partition, std::nth_element\nstd::merge\nstd::inplace_merge\n\n\nThere are also some algorithms that cannot be parallelized\nThose who only operate on several values, e.g. std::min/max/minmax/clamp, std::swap/iter_swap\néšæœºç®—æ³•\nstd::search\nstd::push/pop/make/sort_heap\næ’åˆ—ç®—æ³•\näºŒå‰æœç´¢ç®—æ³•\nOrdered numeric algorithms, i.e. std::iota/accumulate/inner_product/partial_sum\n\n\n\nRange-version Algorithmsç®—æ³•ä¸­éœ€è¦å£°æ˜è¿­ä»£å™¨ï¼Œå½“æ“ä½œçš„æ˜¯ä¸€æ•´ä¸ªå®¹å™¨æ—¶ï¼Œå°±éœ€è¦ begin å’Œendï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨rangesã€‚range-version ç®—æ³•ä¹Ÿå¯ä»¥å«åš constrained algorithmsï¼Œä½¿å¾—ç®—æ³•æ“ä½œæ›´åŠ çµæ´»\n\nYou can additionally specify projection as the last parameter, i.e. transformation of elements before entering the real function æœ€åä¸€ä¸ªå‚æ•°å¯ä»¥æŒ‡å®šä¸€ä¸ªæ˜ å°„ï¼Œä¾‹å¦‚ä½¿ç”¨ transform åœ¨ä¼ å…¥å‡½æ•°å‰è¿›è¡Œå˜æ¢\nThis just changes criteriaï¼ˆæ ‡å‡†ï¼›æ¡ä»¶ï¼‰, the element itself is unchanged\nMultiple ranges may specify multiple projections\n\n\n\nstd::vector vec{-1, 2, -3, 4, -5, 6 };auto print = [](int i) {    std::cout &lt;&lt; i &lt;&lt; \",\";};std::cout &lt;&lt; \"with abs() projection: \\n\";std::ranges::sort(vec, {}, [](int i) {return std::abs(i); });std::range::for_each(vec, print);\n\n\nRange-version algorithms also have these advantages\nä½¿ç”¨äº† C++20 ä¸­çš„ concept\nThe range doesnâ€™t need to be comma (i.e. begin/end with the same type) beginå’Œ end ä¸è¦æ±‚ç±»å‹ç›¸åŒ\næ›´åŠ å®‰å…¨\næœ‰äº›ç®—æ³•è¢«åŠ å¼ºäº†\næ–°çš„æ–¹æ³•åŠ å…¥è¿›æ¥\nç”¨æ¨¡æ¿æ–¹æ³•æ›´å®¹æ˜“\n\n\nThere are also some defects\nä¸èƒ½ä½¿ç”¨å¹¶è¡Œç®—æ³•\nä¸€äº›ç®—æ³•è¢«å‰Šå¼±äº†\nè¿”å›å€¼ç±»å‹å¹¶ä¸å’Œ std:: ç›¸åŒï¼Œè¿”å›å€¼æ”¹å˜æœ‰ä»¥ä¸‹å‡ ç§å½¢å¼\nstdr::in_in_result&lt;I1, I2&gt;: æœ¬æ¥è¿”å›ä¸¤ä¸ªè¿­ä»£å™¨ï¼Œç°åœ¨è¿”å›äº†ä¸€ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢çš„æˆå‘˜å˜é‡æ˜¯ä¸¤ä¸ªè¿­ä»£å™¨\nstdr::in_out_result&lt;I, O&gt;\nstdr::in_in_out_result&lt;I1, I2, O&gt;\nstdr::set_union/intersection/symmetric_difference\nstdr::merge\nbinary stdr::transform\n\n\nstdr::in_out_out_result&lt;I1, I2, O&gt;\nstdr::partition_copy\n\n\nstdr::in_found_result&lt;T&gt;\n\n\n\n\n\nLifetimeStorage duration å­˜å‚¨æŒç»­æ€§There are four kinds of storage duration\n\nStatic storage duration: global variables, static variables in a function/class\nAutomatic storage duration: variables that belong to a block scope ro function arguments å®šä¹‰çš„æ—¶å€™æ„é€ ï¼Œé€€å‡ºçš„æ—¶å€™ææ„\nDynamic storage duration: you can create objects by using or some other allocation functions\nThread storage duration: çº¿ç¨‹åˆ›å»ºçš„æ—¶å€™æ„é€ ï¼Œçº¿ç¨‹é€€å‡ºçš„æ—¶å€™ææ„\n\nThe lifetime of an object begins when storage with proper alignment and size is allocated and the object is initialized åˆé€‚çš„å¯¹é½ï¼Œåˆé€‚çš„å¤§å°ï¼Œä»¥åŠåˆå§‹åŒ–\nThe lifetime of an object ends when itâ€™s destroy, or the dtor is called, or its storage is released or reused by non-nested object ææ„å‡½æ•°è¢«è°ƒç”¨ï¼Œå­˜å‚¨è¢«é‡Šæ”¾ï¼Œè¢«é‡ç”¨ï¼ˆfloatç±»å‹çš„å˜é‡é€šè¿‡æŸäº›æ‰‹æ®µè¢« int ç±»å‹å˜é‡å ç”¨ï¼‰\nTemporary objects are only alive until the statement ends (i.e. until ;) ä¸´æ—¶å˜é‡çš„å£°æ˜å‘¨æœŸåªåˆ°è¯­å¥ç»“æŸä¹‹å‰ï¼Œä¹Ÿå°±æ˜¯ ; åˆ†å·ä¹‹åæ‰ç»“æŸ\n\nå‡½æ•°ä¸­çš„å‚æ•°ä¼ é€’ const&amp; æˆ–std::function_refæ˜¯å®‰å…¨çš„\nè¿”å›ä¸´æ—¶å˜é‡å¯ä»¥å»¶é•¿å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œä¾‹å¦‚const&amp;struct A{};A bar() {return A{};};const A&amp; a = bar();\n\nIn modern C++, pointer is far beyond address; it has type T*, and you can hardly ever access some address by it when there are no underlying objects of type T alive æŒ‡é’ˆçš„åŠŸèƒ½è¿œè¿œè¶…å‡ºå¯»å€çš„è¯­ä¹‰ï¼ŒæŒ‡é’ˆæ˜¯å¸¦æœ‰ç±»å‹çš„æ¦‚å¿µï¼›å¦‚æœæŒ‡é’ˆæŒ‡å‘çš„åœ°å€ä¸ç¬¦åˆæŒ‡é’ˆå…·æœ‰çš„ç±»å‹ï¼Œå¦‚æœå†ç”¨æŒ‡é’ˆè®¿é—®ç›¸åº”çš„å…ƒç´ å°±ä¼šæ˜¯æ— æ•ˆçš„\nPlacement newâ€œå°±åœ°åˆå§‹åŒ–â€ ConstructOnBuffet, which wonâ€™t allocate memory, but only create the object at the place ä¸åœ¨é‡æ–°åˆ†é…å†…å­˜ï¼Œç›´æ¥åœ¨ç°æœ‰å·²å¼€è¾Ÿçš„å†…å­˜ç©ºé—´ä¸­åˆ›å»ºå¯¹è±¡\nalignas(T) unsigned chat buf[sizeof(T)];T* tptr = new(buf) T;tptr-&gt;~T();\n\n\nnew(buffet) Type Initializer, where Initializer is optional\nOf course, you need to make sure the alignment satisfies the requirement of the type, so you can use keyword alignas  ä¸ºäº†ä¿è¯ç±»å‹å¯¹é½éœ€è¦ç”¨åˆ°åœ¨ C++ 11 å¼•å…¥çš„å…³é”®å­—alignas\n\n\n\nstd::byte: defined in &lt;cstddef&gt; since C++ 17; itâ€™s just an enumeration class and explicitly represents a byte (before we may use unsigned char)\nTrivial dtor\nItâ€™s implicitly declared or declared with =default éšå¼ç”Ÿæˆï¼ˆç¼–è¯‘å™¨ï¼‰çš„æˆ–è€…è¢«å®šä¹‰ä¸ºdefault\nItâ€™s non-virtual and all non-static data members have trivial dtor æ‰€æœ‰çš„éé™æ€æˆå‘˜éƒ½æœ‰ trivial dtorï¼Œå¹¶ä¸”æˆå‘˜ä¸èƒ½æ˜¯è™šçš„\nFor example\nâœ…struct A{int a; float b;};\nâœ…class A{int a; public: float b; ~A() = default };\nâœ…class A{int a; public: float b; virtual ~A() = default };\nâclass B : public A{};\nâclass A{~A() {}};\nâclass A{std::unique_ptr&lt;int&gt; ptr;};\n\n\n\n\n\n\nCorner Cases\nCase1: if you construct an object that has the same type as the original object, and they occupies exactly same storage, then the original name, pointers and references are still valid å°±åƒèµ‹å€¼ç¬¦å·ä¸€æ ·\nCase2: itâ€™s best to reuse storage of plain types like int or classes that have trivial dtor å¦‚æœè¦é‡ç”¨å†…å­˜å°½é‡ä½¿ç”¨ç®€å•çš„ç±»å‹ï¼Œä¾‹å¦‚ int æˆ–è€…å¸¦æœ‰ trivial dtor çš„ç±»ï¼Œå¯¹äºå…¶ä»–ç±»å‹ç¼–è¯‘å™¨ä¼šåœ¨é€€å‡ºå½“å‰ scope æ—¶å€™ä¼šè‡ªåŠ¨è°ƒç”¨ææ„å‡½æ•°\nCase3: itâ€™s illegal to reuse memory of const objects that have determined their value in the compilation time\nCase4: unsigned char/std::byte array is explicitly regulated to be able to provide storage è¿™ä¸¤ä¸ªç±»å‹çš„æ•°ç»„æ˜¯æ˜ç¡®åœ°å¯ä»¥æä¾› storage çš„\nCase5: Itâ€™s legal to access the underlying object by pointers without the same type in these cases (type punning/aliasing ç±»å‹å †å  / ç±»å‹åˆ«åï¼‰ åœ¨å°‘æ•°æƒ…å†µä¸‹å¯ä»¥ä½¿ç”¨ä¸åŒç±»å‹çš„æŒ‡é’ˆè®¿é—®ä¸€äº›å¯¹è±¡\nadd/remove cv-qualification intç±»å‹çš„æŒ‡é’ˆå¯ä»¥ä½¿ç”¨ const int ç±»å‹çš„æŒ‡é’ˆè®¿é—®\ndecayed array ç”¨æŒ‡é’ˆè®¿é—®æ•°ç»„çš„å…ƒç´ \nif the underlying type is integer, then using the pointer of its signed/unsigned variant to access it is OK\nconvert it to (unsigned) char*/ std::byte* å…è®¸å°†å¯¹è±¡è§†ä½œå­—èŠ‚æ•°ç»„ byte array\n\n\nCase6:If you have an old pointer where youâ€™ve constructed a new object, but you want to use the old pointer to get the new pointer, you can use std::launderï¼ˆæ´—æ¶¤ï¼›æ´—é’±ï¼‰ defined in &lt;new&gt; since C++ 17\nstd::launder(reinterpret_cast&lt;A*&gt;(buffer)) to get the actual valid pointer ç”¨æ—§çš„æŒ‡é’ˆè·å¾—æŒ‡å‘æ–°çš„å¯¹è±¡çš„æŒ‡é’ˆ\n\n\n\nStrict Aliasing RulesStrict aliasing rules, if pointers are not aliased or not contained as member, then compilers can freely assume that theyâ€™re different objects æœ¬è´¨ä¸Šå°±æ˜¯æ£€æŸ¥ä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„åŒºåŸŸæœ‰æ²¡æœ‰å¯èƒ½é‡å \nstruct T{    uint8_t* target;    char* source;    void Unpack(int size)    {        while (size &gt; 0)        {            uint64_t t;            std::memcpy(&amp;t, source, sizeof(t));            target[0] = t &amp; 0x7;            target[1] = (t &gt;&gt; 3) &amp; 0x7;            target[2] = (t &gt;&gt; 6) &amp; 0x7;            target[3] = (t &gt;&gt; 9) &amp; 0x7;            source += 6, size -= 6, target += 16;        }    }};\n\n\nCompared with non-member version (i.e. Unpack(uint8_t* target, char* src, int size)), itâ€™s 15% slower\ntarget is an alias of this. It will then always reload target[i] instead of caching a qword to prevent change of target ç¼–è¯‘å™¨è®¤ä¸º target æ˜¯thisçš„åˆ«å\n\nOthers\nAttention to lambda lifetime\nLambda lifetime should always be shorter than reference captures\nIf you capture in the class, then this only captures members by this, which may be invalid after destruction å¦‚æœ this è¢«ææ„æ‰ï¼Œå°±ç®—æ˜¯æŠŠ this æ‹·è´å‡ºæ¥ï¼Œè¿˜æ˜¯å¤±æ•ˆçš„\n\n\nAttention to view lifetime\nSometimes you mey return a view generated by range adaptor in a function (e.g. v | std::reverse)\nFor lvalue, itâ€™s same as the lvalue itself, i.e. v here\nFor rvalue, itâ€™ll same as return a value, so that itâ€™s always safe ä¸´æ—¶å€¼\n\n\næ‰€æœ‰çš„ range adaptors åœ¨è°ƒç”¨ä¹‹å‰éƒ½ä¼šè°ƒç”¨ stdv::all å°è¯•å°† range è½¬æ¢æˆ viewï¼›ä½†æ˜¯å¯¹äº view æ¥è¯´ä¸åšä»»ä½•äº‹æƒ…\nFor lvalue range, itâ€™ll create a stdr::ref_view\nFor rvalue range, itâ€™ll create a stdr::owning_view\n\n\n\n\n\nType SafetyImplicit Conversion\nSome implicit conversions are automatic (standard conversions), and others are user-defined å¾ˆå¤šéšå¼çš„è½¬å‹éƒ½æ˜¯è‡ªåŠ¨çš„\nE.g. operator float(). If you declare it as explicit, then implicit conversion will be disabled\n\n\nStandard conversions\nLvalue-to rvalue conversion, array-to-pointer conversion, function-to-pointer conversion\nDecay actually means\nArray/Function -&gt; pointer\nOr for other types, remove remove references first, remove cv-qualifiers(const &amp; volatile) next\nYou can use std::decay_t&lt;T&gt; to get the decayed type\nauto a = xx; will also decay the deduced type, while auto&amp; will not\nBut structured binding auto [a, b] = xx; â€œseemsâ€ not decay decay çœ‹ä¼¼æ²¡å‘ç”Ÿï¼Œå…¶å®æ˜¯å‘ç”Ÿåœ¨ç»“æ„åŒ–ç»‘å®šçš„å®ç°ä¸Šï¼Œç›¸å½“äº auto anonymous = xx;ï¼Œa å’Œbæ˜¯æˆå‘˜å˜é‡çš„åˆ«åï¼Œdecay å‘ç”Ÿåœ¨ anonymous ä¸­\n\n\n\n\n\n\nNumeric promotions and conversions\nPromotion: promotion has higher precedence and will not lose precision\nb + c where b and c are unsigned short will in fact silently promote them to int and then do + å…ˆæå‡åˆ° int ç„¶åå†åšåŠ æ³•\nè‡³å°‘æå‡åˆ°int\nfloat can be promoted to double\n\n\nSigned value has negative values while unsigned ones donâ€™t, but conversion may happen\nfloat cannot represent all int/... but int can be converted to float implicitly\nAny scalar types can be converted to bool\nPointers can be converted to void* to base class, and nullptr can be converted to pointer directly\nPointer to member of derived class can also be converted to pointer to member of base class, i.e. Derived::int* -&gt; Base::int*\nThere are also some numeric conversions that need explicit cast æ•°å€¼ä¸Šçš„è½¬æ¢éœ€è¦æ˜¾ç¤ºçš„è½¬æ¢\nNarrow integer conversion will mod  ä¾‹å¦‚ int -&gt; shortï¼Œlong long -&gt; int ä¼šæŠŠé«˜ä½çš„ä½æ•°æˆªæ–­\nNarrow floating conversion will be rounded\nFloating to integer will truncate the digits after dot; UB if truncated integer is not representable by converted type\n\n\n\n\n(Exception-specified) function pointer conversion\nå¯ä»¥æŠŠ noexcept çš„å‡½æ•°æŒ‡é’ˆè½¬æ¢æˆæ²¡æœ‰ noexcept çš„å‡½æ•°æŒ‡é’ˆ\n\n\nQualification conversions\nYou can convert a non-const/non-volatile to const/volatile one\n\n\n\n\n\nStatic Caststatic_cast is the most powerful one, which can process almost all of normal conversion,defined as static_cast&lt;TargetType&gt;(Exp)\n\nStandard-layout\n\næ‰€æœ‰çš„æˆå‘˜éƒ½æœ‰ç›¸åŒçš„è®¿é—®å±æ€§\næ²¡æœ‰è™šå‡½æ•°\nThe base class is not the type of the first member data åŸºç±»å¯¹è±¡ä¸èƒ½æ˜¯å­ç±»ç¬¬ä¸€ä¸ªæˆå‘˜å˜é‡\næ•´ä¸ªç»§æ‰¿ç»“æ„ï¼Œåªèƒ½æœ‰å…¶ä¸­ä¸€ä¸ªç±»æ˜¯æœ‰éé™æ€çš„å˜é‡\n\n\n\nAll implicit conversions can be explicitly denoted by static_cast å¯ä»¥åšä»»ä½•ä¸€ç§éšå¼çš„è½¬æ¢ï¼Œä¹Ÿä¼šå…è®¸é€†æ“ä½œ e.g. int -&gt; short, double -&gt; float\nScoped enumeration can be converted to/from integer or floating point, which is same as the underlying integer type\nInheritance-related conversions\nupcast å‘åŸºç±»è½¬æ¢ï¼›æ›´å®‰å…¨çš„\ndowncast å‘æ´¾ç”Ÿç±»è½¬æ¢ï¼›æœ‰ç‚¹å±é™©\n\n\nFor static_cast, besides inheritance-related pointer conversion, it also processes void*\nYou can convert any object pointer to void* (this is also implicit conversion)\nYou can also convert explicitly void* to any object pointer å‰ææ˜¯å¯¹è±¡æ½œåœ¨çš„ç±»å‹ U å’ŒæŒ‡é’ˆçš„ç±»å‹ T æœ‰æŸç§ç‰¹æ®Šçš„å…³ç³»â€”â€”pointer-interconvertible\nT == U\nU is a union type, while T is type of its member\nU is standard-layout, while T is type of its first member or its base class\nOr all vice versa/transitivity\n\n\n\n\nå¹¶ä¸ä¿è¯åœ°å€æ˜¯ç›¸åŒçš„\nConvert to void: just discard value, nothing happens\nConstruct new object: if the object ctor can accept a single parameter, which is convertible from the expression, then it in fact constructs a new object. E.g. static_cast&lt;A&gt;(a) for A(int)\nTransform value category\nstatic_cast can be used to specify which overload of functions is used by function-to-pointer conversion\n\nDynamic Cast and RTTIDynamic Caststatic_caståœ¨ç»§æ‰¿é“¾ä¸­æ£€æŸ¥æ˜¯éå¸¸å¼±çš„ï¼ˆå¯ä»¥è¯´æ˜¯ä¸åšæ£€æŸ¥ï¼‰ï¼Œå³ä¾¿è½¬æ¢çš„å¯¹è±¡ä¸æ˜¯æ´¾ç”Ÿç±»çš„ç±»å‹ä»ç„¶ä¼šåšè½¬æ¢ï¼Œåªæ˜¯ä¼šå¸¦æ¥ undefined behaviorã€‚dynamic_castå°è¯•è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¦‚æœè½¬æ¢ä¸åˆé€‚ä¼šå¤±è´¥\n\nå¼•ç”¨ä¸Šè½¬æ¢å¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸throw std::bad_cast\næŒ‡é’ˆä¸Šè½¬æ¢å¤±è´¥ä¼šè¿”å›nullptr\næ¯” UB æ›´å¼ºï¼Œæ›´å®¹æ˜“å®šä½ bug\n\nä¸ºäº†åšäº†è¿è¡Œæ—¶æ£€æŸ¥ï¼ŒC++ ç¼–è¯‘å™¨ä¼šåœ¨æ–‡ä»¶ä¸­ä¿ç•™è¿è¡Œæ—¶çš„ç±»å‹è¯†åˆ«ï¼ˆRTTI, Run-Time Type Information/Identificationï¼‰ï¼Œdynamic_caståªèƒ½ç”¨åœ¨å¤šæ€çš„ç±»å‹è½¬æ¢ä¸­ï¼Œå› ä¸º RTTI ä¾èµ–äºè™šæŒ‡é’ˆç­‰ç‰¹æ€§ã€‚ä½†æ˜¯ dynamic_cast æ€§èƒ½ä¸Šè¦æ¯” static_cast æ…¢ 10 å€ç”šè‡³ç™¾å€\n\nYou can do downcast in polymorphic types\nè¢«è½¬æ¢çš„å¯¹è±¡ï¼Œæ½œåœ¨çš„å¯¹è±¡ç±»å‹å¿…é¡»å’ŒåŸºç±»çš„ç±»å‹ç›¸åŒï¼Œå¦åˆ™ä¸èƒ½è½¬æ¢æˆåŠŸ\ndynamic_castä¸èƒ½ç”¨åœ¨å½“å‰ç±»æ„é€ å‡½æ•°å’Œææ„å‡½æ•°ä¸­ï¼Œå› ä¸ºå½“å‰ç±»çš„è™šæŒ‡é’ˆä¸æ˜¯å®Œæ•´çš„\n\n\nYou can also do sidecast in polymorphic types with multiple inheritance\n\nRTTIC++ æä¾›äº†ä¸€ç§æ–¹å¼å¯ä»¥ç›´æ¥å¾—åˆ°ç±»å‹çš„ä¿¡æ¯ï¼Œå®šä¹‰åœ¨ &lt;typeinfo&gt;ï¼ŒåŒæ ·è¦é™åˆ¶ä½¿ç”¨ï¼Œä¼šé€ æˆæ€§èƒ½ä¸Šçš„é—®é¢˜ã€‚å¯ä»¥ä½¿ç”¨typeid(xxx) å¾—åˆ° const std::type_infoï¼Œç±»ä¼¼äºsizeof æ“ä½œç¬¦ã€‚type_infoæ˜¯åªè¯»çš„ï¼Œä¸èƒ½é€šè¿‡æ‹·è´æˆ–è€…æ„é€ ï¼Œåªèƒ½é€šè¿‡ typeid è·å¾—æˆ–è€…å¼•ç”¨ã€‚å¯ä»¥ä½¿ç”¨ .name() è¿›è¡Œ debug\n\n.name()\n.hash_code()\n.before()\n\nRTTI is unfriendly to shared library å¯¹åŠ¨æ€é“¾æ¥åº“ä¸æ˜¯å‹å¥½çš„\n\nSince GCC 3.0, symbols are compared equality by address instead fo names. So to preserve only one symbol across many .obj file, it  merges them when linking (like in static library) ç¬¦å·ä½¿ç”¨åœ°å€æ¯”è¾ƒç›¸ç­‰æ€§ï¼Œè€Œä¸æ˜¯é€šè¿‡åå­—æ¯”è¾ƒç›¸ç­‰æ€§ï¼›å³ä½¿ä¸¤ä¸ªç¬¦å·çš„åå­—æ˜¯ç›¸ç­‰çš„ï¼Œåœ°å€ä¸ç›¸ç­‰ï¼Œå½“å‡ºç°åœ¨ä¸åŒçš„ .obj æ–‡ä»¶ä¸­çš„æ—¶å€™ï¼Œä¼šå°†åå­—ç›¸ç­‰çš„ç¬¦å·è¿›è¡Œåœ°å€åˆå¹¶\nSo to load shared library quickly, many procedures are omitted, which includes resolving different RTTI symbols ä¸ºäº†å¿«é€Ÿé“¾æ¥åŠ¨æ€é“¾æ¥åº“ï¼Œå¾ˆå¤šæ­¥éª¤éƒ½è¦è¢«çœç•¥ï¼Œå…¶ä¸­ä¹ŸåŒ…æ‹¬ RTTI ç¬¦å·çš„åˆå¹¶\n\nConst Cast\nIt tries to drop the cv-qualifiers\næ˜ç¡®çš„çŸ¥é“äº†åŸæ¥çš„å¯¹è±¡å°±æ˜¯é read-onlyï¼Œç„¶åæ¥æ”¶åˆ°çš„å¯¹è±¡æ˜¯ const ç±»å‹çš„\nThe author forgets the const in parameter, but it in fact doesnâ€™t write it\n\n\nvolatile is similar æŠŠ volatile å»æ‰ä¼šæœ‰ cache çš„é£é™©ï¼Œvolatileè¦æ±‚æ¯æ¬¡ä½¿ç”¨éƒ½è¦åˆ°å†…å­˜ä¸­é‡æ–°å»è¯»\nä¸€èˆ¬æƒ…å†µä¸‹ç”¨ä¸åˆ°\n\nReinterpret Castreinterpret_cast is used to process pointers of different types, which is dangerous because of life time\n\nConverting from an object pointer to another type, i.e. reinterpret_cast&lt;T*&gt;(xxx)\nThis is same as static_cast&lt;T*&gt;)(static_cast&lt;(cv) void*&gt;(xxx))\nstd::launder\n\n\nConverting from a pointer to function to another type of pointer to function; or pointer to member to another one\nConverting pointer to integer or vice versa ï¼ˆåä¹‹äº¦ç„¶ï¼‰\nA pointer can be converted to integer by reinterpret_cast if the integer is large enough (std::uintptr_t)\nThis integer can be converted back to get the original pointer\nreinterpret_cast from 0/NULL is UB\nReference is also convertible å¼•ç”¨å’ŒæŒ‡é’ˆä¸€æ ·\n\n\n\nType-safe union and void*\nSince C++ 17, &lt;variant&gt; and &lt;any&gt; are introduced to guarantee the safety\n\nstd::variant can be seen as a union with a size_t index, which will inspect whether the member is  in its lifetime when getting\nstd::variant&lt;int, float, int, std::vector&lt;int&gt;&gt; v{1.0f };// ç±»ä¼¼äºunion Union {    int _1;    float _2;    int _3;    std::vector&lt;int&gt; _4;};\n\n\nFor construction\nBy default, the first alternative is value-initialized é»˜è®¤ç¬¬ä¸€ä¸ªä½ç½®è¢«åˆå§‹åŒ–\nYou can also assign a value with the same type of some alternative, then thisâ€™s the active alternative\nYou can also construct the member in place,i.e. by (std::in_place_type&lt;T&gt;, args...)\nYou can construct by index, i.e. (std::in_place_index&lt;Index&gt;, args...)\n\n\nTo access or check the existence of alternative\n.index(): return the index of active alternative\nThese methods need the examined type unique in type params\nstd::hold_alternative&lt;T&gt;(v): return Boolean that denotes whether the active alternative is of type T\nstd::get&lt;T&gt;(v): return the active alternative of type T ä¼ å…¥å¼•ç”¨\nstd::get_if&lt;T&gt;(v): return the pointer to the active alternative of type T ä¼ å…¥æŒ‡é’ˆ\n\n\nIf not unique, you can also use index-based access: std::get&lt;I&gt;(v), std::get_if&lt;I&gt;(v)\n\n\nBesides type safety, the most important extension of std::variant than union is that it implements visitor pattern\n\n\nstd::any can be seen as a void* with the original type â€œstoredâ€ magically, so that youâ€™ll fail to graspï¼ˆç†è§£ï¼›é¢†ä¼šï¼‰ the inner object with the wrong type å¯ä»¥åŠ è½½ä»»æ„çš„å¯¹è±¡\nstd::any a{1 };a = 2.0f;a = \"test\";\n\n\næ‰¿è½½çš„å¯¹è±¡å¿…é¡»æœ‰æ„é€ å‡½æ•°ï¼Œç±»å‹ä¼š decay\nYou can also default-construct it or call .reset(), then it holds nothing\n.has_value()\n(std::in_place_t&lt;T&gt;, args...)\nWhen you need to get the underlying object, you need to use std::any_cast&lt;T&gt;(a) or (&amp;a)\nstd::any can have SBO (small buffer optimization) like std::function æ ‡å‡†åº“ä¼šç»™ std::any åœ¨æ ˆä¸Šåˆ†é…æ¯”è¾ƒå°çš„ bufferï¼Œå­˜å‚¨ä¸€äº›éå¸¸å°çš„å¯¹è±¡ï¼Œè€Œä¸æ˜¯åœ¨å †ä¸Šåˆ†é…å†…å­˜\n.swap/std::swap/.emplace\n.type()\nstd::make_any, same as constructing std::any\n\n\n\n\n\nProgramming in Multiple FilesRemember the compilation procedures of C\n\nPreprocess, where comments are stripped and macros are processed (so that your #include can get the file correctly)\nCompile, where each source file is compiled independently ç¼–è¯‘\nAssemble; this is not something we care since it just translate assembly to object file æ±‡ç¼–\nLink, to locate symbols that are referred in other TUs(Translation unit) é“¾æ¥\n\nPreprocessor é¢„å¤„ç†å™¨To be specific, preprocessing can be divided into 6 phases\n\nRead files and map them to translation character set, which guarantees UTF-7 to be supported è¯»æ–‡ä»¶ æ˜ å°„\nBackslashes as the end of line are processed to concatenate two physical lines into a single logical line å¤„ç†åæ–œæ \\\nComments and macros are extracted, and the whole file is parsed\nPreprocessor runs to process all macros\nString literals are encoded as specified by the prefix å¤„ç†å­—ç¬¦ä¸²å¸¸é‡ï¼ŒæŒ‰ç…§æŒ‡å®šçš„å‰ç¼€è¿›è¡Œç¼–ç \nAdjacent string literals are concatenated ï¼›é‚»è¿‘çš„å­—ç¬¦ä¸²æ‹¼æ¥\n\nA preprocessing directive begins with #. There are four kinds of directives\n\n#include ..., which copies all file content into the current file\n\n#include &lt;...&gt;\n#include \"...\"\n\n\n#define i.e. macros, which does pure text replacement\n\n#define FUNC(a, b) a + b\n\nParameters of macros can be blank\n\nParameters of macros are directly parsed by commas when no paratheses surrounded, e.g. FUNC(SomeFunc&lt;int, double&gt;()) -&gt; SomeFunc&lt;int + double&gt;() ç”¨ , ç›´æ¥è¿›è¡Œåˆ†è¯ï¼Œé‡åˆ° , å°±ä¼šæ›¿æ¢\n\nYou need to add an additional pair of paratheses to help parse, e.g. FUNC((SomeFunc&lt;int, double&gt;()), 3)\n\nYou can use ... for parameters of any number, and reference them by __VA_ARGS__ å˜é•¿å‚æ•°çš„æ›¿æ¢\n\nSince C++ 20, you can use __VA_OPT__(content), which will be enabled only when __VA_ARGS__ is not empty\n\n# can be used to turn parameters to strings, and  ## can be used to concatenate parameters to make them a whole token\n#define NameToStr(a, b) #a #bauto str = NameToStr(1, aa)#define ConcatName(a, id) a ## idint ConcatName(a, 1) = 0;std::cout &lt;&lt; a1;\n\n\nYou need #undef to drop the definition of the macro å–æ¶ˆå®å®šä¹‰\n\n\n\nConditional choice of code\n\n#ifdef, (#elifdef since C++ 23), #else\n#ifndef, (#elifndef since C++ 23), #else\n#if defined xx is equivalent to #ifdef xx\n#endif\n#if, #elif, #else\n\n\n#pragma is in fact a macro for implementation-defined usage éœ€è¦æŸ¥çœ‹ç¼–è¯‘å™¨æ–‡æ¡£æˆ–è€…å…¶ä»–ç›¸å…³æ–‡æ¡£æ‰èƒ½çŸ¥é“å…·ä½“çš„ç”¨é€”\n\n#pragma once, #pragma pack\n\n\n#line: specify the line number manually\n\n\nCompileDeclaration &amp; Definition\nTranslation unit (TU)\næ¯ä¸€ä¸ªæºæ–‡ä»¶éƒ½æ˜¯å•ç‹¬è¿›è¡Œç¼–è¯‘ï¼Œæœ€åé€šè¿‡è¿æ¥å™¨å»é“¾æ¥æœªçŸ¥çš„ç¬¦å·ï¼Œæ¯ä¸ªæºæ–‡ä»¶é€šè¿‡é¢„å¤„ç†å°†å…¶ä»–ç¬¦å·åŠ åˆ°å½“å‰æ–‡ä»¶ä¸­ï¼Œè¿™ä¸€æ•´ä¸ªå¤„ç†ç»“æœå°±æ˜¯ TU\nC++ è¦æ±‚å…ˆå£°æ˜å†ä½¿ç”¨ï¼Œæ‰€ä»¥æ¯ä¸ª TU é¦–å…ˆè¦çœ‹åˆ°æ‰€ä½¿ç”¨çš„å£°æ˜\nC/C++ has One-Definition Rule (ODR), meaning that each entity should have only one definition in a TU or even in a program ä¸€ä¸ªå®ä½“åªèƒ½å®šä¹‰ä¸€æ¬¡\n\n\nå…¸å‹çš„å£°æ˜å’Œå®šä¹‰\nFunction prototype &amp; one with function body å‡½æ•°ç­¾åå’Œå…·æœ‰å‡½æ•°ä½“çš„å‡½æ•°ï¼Œä¹ŸåŒ…æ‹¬ç±»çš„æˆå‘˜å‡½æ•°\nclass A;, class A{...}, struct ç±»çš„å£°æ˜å’Œå®šä¹‰\nenum class A (: Type)\n\n\nç±»çš„å£°æ˜æ˜¯ä¸€ä¸ªæ¯”è¾ƒç‰¹æ®Šçš„å®ä½“ï¼Œå¯¹äºå‡½æ•°æ¥è¯´åªéœ€è¦æš´éœ²å‡½æ•°çš„ç­¾åå°±å¯ä»¥ä½¿ç”¨ï¼Œä½†æ˜¯å¯¹äºç±»æ¥è¯´å£°æ˜æ˜¯è¿œè¿œä¸èƒ½å¤Ÿä½¿ç”¨ç±»\nIt only requires the class to be defined only once in a TU\nBesides, class definition requires to fully see all definitions of its members &amp; base classes ç±»çš„å®šä¹‰å¿…é¡»è¦æ±‚æœ‰å®Œæ•´çš„å®šä¹‰ï¼ŒåŒ…æ‹¬ç±»çš„æˆå‘˜å’ŒåŸºç±»\nYou cannot class Vector3; class A {Vector3 v;};\nThis is because compilers need to determine the layout of the class; if definition of some members are unknown, its sizeof is unclear ç¼–è¯‘å™¨å¿…é¡»çŸ¥é“ç±»çš„å¤§å°\n\n\nWe can use mere class declarations in these cases åªéœ€è¦ä½¿ç”¨ç±»çš„å£°æ˜çš„æƒ…å†µ\nAs an argument of prototype; its members and layout are not used åšä¸ºå‡½æ•°çš„å‚æ•°\nWhen you only needs a pointer or reference as members ç”¨æŒ‡é’ˆæˆ–è€…å¼•ç”¨æŒ‡å‘ç±»\n\n\nNotes\nItâ€™s allowed to put definition of methods into class definition\nReturn types and parameter types of declarations and definitions of methods should be the same\nfriend will implicitly declares the class or function\nClass members in class definition is in fact definition instead of just simple declaration, so we donâ€™t need to define it again in .cpp\nDefault parameters of functions should be put into declaration, and shouldnâ€™t be put into definition\nType alias (like using) and static_assert are also declarations\nheader guard è§£å†³å®šä¹‰å‡ºç°ä¸¤æ¬¡çš„é—®é¢˜ #pragma once\n\n\nTemplate çš„å£°æ˜å’Œå®šä¹‰\nTemplate will not preserve its information to object file\nåœ¨å¤´æ–‡ä»¶ä¸­å†™å£°æ˜å’Œå®šä¹‰\nFunction template in class should also be put into header\n\n\n\nNamespace\nWhen code base is large, name conflicts usually happen è§£å†³å‘½åå†²çªï¼ŒC è¯­è¨€ä¸­è§£å†³æ–¹å¼æ˜¯åŠ å¤§é‡çš„å‰ç¼€\n\nusing namespace xx is like from xx import *\n\nusing yy::xx is like from yy import xx\n\nYou should never put using namespace xxx or using xx into header files\n\nInline namespace has nothing to do with inline. Itâ€™ll expose contents into the parent namespace, as if there is a using namespace xx å’Œå…³é”®å­— inline æ¯«æ— å…³ç³»ï¼Œç›®çš„æ˜¯æŠŠæ‰€åŒ…å«çš„å†…å®¹æš´éœ²åˆ°ä¸Šå±‚å‘½åç©ºé—´ä¸­\nnamespace Test6{    inline namespace Implv1    {        void Func();    }}namespace Test6::Implv1{    void Func()    {        std::cout &lt;&lt; \"This is v1.\\n\";    }}// è°ƒç”¨çš„æ—¶å€™å®Œå…¨å¯ä»¥å°† `Implv1` å¿½ç•¥æ‰Test6::Func();\n\n\nè€ä»£ç éœ€è¦å…¼å®¹ï¼Œæ–°ä»£ç å¯ä»¥å¹³æ»‘è¿‡æ¸¡\n\n\n\nInline\nRecall procedures of function calls\nCaller saves registers on the stack\nJump to the calling position è·³è½¬åˆ°å‡½æ•°æ‰€åœ¨çš„åœ°å€\nCallee saves registers, execute code, and restores registers å¯¹äºå‡½æ•°æœ¬èº«æ¥è¯´ä¹Ÿä¼šä¿å­˜å¯„å­˜å™¨ï¼Œå¹¶æ‰§è¡Œä»£ç ï¼Œåœ¨æŠŠå¯„å­˜å™¨ä¸­çš„å†…å­˜æ¢å¤\nJumping back by popping up the return address\nCaller restores registers on the stack\n\n\nIf we can fuse function body into the caller and optimize together, then register saving / restoring and jumping will be almost eliminated ç›´æ¥å°†å†…è”å‡½æ•°æ’å…¥åˆ°è°ƒç”¨çš„åœ°æ–¹ï¼Œå¯„å­˜å™¨çš„ä¿å­˜å’Œæ¢å¤ï¼Œä»¥åŠè·³è½¬çš„å¼€é”€ä¼šè¢«æ¶ˆé™¤ä»¥è¾¾åˆ°ä¼˜åŒ–çš„ç›®çš„\nInline function should be put into header files å› ä¸ºæ¯ä¸ªæºæ–‡ä»¶éƒ½éœ€è¦çŸ¥é“å†…è”çš„å‡½æ•°ä½“\ninlineä¹Ÿä¼šé€ æˆå…¶ä»–é—®é¢˜\nThe code size may bloatï¼ˆè†¨èƒ€ï¼‰, since the function body is inserted everywhere\nUtility of instruction cache may be lower, since the same function has different addresses å¯¹ i-cache çš„åˆ©ç”¨ç‡é™ä½ï¼Œç›¸åŒçš„ä»£ç å…·æœ‰å®Œå…¨ä¸ä¸€æ ·çš„åœ°å€\nInline function wonâ€™t create their function address, so you cannot â€œjump to the nextâ€ when debugging è¿›è¡Œ debug æ—¶æŠŠæ•´ä¸ªå‡½æ•°è·³è¿‡å»äº†\n\n\ninline is just an suggestion to compiler, and compiler may choose to not inline the body\né€’å½’è°ƒç”¨\nå‡½æ•°æœ¬èº«é€»è¾‘æ¯”è¾ƒå¤æ‚\nä¸çŸ¥é“ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ inline åˆé€‚\n\n\nSince C++ 17, inline variables are introduced å†…è”å˜é‡ï¼Œå¯ä»¥ç›´æ¥æŠŠå†…è”å˜é‡æ”¾åˆ°å¤´æ–‡ä»¶ä¸­\nThis mainly facilitates header-only libraries, since they hope to use some global variables without source files\nInline variables can also be in class definitions, so that static variable can be unnecessary to split definition and declaration é™æ€å˜é‡å°±ä¸éœ€è¦åˆ†å¼€å£°æ˜å’Œå®šä¹‰äº†\n\n\nInline functions/variables may cause double symbols in shared libraries å†…è”å‡½æ•° / å˜é‡ä¼šåœ¨åŠ¨æ€é“¾æ¥æ˜¯é€ æˆåŒå®šä¹‰\né™æ€é“¾æ¥åº“æ˜¯éœ€è¦å®Œå…¨çš„ç¬¦å·åˆå¹¶\nä½†æ˜¯åŠ¨æ€é“¾æ¥åº“çš„ç¬¦å·æ˜¯æœªå¿…è¿›è¡Œåˆå¹¶çš„ RTTI\nåœ¨é“¾æ¥åº“çš„å†…å¤–ä¼šå­˜åœ¨ä¸¤ä¸ªç‰ˆæœ¬çš„å˜é‡\n\n\n\nLinkageExternal linkage: Linker can always find the symbol in other TUs é“¾æ¥å™¨åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹éƒ½èƒ½åœ¨å…¶ä»–çš„ TU ä¸­æ‰¾åˆ°ç›¸å…³ç¬¦å·ï¼Œè¿™ç§çš„å«åšå¤–éƒ¨é“¾æ¥ï¼Œå‡ ä¹æ‰€æœ‰çš„å®ä½“åœ¨ä¸åŠ å…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œéƒ½æ˜¯ external linkage\n\nClass members\nFunctions\nFunctions declared by friend\nEnumerations\nTemplates\nNon-const variables, volatile variables and inline variables\n\nInternal linkage: ä½†æ˜¯æœ‰çš„æ—¶å€™ä¸æƒ³æš´éœ²å®ä½“ï¼Œä½¿ç”¨å¤–éƒ¨é“¾æ¥ä¼šè®©å…¶ä»– TU çªƒå–å®ç°çš„ç§å¯†æ€§\n\nstatic in introduced to force internal linkage ç”¨ static å…³é”®å­—å£°æ˜å†…éƒ¨é“¾æ¥æ€§å®ä½“\nUnlike static member functions, static that denotes linkage is necessary in definition åœ¨å‡½æ•°å®šä¹‰æ—¶éœ€è¦å¸¦ä¸Šstaticï¼Œæˆå‘˜å‡½æ•°åˆ™ä¸éœ€è¦\nå¤–éƒ¨é“¾æ¥æ€§å’Œæ¨¡æ¿å®ä¾‹åŒ–ä¸ä¼šå†²çªï¼Œå®Œå…¨æ˜¯ä¸¤ä¸ªä¸ç›¸å¹²çš„æ¦‚å¿µ\n\n\nAnother way is to define things in an anonymous namespace éœ€è¦å®šä¹‰å¤§é‡çš„å†…éƒ¨é“¾æ¥æ€§å®ä½“æ—¶å€™å¯ä»¥ä½¿ç”¨\nThere are some special cases where entities are born with internal linkage\nconst global variables\nAnonymous unions\n\n\n\nSingleton\nReason\nThe sequence of initializing global variables across TU isnâ€™t determined å…¨å±€å˜é‡åˆå§‹åŒ–çš„é¡ºåºåœ¨åŒä¸€ä¸ª TU ä¸­å¯ä»¥ä¿è¯ï¼Œä½†æ˜¯åœ¨ä¸åŒçš„ TU ä¸­ä¸èƒ½ä¿è¯\nSide effects caused by global variables may not be executed\n\n\n\n// singleton.h#pragma onceclass Singleton{public:    static Singleton&amp; GetInstance();private:    Singleton() = default;}// singleton.cpp#include \"singleton.h\"Singleton&amp; Singleton::GetInstance(){    static Singleton* instance = new Singleton();    return *instance;}\n\n\nNo linkage æ— é“¾æ€§\nThis happens for static local variables (i.e. static variables in functions) and normal local variables\nYou can even define a class inside the block scope, which also has no linkage\n\n\n\nXMakeXMake acts as both a build tool and a package manager\n\n(Optional) Project name, project version and required xmake version\nset_project(\"Programming in Multiple Files\")set_xmakever(\"2.8.1\")set_version(\"0.0.0\"\nModes and language version\nadd_rules(\"mode.debug\", \"mode.release\")set_languages(\"cxx20\")\nSome other options\nset_policy(\"build.warning\", true)set_warning(\"all\")\n\n\nset_policy(\"build.warning\", true) means that report warning even if compile success\n\n\nAdd required packages add_requires(\"ctre 3.8.1\", \"catch2\")\n\nSpecify the building target\ntarget(\"example\")    set_kind(\"binary\")    add_headerfiles(\"example1/*.h\")    add_files(\"example1/*.cpp\")\n\n\ntarget(name)\nset_kind(...)\nbinary will compile the executable\nstatic static library\nshared stared library/dynamic-linked library\nphony empty, just used to combine targets like libraries\nheader_only for projects that only have header files\n\n\nadd_files(...)\nadd_headerfiles(...)\n\n\nxmake to compile all targets\n\nxmake -b xx to compile specific targets\nxmake run xx to run specific executable\n\n\n\nModules\nThere are several problems in headers\n\nNon-inline functions cannot be defined to keep ODR\n#include always requires the preprocessor to copy all contents, which makes the real file huge and drags the compilation stage\nIf marcos arenâ€™t undef, they will be leaked\n\n\nEvery module has only one primary interface unit\n\nBegin with export module Name åœ¨æ–‡ä»¶å¼€å§‹æ—¶å£°æ˜\n\nIt regulates that entities are visible to other modules by export æ–‡ä»¶ä¸­çš„å…¶ä»–å®ä½“éƒ½å¯ä»¥åŠ  export å…³é”®å­—\n\nModule interface files have no determined suffix\n\nmsvc - ixx\nclang - cppm\ngcc - donâ€™t care\nIt can also be mmp, mmx\n\n\nexport import å­—é¢æ„ä¹‰\n\nModules ä¹Ÿå…è®¸å£°æ˜å’Œå®šä¹‰åˆ†ç¦»ï¼ŒåŸç†æ˜¯ module implementation unit\n\nIt begins with module Name; and shouldnâ€™t have any export\nA module can have multiple implementation files, as long as they all begin with module Name; ä¸€ä¸ªæ¨¡å—å¯ä»¥æœ‰å¤šä¸ªæºæ–‡ä»¶å»å®ç°\nYou can directly import \"xxx.h\"; theyâ€™re called header unit\nC++ uses global module fragment\nIt begins before export module Name; or module Name;\n\n\n\nmodule; // global module fragment#define NEED_PARAM#include \"Old.h\"module Person; //\n\n\nYou can partition either interface or implementation å¦‚æœæ¨¡å—å¤ªå¤§ä¹Ÿå¯ä»¥è¿›è¡Œæ‹†åˆ†\n\nInterface partition unit: begin with export module Name:SubName;\nImplementation partition unit: begin with module Name:SubName2;\nåˆ†åŒºæ—¶æ¨¡å—å†…éƒ¨çš„æ¦‚å¿µï¼Œå¯¹å…¶ä»–æ¨¡å—æ˜¯é€æ˜çš„\nInside the module, it can use import :SubName to import the partition\nBut in other modules, they cannot use import Name:SubName\n\n\nUnlike module implementation, implementation partition is not implementation of interface partition æ¨¡å—çš„å®ç°åˆ†åŒºå’Œæ¨¡å—çš„æ¥å£åˆ†åŒºå¹¶ä¸æ˜¯å®ç°çš„å¯¹åº”å…³ç³»ï¼Œä¸èƒ½åœ¨å‡ºç°åŒåçš„åˆ†åŒºäº†\nIf there exists module A:B; there shouldnâ€™t exist export module A:B\n\n\nPartitions cannot have partitions (depth == 1) åˆ†åŒºä¸èƒ½å†è¿›è¡Œåˆ†åŒº\n\n\n\nError HandlingError code extensionOptional\nIt uses an additional bool to denote â€œexist or notâ€ ç”¨ bool å€¼æ¥è¡¨ç¤ºæ˜¯å¦å­˜åœ¨\n\nEmpty value then introduced as std::nullopt, which essentially makes the underlying bool to be the false\ntemplate&lt;typename Key, typename Val&gt;std::optional&lt;Val&gt; Get(const std::map&lt;Key, Val&gt;&amp; map, const Key&amp; key){    if (auto it = map.find(key); it != map.end()        return it-&gt;second;    return std::nullopt;}\n\n\nCtor, operator=, swap, emplace, std::swap, std::make_optional\n\nCtor can also accept (std::in_place, Args to construct T)\n\n\noperator&lt;=&gt;\n\nstd::hash; unlike std::variant, itâ€™s guaranteed for std::optional to have the same hash as std::hash&lt;T&gt; if itâ€™s not std::nullopt\n\nYou can just use std::optional as a nullable pointer\n\noperator-&gt;/operator*/operator bool, as if a T*\nThe behavior is undefined for -&gt;/* if itâ€™s in fact std::nullopt\n\n\n.has_value(), .value() (which will throw std::bad_optional_access instead of std::nullopt)\n.value_or(xx) can provide a default value\n\n\nNote\n\nMost of types in Java and C# are nullable, which makes them â€œoptionalâ€ automatically åƒæ˜¯ Java å’Œ C# è¯­è¨€å¤§éƒ¨åˆ†çš„å˜é‡ç±»å‹éƒ½æ˜¯è‡ªåŠ¨çš„â€optionalâ€ï¼Œä½†æ˜¯ä¹Ÿä¼šæœ‰æ•ˆç‡ä¸Šçš„é—®é¢˜\nstd::optional, std::expected, std::any and std::variant are sometimes called â€œvocabulary typeâ€ å®ƒä»¬éƒ½ä¸èƒ½ç”¨ä½œå¼•ç”¨ç±»å‹å»å®ä¾‹åŒ–æ¨¡æ¿ std::optional&lt;int&amp;&gt;\nThough std::optional only store an additional bool, this alignment and padding will make it in fact larger\n\n\n\nExpected\nIt uses an Error type (i.e. std::expected&lt;T, E&gt;) instead of null to denote absent value ç”¨ç¬¬äºŒä¸ªæ¨¡æ¿å‚æ•°æ¥è¡¨è¾¾é”™è¯¯ç±»å‹ï¼Œæ›´è¢«å»ºè®®ç”¨ä½œé”™è¯¯å¤„ç†\n\nstd::expected&lt;double, std::errc&gt; parse_number(std::string_view&amp; str){    double result;    auto begin = str.data();    auto [end, ec] = std::from_chars(begin, begin + str.size(), result);    if (ec != std::errc{})        return std::unexpected{ec};    if (std::isinf(result))        return std::unexpected{std::errc::result_out_of_range};    str.remove_prefix(end - begin);    return result;}\n\nMonad\n&lt;T1, E1&gt;.and_then(T1) needs to return &lt;T2, E1&gt;\nFor std::optional, itâ€™s obligated to return std::optional&lt;T2&gt;\n\n\n&lt;T1, E1&gt;.transform(T1) needs to return T2, which will construct &lt;T2, E1&gt; automatically\nFor std::optional, itâ€™s obligated return T2, which will construct &lt;T2&gt;\n\n\n&lt;T1, E1&gt;.or_else(T1) needs to return &lt;T1, E2&gt;\nFor std::optional, itâ€™s obligated return std::optional&lt;T1&gt;\n\n\n&lt;T1, E1&gt;.transform_error(E1) needs to return E2, which will construct &lt;T1, E2&gt; automatically\n\nauto process = [](std::string_view str){    std::print(\"str: {:?},\", str);    parse_number(str).transform([](double val)    {        std::println(\"value: {}\", val);        return val;    }).transform_error([](std::errc err)    {        if (err == std::errc::invalid_argument)            std::println(\"error: invalid input\");        else if (err == std::errc::result_out_of_range)            std::println(\"error: overflow\");        return err;    });}for (auto src : {\"42\", \"32abc\", \"meow\", \"inf\" })    process(src);\n\nException\nException is a technique that will automatically propagate to the caller if itâ€™s omitted å¼‚å¸¸å¯ä»¥å°†è°ƒç”¨è€…å¿½ç•¥çš„é”™è¯¯è‡ªåŠ¨åœ°ä¼ é€’ç»™æ›´ä¸Šå±‚çš„è°ƒç”¨è€…\nFor example, function chain A -&gt; B -&gt; C -&gt; D, if D throws an exception, and D doesnâ€™t catch it, then C needs to do so; if C doesnâ€™t, B needs to do so; etc.\n\n\ntry - catch block to catch an exception\n\ntry{    Test();}catch (const std::out_of_range&amp; error){    std::cout &lt;&lt; \"Encountering error:\";    std::cout &lt;&lt; error.what() &lt;&lt; \"\\n\";}catch (const std::invalid_argument&amp; error){    // ...}catch (...) {/* ... */}\n\n\n.what() is a virtual method of std::exception\n\n\nNote\nYou only need to catch exception when this method can handle it\nThough you can throw any type, itâ€™s recommended to throw a type inherited from std::exception\nReason: base class can also match derived class exception to catch it, so you can always catch(const std::exception&amp;) and print .what() to know information\n\n\nCatch block is matched one by one catch å—æ˜¯çº¿æ€§çš„è¿›è¡Œçš„\nThough itâ€™s allowed to catch with or without const/&amp;, exception should definitely be caught by const Type&amp;\nIf youâ€™re in a catch block and find that the caught exception still cannot be handled, you can use a single throw; to throw this exception again ä¸èƒ½å¤„ç†å¼‚å¸¸å¯ä»¥ç»§ç»­å¾€ä¸ŠæŠ›å‡ºï¼Œæœ€å¥½ä¸æŠ›å‡ºå¼‚å¸¸å¯¹è±¡\nIf another exception is thrown during internal exception handling (e.g. dtor throw an exception during stack unwinding), std::terminate will also be called åœ¨å¤„ç†å¼‚å¸¸çš„æ—¶å€™ç”±å‡ºç°äº†å¼‚å¸¸ä¼šç›´æ¥ç»ˆç»“ï¼Œä¸å¯èƒ½åœ¨å¼‚å¸¸ä¸­å†é‡æ–°æŠ›å‡ºå¼‚å¸¸äº†\n\n\n\nException Safety\nException safety means that when an exception is thrown and caught, program is still in a valid state and can correctly run å½“å¼‚å¸¸è¢«æŠ›å‡ºå¹¶ä¸”è¢«æ•è·åï¼Œç¨‹åºä¾ç„¶å¤„äºæœ‰æ•ˆçŠ¶æ€å¹¶ä¸”æ­£ç¡®è¿è¡Œ\n\nNo guarantee æ²¡æœ‰å¼‚å¸¸å®‰å…¨æ€§\n\nèµ„æºæˆ–å†…å­˜æ³„æ¼\nä¸å˜é‡è¢«ç ´å\nå†…å­˜å‘ç”Ÿäº†æŸæ¯ï¼Œä¸€ç‰‡å†…å­˜å†™äº†ä¸€éƒ¨åˆ†å°±å‘ç”Ÿäº†æŸåå¹¶é€€å‡ºäº†ç¨‹åº\n\n\nBasic guarantee: at least program can run normally, no resources leak, invariants are maintained, etc\n\nRAII is a really important technique for basic guarantee\n\nè§£å†³æ–¹æ¡ˆæ˜¯ä½¿ç”¨ææ„å‡½æ•° use destructor\n\nRAII (Resource acquirement is initialization): acquire resources in ctor and release them in dtor åœ¨æ„é€ å‡½æ•°é‡Œç”³è¯·èµ„æºï¼Œåœ¨ææ„å‡½æ•°é‡Œé‡Šæ”¾èµ„æºï¼Œè¿™å°±æ˜¯ RAII\n\nstd::unique_ptr to manage heap memory instead of new/delete\nstd::lock_guard to manage mutex instead of lock/unlock\nstd::fstream to manage file instead of FILE* fopen/fclose\nè‡ªå·±ç¼–å†™çš„ç±»ä¹Ÿè¦ç¬¦åˆ RAII çš„åŸåˆ™\n\n\nTo sum up, all members that have been fully constructed will be destruct, but dtor of itself wonâ€™t be called åªæœ‰åœ¨æ„é€ å‡½æ•°ä¸­å®Œå…¨åˆå§‹åŒ–ï¼ˆæ²¡æœ‰å¼‚å¸¸ï¼‰ææ„å‡½æ•°æ‰ä¼šæ‰§è¡Œ\nMyData(int id) : ptr1{nullptr }, someData{nullptr } {    auto init_ptr1 = std::unique_ptr&lt;int&gt;{new int {id} };    auto init_someData = std::unique_ptr&lt;int&gt;{new int {id} };    // will never throw below    ptr1 = init_ptr1.release(); // release ownership, so dtor of    someData = init_someData.release(); // unique_ptr does nothing}~MyData() { delete ptr1; delete someData; }\n\n\næŒ‡é’ˆæŠ›å‡ºçš„å¼‚å¸¸æ˜¯std::bad_alloc\nnew(std::nothrow) will return nullptr instead of throwing exception. e.g. new(std::throw) int{id} ä½†æ˜¯ä»ç„¶éœ€è¦åˆ¤æ–­nullptr\n\n\n\n\nStrong exception guarantee å¼ºå¼‚å¸¸ä¿è¯ï¼Œå½“å‡½æ•°æŠ›å‡ºå¼‚å¸¸åï¼Œç¨‹åºèƒ½å¤Ÿå›æ»šåˆ°åŸæ¥çš„çŠ¶æ€\n\nMost of methods in STL obey strong exception guarantee\n\nstd::vector::push_back(), std::vector has same elements as before even if exception is thrown å½“æ’å…¥å…ƒç´ å¤±è´¥çš„æ—¶å€™ï¼ŒåŸæ¥ vector ä¸­çš„å…ƒç´ è¿˜å­˜åœ¨\n\n\nA technique to maintain strong exception guarantee in assignment operator is copy-and-swap idiom æ‹·è´äº¤æ¢æƒ¯ç”¨æ³•\ntemplate&lt;typename T&gt;class Vector{public:    Vector(std::size_t num, const T&amp; val)    {        std::unique_ptr&lt;T[]&gt; arr{ new T[num] };        std::ranges::fill(arr.get(), arr.get() + num, val);        first_ = arr.release();        last_ = end_ = first_ + num;    }    std::size_t size() const noexcept {return last_ - first_; }    auto&amp; operator[](std::size_t idx) noexcept {return first_[idx]; }    const auto&amp; operator[](std::size_t idx) const noexcept {return first_[idx]; }    Vector(const Vector&amp; another)    {        auto size = another.size();        std::unique_ptr&lt;T[]&gt; arr{ new T[size] };        std::ranges::copy(another.first_, another.last_, arr.get());        first_ = arr.release();        last_ = end_ = first_ + size;    }private:    T* first_, *last_, *end_;};\n\nå¦‚ä½•å®ç°operator=\nVector&amp; operator=(const Vector&amp; another){    delete[] first_; // åªæ˜¯æ”¾æŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å­˜    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    first_ = arr.release();    std::ranges::copy(another.first_, another.last_, first_);    last_ = end_ = first_ + size;    return *this;}\n\nå¦‚æœ new æŠ›å‡ºå¼‚å¸¸ï¼Œå°½ç®¡å†…å­˜å·²ç»é‡Šæ”¾æ‰äº†ï¼Œä½†æ˜¯ first_ å’Œend_ä»ç„¶ä¸å˜ï¼Œæ‰€ä»¥ .size() ä¾ç„¶ä¸å˜\nVector&amp; operator=(const Vector&amp; another){    delete[] first_;    first_ = last_ = end_ = nullptr; // å°†æŒ‡é’ˆä¹Ÿé‡Šæ”¾æ‰    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    first_ = arr.release();    std::ranges::copy(another.first_, another.last_, first_);    last_ = end_ = first_ + size;    return *this;}\n\nå¦‚æœ std::ranges::copy å‡ºç°äº†å¼‚å¸¸ï¼Œé‚£ä¹ˆ first_ ï¼Œlast_ï¼Œend_ çŠ¶æ€åˆæ˜¯ä¸ä¸€è‡´çš„ï¼Œfirst_` è¢«å…ˆèµ‹å€¼çš„\nVector&amp; operator=(const Vector&amp; another){    delete[] first_;    first_ = last_ = end_ = nullptr; // å°†æŒ‡é’ˆä¹Ÿé‡Šæ”¾æ‰    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    std::ranges::copy(another.first_, another.last_, first_);    // only release when all exceptions are possibly thrown!    first_ = arr.release();    last_ = end_ = first_ + size;    return *this;}\n\næ»¡è¶³äº†åŸºæœ¬å¼‚å¸¸å®‰å…¨çš„ä¿è¯ï¼Œä½†æ˜¯ä¸æ»¡è¶³å¼ºå¼‚å¸¸å®‰å…¨æ€§çš„ä¿è¯ï¼Œå¿…é¡»ä¿è¯é‡Šæ”¾èµ„æºæ˜¯åœ¨æ‰€æœ‰å¯èƒ½æŠ›å‡ºå¼‚å¸¸è¯­å¥çš„åé¢\nVector&amp; operator=(const Vector&amp; another){    auto size = another.size();    std::unique_ptr&lt;T[]&gt; arr{ new T[size] };    std::ranges::copy(another.first_, another.last_, first_);    delete[] first_;    first_ = arr.release();    last_ = end_ = first_ + size;    return *this;}\n\né™¤äº† delete[] å…¶ä»–çš„å’Œæ„é€ å‡½æ•°å‡ ä¹ä¸€æ ·ï¼Œå¯ä»¥æ¢ä¸€ç§æ–¹å¼å®ç°\nfriend void swap(Vector&amp; vec1, Vector&amp; vec2) noexcept{    std::range::swap(vec1.first_, vec2.first_);    std::range::swap(vec1.last_, vec2.last_);    std::range::swap(vec1.end_, vec2.end_);}Vector&amp; operator=(const Vector&amp; another){    Vector vec{another};    swap(vec, *this);    return *this;}\n\n\nAllocating memory before releasing, which increases peak memory\nSwap cost it slightly higher than direct assignment\nMay be not optimal for performance\n\n\nException safety of containers\n\nAll read-only &amp; .swap() donâ€™t throw at all æ‰€æœ‰åªè¯»æ–¹æ³•å’Œ .swap() éƒ½ä¸æŠ›å‡ºå¼‚å¸¸ï¼Œé™¤äº†æ•…æ„æŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°\nFor std::vector, .push_back(), emplace_back(), or .insert/emplace/insert_range/append_range() only one element at back provide strong exception guarantee\nFor std::list/forward_list, all strong exception guarantee å› ä¸ºå†…å­˜ä¸æ˜¯è¿ç»­çš„ï¼Œæ‰€æœ‰çš„æ–¹æ³•éƒ½ä¼šä¿è¯å¼ºå¼‚å¸¸å®‰å…¨æ€§\nFor std::deque, itâ€™s similar to std::vector, adding push at front\nFor associative containers, .insert/... a node only a single element has strong exception guarantee\n\n\n\n\nStrongest exception safety æœ€å¼ºå¼‚å¸¸å®‰å…¨æ€§ï¼šä¸€ä¸ªæ–¹æ³•æ°¸è¿œéƒ½ä¸ä¼šæŠ›å‡ºå¼‚å¸¸å¯ä»¥åŠ ä¸Š noexcept æ ‡è¯†ç¬¦\n\nIf your function is labeled as noexcept but it throws exception, then std::terminate will be called\nnoexcept is also an operator ä¹Ÿæ˜¯ä¸€ä¸ªè¿ç®—ç¬¦ï¼Œç”¨ evaluate å‡½æ•°æ˜¯å¦æ ‡è®°äº† noexcept æ ‡è¯†ç¬¦\nIMPORT: destructor &amp; deallocation is always assumed to be noexcept by standard library æ ‡å‡†åº“æ°¸è¿œå‡è®¾ææ„å‡½æ•°å’Œé‡Šæ”¾è¡Œä¸ºä¸ä¼šæŠ›å‡ºå¼‚å¸¸\nDtor is the only function by default noexcept without any explicit specifier if all dtors of members are noexcept\nç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆçš„æ„é€ å‡½æ•°æˆ–èµ‹å€¼å‡½æ•°ä¹Ÿæ˜¯noexcept\n\n\nSince C++ 17, noexcept function pointer is also supported C++ 17 æ”¯æŒäº†å‡½æ•°æŒ‡é’ˆç”¨ noexcept æ ‡è¯† e.g. using Ptr = void(*)(int) noexcept; Ptr ptr = square; ä¸èƒ½æŒ‡å‘å¯ä»¥æŠ›å‡ºå¼‚å¸¸çš„å‡½æ•°\nGeneral rule: for normal methods, only when the operation obviously doesnâ€™t throw should you add noexcept\nMerely read-only methods in containers (like .size()) are marked as noexcept\n\n\n\n\n\n\n\nWhen to use exception\nException is relatively costly compared with other error handling mechanisms, like it relies on heap allocation ç›¸å¯¹äºå…¶ä»–é”™è¯¯å¤„ç†æœºåˆ¶ä»£ä»·æ›´é«˜ï¼Œéœ€è¦ä¿è¯æŠ›å‡ºå¼‚å¸¸å‘ç”Ÿæƒ…å†µæ˜¯æå°‘æ•°çš„æƒ…å†µï¼›åªæœ‰åœ¨æŠ›å‡ºå’Œæ•è·çš„æ—¶å€™æ‰æœ‰å¼€é”€\nBesides, in current typical implementations, stack unwinding of exception needs a global lock, which is really unfriendly to multi-threading programs å¯¹å¤šçº¿ç¨‹ä¸å‹å¥½\nAlso, exception is highly dependent on platform (just like RTTI)\n\nAssertionAssertion is a technique to check expected behaviors of functions or code segments when debugging\n\nWhen the parameter is evaluated to false, program will be aborted\nstd::abort() is the default behavior of std::terminate(), but latter can change its behavior by std::set_terminate_handler(...)\nItâ€™s a macro defined in &lt;cassert&gt;\n\n\nassertç”¨ä½œæ²¡æœ‰å‰¯ä½œç”¨è¡Œä¸ºçš„æ¡ä»¶æ£€æŸ¥\nassert is done in runtime; if you want to determine in compile time, you can use keyword static_asset(xx, msg), msg can be omitted since C++ 17\né€šå¸¸ç”¨äºå†…éƒ¨çš„æ–¹æ³•ï¼Œæ£€æŸ¥å·²åº”è¿‡æ»¤æ‰ï¼Œä½†æ˜¯ä»ç„¶ä¼šå‡ºç°çš„éæ³•çš„æƒ…å†µï¼Œç”¨äºåœ¨ debug ä¸­å®šä½é—®é¢˜\nAssertion åœ¨å®‰å…¨æ£€æŸ¥æ–¹é¢æ˜¯éå¸¸æœ‰é™çš„\nContract C++ 26 is likely to add contract, which will enrich it a lot\n\nDebug Helpers\nSource Location\n\nBefore C++ 20, we may use maros __FILE__ and __LINE__, which will be substituted to source file name and line number\nstatic void CheckError(cudaError_t error, const char* file, int line){    if (error == cudaSuccess)        return;    std::cerr &lt;&lt; \"Cuda Error at file\" &lt;&lt; file &lt;&lt; \"line :\" line &lt;&lt; \":\" &lt;&lt; cudaGetErrorString(error);    exit(EXIT_FAILURE);}#define CHECK_ERROR(error) (CheckError((error), __FILE__, __LINE__))\n\n__FILE__å’Œ __LINE__ æ˜¯ä¸èƒ½ç”¨åœ¨ CheckError çš„é»˜è®¤å‚æ•°ä¸­çš„ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå®æ˜¯åœ¨é¢„å¤„ç†çš„æ—¶å€™ç¡®å®šçš„ï¼Œè€Œä¸æ˜¯åœ¨è°ƒç”¨çš„æ—¶å€™ç¡®å®šçš„\n\nSince C++ 20, &lt;source_location&gt; is added to solve it\n\nvoid logError(std::string_view errorInfo, std::ostream&amp; logFile = std::cerr, const std::source_location&amp; location =  std::source_location::current());\n\nvoid logError(std::string_view errorInfo, std::ostream &amp;logFile = std::cerr, const std::source_location &amp;location = std::source_location::current()){    logFile &lt;&lt; std::format(\"In file {} function {} - line {}, Error :\\n{}\\n\",        location.file_name(), location.function_name(), location.line(), errorInfo);    return;}\n\n\nstacktrace\n\nSince C++ 23, in &lt;stacktrace&gt;\nSimilar to source_location, you need std::stacktrace::current to get it; but you may print it directly\n\n\ndebugging, Since C++ 26, in &lt;debugging&gt;\n\n\nUnit TestCatch2A C++ unit test framework - Catch2\n\nCatch2 uses macro, so still remember to add paratheses for comma\nCatch2 overloads operator&amp;&amp; and operator||, so using them wonâ€™t be short-circuit\nThus, you may need to split it to multiple REQUIRE\n\n\nSECTION can be generated dynamically; you just need to ensure they have different names\n\nString and String View\nå¸¸é‡å­—ç¬¦ä¸²ç±»å‹ const char[] èµ‹å€¼ç»™ auto ç±»å‹ä¼šé€€åŒ–ä¸º const char*ï¼ŒC++ ä¸­ä¸èƒ½å°†const char[] èµ‹å€¼ç»™char*ï¼Œé™¤éä½¿ç”¨const_cast\nå¯ä»¥ä½¿ç”¨ç©ºæ ¼æˆ–æ¢è¡Œæ¥è¿æ¥ä¸¤ä¸ªå­—ç¬¦ä¸²å¸¸é‡ e.g. \"123\" \"456\"å’Œ \"123456\" ä¸€æ ·ï¼Œç¼–è¯‘å™¨ç¼–è¯‘çš„æ—¶å€™ä¼šè¿›è¡Œæ‹¼æ¥\nRaw strings: ä»»æ„å­—ç¬¦éƒ½ä¸ä¼šè¢«è½¬ä¹‰ escaped\n\\\\\\n\\\"åœ¨æ™®é€šå­—ç¬¦ä¸²è§£é‡Šä¸º \\\\n\"ï¼Œä½†æ˜¯ç”¨è£¸å­—ç¬¦ä¸²è¡¨ç¤ºR\"(\\\\\\n\\\")\" å°±æ˜¯ 6 ä¸ªå­—ç¬¦\nä¾‹å¦‚ Windows ç³»ç»Ÿä¸­çš„æ–‡ä»¶è·¯å¾„\nè£¸å­—ç¬¦è§£æä¸»è¦æ˜¯é€šè¿‡åŒ¹é… \"( å’Œ')\"'ï¼Œä½†æ˜¯å¯ä»¥åœ¨ \" å’Œ(æˆ– ) ä¹‹é—´åŠ å…¥ä»»æ„å…¶ä»–é€šé…ç¬¦é…åˆå°†ä¸­é—´çš„å­—ç¬¦éƒ¨åˆ†è§£æä¸ºè£¸å­—ç¬¦ä¸² e.g. R\"+(I want a)\"!)+\"\n\n\n\nString\nstd::stringæ˜¯ std::vector&lt;char&gt; çš„åŠ å¼ºç‰ˆ\nå¾ˆå¤šæ–¹æ³•å’Œ std::vector ä¸€æ¨¡ä¸€æ ·\næä¾›äº† .length() å‡½æ•°ï¼Œå’Œ .size() ä¸€æ ·ï¼Œåªæ˜¯ length æ˜¯æ›´å¸¸è§å‘½åä¹ æƒ¯\n.append, .append_rangeå’Œ insert(str.end(), ...) ä¸€æ ·ï¼Œä½†æ˜¯ä¸èƒ½æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿”å›å€¼æ˜¯å¯¹ string çš„å¼•ç”¨\n.assign, .insert, .erase, .appendéƒ½æä¾›äº†ä¸‹æ ‡çš„ç‰ˆæœ¬\n.starts_with, ends_with (C++ 20); contains (C++ 23)\n.substr(index(, count)): ä» index å¼€å§‹åˆ° count ç»“æŸï¼Œcounté»˜è®¤æ˜¯std::string::nposï¼Œä¼šåˆ›å»ºæ–°çš„å¯¹è±¡\n.replace: replace part of the string with a new string same as sub-string\n.data(), .c_str(): get the underlying pointer\nC++ 17 ä¹‹å .data() è¿”å›çš„æ˜¯char*ï¼Œè€Œä¸æ˜¯const char*\n.c_str()è¿”å›çš„æ˜¯const char *\n\n\nSearch\nå¦‚æœæ‰¾ä¸åˆ°åˆ™è¿”å› std::string::nposï¼Œä¹Ÿå°±æ˜¯static_cast&lt;size_t&gt;(-1) ä¸€ä¸ªå¾ˆå¤§çš„æ•°\n.find(),rfind(): æ­£å‘æŸ¥æ‰¾æˆ–é€†å‘æŸ¥æ‰¾\nfind_first_of(), find_first_not_of(), find_last_of(), find_last_not_of()\n\n\nNotes\nfind()æ—¶ï¼Œä½¿ç”¨ä¸ç­‰å·æ¥åˆ¤æ–­æ˜¯å¦æ‰¾åˆ°ï¼Œè€Œä¸æ˜¯ç”¨&gt;, &gt;=, &lt;, &lt;=\nstd::string guarantees the underlying string is null-terminated\nstd::stringå¯ä»¥å­˜å‚¨'\\0'\n\n\nstd::string has SSO (small string optimization) æ®µå­—ç¬¦ä¸²ä¼˜åŒ–\nå½“ string éå¸¸å°çš„æ—¶å€™å¯ä»¥æ”¾åˆ°æ ˆä¸Šè€Œä¸æ˜¯æ”¾åˆ°å †ä¸Šï¼Œé™ä½å†…å­˜åˆ†é…\nå…·ä½“ string åœ¨æ ˆä¸Šå¯ä»¥å®¹çº³å¤šå°‘å­—ç¬¦æ˜¯ç”±æ ‡å‡†åº“å®ç°çš„ï¼›åœ¨ x64 libstdc++/VC ä¸Šæ˜¯ 15ï¼Œåœ¨ libc++ ä¸Šæ˜¯ 22\n\n\nC++ 23 introduces another optimization for resizing\nResize é€šå¸¸éœ€è¦ç”¨å›ºå®šçš„å­—ç¬¦ï¼ˆä¾‹å¦‚ '\\0'ï¼‰å»å¡«å……ï¼Œé€šå¸¸éœ€è¦reserve å’Œinsertä¸¤ä¸ªæ­¥éª¤ï¼Œæ€§èƒ½ä¸Šä¼šæœ‰æŸè€—\n.resize_and_overwrite(newSize, Op)æ„ä¹‰æ›´æ˜ç¡®ï¼Œå¹¶ä¸”æ˜¯è¦†ç›–\n\n\nå’Œæ•°å­—è¿›è¡Œç›¸äº’è½¬æ¢\nstd::stoi/sto(u)l/sto(u)ll(string, std::size_t* end = nullptr, int base = 10)\nIt will stop at the end of the first parsed number, and try to write the stop index to *end åœ¨ç»“æŸä¹‹å‰è§£æå¥½ï¼Œè§£æå¤±è´¥ä¼šæŠ›å‡ºå¼‚å¸¸std::invalid_argument\n\n\nBaseï¼ˆè¿›åˆ¶ï¼‰ can be 2 - 36 æŒ‰ç…§å­—æ¯è¡¨çš„é¡ºåºæ·»åŠ ï¼›base=0æ—¶ä¼šæ ¹æ®å­—ç¬¦ä¸²å‰ç¼€è‡ªåŠ¨è§£æè¿›åˆ¶å¤§å°\nå‰ç¼€æ—¶ 0 æ˜¯å…«è¿›åˆ¶\nå‰ç¼€æ˜¯ 0x æ˜¯åå…­è¿›åˆ¶\n\n\nstd::stof/stod/stold(string, std::size_t* end = nullptr)\nstd::to_string()\n\n\n\n\n\nString Viewå¦‚æœåœ¨å‡½æ•°ä¸­ä»…ä»…æ˜¯è¯»å–ä¸€ä¸ª stringï¼Œå°±ä¼šç”¨ const std::string&amp; ä½œä¸ºå‚æ•°ï¼Œå¦‚æœä¼ å…¥çš„æ˜¯ C-string ç±»å‹ï¼Œå°±ä¼šæ„é€ ä¸€ä¸ªä¸´æ—¶çš„ string å¯¹è±¡ï¼Œè¿™ç§æƒ…å†µå¯ä»¥ä½¿ç”¨std::string_viewï¼ˆC++ 17ï¼‰ã€‚å¯ä»¥ç†è§£ä¸ºæœ¬èº«å°±å­˜å‚¨äº†ä¸€ä¸ªconst char*\n\n.substrè¿”å›çš„ä»ç„¶æ˜¯ std::string_view è€Œä¸æ˜¯std::string\nä¸æ”¯æŒoperator+\nstd::string_view is not required to be null-terminated éƒ½æ˜¯é€šè¿‡ length è¯†åˆ«é•¿åº¦çš„\nThe pointer it contains can be nullptr\nC++ 23 å¼€å§‹ä¸èƒ½ä½¿ç”¨ nullptr è¿›è¡Œæ„é€ \n\n\nå½“ std::string_view åšä¸ºè¿”å›å€¼æ—¶ï¼Œæ³¨æ„æŒ‡é’ˆæ‚¬å‚çš„é—®é¢˜\nè¿”å› std::string æ˜¯å®‰å…¨çš„\n\n\nä½œä¸ºæ¨¡æ¿å‚æ•°æ—¶ä¹Ÿè¦æ³¨æ„å£°æ˜å‘¨æœŸ\n\nUser-defined literals ç”¨æˆ·å®šä¹‰è‡ªå˜é‡\nç±»ä¼¼æ•°å€¼ç±»å‹ 1ull è¡¨ç¤ºæ•°å­— 1 æ˜¯unsigned long long ç±»å‹çš„ï¼Œå­—ç¬¦ä¸²å¯¹è±¡ä¹Ÿå¯ä»¥ä½¿ç”¨ç”¨æˆ·è‡ªå®šä¹‰å˜é‡\nstd::string: \"PKU\"s\nstd::string_view: \"PKU\"sv\n1s for seconds, 1.1ms for milliseconds, 1d for a day\n1i for pure imaginary number å¤æ•°ï¼Œ1.2if, 2.5id\nRemember using namespace std::literals; in your local scope\nä¹Ÿå¯ä»¥è‡ªå·±å®šä¹‰ç”¨æˆ·å®šä¹‰è‡ªå˜é‡\nconstexpr unsigned int operator\"\" _KB(unsigned long long m) {return static_cast&lt;unsigned int&gt;(m) * 1024; }\nThe parameter type is limited å‚æ•°ç±»å‹çš„é™åˆ¶\nå¯¹æ•´æ•°æ¥è¯´åªæ”¯æŒunsigned long longï¼Œæœ€å¤§çš„æ•´æ•°ç±»å‹\nå¯¹æµ®ç‚¹æ•°åªæ”¯æŒlong double\nå¯¹å­—ç¬¦char\nå¯¹ C-stringsconst CHAR*, std::size_t\næœ€åå…œåº•ï¼ˆfallbackï¼‰ç±»å‹æ˜¯const char*\n\n\n\n\n\ncharconv\nstd::from_chars(const char* begin, const char* end, val) will try to save the result into val å¿…é¡»ä»¥æ•°å­—å¼€å¤´\nbase/std::chars_format è¿›åˆ¶æˆ–æ ¼å¼\n\n\nstd::to_chars(const char* begin, const char* end, val) will try to write val (an integer or a floating point) into [begin, end)\nbase/std::chars_format\n\n\n\n","categories":["C++"],"tags":["C++","ç°ä»£ C++"]},{"title":"å“ˆå¸Œè¡¨","url":"/2021/11/08/6/","content":"å“ˆå¸Œè¡¨  å“ˆå¸Œè¡¨ï¼Œä¹Ÿå«æ•£åˆ—è¡¨ï¼Œå®ƒæ˜¯åŸºäºå¿«é€Ÿå­˜å–çš„è§’åº¦è®¾è®¡çš„ï¼Œæ˜¯ä¸€ç§å…¸å‹çš„â€œç©ºé—´æ¢æ—¶é—´â€çš„åšæ³•ã€‚å®ƒå¯ä»¥æä¾›å¿«é€Ÿåœ°æ’å…¥å’ŒæŸ¥æ‰¾æ“ä½œã€‚\nå“ˆå¸Œè¡¨å‡½æ•°çš„æ„é€ æ–¹æ³•  ç›´æ¥å®šå€æ³• ï¼ˆã€ ä¸ºå¸¸æ•°ï¼‰ï¼Œå³å–å…³é”®ç çš„æŸä¸ªçº¿æ€§å‡½æ•°å€¼ä¸ºå“ˆå¸Œåœ°å€ï¼Œä¸ä¼šäº§ç”Ÿå†²çªï¼Œä½†è¦æ±‚åœ°å€é›†åˆä¸å…³é”®ç é›†åˆå¤§å°ç›¸åŒã€‚å› æ­¤ï¼Œå¯¹äºè¾ƒå¤§çš„å…³é”®ç é›†åˆä¸é€‚ç”¨ã€‚\né™¤ç•™ä½™æ•°æ³• ï¼ˆ æ˜¯ä¸€ä¸ªæ•´æ•°ï¼‰ï¼Œå³å–å…³é”®ç é™¤ä»¥  çš„ä½™æ•°ä½œä¸ºå“ˆå¸Œåœ°å€ã€‚ä½¿ç”¨é™¤ç•™ä½™æ•°æ³•ï¼Œé€‰å–åˆé€‚çš„  å¾ˆé‡è¦ï¼Œè‹¥å“ˆå¸Œè¡¨è¡¨é•¿ä¸º ï¼Œåˆ™è¦æ±‚ï¼Œä¸”æ¥è¿‘ æˆ–ç­‰äº ã€‚ ä¸€èˆ¬é€‰å–è´¨æ•°ï¼Œä¹Ÿå¯ä»¥æ˜¯ä¸åŒ…å«å°äº 20 è´¨å› å­çš„åˆæ•°ã€‚\næ•°å­—åˆ†ææ³•  è®¾å…³é”®ç é›†åˆä¸­ï¼Œæ¯ä¸ªå…³é”®ç å‡ç”±  ä½ç»„æˆï¼Œæ¯ä½ä¸Šå¯èƒ½æœ‰  ç§ä¸åŒçš„ç¬¦å·ã€‚\nå¹³æ–¹å–ä¸­æ³•  å¯¹å…³é”®ç å¹³æ–¹åï¼ŒæŒ‰å“ˆå¸Œè¡¨å¤§å°ï¼Œå–ä¸­é—´çš„è‹¥å¹²ä½ä½œä¸ºå“ˆå¸Œåœ°å€ã€‚\nå¤„ç†å†²çªçš„æ–¹æ³•  å¼€æ”¾å¯»å€æ³•  ï¼Œå…¶ä¸­ ä¸ºæ•£åˆ—å‡½æ•°ï¼Œä¸ºæ•£åˆ—è¡¨é•¿ï¼Œä¸ºå¢é‡åºåˆ—ï¼Œå¯æœ‰ä»¥ä¸‹ä¸‰ç§å»æ³•ï¼š\n\nï¼Œç§°çº¿æ€§æ¢æµ‹å†æ•£åˆ—ï¼›\nç§°äºŒæ¬¡æ¢æµ‹å†æ•£åˆ—ï¼›\nä¼ªéšæœºæ•°åºåˆ—ï¼Œç§°ä¼ªéšæœºæ¢æµ‹å†æ•£åˆ—ã€‚\n\nå†æ•£åˆ—æ³• ï¼Œ æ˜¯ä¸åŒçš„æ•£åˆ—å‡½æ•°ï¼Œå³åœ¨åŒä¹‰è¯äº§ç”Ÿåœ°å€å†²çªæ—¶è®¡ç®—å¦ä¸€ä¸ªæ•£åˆ—å‡½æ•°åœ°å€ï¼Œç›´åˆ°å†²çªä¸å†å‘ç”Ÿï¼Œè¿™ç§æ–¹æ³•ä¸æ˜“äº§ç”Ÿâ€œèšé›†â€ï¼Œä½†å¢åŠ äº†è®¡ç®—æ—¶é—´ã€‚\né“¾åœ°å€æ³•ï¼ˆæ‹‰é“¾æ³•ï¼‰å½“å­˜å‚¨ç»“æ„æ˜¯é“¾è¡¨æ—¶ï¼Œå¤šé‡‡ç”¨æ‹‰é“¾æ³•ã€‚ç”¨æ‹‰é“¾æ³•å¤„ç†å†²çªçš„åŠæ³•æ˜¯ï¼šæŠŠå…·æœ‰ç›¸åŒæ•£åˆ—åœ°å€çš„å…³é”®å­—ï¼ˆåŒä¹‰è¯ï¼‰å€¼æ”¾åœ¨åŒä¸€é“¾è¡¨ä¸­ï¼Œç§°ä¸ºç”¨ä¸€æ¬¡é“¾è¡¨ã€‚æœ‰  ä¸ªæ•£åˆ—åœ°å€å°±æœ‰  ä¸ªé“¾è¡¨ï¼ŒåŒæ—¶ç”¨æŒ‡é’ˆæ•°ç»„ T[0...m - 1] å­˜æ”¾å„ä¸ªé“¾è¡¨çš„å¤´æŒ‡é’ˆï¼Œå‡¡äº‹æ•£åˆ—åœ°å€ä¸º  çš„è®°å½•éƒ½ä»¥ç»“ç‚¹æ–¹å¼æ’å…¥åˆ°ä»¥ T[i] ä¸ºæŒ‡é’ˆçš„å•é“¾è¡¨ä¸­ã€‚\nå»ºç«‹ä¸€ä¸ªå…¬å…±æº¢å‡ºåŒº  è®¾å“ˆå¸Œå‡½æ•°äº§ç”Ÿçš„å“ˆå¸Œåœ°å€é›†ä¸ºï¼Œåˆ™åˆ†é…ä¸¤ä¸ªè¡¨ï¼šä¸€ä¸ªåŸºæœ¬è¡¨ElemType baseTbl[m]ï¼›æ¯ä¸ªå•å…ƒåªèƒ½æ”¾ä¸€ä¸ªå…ƒç´ ï¼›ä¸€ä¸ªæº¢å‡ºè¡¨ElemType overTbl[k]ï¼›åªè¦å…³é”®ç å¯¹åº”çš„å“ˆå¸Œåœ°å€åœ¨åŸºæœ¬è¡¨ä¸Šäº§ç”Ÿå†²çªï¼Œåˆ™æ‰€æœ‰è¿™æ ·çš„åŸè‰²ä¸€å¾‹å­˜å…¥è¯¥è¡¨ä¸­ã€‚\nå“ˆå¸Œè¡¨çš„æŸ¥æ‰¾\nç†æƒ³æƒ…å†µä¸‹æˆ‘ä»¬æ ¹æ®å…³é”®å­— key, é€šè¿‡é€ è¡¨æ—¶å€™çš„å“ˆå¸Œå‡½æ•°æ±‚å¾—å“ˆå¸Œåœ°å€ï¼Œè¯¥è¡¨æ­¤ä½ç½®ä¸Šçš„è®°å½•çš„å…³é”®å­—ä¸æˆ‘ä»¬ç»™å®šçš„å…³é”®å­— key ç›¸ç­‰ï¼Œåˆ™æŸ¥æ‰¾æˆåŠŸã€‚\nä½†æ˜¯å¦‚æœæœ‰å†²çªï¼Œå³è¯¥è¡¨æ­¤ä½ç½®ä¸Šçš„è®°å½•ä¸æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„è®°å½•ï¼Œåˆ™æ ¹æ®é€ è¡¨æ—¶å€™è®¾å®šçš„å†²çªå¤„ç†æ–¹æ³•å¯»æ‰¾â€œä¸‹ä¸€ä¸ªåœ°å€â€ï¼Œä¸€ç›´åˆ°å“ˆå¸Œè¡¨çš„æŸä¸€ä¸ªä½ç½®ä¸ºâ€œç©ºâ€æˆ–è€…è¡¨ä¸­è®°å½•çš„å…³é”®å­—ä¸ºæˆ‘ä»¬ç»™å®šçš„å…³é”®å­— keyã€‚\n\n","categories":["æ•°æ®ç»“æ„"],"tags":["æ•°æ®ç»“æ„","å“ˆå¸Œè¡¨"]},{"title":"OpenGL with Xmake","url":"/2024/06/20/58/","content":"\n    \n\n\n\n\nç›®å½•ç»“æ„|-- dependence    |-- glew-2.1.0    |-- glfw-3.4.bin.WIN32    |-- glfw-3.4.bin.WIN64        |-- include        |-- ...        |-- lib-static-ucrt            |-- glfw3.dll            |-- glfw3dll.dll|-- src    |-- HelloOpenGl.cpp|-- xmake.lua\n\nxmake é…ç½®set_project(&quot;OpenGL Tutorial&quot;)add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)target(&quot;HelloOpenGL&quot;)    set_kind(&quot;binary&quot;)    add_files(&quot;src/*.cpp&quot;)    add_includedirs(&quot;/dependence/glfw-3.4.bin.WIN64/include&quot;) -- include æ–‡ä»¶    add_includedirs(&quot;/dependence/glew-2.1.0/include&quot;)    add_linkdirs(&quot;/dependence/glfw-3.4.bin.WIN64/lib-static-ucrt&quot;) -- gcc ç¼–è¯‘çš„é™æ€é“¾æ¥åº“ç›®å½•    add_linkdirs(&quot;/dependence/glew-2.1.0/lib/Release/Win32&quot;)    add_linkdirs(&quot;/dependence/glew-2.1.0/bin/Release/x64&quot;)    add_links(&quot;glfw3dll&quot;, &quot;glew32&quot;) -- é“¾æ¥ glfw å’Œ glew    add_syslinks(&quot;opengl32&quot;) -- é“¾æ¥ç³»ç»Ÿåº“\n\nNotes\né¡¶ç‚¹ç€è‰²å™¨\næ¯ä¸ªé¡¶ç‚¹è¿è¡Œä¸€æ¬¡\nç¡®å®šä½ç½®\n\n\nç‰‡æ®µ / åƒç´ ç€è‰²å™¨\nå¡«å……ä¸‰è§’å½¢çš„æ¯ä¸ªåƒç´ è®¡ç®—ä¸€æ¬¡\n\n\nä¸ºä»€ä¹ˆç´¢å¼•ç¼“å†²æ˜¯ unsigned int æ— ç¬¦å·çš„\né”™è¯¯å¤„ç†\nglGetError\nå®å®šä¹‰\n\n\nuniform å˜é‡\nVAO vertex array object\nå½“ç©ºé—´ä¸­æœ‰å¤šä¸ªå¯¹è±¡ã€ç½‘æ ¼ã€é¡¶ç‚¹ç¼“å†²åŒºç­‰ï¼Œæ¯ä¸ªéƒ½è¦è¿›è¡Œç»‘å®šç€è‰²å™¨ã€ç»‘å®šé¡¶ç‚¹ç¼“å†²åŒº ã€ è®¾ç½®é¡¶ç‚¹å¸ƒå±€ ã€ ç»‘å®šç´¢å¼•ç¼“å†²åŒºã€è°ƒç”¨ DrawCall è¿›è¡Œç»˜åˆ¶\nç»‘å®šé¡¶ç‚¹ç¼“å†²åŒºä¹‹åè¿˜è¦å£°æ˜é¡¶ç‚¹ç¼“å†²åŒºçš„å¸ƒå±€ï¼Œä¸åŒçš„é¡¶ç‚¹ç¼“å†²åŒºæœ‰ä¸åŒçš„å¸ƒå±€\nå®é™…ä¸Šéƒ½æ˜¯å’Œ VAO æœ‰å…³ç³»\nVAO å®ƒå°†æ‰€æœ‰é¡¶ç‚¹ç»˜åˆ¶è¿‡ç¨‹ä¸­çš„è¿™äº›è®¾ç½®å’Œç»‘å®šè¿‡ç¨‹é›†ä¸­å­˜å‚¨åœ¨ä¸€èµ·\nVAO æ˜¯å¦ç”Ÿæ•ˆç”±é…ç½®æ–‡ä»¶ç±»å‹å†³å®šçš„ The compalibility profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all\nä»€ä¹ˆæ—¶å€™ä½¿ç”¨ VAO\nå¦‚æœä½¿ç”¨æ ¸å¿ƒé…ç½®ï¼Œå°±å¿…é¡»ä½¿ç”¨è‡ªå®šä¹‰çš„ VAO\nå¦‚æœåªä½¿ç”¨å…¼å®¹æ€§é…ç½®ï¼Œæœ‰ä¸€ä¸ªé»˜è®¤çš„ VAO\n\n\n\n\nç€è‰²å™¨å¤„ç†çš„æ­¥éª¤\nä¼ å…¥æ–‡ä»¶æˆ–è€…å­—ç¬¦ä¸²ï¼Œå¯ä»¥ç¼–è¯‘ä¸ºç€è‰²å™¨\nç»‘å®šå’Œè§£ç»‘ç€è‰²å™¨\nå¯ä»¥è®¾ç½®ç€è‰²å™¨ä¸­çš„ä¸åŒçš„uniform\n\n\næ¸²æŸ“å™¨ç±»\nè°ƒç”¨ Draw Call æ—¶éœ€è¦é¡¶ç‚¹æ•°ç»„ã€ç´¢å¼•ç¼“å†²åŒºã€ç€è‰²å™¨\nè§£ç»‘ä¸æ˜¯å¿…è¦çš„ï¼Œè§£ç»‘åªä¼šæµªè´¹æ€§èƒ½\næ­£å¸¸ä¼šç”¨æè´¨æ›¿æ¢ç€è‰²å™¨\n\n\nå¦‚ä½•é€šè¿‡ OpenGL å°†ç¡¬ç›˜ä¸­çš„ png å›¾ç‰‡æ˜¾ç¤ºåˆ°å±å¹•ä¸Šï¼ˆpng å¹¶ä¸æ˜¯å¼•æ“ç›´æ¥ä½¿ç”¨çš„æ ¼å¼ï¼Œå¤§å¤šæ•°å¼•æ“éƒ½æœ‰è‡ªå·±çš„çº¹ç†æ ¼å¼ï¼‰\nå°†å›¾åƒåŠ è½½åˆ°å†…å­˜ä¸­â€”â€”stb_image\nè·å–åƒç´ çš„æ•°ç»„ï¼Œç„¶åä¼ åˆ°æ˜¾å­˜ä¸­â€”â€”OpenGL\né€šè¿‡ç€è‰²å™¨æ¥è¯»å–çº¹ç†ï¼Œå¹¶è®¡ç®—å‡ºçœŸæ­£çš„åƒç´ å€¼â€”â€”åƒç´  / ç‰‡æ®µç€è‰²å™¨ï¼ˆç»‘å®šçº¹ç†ï¼‰\nåœ¨ OpenGL ä¸­ï¼Œç”¨ slots æ¥ç»‘å®šçº¹ç†ï¼Œå¯ä»¥ä¸€æ¬¡æ€§ç»‘å®šå¤šä¸ªçº¹ç†\nåœ¨ Windows ä¸Šæœ‰ 32 ä¸ª slots\nåœ¨ç§»åŠ¨è®¾å¤‡ï¼ŒAndroid æˆ– IOS ä¸Šå¯èƒ½ä¼šæœ‰ 8 ä¸ª slots\n\n\nOpenGL åŠ è½½çº¹ç†æ˜¯ä»å·¦ä¸‹è§’å¼€å§‹ï¼Œå³å·¦ä¸‹è§’çš„åæ ‡æ˜¯(0, 0)ï¼Œæ­£å¸¸åŠ è½½çš„å›¾ç‰‡æ˜¯ä»å·¦ä¸Šè§’å¼€å§‹éå†ï¼Œæ‰€ä»¥åŠ è½½å›¾ç‰‡åéœ€è¦å‚ç›´ç¿»è½¬\nçº¹ç†åæ ‡\næŒ‡å®šæ¯ä¸ªé¡¶ç‚¹å¯¹åº”çš„çº¹ç†æ˜¯ä»€ä¹ˆï¼Œæ ¹æ®é¡¶ç‚¹å¯¹åº”çš„  çº¹ç†åæ ‡  è¿›è¡Œé‡‡æ ·\nç‰‡æ®µç€è‰²å™¨ä¼šæ ¹æ®è¦æ¸²æŸ“çš„åƒç´ çš„ä½ç½®ï¼Œè¿›è¡Œæ’å€¼è®¡ç®—å…·ä½“çš„é¢œè‰²å€¼\n\n\n\n\næ··åˆ\nBlending determies how we combine our output color with what is already in our target buffer\nOutput: the color we output from our fragment shader ä»ç‰‡æ®µç€è‰²å™¨ä¸­è¾“å‡ºçš„é¢œè‰² SRC\nTarget buffer: the buffer our fragment shader is drawing to å·²ç»å­˜åœ¨çš„ç¼“å†²åŒºä¸Šçš„é¢œè‰² DEST\n\n\nå¦‚ä½•æ§åˆ¶æ··åˆ\nglEnableã€glDisable\nglBlendFunc(src, dest)\nsrc: how the src RGBA factor is computed (default is GL_ONE) é»˜è®¤æ˜¯ 1ï¼Œæ¯ä¸ªé€šé“éƒ½æ˜¯å•ç‹¬è®¡ç®—çš„\ndest: how the dest RGBA factor is computed (default is GL_ZERO) é»˜è®¤æ˜¯ 0ï¼Œä¹Ÿå°±æ˜¯è¯´ src ä¼šè¦†ç›–åˆ° dest ä¸Šé¢\n\n\nglBlendEquation(mode)\nmode: how we combine the src and dest colors\nDefault value is GL_FUNC_ADD\n\n\n\n\n\n\næŠ•å½±çŸ©é˜µ\næŠ•å½±å°±æ˜¯åœ¨å¤šç»´ç©ºé—´ä¸­ç¡®å®šåæ ‡ç³»\nå°†åœºæ™¯ä¸­ä¸‰ç»´ç©ºé—´ä¸­çš„åæ ‡è½¬æ¢åˆ° NDCï¼ˆNormalized Device Coordinatesï¼‰ï¼Œå³æ ‡å‡†ç©ºé—´\nåœ¨çª—å£ä¸­æ¸²æŸ“çš„å†…å®¹çš„åæ ‡èŒƒå›´å¿…é¡»ä»å·¦åˆ°å³åœ¨ [-1, 1] ä¹‹é—´ï¼Œä»ä¸Šåˆ°ä¸‹åœ¨ [-1, 1] ä¹‹é—´\næŠ•å½±çŸ©é˜µçš„ä½œç”¨å°±æ˜¯å†³å®šåæ ‡ç©ºé—´æ˜¯ä»€ä¹ˆæ ·çš„\næ— è®ºæ˜¯æ­£äº¤ï¼ˆOrthographicï¼‰å¤„ç†åçš„é¡¶ç‚¹ï¼Œè¿˜æ˜¯é€è§†ï¼ˆPerspectiveï¼‰å¤„ç†åçš„é¡¶ç‚¹ï¼Œæœ€ç»ˆéƒ½ä¼šæ˜ å°„åˆ°æ ‡å‡†ç©ºé—´ä¸­\n\n\n\n\nè§†å›¾çŸ©é˜µ ç›¸æœºçš„å˜æ¢ï¼ˆä½ç§»å’Œæ–¹å‘ï¼‰\næ¨¡å‹çŸ©é˜µ å¯¹è±¡çš„å˜æ¢ï¼ˆä½ç§»ã€æ—‹è½¬ã€ç¼©æ”¾ï¼ŒTRSï¼‰\nImGui\næµ‹è¯•æ¡†æ¶\nå£°æ˜å‘¨æœŸ\nå°è£… ImGui\n\n\n\n\næ‰¹æ¸²æŸ“\nåœ¨ä¸€æ¬¡ DrawCall ä¸­æ¸²æŸ“å¤šä¸ªå¯¹è±¡\n\n\n\n\n    \n\n\nçº¹ç†çš„æ‰¹æ¸²æŸ“\né¢œè‰²æ˜¯ uniform å˜é‡å¯ä»¥æ”¾åˆ°é¡¶ç‚¹ç¼“å†²ä¸­ï¼Œä½†æ˜¯ä¸èƒ½æŠŠçº¹ç†æ”¾åˆ°é¡¶ç‚¹ç¼“å†²åŒºä¸­\nä½†æ˜¯å¯ä»¥åƒé¢œè‰²ä¸€æ ·æä¾›çº¹ç†ç´¢å¼•ï¼Œè¿™ä¸ªç´¢å¼•åœ¨æ¸²æŸ“ Quad æ—¶ï¼Œä»é¡¶ç‚¹ç€è‰²å™¨ä¼ åˆ°ç‰‡æ®µç€è‰²å™¨\nç‰‡æ®µç€è‰²å™¨ç”¨ä½œçº¹ç†æ•°ç»„å’Œé‡‡æ ·æ•°ç»„è¿™äº› uniform çš„ç´¢å¼•\n\nC++ ä»£ç ä¸­å®šä¹‰\n// (x, y, x) è¡¨ç¤ºåæ ‡// (r, g, b, a) è¡¨ç¤ºé¢œè‰²// (u, v) è¡¨ç¤ºçº¹ç†// texture_index å°±æ˜¯ä¸Šé¢è¯´çš„çº¹ç†ç´¢å¼•ï¼Œå¯¹åº”çº¹ç†æ§½ä½float vertices[] = &#123;  x, y, z, r, g, b, a, u, v, texture_index_1,  ...  x, y, z, r, g, b, a, u, v, texture_index_2,&#125;\n\nShader ä¸­çš„å®šä¹‰\n// vertex.shaderlayout (location = 0) in vec3 position;layout (location = 1) in vec4 color;layout (location = 2) in vec2 texCoord;layout (location = 3) in float texIndex;...out vec4 _color;out vec2 _texCoord;out float _texIndex;// fragment.shaderlayout (location = 0) out vec4 color;uniform sampler2D textureSamplers[2];in vec4 _color;in vec2 _texCoord;in float _texIndex;void main()&#123;  int index = int(_texIndex);  color = texture(textureSamplers[index], _texCoord); // æ ¹æ®ç´¢å¼•è¿›è¡Œé‡‡æ ·&#125;\n\nå°†çº¹ç†å’Œæ§½ç»‘å®šï¼Œåˆ©ç”¨ uniform ä¼ é€’æ•°æ®åˆ° shader\nglBindTextureUnit(0, texture1);glBindTextureUnit(1, texture2);auto loc = glGetUniformLocation(shader-&gt;GetRenderId(), &quot;textureSamplers&quot;);int samplers[2] = &#123; 0, 1 &#125;;glUniform1iv(loc, 2, samplers);\n\nåŠ¨æ€é¡¶ç‚¹ç¼“å†²  é¢„å…ˆåˆ†é…å¥½æœ€å¤§çš„é¡¶ç‚¹ç¼“å†²åŒºçš„å¤§å°ï¼ˆæ¯”å¦‚ 1KBï¼‰\n\nå°†é¡¶ç‚¹æ•°ç»„ç”¨ç»“æ„åŒ–çš„æ–¹å¼è¡¨ç¤º\n\nstruct Vertex&#123;  float Position[3];  float Color[4];  float TexCoords[2];  float TexId;&#125;\n\n\nç»‘å®šç¼“å†²æ•°æ®æ—¶ä½¿ç”¨ GL_DYNAMIC_DRAW ç±»å‹\nç»‘å®šé¡¶ç‚¹å±æ€§æ—¶ offset ä½¿ç”¨å†…ç½®å‡½æ•° offsetof æ¥ç¡®å®šæ¯ç§æ•°æ®ç±»å‹çš„åç§»é‡\n\nglBufferData(GL_ARRAY_BUFFER, sizeof(Vertex) * 1000, nullptr, GL_DYNAMIC_DRAW);...glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Position));glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, Color));glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexCoords));glVertexAttribPointer(3, 1, GL_FLOAT, GL_FALSE, sizeof(Vertex), (const void*)offsetof(Vertex, TexId));\n\n\nåŠ¨æ€ç»‘å®šé¡¶ç‚¹ç¼“å†²\n\n// ä¸€ä¸ª quad éœ€è¦å››ä¸ªç‚¹std::array&lt;Vertex, 4&gt; CreateQuad(float x, float y, float texId)&#123;  Vertex v0;  ...  Vertex v1;  ...  Vertex v2;  ...  Vertex v3;  ...  return &#123; v0, v1, v2, v3 &#125;;&#125;auto q0 = CreateQuad(-1.5f, -0.5f, 0.0f);auto q1 = CreateQuad(0.5f, -0.5f, 1.0f);// é€šè¿‡å†…å­˜æ‹·è´çš„æ–¹å¼ç›´æ¥å°† `std::array` ä¸­çš„å†…å®¹æ‹·è´åˆ°ä¸€ç»´æ•°ç»„ä¸­Vertex vertices[8];memcpy(vertices, q0.data(), q0.size() * sizeof(Vertex));memcpy(vertices + q0.size(), q1.data(), q0.size() * sizeof(Vertex));...glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);\n\nåŠ¨æ€ç´¢å¼•ç¼“å†²\né¦–å…ˆç¡®å®šç»˜åˆ¶çš„æœ€å¤§çš„ Quad çš„æ•°é‡maxQuadCount\nç”± maxQuadCount ç¡®å®šé¡¶ç‚¹æ•°é‡ï¼ˆmaxQuadCount * 4ï¼‰å’Œç´¢å¼•æ•°é‡ï¼ˆmaxQuadCount * 6ï¼‰\n\nuint32_t indices[maxQuadCount * 6];uint32_t offset = 0;for (size_t i = 0; i &lt; maxQuadCount * 6; i += 6)&#123;  indices[i + 0] = 0 + offset;  indices[i + 1] = 1 + offset;  indices[i + 2] = 2 + offset;  indices[i + 3] = 2 + offset;  indices[i + 4] = 3 + offset;  indices[i + 5] = 0 + offset;  offset += 4;&#125;\n\n\næ›´æ”¹ CreateQuad å‡½æ•°ï¼Œä¼ å…¥é¢„å…ˆå®šä¹‰å¥½å¤§å°çš„é¡¶ç‚¹æ•°æ®ç»“æ„æ•°ç»„ï¼Œå¦‚std::array&lt;Vertex, 1000&gt;ï¼ŒåŒæ—¶å¢åŠ é¡¶ç‚¹ç´¢å¼•æ•°é‡\n\nVertex* CreateQuad(Vertex* target, float x, float y, float textureId)&#123;  target-&gt;Position = &#123; x, y, 0.0f &#125;;  target-&gt;Color = &#123; 0.18f, 0.6f, 0.96f, 1.0f &#125;;  target-&gt;TexCoors = &#123; 0.0f, 0.0f &#125;;  target-&gt;TexId = textureId;  target++;  ...  return target;&#125;size_t indexCount = 0std::array&lt;Vertex, 1000&gt; vertices;Vertex* buffer = vertices.data();for (int y = 0; y &lt; 5; y++)&#123;  for (int x = 0; x &lt; 5; x++)  &#123;    buffer = CreateQuad(buffer, x, y, (x + y) % 2);    indexCount += 6;  &#125;&#125;glBufferSubData(GL_ARRAY_BUFFER, 0, vertices.size() * sizeof(Vertex), vertices.data());...glDrawElements(GL_TRIANGLE, indexCount, GL_UNSIGNED_INT, nullptr);\n\nAPIs\nglGenBuffers: Generate buffer object names ç”Ÿæˆç¼“å†²åŒºçš„æ ‡è¯†\n\nn: Specifies the number of buffer object names to be generated éœ€è¦ç¼“å†²åŒºæ ‡è¯†çš„æ•°é‡\nbuffers: Specifies an array in which the generated buffer object names are stored ç”¨äºå­˜æ”¾ç¼“å†²åŒºæ ‡è¯†\n\n\nglBindBufferï¼š Bind a named buffer object ç»‘å®šç¼“å†²åŒºæ ‡è¯†çš„å¯¹è±¡ç±»å‹\nglBindBuffer binds a buffer object to the specified buffer binding point. Calling glBindBuffer with target set to one of the accepted symbolic constants and buffer set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name buffer exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.glBindBufferå‡½æ•°å°†ç¼“å†²å¯¹è±¡ç»‘å®šåˆ° OpenGL ä¸Šä¸‹æ–‡ç¯å¢ƒä¸­ï¼Œè°ƒç”¨ glBindBuffer å‡½æ•°ï¼Œéœ€è¦å°† target è®¾ç½®ä¸ºä¸€ä¸ªç¬¦å·å¸¸é‡ï¼ˆæŒ‡å®šç¼“å†²å¯¹è±¡çš„ç±»å‹ï¼‰ï¼Œå°† buffer è®¾ç½®ä¸ºç¼“å†²å¯¹è±¡çš„æ ‡è¯†ç¬¦ï¼Œè¿™æ ·å°±å°†ç¼“å†²å¯¹è±¡å’Œæ ‡è¯†ç¬¦è¿›è¡Œç»‘å®šäº†ã€‚å¦‚æœæ ‡è¯†ç¬¦æ²¡æœ‰å…³è”ç¼“å†²å¯¹è±¡ï¼Œå°±åˆ›å»ºä¸€ä¸ªç¼“å†²å¯¹è±¡ã€‚å½“ç¼“å†²å¯¹è±¡å·²ç»ç¡®å®šå¥½å¯¹è±¡ç±»å‹ï¼Œä¹‹å‰ç»‘å®šçš„ç±»å‹å°±ä¼šå¤±æ•ˆ\nBuffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.å› ä¸ºç¼“å†²åŒºå¯¹è±¡æ ‡è¯†ç¬¦æ˜¯æ— ç¬¦å·ç±»å‹çš„æ•´æ•°ï¼ˆéè´Ÿæ•´æ•°ï¼‰ï¼Œå¦‚æœæ ‡è¯†ç¬¦æ˜¯ 0 æ„å‘³ç€ç¼“å†²åŒºå¯¹è±¡ç±»å‹æ²¡æœ‰ç»‘å®šä»»ä½•ç¼“å†²åŒºå¯¹è±¡ï¼Œè¿™æ ·å¯ä»¥å°† buffer å‚æ•°è®¾ç½®ä¸º 0 è¡¨ç¤ºä»ç¼“å†²åŒºå¯¹è±¡ç±»å‹å’Œç¼“å†²åŒºè§£ç»‘ï¼ŒåŒæ—¶ä¹Ÿä¼šæ¸…é™¤åŸæ¥ç¼“å†²åŒºä¸­çš„å†…å®¹ã€‚\n\ntarget: Specifies the target to which the buffer object is bound\nGL_ARRAY_BUFFER: Vertex attributes\nGL_ATOMIC_COUNTER_BUFFER: Atomic counter storage\nGL_COPY_READ_BUFFER: Buffer copy source\nGL_COPY_WRITE_BUFFER: Buffer copy destination\nGL_DISPATCH_INDIRECT_BUFFER: Indirect compute dispatch commands\nGL_DRAW_INDIRECT_BUFFER: Indirect command arguments\nGL_ELEMENT_ARRAY_BUFFER: Vertex array indices\nGL_PIXEL_PACK_BUFFER: Pixel read target\nGL_PIXEL_UNPACK_BUFFER: Texture data source\nGL_QUERY_BUFFER: Query result buffer\nGL_SHADER_STORAGE_BUFFER: Read-write storage for shaders\nGL_TEXTURE_BUFFER: Texture data buffer\nGL_TRANSFORM_FEEDBACK_BUFFER: Transform feedback buffer\nGL_UNIFORM_BUFFER: Uniform block storage\n\n\nbuffer: Specifies the name of a buffer object\n\n\nglBufferData: ç”¨æ¥æŠŠç”¨æˆ·å®šä¹‰çš„æ•°æ®å¤åˆ¶åˆ°å½“å‰ç»‘å®šç¼“å†²çš„å‡½æ•°\n\nGLenum target: ç›®æ ‡ç¼“å†²çš„ç±»å‹\nGLsizeiptr size: ä¼ è¾“æ•°æ®çš„å¤§å°ï¼ˆä»¥å­—èŠ‚ä¸ºå•ä½ï¼‰ï¼Œä¸€èˆ¬ç”¨ sizeof() å‡½æ•°\nconst void * data: å®é™…æ•°æ®\nGLenum usage: æ˜¾å¡å¦‚ä½•ç®¡ç†ç»™å®šçš„æ•°æ®\nGL_STATIC_DRAW: æ•°æ®ä¸ä¼šæˆ–å‡ ä¹ä¸ä¼šæ”¹å˜\nGL_DYNAMIC_DRAW: æ•°æ®ä¼šè¢«æ”¹å˜å¾ˆå¤š\nGL_STREAM_DRAW: æ•°æ®æ¯æ¬¡ç»˜åˆ¶æ—¶éƒ½ä¼šæ”¹å˜\n\n\n\n\nglVertexAttribPointer: å°† CPU çš„æ•°ç»„ç¼“å†²åŒºç»‘å®šåˆ° GPU çš„é¡¶ç‚¹ç¼“å†²åŒº\n\nGLuint index: Specifies the index of the generic vertex attribute to be modified é¡¶ç‚¹å±æ€§çš„ä½ç½®\nGLint size: Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant GL_BGRA is accepted by glVertexAttribPointer. The initial value is 4 é¡¶ç‚¹æ¯ä¸ªå±æ€§çš„å…ƒç´ æ•°é‡ï¼Œä¸€å®šæ˜¯ 1ï¼Œ2ï¼Œ3ï¼Œ4 ä¸­çš„ä¸€ä¸ªæ•°ã€‚å½“ type ä¸ºGL_BGRAæ—¶ï¼Œåˆå§‹å€¼æ˜¯ 4\nGLenum type: Specifies the data type of each component in the array. é¡¶ç‚¹æ¯ä¸ªå±æ€§çš„å…ƒç´ çš„æ•°æ®ç±»å‹æšä¸¾\nGLboolean normalized: Specifies whether fixed-point data values should be normalized (GL_TRUE) or converted directly as fixed-point values (GL_FALSE) when they are accessed å¦‚æœè®¾ç½®ä¸º GL_TRUEï¼Œæ‰€æœ‰æ•°æ®éƒ½ä¼šè¢«æ˜ å°„åˆ°[0, 1] ä¹‹é—´ï¼ˆå¯¹äºæœ‰ç¬¦å·ç±»å‹çš„æ•°æ®æ˜¯ [-1, 1] ä¹‹é—´ï¼‰\nGLsizei stride: Specifies the byte offset between consecutive generic vertex attributes. If strideâ€‹ is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0 åœ¨é¡¶ç‚¹è‹¥å¹²å±æ€§ä¸­ä¸¤ä¸ªç›¸åŒå±æ€§ä¹‹é—´çš„æ­¥é•¿ï¼Œå¦‚æœæ­¥é•¿æ˜¯ 0\nconst void * pointer: Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the GL_ARRAY_BUFFER target. The initial value is 0. æ¯ä¸ªé¡¶ç‚¹å±æ€§ç›¸å¯¹äºèµ·å§‹å±æ€§çš„åç§»é‡çš„æŒ‡é’ˆçš„ä½ç½®\n\n\nglGetError: è¿”å›é”™è¯¯æ ‡å¿—çš„å€¼ã€‚æ¯ä¸ªå¯æ£€æµ‹çš„é”™è¯¯éƒ½åˆ†é…æœ‰æ•°å­—ä»£ç å’Œç¬¦å·åç§°ã€‚å‘ç”Ÿé”™è¯¯æ—¶ï¼Œé”™è¯¯æ ‡å¿—å°†è®¾ç½®ä¸ºç›¸åº”çš„é”™è¯¯ä»£ç å€¼ã€‚åœ¨è°ƒç”¨ glGetErrorï¼ˆè¿”å›é”™è¯¯ä»£ç ï¼‰ä¹‹å‰ï¼Œä¸ä¼šè®°å½•å…¶ä»–é”™è¯¯ï¼Œå¹¶å°†æ ‡å¿—é‡ç½®ä¸ºGL_NO_ERRORã€‚å¦‚æœå¯¹glGetError çš„è°ƒç”¨è¿”å› GL_NO_ERRORï¼Œåˆ™è‡ªä¸Šæ¬¡è°ƒç”¨glGetError æˆ–è‡ª GL åˆå§‹åŒ–ä»¥æ¥ï¼Œæ²¡æœ‰å¯æ£€æµ‹åˆ°çš„é”™è¯¯\n\nglGenTextures: generate texture names\nglGenTextures returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to glGenTextures èƒ½å¤Ÿä¿è¯åœ¨è°ƒç”¨ glGenTextures å‰è¿”å›çš„æ ‡è¯†ç¬¦æ˜¯æ²¡æœ‰è¢«ç”¨è¿‡çš„\nThe generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound ç”Ÿæˆçš„çº¹ç†æ˜¯æ²¡æœ‰ç»´åº¦çš„ï¼Œå‡å®šçº¹ç†çš„ç»´åº¦æ˜¯ç¬¬ä¸€æ¬¡ç»‘å®šçš„ç»´åº¦ï¼ˆä¸æ˜¯å¾ˆç†è§£ï¼‰\nTexture names returned by a call to glGenTextures are not returned by subsequent calls, unless they are first deleted with glDeleteTextures è¿ç»­è°ƒç”¨ glGenTextures ä¸ä¼šè¿”å›è¡¨ç¤ºç¬¦äº†ï¼Œé™¤éå…ˆè°ƒç”¨ glDeleteTextures åˆ é™¤çº¹ç†\n\nglBindTextureï¼š å°†ä¸€ä¸ªçº¹ç†æ ‡è¯†ç¬¦ç»‘å®šåˆ°ä¸€ä¸ªçº¹ç†å¯¹è±¡ä¸ŠTexture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. å¯¹äºå½“å‰çš„ GL æ¸²æŸ“ä¸Šä¸‹æ–‡ä¸­çš„å…±äº«å¯¹è±¡ç©ºé—´ï¼Œçº¹ç†åç§°ä»¥åŠå®ƒä»¬å¯¹åº”çš„çº¹ç†å†…å®¹æ˜¯å±€éƒ¨çš„ï¼›åªæœ‰åœ¨æ˜¾å¼å¼€å¯ä¸Šä¸‹æ–‡ä¹‹é—´çš„å…±äº«ï¼Œä¸¤ä¸ªæ¸²æŸ“ä¸Šä¸‹æ–‡æ‰å¯ä»¥å…±äº«çº¹ç†åç§°\n\nglTexParameteri\n\nglTexImage2D\n\nglActiveTexture\n\nglClear\n\nä¸è°ƒç”¨ glClear çš„è¯ï¼Œä¸‹ä¸€å¸§çš„å†…å®¹ä¼šå’Œä¸Šä¸€å¸§çš„å†…å®¹é‡å åœ¨ä¸€èµ·ï¼Œä¸Šä¸€å¸§çš„ç‰©ä½“è¿˜åœ¨åŸæ¥çš„åœ°æ–¹\nglClearColor\næŒ‡å®šåˆ·æ–°é¢œè‰²ç¼“å†²åŒºæ—¶æ‰€ç”¨çš„é¢œè‰²\nglClearColoråªæ˜¯è®¾ç½®ç¼“å†²åŒºé¢œè‰²ï¼Œå¹¶ä¸ä¸ä¼šæ¸…é™¤ç¼“å†²åŒºçš„é¢œè‰²ï¼Œéœ€è¦åœ¨è®¾ç½®å¥½é¢œè‰²ä¹‹åè°ƒç”¨ glClear æ‰ä¼šåˆ·æ–°ç¼“å†²åŒºçš„é¢œè‰²\nglClearColorå¹¶ä¸æ˜¯å¿…é¡»çš„\n\n\n\n\nglUniform1iv\n\n\n","categories":["Learning OpenGL"],"tags":["OpenGL","å›¾å½¢å­¦"]},{"title":"æ»¡å ‚èŠ±é†‰ä¸‰åƒå®¢ï¼Œä¸€å‰‘éœœå¯’åå››å·","url":"/2024/07/12/60/","content":"\n\n","categories":["ç›¸å†Œ"],"tags":["å®‰å¾½","å°å·"]},{"title":"C++ 20 æ–°ç‰¹æ€§","url":"/2024/07/11/59/","content":"\n    \n\n\n\n\nè¯­è¨€ç‰¹æ€§  ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦  ä¸‰è·¯æ¯”è¾ƒè¿ç®—ç¬¦è¡¨è¾¾å¼çš„å½¢å¼ä¸ºï¼šå·¦æ“ä½œæ•° &lt;=&gt; å³æ“ä½œæ•°ï¼Œè¡¨è¾¾å¼è¿”å›ä¸€ä¸ªå¯¹è±¡ï¼Œä½¿å¾—\n\nè‹¥å·¦æ“ä½œæ•° &lt; å³æ“ä½œæ•°åˆ™(a &lt;=&gt; b) &lt; 0\nè‹¥å·¦æ“ä½œæ•° &gt; å³æ“ä½œæ•°åˆ™(a &lt;=&gt; b) &gt; 0\nè€Œè‹¥å·¦æ“ä½œæ•°å’Œå³æ“ä½œæ•°ç›¸ç­‰ / ç­‰ä»·åˆ™(a &lt;=&gt; b) == 0\n\nint main() &#123;    double foo = -0.0;    double bar = 0.0;     auto res = foo &lt;=&gt; bar;     if (res &lt; 0)        std::cout &lt;&lt; &quot;-0 å°äº 0&quot;;    else if (res &gt; 0)        std::cout &lt;&lt; &quot;-0 å¤§äº 0&quot;;    else // (res == 0)        std::cout &lt;&lt; &quot;-0 ä¸ 0 ç›¸ç­‰ &quot;;&#125;\n\nèŒƒå›´ for ä¸­çš„åˆå§‹åŒ–è¯­å¥å’Œåˆå§‹åŒ–å™¨  ç»§ C++ 17 ä¸­åœ¨ if å’Œswitchè¯­å¥ä¸­æ·»åŠ åˆå§‹åŒ–å™¨åï¼ŒC++ 20 åœ¨èŒƒå›´ for ä¸­ä¹Ÿå®ç°äº†è¿™ä¸ªåŠŸèƒ½\nfor (auto n = v.size(); auto i : v) // åˆå§‹åŒ–è¯­å¥ï¼ˆC++20ï¼‰    std::cout &lt;&lt; --n + i &lt;&lt; &#x27; &#x27;;\n\nconstevalconstevalæŒ‡å®šå‡½æ•°æ˜¯ç«‹å³å‡½æ•°ï¼ˆimmediate functionï¼‰ï¼Œå³æ¯æ¬¡è°ƒç”¨è¯¥å‡½æ•°å¿…é¡»äº§ç”Ÿç¼–è¯‘æ—¶å¸¸é‡ã€‚å¦‚æœä¸èƒ½åœ¨ç¼–è¯‘æœŸé—´æ‰§è¡Œï¼Œåˆ™ç¼–è¯‘å¤±è´¥\nconsteval int sqr(int n) &#123;  return n * n;&#125;constexpr int r = sqr(100);  // OK int x = 100;int r2 = sqr(x);  // é”™è¯¯ï¼šè°ƒç”¨ä¸äº§ç”Ÿå¸¸é‡ consteval int sqrsqr(int n) &#123;  return sqr(sqr(n)); // åœ¨æ­¤ç‚¹éå¸¸é‡è¡¨è¾¾å¼ï¼Œä½†æ˜¯ OK&#125; constexpr int dblsqr(int n) &#123;  return 2 * sqr(n); // é”™è¯¯ï¼šå¤–å›´å‡½æ•°å¹¶é consteval ä¸” sqr(n) ä¸æ˜¯å¸¸é‡&#125;\n\nconstintconstinitæ–­è¨€å˜é‡æ‹¥æœ‰é™æ€åˆå§‹åŒ–ï¼Œå³é›¶åˆå§‹åŒ–ä¸å¸¸é‡åˆå§‹åŒ–ï¼Œå¦åˆ™ç¨‹åºéè‰¯æ„\nconst char *g() &#123; return &quot;dynamic initialization&quot;; &#125;constexpr const char *f(bool p) &#123; return p ? &quot;constant initializer&quot; : g(); &#125; constinit const char *c = f(true); // OK// constinit const char *d = f(false); // é”™è¯¯\n\næ¦‚å¿µï¼ˆconceptsï¼‰æ¦‚å¿µï¼ˆconceptsï¼‰å°±æ˜¯ä¸€ç§ç¼–è¯‘æ—¶è°“è¯ï¼ŒæŒ‡å‡ºä¸€ä¸ªæˆ–å¤šä¸ªç±»å‹åº”å¦‚ä½•ä½¿ç”¨ï¼Œå…¶èƒ½ç”¨äºè¿›è¡Œæ¨¡æ¿å®å‚çš„ç¼–è¯‘æ—¶æ ¡éªŒï¼Œä»¥åŠåŸºäºç±»å‹å±æ€§çš„å‡½æ•°æ´¾å‘ã€‚\nä¾‹å¦‚åœ¨è€ç‰ˆæœ¬çš„ C++ï¼Œå¦‚æœæƒ³è¦å®šä¹‰ä¸€ä¸ªåªé’ˆå¯¹æŸä¸ªç±»å‹çš„å‡½æ•°æ¨¡æ¿ï¼Œå°±åªèƒ½é€šè¿‡ç±»å‹èƒå–æœºåˆ¶å¦‚ enable_if_t å†™ä¸€äº›åˆè‡­åˆé•¿çš„ä»£ç ã€‚ä¾‹å¦‚æƒ³å£°æ˜ä¸€ä¸ªåªé’ˆå¯¹æ•´æ•°çš„å‡½æ•°æ¨¡æ¿\ntemplate &lt;typename T&gt;auto mod(std::enable_if_t&lt;std::is_integral_v&lt;T&gt;, T&gt; d)&#123;    return d % 10;&#125;\n\nå¦‚æœçº¦æŸæ¡ä»¶ç®€å•è¿˜è¡Œï¼Œä½†æ˜¯å¦‚æœæ¡ä»¶å¤æ‚ï¼Œåˆ™ä»£ç å°±ä¼šåˆè‡­åˆé•¿ï¼Œä¸”éš¾ä»¥è¿›è¡Œå¤ç”¨ã€‚è€Œåœ¨ C++ 20 ä¸­å¼•å…¥äº† conceptsï¼Œæ­¤æ—¶æˆ‘ä»¬å°±å¯ä»¥ç”¨ concepts æ¥æŒ‡å®šå‡½æ•°ç±»å‹ï¼Œä¾‹å¦‚ï¼š\ntemplate &lt;class T&gt;concept integral = std::is_integral_v&lt;T&gt;; template &lt;integral T&gt;auto mod(T d)&#123;    return d % 10;&#125;\n\nçº¦æŸ  çº¦æŸæ˜¯é€»è¾‘æ“ä½œå’Œæ“ä½œæ•°çš„åºåˆ—ï¼Œå®ƒäº†æŒ‡å®šå¯¹æ¨¡æ¿å®å‚çš„è¦æ±‚ã€‚å®ƒä»¬å¯ä»¥åœ¨ requires è¡¨è¾¾å¼ä¸­å‡ºç°ï¼Œä¹Ÿå¯ä»¥ç›´æ¥ä½œä¸ºæ¦‚å¿µçš„ä¸»ä½“ã€‚ä¾‹å¦‚è¿™é‡Œä½¿ç”¨ requires çº¦æŸè¡¨è¾¾å¼å†™ä¸€ä¸ªé’ˆå¯¹ utf-8 çš„ string çš„çº¦æŸç±»å‹u8string_t\ntemplate &lt;typename T&gt;concept u8string_t = requires (T t)&#123;    t += u8&quot;&quot;;&#125;;\n\næ¥ç€ä»¥è¿™ä¸ªçº¦æŸç±»å‹å£°æ˜ä¸€ä¸ªæ¨¡æ¿å‡½æ•° printï¼Œæ­¤æ—¶åªèƒ½èƒ½å¤Ÿæ»¡è¶³u8string_t çº¦æŸçš„ç±»å‹æ‰èƒ½å¤ŸåŒ¹é…å½“å‰æ¨¡æ¿\ntemplate &lt;u8string_t T&gt;auto print(T t)&#123;    cout &lt;&lt; t &lt;&lt; endl;&#125;\n\næ­¤æ—¶ä»¥ä¸åŒç±»å‹çš„ string æ¥å°è¯•è°ƒç”¨ï¼Œæ­¤æ—¶åªæœ‰ u8string è°ƒç”¨æˆåŠŸ\nint main()&#123;    string str;    u8string str_u8;    u16string str_u16;    u32string str_u32;    print(str);     // è°ƒç”¨å¤±è´¥    print(str_u8);  // è°ƒç”¨æˆåŠŸ    print(str_u16); // è°ƒç”¨å¤±è´¥    print(str_u32); // è°ƒç”¨å¤±è´¥&#125;\n\nåç¨‹  åç¨‹æ˜¯èƒ½æš‚åœæ‰§è¡Œä»¥åœ¨ä¹‹åæ¢å¤çš„å‡½æ•°ã€‚åç¨‹æ˜¯æ— æ ˆçš„ï¼šå®ƒä»¬é€šè¿‡è¿”å›åˆ°è°ƒç”¨æ–¹æš‚åœæ‰§è¡Œï¼Œå¹¶ä¸”ä»æ ˆåˆ†ç¦»å­˜å‚¨æ¢å¤æ‰§è¡Œéœ€è¦çš„æ•°æ®ã€‚è¿™æ ·å°±å¯ä»¥ç¼–å†™å¼‚æ­¥æ‰§è¡Œçš„é¡ºåºä»£ç ï¼ˆä¾‹å¦‚ä¸ä½¿ç”¨æ˜¾å¼çš„å›è°ƒæ¥å¤„ç†éé˜»å¡ I/Oï¼‰ï¼Œè¿˜æ”¯æŒå¯¹æƒ°æ€§è®¡ç®—çš„æ— é™åºåˆ—ä¸Šçš„ç®—æ³•åŠå…¶ä»–ç”¨é€”\nå¦‚æœå‡½æ•°çš„å®šä¹‰è¿›è¡Œäº†ä¸‹åˆ—æ“ä½œä¹‹ä¸€ï¼Œé‚£ä¹ˆå®ƒæ˜¯åç¨‹ï¼š\n\nco_await æš‚åœæ‰§è¡Œï¼Œç›´åˆ°æ¢å¤\n\ntask&lt;&gt; tcp_echo_server() &#123;  char data[1024];  while (true) &#123;    std::size_t n = co_await socket.async_read_some(buffer(data));    co_await async_write(socket, buffer(data, n));  &#125;&#125;\n\n\nco_yield æš‚åœæ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªå€¼ï¼ˆåç¨‹æ— æ³•returnï¼‰\n\ngenerator&lt;int&gt; iota(int n = 0) &#123;  while(true)    co_yield n++;&#125;\n\n\nco_returnå®Œæˆæ‰§è¡Œå¹¶è¿”å›ä¸€ä¸ªå€¼\n\nlazy&lt;int&gt; f() &#123;  co_return 7;&#125;\n\n\næ³¨æ„ï¼šåç¨‹ä¸èƒ½ä½¿ç”¨å˜é•¿å®å‚ï¼Œæ™®é€šçš„ return è¯­å¥ï¼Œæˆ–å ä½ç¬¦è¿”å›ç±»å‹ï¼ˆautoæˆ– Conceptï¼‰ã€‚constexprå‡½æ•°ã€æ„é€ å‡½æ•°ã€ææ„å‡½æ•°åŠ main å‡½æ•°ä¸èƒ½æ˜¯åç¨‹\n\næ¨¡å—C++ 20 ä¸­æ­£å¼å¼•å…¥äº†æ¨¡å—çš„æ¦‚å¿µï¼Œæ¨¡å—æ˜¯ä¸€ä¸ªç”¨äºåœ¨ç¿»è¯‘å•å…ƒé—´åˆ†äº«å£°æ˜å’Œå®šä¹‰çš„è¯­è¨€ç‰¹æ€§ã€‚å®ƒä»¬å¯ä»¥åœ¨æŸäº›åœ°æ–¹æ›¿ä»£ä½¿ç”¨å¤´æ–‡ä»¶ã€‚å…¶ä¸»è¦ä¼˜ç‚¹å¦‚ä¸‹ï¼š\n\næ²¡æœ‰å¤´æ–‡ä»¶\nå£°æ˜å®ç°ä»ç„¶å¯åˆ†ç¦»ï¼Œä½†éå¿…è¦\nå¯ä»¥æ˜¾å¼æŒ‡å®šå¯¼å‡ºå“ªäº›ç±»æˆ–å‡½æ•°\nä¸éœ€è¦å¤´æ–‡ä»¶é‡å¤å¼•å…¥å®ï¼ˆinclude guardsï¼‰\næ¨¡å—ä¹‹é—´åç§°å¯ä»¥ç›¸åŒï¼Œå¹¶ä¸”ä¸ä¼šå†²çª\næ¨¡å—åªå¤„ç†ä¸€æ¬¡ï¼Œç¼–è¯‘æ›´å¿«ï¼ˆå¤´æ–‡ä»¶æ¯æ¬¡å¼•å…¥éƒ½éœ€è¦å¤„ç†ï¼Œéœ€è¦é€šè¿‡ pragma once çº¦æŸï¼‰\né¢„å¤„ç†å®åªåœ¨æ¨¡å—å†…æœ‰æ•ˆ\næ¨¡å—çš„å¼•å…¥ä¸å¼•å…¥é¡ºåºæ— å…³\n\nåˆ›å»ºæ¨¡å—// helloworld.cppexport module helloworld;  // æ¨¡å—å£°æ˜import &lt;iostream&gt;;         // å¯¼å…¥å£°æ˜ export void hello() &#123;      // å¯¼å‡ºå£°æ˜    std::cout &lt;&lt; &quot;Hello world!\\n&quot;;&#125;\n\nå¯¼å…¥æ¨¡å—// main.cppimport helloworld;  // å¯¼å…¥å£°æ˜ int main() &#123;    hello();&#125;\n\nåº“ç‰¹æ€§ format æ–‡æœ¬æ ¼å¼åŒ–åº“æä¾› printf å‡½æ•°æ—çš„å®‰å…¨ä¸”å¯æ‰©å±•çš„æ›¿ç”¨å“ã€‚æœ‰æ„ä½¿ä¹‹è¡¥å……æ—¢å­˜çš„ C++ I/O æµåº“å¹¶å¤ç”¨å…¶åŸºç¡€è®¾æ–½ï¼Œä¾‹å¦‚å¯¹ç”¨æˆ·å®šä¹‰ç±»å‹é‡è½½çš„æµæ’å…¥è¿ç®—ç¬¦\nstd::string message = std::format(&quot;The answer is &#123;&#125;.&quot;, 42);osyncstreamtemplate&lt;    class CharT,    class Traits = std::char_traits&lt;CharT&gt;,    class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_osyncstream: public std::basic_ostream&lt;CharT, Traits&gt;\n\nç±»æ¨¡æ¿ std::basic_osyncstream æ˜¯std::basic_syncbufçš„ä¾¿åˆ©åŒ…è£…ã€‚å®ƒæä¾›æœºåˆ¶ä»¥åŒæ­¥å†™å…¥åŒä¸€æµçš„çº¿ç¨‹ï¼ˆä¸»è¦ç”¨äºè§£å†³ std::cout çº¿ç¨‹ä¸å®‰å…¨é—®é¢˜ï¼‰\nç”¨æ³•å¦‚ä¸‹ï¼š\n&#123;    std::osyncstream sync_out(std::cout); // std::cout çš„åŒæ­¥åŒ…è£…    sync_out &lt;&lt; &quot;Hello, &quot;;    sync_out &lt;&lt; &quot;World!&quot;;    sync_out &lt;&lt; std::endl; // æ³¨æ„æœ‰å†²å…¥ï¼Œä½†ä»æœªè¿›è¡Œ    sync_out &lt;&lt; &quot;and more!\\n&quot;;&#125; // è½¬ç§»å­—ç¬¦å¹¶å†²å…¥ std::cout\n\nspanspanæ˜¯å¯¹è±¡çš„è¿ç»­åºåˆ—ä¸Šçš„æ— æ‰€æœ‰æƒè§†å›¾ã€‚å…¶æ‰€æè¿°çš„å¯¹è±¡èƒ½æŒ‡ä»£å¯¹è±¡çš„ç›¸æ¥åºåˆ—ï¼Œåºåˆ—çš„é¦–å…ƒç´ åœ¨é›¶ä½ç½®ã€‚spanèƒ½æ‹¥æœ‰é™æ€é•¿åº¦ï¼Œè¯¥æƒ…å†µä¸‹åºåˆ—ä¸­çš„å…ƒç´ æ•°å·²çŸ¥å¹¶ç¼–ç äºç±»å‹ä¸­ï¼Œæˆ–æ‹¥æœ‰åŠ¨æ€é•¿åº¦\n#include &lt;algorithm&gt;#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;span&gt; template&lt;class T, std::size_t N&gt; [[nodiscard]]constexpr auto slide(std::span&lt;T,N&gt; s, std::size_t offset, std::size_t width) &#123;    return s.subspan(offset, offset + width &lt;= s.size() ? width : 0U);&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool starts_with(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; prefix) &#123;    return data.size() &gt;= prefix.size()         &amp;&amp; std::equal(prefix.begin(), prefix.end(), data.begin());&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool ends_with(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; suffix) &#123;    return data.size() &gt;= suffix.size()         &amp;&amp; std::equal(data.end() - suffix.size(), data.end(),                       suffix.end() - suffix.size());&#125; template&lt;class T, std::size_t N, std::size_t M&gt; [[nodiscard]]constexpr bool contains(std::span&lt;T,N&gt; span, std::span&lt;T,M&gt; sub) &#123;    return std::search(span.begin(), span.end(), sub.begin(), sub.end()) != span.end();//  return std::ranges::search(span, sub).begin() != span.end();&#125; void print(const auto&amp; seq) &#123;    for (const auto&amp; elem : seq) std::cout &lt;&lt; elem &lt;&lt; &#x27; &#x27;;    std::cout &lt;&lt; &#x27;\\n&#x27;;&#125; int main()&#123;    constexpr int a[] &#123; 0, 1, 2, 3, 4, 5, 6, 7, 8 &#125;;    constexpr int b[] &#123; 8, 7, 6 &#125;;     for (std::size_t offset&#123;&#125;; ; ++offset) &#123;        constexpr std::size_t width&#123;6&#125;;        auto s = slide(std::span&#123;a&#125;, offset, width);        if (s.empty())            break;        print(s);    &#125;     static_assert(starts_with(std::span&#123;a&#125;, std::span&#123;a,4&#125;)        &amp;&amp; starts_with(std::span&#123;a+1, 4&#125;, std::span&#123;a+1,3&#125;)        &amp;&amp; !starts_with(std::span&#123;a&#125;, std::span&#123;b&#125;)        &amp;&amp; !starts_with(std::span&#123;a,8&#125;, std::span&#123;a+1,3&#125;)        &amp;&amp; ends_with(std::span&#123;a&#125;, std::span&#123;a+6,3&#125;)        &amp;&amp; !ends_with(std::span&#123;a&#125;, std::span&#123;a+6,2&#125;)        &amp;&amp; contains(std::span&#123;a&#125;, std::span&#123;a+1,4&#125;)        &amp;&amp; !contains(std::span&#123;a,8&#125;, std::span&#123;a,9&#125;));&#125;\n\nendianendianä¸»è¦ç”¨äºåˆ¤æ–­å½“å‰æœºå™¨æ˜¯å¤§ç«¯è¿˜æ˜¯å°ç«¯ï¼ˆä¹‹å‰åªèƒ½é€šè¿‡æ•´å‹æˆªæ–­æˆ–è€… union åˆ¤æ–­ï¼Œè¾ƒä¸ºéº»çƒ¦ï¼‰\n\nè‹¥æ‰€æœ‰æ ‡é‡ç±»å‹å‡ä¸ºå°ç«¯ï¼Œåˆ™ std::endian::native ç­‰äºstd::endian::little\nè‹¥æ‰€æœ‰æ ‡é‡ç±»å‹å‡ä¸ºå¤§ç«¯ï¼Œåˆ™ std::endian::native ç­‰äºstd::endian::big\nè‹¥æ‰€æœ‰æ ‡é‡ç±»å‹æ‹¥æœ‰ç­‰äº 1 çš„ sizeofï¼Œåˆ™ç«¯åºæ— å½±å“ï¼Œä¸”std::endian::littleï¼Œstd::endian::big åŠstd::endian::nativeä¸‰ä¸ªå€¼ç›¸åŒ\nè‹¥å¹³å°ä½¿ç”¨æ··åˆç«¯åºï¼Œåˆ™ std::endian::native æ—¢ä¸ç­‰äº std::endian::big äº¦ä¸ç­‰äºstd::endian::little\n\n#include &lt;bit&gt;#include &lt;iostream&gt; int main() &#123;     if constexpr (std::endian::native == std::endian::big)        std::cout &lt;&lt; &quot;big-endian\\n&quot;;    else if constexpr (std::endian::native == std::endian::little)        std::cout &lt;&lt; &quot;little-endian\\n&quot;;    else std::cout &lt;&lt; &quot;mixed-endian\\n&quot;;&#125;\n\njthreadjthreadå³æ˜¯é€šè¿‡ RAII æœºåˆ¶å°è£…çš„ threadï¼Œå…¶ä¼šåœ¨ææ„æ—¶è‡ªåŠ¨è°ƒç”¨join é˜²æ­¢çº¿ç¨‹ crashã€‚åŒæ—¶å…¶ä¹Ÿæ˜¯å¯ä¸­æ–­çš„ï¼Œå¯ä»¥æ­é…è¿™äº›ä¸­æ–­çº¿ç¨‹æ‰§è¡Œçš„ç›¸å…³ç±»ä½¿ç”¨ï¼š\n\nstop_tokenï¼šæŸ¥è¯¢çº¿ç¨‹æ˜¯å¦ä¸­æ–­\nstop_sourceï¼šè¯·æ±‚çº¿ç¨‹åœæ­¢è¿è¡Œ\nstop_callbackï¼šstop_tokenæ‰§è¡Œæ—¶ï¼Œå¯ä»¥è§¦å‘çš„å›è°ƒå‡½æ•°\n\nsemaphoreä¿¡å·é‡æ˜¯ä¸€ä¸ªè½»é‡çº§çš„åŒæ­¥åŸè¯­ï¼Œå¯ç”¨æ¥å®ç°ä»»ä½•å…¶ä»–åŒæ­¥æ¦‚å¿µå¦‚ mutexã€shared_mutexã€latchesã€barriers ç­‰\næ ¹æ® LeastMaxValue ä¸åŒï¼Œä¸»è¦åˆ†ä¸ºä¸¤ç§ï¼š\n\ncounting_semaphoreï¼ˆå¤šå…ƒä¿¡å·é‡ï¼‰ï¼šcounting_semaphoreå…è®¸åŒä¸€èµ„æºæœ‰å¤šäºä¸€ä¸ªåŒæ—¶è®¿é—®ï¼Œè‡³å°‘å…è®¸ LeastMaxValue ä¸ªåŒæ—¶çš„è®¿é—®è€…\nbinary_semaphoreï¼ˆäºŒå…ƒä¿¡å·é‡ï¼‰ï¼šæ˜¯ counting_semaphore çš„ç‰¹åŒ–çš„åˆ«åï¼Œå…¶ LeastMaxValue ä¸º 1 ã€‚å®ç°å¯èƒ½å°† binary_semaphore å®ç°å¾—æ¯” counting_semaphore çš„é»˜è®¤å®ç°æ›´é«˜æ•ˆ\n\n// å…¨å±€äºŒå…ƒä¿¡å·é‡å®ä¾‹// è®¾ç½®å¯¹è±¡è®¡æ•°ä¸ºé›¶// å¯¹è±¡åœ¨æœªè¢«å‘ä¿¡çŠ¶æ€std::binary_semaphore smphSignal(0); void ThreadProc()&#123;    // é€šè¿‡å°è¯•å‡å°‘ä¿¡å·é‡çš„è®¡æ•°ç­‰å¾…æ¥è‡ªä¸»ç¨‹åºçš„ä¿¡å·    smphSignal.acquire();     // æ­¤è°ƒç”¨é˜»å¡ç›´è‡³ä¿¡å·é‡çš„è®¡æ•°è¢«ä»ä¸»ç¨‹åºå¢åŠ      std::cout &lt;&lt; &quot;[thread] Got the signal&quot; &lt;&lt; std::endl; // å›åº”æ¶ˆæ¯     // ç­‰å¾… 3 ç§’ä»¥æ¨¡ä»¿æŸç§çº¿ç¨‹æ­£åœ¨è¿›è¡Œçš„å·¥ä½œ    std::this_thread::sleep_for(3s);     std::cout &lt;&lt; &quot;[thread] Send the signal\\n&quot;; // æ¶ˆæ¯     // å¯¹ä¸»ç¨‹åºå›å¤å‘ä¿¡    smphSignal.release();&#125; int main()&#123;    // åˆ›å»ºæŸä¸ªèƒŒæ™¯å·¥ä½œçº¿ç¨‹ï¼Œå®ƒå°†é•¿æœŸå­˜åœ¨    std::jthread thrWorker(ThreadProc);     std::cout &lt;&lt; &quot;[main] Send the signal\\n&quot;; // æ¶ˆæ¯     // é€šè¿‡å¢åŠ ä¿¡å·é‡çš„è®¡æ•°å¯¹å·¥ä½œçº¿ç¨‹å‘ä¿¡ä»¥å¼€å§‹å·¥ä½œ    smphSignal.release();     // release() åéš acquire() å¯ä»¥é˜»æ­¢å·¥ä½œçº¿ç¨‹è·å–ä¿¡å·é‡ï¼Œæ‰€ä»¥æ·»åŠ å»¶è¿Ÿï¼š    std::this_thread::sleep_for(50ms);     // é€šè¿‡è¯•å›¾å‡å°‘ä¿¡å·é‡çš„è®¡æ•°ç­‰å¾…ç›´è‡³å·¥ä½œçº¿ç¨‹å®Œæˆå·¥ä½œ    smphSignal.acquire();     std::cout &lt;&lt; &quot;[main] Got the signal\\n&quot;; // å›åº”æ¶ˆæ¯&#125;\n\nlatchlatchæ˜¯ std::ptrdiff_t ç±»å‹çš„å‘ä¸‹è®¡æ•°å™¨ï¼Œå®ƒèƒ½ç”¨äºåŒæ­¥çº¿ç¨‹ã€‚åœ¨åˆ›å»ºæ—¶åˆå§‹åŒ–è®¡æ•°å™¨çš„å€¼ã€‚å…¶ä¸»è¦æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š\n\nçº¿ç¨‹å¯èƒ½åœ¨ latch ä¸Šé˜»å¡ç›´è‡³è®¡æ•°å™¨å‡å°‘åˆ°é›¶ã€‚æ²¡æœ‰å¯èƒ½å¢åŠ æˆ–é‡ç½®è®¡æ•°å™¨ï¼Œè¿™ä½¿å¾— latch ä¸ºå•æ¬¡ä½¿ç”¨çš„å±éšœ\nåŒæ—¶è°ƒç”¨ latch çš„æˆå‘˜å‡½æ•°ï¼Œé™¤äº†ææ„å‡½æ•°ï¼Œä¸å¼•å…¥æ•°æ®ç«äº‰\nä¸åŒäº std::barrierï¼Œå‚ä¸çº¿ç¨‹èƒ½å‡å°‘std::latch å¤šäºä¸€æ¬¡\n\nbarrierç±»æ¨¡æ¿ barrier æä¾›å…è®¸è‡³å¤šä¸ºæœŸå¾…æ•°é‡çš„çº¿ç¨‹é˜»å¡ç›´è‡³æœŸå¾…æ•°é‡çš„çº¿ç¨‹åˆ°è¾¾è¯¥å±éšœã€‚ä¸åŒäº latchï¼Œå±éšœå¯é‡ç”¨ï¼šä¸€æ—¦åˆ°è¾¾çš„çº¿ç¨‹ä»å±éšœé˜¶æ®µçš„åŒæ­¥ç‚¹é™¤é˜»ï¼Œåˆ™å¯é‡ç”¨åŒä¸€å±éšœã€‚å±éšœå¯¹è±¡çš„ç”Ÿå­˜æœŸç”±å±éšœé˜¶æ®µçš„åºåˆ—ç»„æˆã€‚æ¯ä¸ªé˜¶æ®µå®šä¹‰ä¸€ä¸ªé˜¶æ®µåŒæ­¥ç‚¹ã€‚åœ¨é˜¶æ®µä¸­åˆ°è¾¾å±éšœçš„çº¿ç¨‹èƒ½é€šè¿‡è°ƒç”¨wait åœ¨é˜¶æ®µåŒæ­¥ç‚¹ä¸Šé˜»å¡ï¼Œè€Œä¸”å°†ä¿æŒé˜»å¡ç›´è‡³è¿è¡Œé˜¶æ®µå®Œæˆæ­¥éª¤\nå±éšœé˜¶æ®µç”±ä»¥ä¸‹æ­¥éª¤ç»„æˆï¼š\n\næ¯æ¬¡è°ƒç”¨ arrive æˆ–arrive_and_dropå‡å°‘æœŸå¾…è®¡æ•°\næœŸå¾…è®¡æ•°æŠµè¾¾é›¶æ—¶ï¼Œè¿è¡Œé˜¶æ®µå®Œæˆæ­¥éª¤ã€‚å®Œæˆæ­¥éª¤è°ƒç”¨å®Œæˆå‡½æ•°å¯¹è±¡ï¼Œå¹¶é™¤é˜»æ‰€æœ‰åœ¨é˜¶æ®µåŒæ­¥ç‚¹ä¸Šé˜»å¡çš„çº¿ç¨‹ã€‚å®Œæˆæ­¥éª¤çš„ç»“æŸå¼ºå…ˆå‘ç”Ÿäºæ‰€æœ‰ä»å®Œæˆæ­¥éª¤æ‰€é™¤é˜»çš„è°ƒç”¨çš„è¿”å›\nå¯¹äºç‰¹åŒ– std::barrier&lt;&gt;ï¼ˆä½¿ç”¨é»˜è®¤æ¨¡æ¿å®å‚ï¼‰ï¼Œå®Œæˆæ­¥éª¤ä½œä¸ºå¯¹arrive æˆ–arrive_and_dropçš„å¯¼è‡´æœŸå¾…è®¡æ•°æŠµè¾¾é›¶çš„è°ƒç”¨çš„ä¸€éƒ¨åˆ†è¿è¡Œ\nå¯¹äºå…¶ä»–ç‰¹åŒ–ï¼Œå®Œæˆæ­¥éª¤åœ¨è¯¥é˜¶æ®µæœŸé—´åˆ°è¾¾å±éšœçš„çº¿ç¨‹ä¹‹ä¸€ä¸Šè¿è¡Œã€‚è€Œè‹¥åœ¨å®Œæˆæ­¥éª¤ä¸­è°ƒç”¨å±éšœå¯¹è±¡çš„ wait ä»¥å¤–çš„æˆå‘˜å‡½æ•°ï¼Œåˆ™è¡Œä¸ºæœªå®šä¹‰\n\n\nå®Œæˆæ­¥éª¤ç»“æŸæ—¶ï¼Œé‡ç½®æœŸå¾…è®¡æ•°ä¸ºæ„é€ ä¸­æŒ‡å®šçš„å€¼ï¼Œå¯èƒ½ä¸º arrive_and_drop è°ƒç”¨æ‰€è°ƒæ•´ï¼Œå¹¶å¼€å§‹ä¸‹ä¸€é˜¶æ®µ\n\nåŒæ—¶è°ƒç”¨ barrier çš„æˆå‘˜å‡½æ•°ï¼Œé™¤äº†ææ„å‡½æ•°ï¼Œä¸å¼•å…¥æ•°æ®ç«äº‰\nä½è¿ç®—åº“ bit åº“å°è£…äº†ä¸€äº›å¸¸ç”¨çš„ä½æ“ä½œã€‚åŒ…æ‹¬ï¼š\nbit_castï¼šå°†ä¸€ä¸ªç±»å‹çš„å¯¹è±¡è¡¨ç¤ºé‡è§£é‡Šä¸ºå¦ä¸€ç±»å‹çš„å¯¹è±¡è¡¨ç¤ºbyteswapï¼šåè½¬ç»™å®šæ•´æ•°å€¼ä¸­çš„å­—èŠ‚has_single_bitï¼šæ£€æŸ¥ä¸€ä¸ªæ•°æ˜¯å¦ä¸ºäºŒçš„æ•´æ•°æ¬¡å¹‚bit_ceilï¼šå¯»æ‰¾ä¸å°äºç»™å®šå€¼çš„æœ€å°çš„äºŒçš„æ•´æ•°æ¬¡å¹‚bit_floorï¼šå¯»æ‰¾ä¸å¤§äºç»™å®šå€¼çš„æœ€å¤§çš„äºŒçš„æ•´æ•°æ¬¡å¹‚bit_widthï¼šå¯»æ‰¾è¡¨ç¤ºç»™å®šå€¼æ‰€éœ€çš„æœ€å°ä½æ•°rotlï¼šè®¡ç®—é€ä½å·¦æ—‹è½¬çš„ç»“æœrotrï¼šè®¡ç®—é€ä½å³æ—‹è½¬çš„ç»“æœcountl_zeroï¼šä»æœ€é«˜ä½èµ·è®¡é‡è¿ç»­çš„ 0 ä½çš„æ•°é‡countl_oneï¼šä»æœ€é«˜ä½èµ·è®¡é‡è¿ç»­çš„ 1 ä½çš„æ•°é‡countr_zeroï¼šä»æœ€ä½ä½èµ·è®¡é‡è¿ç»­çš„ 0 ä½çš„æ•°é‡countr_oneï¼šä»æœ€ä½ä½èµ·è®¡é‡è¿ç»­çš„ 1 ä½çš„æ•°é‡popcountï¼šè®¡é‡æ— ç¬¦å·æ•´æ•°ä¸­ä¸º 1 çš„ä½çš„æ•°é‡\nnamespace std &#123;  // bit_Â­cast  template&lt;class To, class From&gt;    constexpr To bit_cast(const From&amp; from) noexcept;   // ä½äº¤æ¢  template &lt;class T&gt;  constexpr T byteswap (T value) noexcept;   // 2 çš„æ•´æ•°æ¬¡å¹‚  template&lt;class T&gt;    constexpr bool has_single_bit(T x) noexcept;  template&lt;class T&gt;    constexpr T bit_ceil(T x);  template&lt;class T&gt;    constexpr T bit_floor(T x) noexcept;  template&lt;class T&gt;    constexpr T bit_width(T x) noexcept;   // æ—‹è½¬  template&lt;class T&gt;    [[nodiscard]] constexpr T rotl(T x, int s) noexcept;  template&lt;class T&gt;    [[nodiscard]] constexpr T rotr(T x, int s) noexcept;   // è®¡æ•°  template&lt;class T&gt;    constexpr int countl_zero(T x) noexcept;  template&lt;class T&gt;    constexpr int countl_one(T x) noexcept;  template&lt;class T&gt;    constexpr int countr_zero(T x) noexcept;  template&lt;class T&gt;    constexpr int countr_one(T x) noexcept;  template&lt;class T&gt;    constexpr int popcount(T x) noexcept;   // ç«¯åº  enum class endian &#123;    little = /* è§æè¿° */,    big    = /* è§æè¿° */,    native = /* è§æè¿° */  &#125;;&#125;\n\nrangesrangesæä¾›å¤„ç†å…ƒç´ èŒƒå›´çš„ç»„ä»¶ï¼ŒåŒ…æ‹¬å„ç§è§†å›¾é€‚é…å™¨ã€‚å…¶æœ€å¤§çš„ä½œç”¨å°±æ˜¯è®©æˆ‘ä»¬å¯ä»¥åƒç»„è£…å‡½æ•°ä¸€æ ·ç»„è£…ç®—æ³•ï¼Œä½¿ä»£ç æ›´åŠ é«˜æ•ˆã€ä¾¿åˆ©ã€å¯è¯»ã€‚æä¾›å‘½åç©ºé—´åˆ«å std::viewsï¼Œä½œä¸ºstd::ranges::views çš„ç¼©å†™\n#include &lt;ranges&gt;#include &lt;iostream&gt; int main()&#123;    auto const ints = &#123;0,1,2,3,4,5&#125;;    auto even = [](int i) &#123; return 0 == i % 2; &#125;;    auto square = [](int i) &#123; return i * i; &#125;;     // ç»„åˆè§†å›¾çš„â€œç®¡é“â€è¯­æ³•ï¼š    for (int i : ints | std::views::filter(even) | std::views::transform(square)) &#123;        std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;    &#125;     std::cout &lt;&lt; &#x27;\\n&#x27;;     // ä¼ ç»Ÿçš„â€œå‡½æ•°å¼â€ç»„åˆè¯­æ³•ï¼š    for (int i : std::views::transform(std::views::filter(ints, even), square)) &#123;        std::cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;    &#125;&#125;","categories":["C++"],"tags":["C++","C++ 20","Modern C++"]},{"title":"é«˜è´¨é‡å®æ—¶æ¸²æŸ“","url":"/2021/11/08/7/","content":"\n    \n\n\n\n\nOpenGLVertex Shader &amp; Fragment Shader\nFor each vertex in parallel æ¯ä¸€ä¸ªé¡¶ç‚¹éƒ½è¦åš\nåœ¨ OpenGL ä¸­è°ƒç”¨ç¨‹åºå®šä¹‰çš„ vertex shaderï¼šåšé¡¶ç‚¹å˜æ¢ï¼ŒåŒ…æ‹¬ MVP å˜æ¢ã€éœ€è¦æ’å€¼çš„å±æ€§è¾“å‡ºç»™ fragment shader\n\n\nFor each primitive, OpenGL rasterizes å¯¹æ¯ä¸€ä¸ªç‰‡å…ƒï¼ŒOpenGL è¿›è¡Œ  æ‰“æˆä¸€å †åƒç´ \nGenerates a fragment for each pixel the fragment covers\n\n\nFor each fragment in parallel æ¯ä¸€ä¸ªç‰‡æ®µéƒ½è¦åš\nåœ¨ OpenGL ä¸­è°ƒç”¨ç¨‹åºå®šä¹‰çš„ fragment shaderï¼šåšç€è‰²å’Œå…‰ç…§è®¡ç®—\n\n\n\nShadow MappingRender from Light &amp; Eye\nPass 1: Output a â€œdepth textureâ€ from the light source ä»å…‰æºçš„è§’åº¦å‡ºå‘ç”Ÿæˆä¸€å¹…æ·±åº¦å›¾\nPass 2: Render a standard image from eye\n\nProject to light for shadows\nProject visible points in eye view back to light source è¿å‘å…‰æºï¼Œæ¯”è¾ƒåœºæ™¯ä¸Šçš„æ·±åº¦å’Œ Shadow Map ä¸­çš„æ·±åº¦çš„å¤§å°\n\nIssues in Shadow MappingSelf Occlusion\n    \n\n\nä»å…‰æºçš„è§’åº¦çœ‹åœºæ™¯æ‰€å½¢æˆçš„ shadow map æ˜¯ä¸€ä¸ªç¦»æ•£çš„å›¾ï¼Œshadow map ä¸Šä¸€ä¸ªåƒç´ æ‰€è¦†ç›–çš„åŒºåŸŸæ˜¯çš„  æ·±åº¦å€¼  åˆ™ä¸ºä¸€ä¸ª  å¸¸æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ shadow map è®°å½•çš„æ·±åº¦ä¸æ˜¯è¿ç»­çš„ï¼Œä¸å®é™…åœºæ™¯ä¸ç¬¦ã€‚å½“è¿›è¡Œç¬¬äºŒæ¬¡ Pass æ—¶ï¼Œä»åœºæ™¯æŸä¸€ç‚¹å‡ºå‘çœ‹å‘å…‰æºï¼Œå°±ä¼šè¢«é®æŒ¡ä½ï¼Œå¦‚å›¾ä¸­é»‘è‰²éƒ¨åˆ†\n\nå¦‚æœå…‰æºæ–¹å‘ä»ä¸Šå¾€ä¸‹å‚ç›´ç…§å‘å¹³é¢çš„æ—¶å€™æ²¡æœ‰è‡ªé®æŒ¡çš„é—®é¢˜ï¼Œå¦‚æœå…‰æºæ–¹å‘å‡ ä¹å¹³è¡Œä¸å¹³é¢æ—¶è‡ªé®æŒ¡çš„é—®é¢˜æœ€ä¸¥é‡\n\n\nAdding a (variable) bias to reduce self occlusion\nå¦‚æœå®é™…çš„æ·±åº¦ä¸  å…‰æºæ·±åº¦  çš„å·®å€¼å°äºæŸä¸ªé˜ˆå€¼å°±ä¸ç®—é®æŒ¡ï¼Œç›¸å½“äºé®æŒ¡ç‰©è·åœºæ™¯é•¿çš„ç‚¹è¶³å¤Ÿå°å°±å¿½ç•¥è¿™ä¸ªé®æŒ¡ç‰©ã€‚è¿™ä¸ªé˜ˆå€¼å¯ä»¥ä¸æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œå¯ä»¥æ ¹æ®å…‰æºçš„è§’åº¦å˜åŒ–ã€‚ä¹Ÿå¯ä»¥ä»ä¸‹å›¾å»ç†è§£è¿™ä¸ª Shadow Biasã€‚\n\n    \n\n\nä½†æ˜¯å¯èƒ½å›é€ æˆæ‚¬æµ®ï¼ˆPeter Panningï¼‰çš„é—®é¢˜ï¼Œå› ä¸ºç‰©ä½“çœ‹èµ·æ¥è½»è½»æ‚¬æµ®åœ¨è¡¨é¢ä¹‹ä¸Šã€‚\nè§£å†³æ–¹æ¡ˆï¼ˆç›®å‰æ²¡æœ‰å®Œç¾çš„è§£å†³æ–¹æ¡ˆï¼‰ï¼š\n\næ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„ Shadow Biasâ€”â€”å·¥ä¸šç•Œçš„è§£å†³æ–¹æ³•\n\nSecond-dpeth shadow mappingâ€”â€”å®é™…ä¸­æ²¡æœ‰äººç”¨\n\nUsing the midpoint between first and second depths in shadow map\nrequires objects to be waterlight\nthe overhead may not worth it\n\n\n\n\n\nAliaså®æ—¶æ¸²æŸ“ä¸­é˜´å½±èƒŒåçš„æ•°å­¦çŸ¥è¯†There are a lot of useful inequalities in caculus\nè®¾  å’Œåœ¨  ä¸Šéƒ½å¯ç§¯ï¼Œåˆ™ï¼š\n\nSchwarz ä¸ç­‰å¼\n\nMinkowksi ä¸ç­‰å¼\n\n\nåœ¨å®æ—¶æ¸²æŸ“ä¸­ä¸å¤ªå…³å¿ƒä¸ç­‰ï¼Œå…³å¿ƒçš„æ˜¯è¿‘ä¼¼ç›¸ç­‰ï¼Œè´¯ç©¿æ•´ä¸ªå®æ—¶æ¸²æŸ“çš„ä¸€ä¸ªé‡è¦çš„ä¸ç­‰å¼å¦‚ä¸‹ï¼šä»€ä¹ˆæ—¶å€™ä¸Šè¿°ä¸ç­‰å¼æ›´åŠ å‡†ç¡®ï¼š\n\nçš„ support è¶³å¤Ÿå°\næ˜¯è¶³å¤Ÿå…‰æ»‘çš„\n\nPercentage Closer Soft Shadows\nPercentage Closer Filtering\n\nPerform multipule(e.g. ) depth comparisons for each fragment\nThen, averages result of comparisons\n\n\nè¿‡æ»¤æˆ–å¹³å‡çš„æ˜¯ä»€ä¹ˆï¼Ÿ\nå¹³å‡çš„æ˜¯ä»»æ„ shading point åšçš„å¾ˆå¤šæ¬¡é˜´å½±æ·±åº¦æ¯”è¾ƒçš„ç»“æœï¼Œæ—¢ä¸æ˜¯å¯¹ shadow map åšæ¨¡ç³Šæ“ä½œï¼Œä¹Ÿä¸æ˜¯å¯¹æœ€åçš„é˜´å½±å›¾åšæ¨¡ç³Šæ“ä½œ\n\n\nFilter size &lt;-&gt; blocker distance å¦‚ä½•ç¡®å®š filter çš„å¤§å°\n\n\n\n    \n\n\n\nThe complete algorithm of PCSS\nStep 1: Blocker search (getting the average blocker depth in a certain region)\nStep 2: Penumbra estimation (using the average blocker depth to determine the filter size)\nStep 3: Percentage Closer Filtering\n\nWhich region to perform blocker search? å¦‚ä½•ç¡®å®š blocker çš„å¤§å°\n    \n\n\nå…‰æºçœ‹å»ç”Ÿæˆä¸€ä¸ª shadow mapï¼Œå‡è®¾ shadow map æ”¾åœ¨è§†é”¥ä½“çš„è¿‘å¹³é¢ä¸Šï¼Œä» shading point è¿å‘å…‰æºï¼Œè®¡ç®—åœ¨ shadow map ä¸Šè¦†ç›–çš„åŒºåŸŸå³ä¸º blocker size\nVariance Soft Shadow MappingA Deeper Look at PCF\nFilter / Convolution\n\nIn PCSSæ¯ä¸€ä¸ª shadow map ä¸Š  ç‚¹çš„æ·±åº¦å’Œåœºæ™¯ä¸Š  ç‚¹çš„æ·±åº¦æ¯”è¾ƒï¼ŒæŒ‰ç…§æŸç§å½¢å¼åŠ æƒå¹³å‡èµ·æ¥\n\nTherefore, PCF is not filtering the shadow map then compare å¹¶ä¸æ˜¯å¯¹ shadow map åšæ¨¡ç³Šç„¶åæ¯”è¾ƒ\n\nAnd PCF is not filtering the resulting image with binary visibilities ä¹Ÿä¸æ˜¯æœ€åçš„é˜´å½±å›¾åšæ¨¡ç³Šæ“ä½œ\n\n\nVariance Soft Shadow MappingWhich step(s) can be slow?\nStep 1\nStep 3\n\nVariance Soft Shadow Mapping\nPCF å¯ä»¥ç†è§£ä¸ºåœ¨ä¸€åœºè€ƒè¯•ä¸­çŸ¥é“è‡ªå·±å¤šå°‘åˆ†ï¼Œæƒ³çŸ¥é“è‡ªå·±çš„æ’ååœ¨ç™¾åˆ†ä¹‹å‡ ï¼Œå°±éœ€è¦æŠŠæ‰€æœ‰çš„äººçš„æˆç»©éƒ½ç»Ÿè®¡å‡ºæ¥ï¼ŒVSSM åˆ™ä¸éœ€è¦çŸ¥é“æ‰€æœ‰äººçš„æˆç»©ï¼Œå°±å¥½æ¯”çŸ¥é“æˆç»©çš„åˆ†å¸ƒï¼Œç„¶åæ ¹æ®è‡ªå·±çš„æˆç»©å°±çŸ¥é“æ‰€åœ¨ä½ç½®äº†\n\n\nKey Idea: Quickly compute the mean and variance of depths in an area\n\nMean\n\nHardware MIPMAPing\nSummed Area Tables(SAT)\n\n\nVariance\n\n åˆ©ç”¨æœŸæœ›å’Œæ–¹å·®å…³ç³»çš„å…¬å¼ï¼Œå¯ä»¥ç”±å¦å¤–ä¸€ä¸ª shadow mapï¼Œè¿™ä¸ª shadow map è®°å½•çš„æ—¶æ‰€æœ‰æ·±åº¦å€¼çš„å¹³æ–¹ï¼Œåœ¨ OpenGL ä¸­å¯ä»¥å°†è¿™ä¸ªæ·±åº¦å¹³æ–¹çš„å€¼è®°å½•åœ¨å…¶ä»–é€šé“ä¸­ï¼ˆçº¹ç†ç”± Rã€Gã€Bã€A å››ä¸ªé€šé“ï¼Œshadow map å ç”¨ä¸€ä¸ªé€šé“ï¼‰\nJust generate a â€œsquare-depth mapâ€ along with the shadow map\n\n\nPercentage of texels that are closer than the shading point çŸ¥é“äº†æœŸæœ›å’Œæ–¹å·®å¦‚ä½•è®¡ç®—æ·±åº¦æ¯” shading point æ›´è¿‘ç‚¹çš„å æ¯”\nå¯ç”±å•è¾¹åˆ‡æ¯”é›ªå¤«ä¸ç­‰å¼æ›´å¿«çš„ç®—å‡ºæ¥ï¼šæ˜¯å‡å€¼ï¼Œæ˜¯æ–¹å·®ï¼Œåªè¦çŸ¥é“å‡å€¼å’Œæ–¹å·®å³å¯å¸¦å…¥ä¸Šè¿°å…¬å¼ï¼Œä½†æ˜¯å¿…é¡»æ»¡è¶³ï¼Œå¯ä»¥ç›´è§‚æ„Ÿå—åˆ‡æ¯”é›ªå¤«ä¸ç­‰å¼\n\n    \n\n\nBlocker search\n    \n\n\nå‡è®¾ shading point çš„æ·±åº¦æ˜¯ 7ï¼Œå·²ç»çŸ¥é“äº†  åŒºåŸŸå¤§å°çš„å¹³å‡æ·±åº¦ï¼Œä½†æ˜¯å°äº 7 çš„é®æŒ¡ç‰©çš„å¹³å‡æ·±åº¦æ˜¯æœªçŸ¥çš„\n\nKey idea\nBlockerï¼ˆçš„éƒ¨åˆ†ï¼Œè“è‰²éƒ¨åˆ†ï¼‰çš„å¹³å‡å€¼è®°ä¸º\nNon-blockerï¼ˆçš„éƒ¨åˆ†ï¼Œçº¢è‰²éƒ¨åˆ†ï¼‰çš„å¹³å‡å€¼è®°ä¸º\næ»¡è¶³\næ ¹æ®åˆ‡æ¯”é›ªå¤«å¯ä»¥ä¼°è®¡ï¼šï¼Œ\nåˆåšäº†ä¸ªå‡è®¾ï¼šï¼Œä¾‹å¦‚å¤§å¤šæ•°çš„é˜´å½±æ¥å—ç‰©ä½“æ˜¯ä¸€ä¸ªå¹³é¢\n\n\nStep 1 solved with negligible additional cost\n\nSAT for Range Query\nNeed to quickly grab  and  from an arbitrary range (rectangular) éœ€è¦å¿«é€Ÿè®¡ç®—å‡ºä»»æ„çŸ©å½¢èŒƒå›´å†…çš„å‡å€¼å’Œæ–¹å·®\n\nå¯¹äºå‡å€¼ï¼ŒMIPMAP å’Œ Summed Area Table éƒ½å¯ä»¥æ¥è®¡ç®—ï¼ŒMIPMAP å­˜åœ¨è¯¯å·®çš„é—®é¢˜ï¼Œå¹¶ä¸”ä¸èƒ½æŸ¥è¯¢éæ­£æ–¹å½¢çš„åŒºåŸŸ\nClassic data structure and algorithm (prefix sum) ç»å…¸æ•°æ®ç»“æ„â€”â€”å‰ç¼€å’Œ  ä¸€ç»´ï¼š\n    \n\n\näºŒç»´ï¼š\n    \n\n\nMoment Shadow Mapping\n    \n\n\nMoments\næœ€ç®€å•çš„çŸ©ï¼š\nVSSM is essentially using the ï¬rst two orders of moments\n\nWhat can moments do?\nConclusion: first  orders of moments can represent a function with  steps\nUsually, 4 is good enough to approximate the actual CDF of depth dist\n\nEnvironment MappingDistance Field Soft Shadow\nDistance function: At any point, giving the minimun distance (could be signed distance) to the closest location on an object åœ¨ç©ºé—´ä¸­çš„ä»»ä½•ä¸€ä¸ªç‚¹ï¼Œåˆ°æŸä¸ªç‰©ä½“è¡¨é¢çš„æœ€å°è·ç¦»ï¼ˆè·ç¦»åœºå¯ä»¥æ˜¯æœ‰å‘çš„ï¼Œæ¯”å¦‚åœ¨ç‰©ä½“å†…éƒ¨ä¸ºè´Ÿï¼Œåœ¨ç‰©ä½“å¤–éƒ¨ä¸ºæ­£ï¼‰\n\nAn Example: Blending (linear interp.) a moving boundary\n\n    \n\n\nThe Usages of Distance Fields\nRay marching (Sphere tracing) to perform ray-SDF intersection\nä»»ä½•ä¸€ä¸ªç‚¹ä¸Šéƒ½ç›¸å½“äºå®šä¹‰äº†ä¸€ä¸ªå®‰å…¨è·ç¦»ï¼ˆsafe distanceï¼‰ï¼Œåˆ©ç”¨è¿™ä¸ªå®‰å…¨è·ç¦»å¯ä»¥è¿‘ä¼¼æ±‚å‡ºå…‰çº¿ä¸åœºæ™¯ä¸­ç‰©ä½“çš„äº¤ç‚¹\n\nUse SDF to determine the (approx.) percentage of occlusion\næŠŠå®‰å…¨è·ç¦»å»¶ç”³ä¸ºå®‰å…¨è§’åº¦ï¼ˆsafe angleï¼‰ï¼Œæœ€åè½¬æ¢ä¸ºé˜´å½±çš„å€¼\n\n\nHow to compute the safe angle?åˆ©ç”¨åä¸‰è§’å‡½æ•°ï¼šï¼Œå›¾å½¢å­¦ä¸­ä¸æå€¡è®¡ç®—åä¸‰è§’å‡½æ•°ï¼ˆè®¡ç®—é‡å¾ˆå¤§ï¼‰ï¼Œå¯ä»¥é€šè¿‡è·ç¦»çš„æ¯”å€¼æ¥è¡¨ç¤ºè§’åº¦çš„è¿‘ä¼¼ï¼Œå³ï¼šï¼Œç”¨æ¥æ§åˆ¶é˜´å½±çš„è½¯ç¡¬ç¨‹åº¦\nShading from Environment LightingHow to use it to shade point (without shadows)?\n    \n\n\nä¸è€ƒè™‘ visibilityï¼Œä»»ä½•ä¸€ä¸ª Shading Point éƒ½è¦æ±‚è§£è¿™ä¸ªæ¸²æŸ“æ–¹ç¨‹ï¼Œè®¡ç®—é‡ç‰¹åˆ«å¤§ï¼Œä¸èƒ½ç”¨åœ¨å®æ—¶æ¸²æŸ“ä¸­ï¼Œå³å¦‚æœå­˜åœ¨é‡‡æ ·ï¼ˆsampleï¼‰çš„æ“ä½œï¼Œå°±å¾ˆéš¾åº”ç”¨åœ¨å®æ—¶æ¸²æŸ“ä¸­\nThe Split Sum: 1st Stage\nRecall: the approximation\n\n\nConditions for acceptable accuracy? è¿™ä¸ªå…¬å¼ä»€ä¹ˆæ—¶å€™ä¼šæ¯”è¾ƒå‡†ç¡®\n\nçš„ support æ¯”è¾ƒå°çš„æƒ…å†µä¸‹â†’BRDF is glossy\næˆ–è€…  çš„å€¼æ¯”è¾ƒ smooth çš„æƒ…å†µä¸‹â†’BRDF is diffuse\n\n\näºæ˜¯å°±å¯ä»¥æŠŠå…‰æºé¡¹æ‹†å‡ºæ¥  æ‹†å‡ºæ¥çš„é¡¹ç›¸å½“äºæŠŠ Light å¯¹åº”åŒºåŸŸç§¯åˆ†å¹¶å½’ä¸€åŒ–ï¼Œä¹Ÿå°±æ˜¯æŠŠ IBL è¡¨ç¤ºçš„ä¸€å¼ å›¾è¿›è¡Œ  æ¨¡ç³Š\nä¸ºä»€ä¹ˆè¦åš pre-filteringï¼šThen query the per-filtered environment lighting at the (mirror reflected) drection\n\n\nThe Split Sum: 2nd Stage\nå¦‚ä½•é¿å…å¯¹ BRDF ç§¯åˆ†çš„é‡‡æ ·ï¼Œå³\n\nIdeaï¼šPrecompute its value for all possible combinations of variables roughness, color(Fresnel term), etc. é¢„è®¡ç®—æ‰€æœ‰çš„å‚æ•°çš„å¯èƒ½æ€§\nåŸºäºå¾®è¡¨é¢çš„ BRDF éœ€è¦è€ƒè™‘çš„å‚æ•°ï¼š\n\nfresnel term è²å°¼å°”é¡¹\nNDF å¾®è¡¨é¢çš„æ³•çº¿åˆ†å¸ƒ\n\n\nRecall : Microfacet BRDF\n\n    \n\n\nè²å°¼å°”é¡¹å¯ä»¥ç”¨ Schlickâ€™s æ–¹æ³•è¿‘ä¼¼ï¼šï¼šåˆå§‹åå°„ç‡\nï¼šå…¥å°„è§’åº¦\næ³•çº¿åˆ†å¸ƒå¯ä»¥ä½¿ç”¨ Beckmann distributionï¼šï¼šç‰©ä½“çš„ç²—ç³™åº¦\nï¼šåŠç¨‹å‘é‡å’Œæ³•çº¿çš„å¤¹è§’\n\n    \n\n\nç”±äºä¸¤ä¸ªç±»å‹çš„è§’åº¦å¯ä»¥è¿‘ä¼¼ï¼Œé¢„è®¡ç®—çš„ç»´åº¦ä¸ºä¸‰ç»´ï¼Œä½†ä»ç„¶éœ€è¦é™ç»´ã€‚å¯ä»¥æŠŠè²å°¼å°”é¡¹çš„è¿‘ä¼¼å½¢å¼â€”â€”Schlickâ€™s å¸¦å…¥åˆ°ç§¯åˆ†ä¸­ï¼šEach integral produces one value for each (roughness, incident angle) pair\nåœ¨å®æ—¶é¢†åŸŸã€å·¥ä¸šç•Œé€šå¸¸å†™ä¸ºæ±‚å’Œï¼Œæ‰€ä»¥ä¹Ÿè¢«ç§°ä¸º split sum æ–¹æ³•ï¼š\n\n\n\n\nShadow from environment lighting\nIn general, very difficult for real-time rendering ç¯å¢ƒå…‰ç…§ä¸‹çš„é˜´å½±åšä¸åˆ°\n\nDifferent perspectives of view\nAs a many-light problem ç¯å¢ƒå…‰ç…§å¯ä»¥è®¤ä¸ºæ˜¯å¾ˆå¤šå…‰æºï¼Œæ¯ä¸€ä¸ªå…‰æºéƒ½è¦ç”Ÿæˆä¸€ä¸ª Shadow Map ä»£ä»·éå¸¸å¤§\nAs a sampling problem é€šè¿‡è§£æ¸²æŸ“æ–¹ç¨‹éœ€è¦å¤§é‡çš„é‡‡æ ·ï¼Œæ±‚è§£ Visibility Term é¡¹æ˜¯æœ€éš¾çš„ï¼Œåªèƒ½ç›²ç›®çš„é‡‡æ ·\n\nIndustrial solutionGenerate one (or a little bit more) shadows ä»æœ€äº®çš„ä¸€ä¸ªæˆ–å‡ ä¸ªå…‰æºä¸‹ç”Ÿæˆé˜´å½±\nPrecomputed Radiance TransferBackground knowledgeFourier TransformRepresent a function as a weighted sum of sines and cosines ä¸€ä¸ªå‡½æ•°å¯ä»¥å†™æˆè‹¥å¹²  é¡¹å’Œ  é¡¹çš„ç»„åˆ\nA general understandingAny product integra can be considered as filtering ä¸¤ä¸ªå‡½æ•°ç›¸ä¹˜å†ç§¯åˆ†å°±è®¤ä¸ºæ˜¯æ»¤æ³¢æ“ä½œ\nBasis FunctionsA set of functions that can be used to represent other functions in general ä¸€ä¸ªå‡½æ•°å¯ä»¥æè¿°ä¸ºå…¶ä»–å‡½æ•°çš„çº¿æ€§ç»„åˆ\n\nThe Fourier series is a set of basis functions\nThe polynomial series can also be a set of basis functions ()\n\nReal-time environment lightingSpherical Harmonics\nå®šä¹‰ï¼šA set of 2D basis functions  defined on the sphere ä¸€ç³»åˆ—å®šä¹‰åœ¨çƒé¢ä¸Šçš„äºŒç»´åŸºå‡½æ•°ï¼Œâ€œçƒé¢ä¸Šâ€è¡¨ç¤ºæ–¹å‘\n\n\n    \n    Alternative picture for the real spherical harmonics\n\n&gt; åˆ°åº•æ˜¯ä»€ä¹ˆï¼Ÿ\n&gt;\n&gt; ä¸€å †å‡½æ•°ï¼Œæ¯ä¸€é˜¶æ‹¥æœ‰ä¸€ç§é¢‘ç‡ï¼Œé˜¶è¶Šé«˜å¯¹åº”çš„åŸºå‡½æ•°çš„æ•°é‡è¶Šå¤š\n\n\nEach SH basis function  is associated with a (Legendre) polynomial\n\nProjection: obtaining the coefficient of each SH basis function å·²çŸ¥ä»»ä½•ä¸€ä¸ªäºŒç»´çš„å‡½æ•° ï¼Œä»»ä½•ä¸€ä¸ªåŸºå‡½æ•°å¯¹åº”çš„ç³»æ•°å¯ä»¥é€šè¿‡ Product Integral è·å¾—ï¼Œæ±‚ç³»æ•°çš„è¿‡ç¨‹å°±å«åš æŠ•å½±\n\n\nAnalytic Irradiance Formula\n    \n    ç”¨ SH æè¿°BRDF\n\n\nç”¨ä¸åŒé˜¶çš„ SH æè¿°  å…¨å±€å…‰ç…§\n\n    \n\n\n\nå¯¹äºä»»ä½•çš„å…‰ç…§æ¡ä»¶ï¼Œåªè¦æè´¨æ˜¯ Diffusedï¼Œéƒ½å¯ä»¥ç”¨å‰ä¸‰é˜¶çš„ SH æ¥  æè¿°å…‰ç…§\n\nA Brief Summarization\nUsage of basis function\nRepresenting any function (with enough #basis) è¶³å¤Ÿå¤šçš„åŸºå‡½æ•°å¯ä»¥è¡¨ç¤ºä¸€ä¸ªå‡½æ•°\nKeeping a certain frequency contents (with a low #basis) ä¿ç•™ä¸€äº›ä½é¢‘ä¿¡æ¯ï¼Œå¯ä»¥ç”¨å‰å‡ é˜¶çš„åŸºå‡½æ•°\nReducing integrals to dot products\n\n\nBut here itâ€™s still shading from environment lighting\nNo shadows yet ä»ç„¶æ²¡æœ‰åŠ å…¥é˜´å½±\n\n\n\nPrecomputed Radiance TransferRendering under environment lighting\n\nï¼šLigghting Term ç¯å¢ƒå…‰\nï¼šVisibility Term ä»ä¸€ç‚¹å¾€å››é¢å…«æ–¹çœ‹ï¼Œç»“æœè¦ä¹ˆæ˜¯ 0ï¼Œè¦ä¹ˆæ˜¯ 1\nï¼šBRDF Term åŸæœ¬æ˜¯å››ç»´çš„ï¼Œä½†æ˜¯ä»æŸä¸ªåœ°æ–¹çœ‹å³è¡¨ç¤ºçŸ¥é“è§‚å¯Ÿæ–¹å‘ï¼Œä¹Ÿå°±çŸ¥é“äº†å…¥å°„æ–¹å‘ï¼Œå°±å¯ä»¥ç”¨äºŒç»´å˜é‡æè¿°\n\n\n, incoming directions\n,view directions\n\nBrute-force computation è¿™ä¸‰é¡¹éƒ½å¯ä»¥æè¿°æˆäºŒç»´çš„çƒé¢å‡½æ•°ï¼Œå¦‚æœè¿™æ ·è®¡ç®—é‡ä¼šç‰¹åˆ«å¤§\nBasic idea of PRT\nå‡è®¾ï¼šåœºæ™¯ä¸­å…¶ä»–æ‰€æœ‰çš„éƒ½ä¸å˜ï¼Œåªæœ‰å…‰ç…§ä¼šå‘ç”Ÿå˜åŒ–ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ light transport ä¹Ÿå¯ä»¥å½“ä½œçƒé¢å‡½æ•°\n\n\nApproximate lighting using basis functions æŠŠå…‰ç…§æ‹†æˆ basis functions\n\n\n\nPrecomputation stage\ncompute light transport, and project to basis function space\n\n\nRuntime stage\ndot product (diffuse) or matrix-vector multiplication (glossy)\n\n\n\nDiffuse Case\nBRDFâ€”â€”æ˜¯ä¸€ä¸ªå¸¸å€¼\n\n\n\nä¸€ç§ç†è§£æ–¹å¼\n\nä¸Šå¼ä¸­çš„  å°±æ˜¯ light transport çš„çƒé¢å‡½æ•°æŠ•å½±åˆ°æŸä¸ªåŸºå‡½æ•°ä¸Šçš„  ç³»æ•°\n\nReduce rendering computation to dot product å°±æ˜¯ä¸¤ä¸ªå‘é‡çš„ç‚¹ä¹˜\n\n\n\nå¦ä¸€ç§ç†è§£æ–¹å¼\n\nSeparately precompute lighting and light transport\nå…‰ç…§é¡¹åˆ†åˆ«ä¸º lighting coefficient å’Œ basis functions\n\n\n\nå…‰ç…§ä¼ è¾“é¡¹åˆ†åˆ«ä¸º lighting transport coefficient å’Œ basis functions\n\n\n\n\nWhy is it a dot product? (This seems to be  rather than ?)\nè™½ç„¶çœ‹èµ·æ¥åƒæ˜¯äºŒç»´çš„æ±‚å’Œï¼Œä½†æ˜¯æ ¹æ® SH çš„æ­£äº¤æ€§ï¼Œåªæœ‰å½“  æ—¶ç§¯åˆ†ä¸ä¸º 0ï¼›ç›¸å½“äºè®¡ç®—äºŒç»´çŸ©é˜µå¯¹è§’çº¿ä¸Šçš„å€¼\n\n\n\nGlossy Case\nä¸ Diffuse çš„åŒºåˆ«åœ¨äº BRDFï¼ŒDiffuse çš„ BRDF æ˜¯ä¸€ä¸ªå¸¸æ•°ï¼ŒGlossy çš„ BRDF è¡¨ç¤ºä¸åŒæ–¹å‘å…¥å°„å…‰çº¿ç…§åˆ°ç‰©ä½“è¡¨é¢ï¼Œåå°„åˆ°ä¸åŒçš„æ–¹å‘çš„ç»“æœï¼Œæ‰€ä»¥ Glossy çš„ BRDF æ˜¯ä¸€ä¸ª  å››ç»´  çš„å‘é‡ã€‚ç»™å®šä»»æ„è§‚å¯Ÿæ–¹å‘ ï¼Œlight transport éƒ½ä¼šæŠ•å½±å‡ºæ¥ä¸€ç»„å®Œå…¨ä¸åŒçš„å‘é‡ï¼Œæ‰€ä»¥åœ¨ä»»æ„è§‚å¯Ÿæ–¹å‘ä¸Š light transport ä¸æ˜¯ä¸ªå¸¸æ•°ï¼Œè€Œæ˜¯ çš„å‡½æ•°\n\nGlossy çš„ç‰©ä½“æœ‰ä¸€ä¸ªéå¸¸é‡è¦çš„æ€§è´¨â€”â€”å’Œè§†ç‚¹æœ‰å…³ ï¼ŒDiffuse çš„ç‰©ä½“å’Œ è§†ç‚¹æ— å…³\n\nInterreflections and Caustics\n\nLï¼šLight å…‰ç…§\nEï¼šEye çœ¼ç›\nGï¼šGlossy\nDï¼šDiffuse\nSï¼šSpecular\n\n\nRuntime is independent of transport complexity\nL(D|G)*Eã€LS*(D|G)*E èµ·ç‚¹éƒ½æ˜¯å…‰ç…§ï¼Œç»ˆç‚¹éƒ½æ˜¯è§†è§’ï¼Œä¸­é—´çš„éƒ¨åˆ†éƒ½å¯ä»¥è®¤ä¸ºæ˜¯ Light Transportï¼Œæ‰€ä»¥è¿è¡Œæ—¶çš„å¤æ‚åº¦å’Œ Light Transport çš„å¤æ‚åº¦æ— å…³\nBasis Functions Properties æ€§è´¨\northonormal æ­£äº¤æ€§\n\nsimple projection/reconstruction æŠ•å½±æ˜“ç®—\n\nProjection to SH space\n\nReconstruction\n\n\n\nsimple rotation æ—‹è½¬ä»»æ„ä¸€ä¸ªåŸºå‡½æ•°æŸä¸ªè§’åº¦ï¼Œéƒ½å¯ä»¥è¢«åŒé˜¶çš„åŸºå‡½æ•°çº¿æ€§ç»„åˆå¾—åˆ°\n\nsimple convolution\n\nfew basis functions: low freqs\n\n\nMore basis functions\nSpherical Harmonics (SH)\nWavelet å®šä¹‰åœ¨äºŒç»´å¹³é¢ä¸Š\n2D Haar wavelet\nProjection\nWavelet Transformation\nRetain a small number of  non-zero coefficients  ä¿ç•™äº†ä¸€å°éƒ¨åˆ†éé›¶çš„åŸºå‡½æ•°çš„ç³»æ•°\n\n\nA non-linear approximation ä¿ç•™éé›¶æˆ–æœ€å¤§çš„æ•°å€¼\nAll-frequency representation æ”¯æŒå…¨é¢‘ç‡è¡¨ç¤º\nä¸æ”¯æŒå¿«é€Ÿæ—‹è½¬\n\n\nZonal Harmonics\nSpherical Gaussian (SG)\nPiecewise Constant\n\nPrecomputation\nlight transport æŠ•å½±åˆ°ä»»ä½•ä¸€ä¸ªåŸºå‡½æ•°ä¸Šï¼Œç›¸å½“äºç”¨ basis functions æ‰€æè¿°çš„ç¯å¢ƒå…‰ç…§ï¼Œç…§äº®å„ä¸ªç‰©ä½“ï¼Œä»è€Œè®¡ç®—ç‰©ä½“å„ä¸ªç‚¹ä¸Š shading çš„å€¼ï¼Œç›¸å½“äº render equation\n\n\nRun-time Rendering\n\nRendering at each point is reduced to a dot product\nFirst, project the lighting to the basis to obtain \nOr, rotate the lighting instead of re-projection\nThen, compute the dot product\n\n\nReal-time: easily implemented in shader\n\nReal-Time Global IlluminationReflective Shadow Maps (RSM)\nWhich surface patches are directly lit? ä»€ä¹ˆæ ·çš„è¡¨é¢èƒ½éƒ½è¢«å…‰æºç›´æ¥ç…§å°„åˆ°\n\nPerfectly solved with a classic shadow map å¯ä»¥é€šè¿‡ Shadow Map è®¡ç®—å‡º\nEach pixel on the shadow map is a small surface patch Shadow Map ä¸Šçš„æ¯ä¸€ä¸ªåƒç´ éƒ½æ˜¯ä¸€ç‰‡æ¬¡çº§å…‰æº\nAssumption\nAny reflector is diffuse å‡è®¾ä»»ä½•æ¬¡çº§å…‰æºçš„æè´¨éƒ½æ˜¯ Diffuse\nTherefore, outgoing radiance is uniform toward all directions\n\n\n\n\nWhat is the contribution from each surface patch to \n\n    \n\n\n\nAn integration over the solid angle covered by the patch\nCan be converted to the integration on the area of the patch\n\n\n\nFor a diffuse reflective path\n\n\n\n\n\nTherefore\n\n\n\nNot all pixels in the RSM can contribute\n\nVisibility å¯è§æ€§\nOrientation æ–¹å‘\nDistance è·ç¦»\n\n\nWhat is needed to record in an RSM?\n\nDepth\nWorld coordinate\nNormal\nflux\netc.\n\n\n\nLight Propagation Volumes (LPV)\n\nKey problem\nQuery the radiance from any direction at any position ä»ä»»ä½•ä¸€ä¸ªæ–¹å‘åˆ°è¾¾ä»»æ„ä¸€ç‚¹çš„ radiance æ˜¯å¤šå°‘\n\nKey Idea\nRadiance travels in straight line and does not change radiance åœ¨ä¼ æ’­è¿‡ç¨‹ä¸­ä¸ä¼šè¡°å‡\n\nKey solution\nUse a 3D grid to propagate radiance from directly illuminated surfaces to anywhere else\n\n\n\nSteps\nGeneration of raidance point scene representation å“ªäº›ç‚¹ä½œä¸ºæ¬¡çº§å…‰æºï¼ˆå“ªäº›ç‚¹æ¥æ”¶åˆ°ç›´æ¥å…‰ç…§ï¼‰\n\nThis is to find directly lit surfaces å“ªäº› surface è¢«ç›´æ¥ç…§äº®\nSimply applying RSM would suffice å¯ä»¥åˆ©ç”¨ RSM\nMay use a reduces set of diffuse sufface patches (virtual light sources) ä¸å¿…è¦æ‰€æœ‰çš„ patch éƒ½å½“ä½œæ¬¡çº§å…‰æºï¼Œå¯ä»¥åˆ©ç”¨é‡‡æ ·ç­‰æ–¹æ³•é™ä½ patch çš„æ•°é‡\n\n\nInjection of point cloud of virtual light sources into radiance volume æŠŠåœºæ™¯ä¸­æ¥æ”¶åˆ°ç›´æ¥å…‰ç…§çš„ç‚¹æ”¾åˆ°åœºæ™¯ä¸­åˆ’åˆ†å¥½çš„æ ¼å­ä¸­\n\nPre-subdivide the scene into a 3D grid é¦–å…ˆåœºæ™¯ä¸­æœ‰ä¸€ä¸ªä¸‰ç»´çš„æ ¼å­ï¼Œå·¥ä¸šç•Œå¤§å¤šæ•°ç”¨ä¸‰ç»´çº¹ç†\nFor each grid cell, find enclosed vitual light sources æ¯ä¸ªæ ¼å­å†…éƒ½æœ‰æœå‘ä¸åŒçš„æ¬¡çº§å…‰æº\nSum up their directional radiance distribution æŠŠè¿™äº›æ¬¡çº§å…‰æºçš„ radiance ç´¯åŠ \nProject to first 2 orders of SHs (4 in total) åˆ©ç”¨ SH å¯¹æ¯ä¸ªæ ¼å­å†…çš„æ¬¡çº§å…‰æºçš„åˆ†å¸ƒè¿›è¡Œå‹ç¼©\n\n\nVolumtric radiance propagation\n\nFor each grid cell collect the radiance received from each of its 6 faces \n\n    \n\nSum up, and again use SH to represent\n\nRepeat this propagation several times till the volume becomes stable è¿­ä»£\n\n\n\nScene lighting with final light propagation volume ä¼ æ’­å®Œæˆåå°±çŸ¥é“äº†åœºæ™¯ä¸­æ¯ä¸ªæ ¼å­ä¸Šçš„ radianceï¼Œç›´æ¥æ‹¿å»æ¸²æŸ“\n\nFor any shading point, find the grid cell it is located in\nGrab the incident radiance in the grid cell (from all directions)\nShade\n\n\n\nLight leaking\n    \n    \n\n\n\nå‡è®¾  ç‚¹æ˜¯æ¬¡çº§å…‰æºï¼Œä½†æ˜¯æ— è®ºå¦‚ä½•éƒ½ä¸ä¼šæœ‰ä»  ç‚¹åå°„å‡ºå»çš„ radiance åˆ°å³è¾¹çš„æƒ…å†µï¼Œä½†æ˜¯ç”±äºæŠŠåœºæ™¯åˆ’åˆ†æˆæ ¼å­ï¼Œè¿™ä¸¤ä¸ªç‚¹éƒ½åœ¨ä¸€ä¸ªæ ¼å­é‡Œé¢ï¼Œæ‰€ä»¥è¿™ä¸¤ä¸ªç‚¹çš„ radiance æ˜¯ä¸€æ ·çš„ã€‚å¦‚æœæ ¼å­åˆ’åˆ†çš„ç‰¹åˆ«å°æ˜¯å¯ä»¥è§£å†³ light leaking çš„é—®é¢˜ï¼Œä½†æ˜¯è®¡ç®—æ—¶é—´å’Œå­˜å‚¨çš„é—®é¢˜ï¼Œå·¥ä¸šç•Œä¼šç”¨ä¸åŒåˆ†è¾¨ç‡çš„æ ¼å­â€”â€”cascade\n\nVoxel Global Illumination (VXGI)\n\nStill a two-pass algorithm\nTwo main diffetences with RSM\nDirectly illuminated pixels -&gt; (hierachical) voxel ä» RSM çš„åƒç´ è¡¨ç¤ºçš„å¾®å°çš„è¡¨é¢åˆ°æ•´ä¸ªåœºæ™¯åˆ’åˆ†å‡ºæ¥å…·æœ‰å±‚æ¬¡ç»“æ„çš„æ ¼å­\nSampling on RSM -&gt; tracing reflected cones in 3D (Note the inaccuracy in sampling RSM) RSM å’Œ LPV åšä¼ æ’­éƒ½æ˜¯ ray-tracingï¼ˆæ¯ä¸ªç‚¹ç”¨ä¸€ä¸ªå…‰çº¿ä¼ æ’­ï¼‰ï¼ŒVXGI æ˜¯ cone-tracingï¼ˆæ¯ä¸ªç‚¹ç”¨é”¥å½¢çš„å½¢å¼è¿›è¡Œå…‰çº¿ä¼ æ’­ï¼‰\n\n\n\n\nReal-Time Global Illumination (Screen Space)Whatâ€™s is â€œscreen spaceâ€?\n\nUsing information only from â€œthe screenâ€\nIn other words, post processing on existing renderings\n\nScreen Space Ambient Occlusion (SSAO)Why AO? ä¸ºä»€ä¹ˆè¦Ambient Occlusion\nCheap to implement\nBut enhances the sense of relative positions é€šè¿‡é˜´å½±çš„æ–¹å¼ï¼Œç‰©ä½“çš„ç«‹ä½“æ„Ÿçš„æ›´åŠ æ˜æ˜¾äº†\n\nWhat is SSAO?\nAn approximation of global illumination å¯¹å…¨å±€å…‰ç…§çš„è¿‘ä¼¼\nIn screen space\n\nTheory\nStill, everything starts from the rendering equation\n\nAnd again\n\nSepatating the visibility term æŠŠ visibility é¡¹æ‹†é™¤å»\n\nä¹˜å·  å·¦è¾¹ä¸€é¡¹å¯ä»¥å†™ä¸ºï¼ˆthe weight-averaged visibility  from all directionsï¼‰ï¼š\nä¹˜å·  å³è¾¹ä¸€é¡¹å¯ä»¥å†™ä¸ºï¼ˆconstant for AOï¼‰ï¼š\n\nA deeper understanding 1the average  in the support of \n\nA deeper understanding 2\n\nWhy can we take the cosine term with ?\n\n\nProjected solid angle \nå°†å•ä½çƒä¸Šçš„é¢ç§¯æŠ•å½±åˆ°ä¸€ä¸ªå•ä½åœ†ä¸Š\n\nunit hemisphere -&gt; unit disk\nintegration of peojected solid angle -&gt; the area of the unit disk\n\n\n    \n\n\n\nActually, a much simpler understanding\n\nUniform incident lighting -  is constant\n\nDiffuse DSDF -  is also constant\n\nTherefore, taking both out of the integral:\n\n\n\n\nAmbient occlusion using the z-buffer\n    \n\n\n\nUsing the readily available depth buffer as an approximation of the scene geometry ä»»ä½•ä¸€ä¸ª Shading Point éƒ½ä»¥è‡ªèº«ä¸ºä¸­å¿ƒï¼ŒåŠå¾„ä¸º  çš„çƒå†…éƒ¨é‡‡æ ·ä¸€äº›ç‚¹ï¼Œåˆ¤æ–­é‡‡æ ·ç‚¹èƒ½å¦è¢« Shading Point çœ‹åˆ°\nTake samples in a sphere around each pixel and test against buffer \nIf more than half the samples are inside, AO is applied, amount depending on ratio of samples that pass and fail depth test\nUses sphere instead of hemisphere, since normal information isnâ€™t available æ‰€æœ‰çš„æ¸²æŸ“æ–¹ç¨‹çš„å®šä¹‰åŸŸéƒ½æ˜¯åŠçƒï¼Œé‚£ä¸ºä»€ä¹ˆ AO ç”¨æ•´ä¸ªçƒï¼Ÿå› ä¸º Camera æ¸²æŸ“å‡ºæ¥ä¸èƒ½æ—¢çŸ¥é“æ·±åº¦æœ‰çŸ¥é“æ³•çº¿ï¼Œä¸çŸ¥é“æ³•çº¿å°±æ— æ³•ç”¨åŠçƒæ¥ä¼°è®¡\nApproximation of the scene geometry, some fails are incorrect. The one behind the red line for example. False occlusions.\nSamples are not weighted by , so not physically accurate, but looks convincing.\n\nHorizon based ambient occlusion (HBAO)\nAlso done in screen space.\nApproximates ray-tracing the depth buffer\nRequires that the normal is know, and only samples in a hemisphere\n\n\n    \n\n\nScreen Space Directional Occlusion (SSDO)Very similar to path tracing\nAt shading point , shoot a random ray\nif it does not hit an obstacle, direct illumination\nIf it hits one, indirect illumination\n\nComparison with SSAO\nAO: indirect illumination +  no indirect illuminatino\nåœ¨ AO ä¸­ï¼Œçº¢è‰²åœˆå†…çš„è¡¨ç¤ºèƒ½æ¥æ”¶åˆ°é—´æ¥å…‰ç…§ï¼Œæ©™è‰²åœˆå†…çš„è¡¨ç¤ºæ²¡æœ‰é—´æ¥å…‰ç…§\n\nDO: no indirect illumination +  indirect illuminatino\nåœ¨ DO ä¸­ï¼Œçº¢è‰²åœˆå†…åˆ™è¡¨ç¤ºç›´æ¥å…‰ç…§ï¼Œæ©™è‰²åœˆå†…åˆ™è¡¨ç¤ºèƒ½æ¥æ”¶åˆ°é—´æ¥å…‰ç…§\n\n\n\n    \n\n\nConsider unoccluded and occluded directions separately\nSSDO similar to HBAO\n\n\nä»  ç‚¹å¾€ ã€ã€ã€ æ–¹å‘çœ‹èƒ½ä¸èƒ½è¢«æŒ¡ä½ï¼Œè¿˜åšä¹‹å‰çš„å‡è®¾â€”â€”ä¸ç®¡ä»  åˆ°èƒ½ä¸èƒ½è¢«æŒ¡ä½ï¼Œåªè€ƒè™‘ä»ç›¸æœºåˆ°  èƒ½ä¸èƒ½è¢«æŒ¡ä½ï¼ˆéå¸¸å¤§èƒ†çš„å‡è®¾ï¼Œä½†ä¸€å®šç¨‹åº¦ä¸Šæ˜¯æœ‰æ•ˆçš„ï¼‰ã€‚å³é¢çš„ä¸€å¹…å›¾å¯ä»¥ç†è§£ä¸ºå¯¹  æœ‰è´¡çŒ®çš„ç‚¹çš„å’Œï¼Œç‚¹ç”±äºè¢«é®æŒ¡æ‰€ä»¥ä¸è®¡ç®—åœ¨å†…ã€‚è¿™æ ·å‡è®¾ä¹Ÿä¼šå‡ºç°ä¸€äº›å¤§é—®é¢˜ï¼Œå¦‚ç¬¬ä¸‰å¹…å›¾çš„æƒ…å†µâ€”â€”ä»ç›¸æœºè§†è§’è¢«ä¸€ä¸ªæ‚¬æµ®çš„ç‰©ä½“æŒ¡ä½äº†ï¼Œä½†æ˜¯  ç‚¹æ˜¯å¯ä»¥ç›´æ¥çœ‹åˆ°  ç‚¹ã€‚\nIssues\nGI in a short range åªèƒ½è§£å†³ä¸€ä¸ªå°çš„èŒƒå›´å†…çš„å…¨å±€å…‰ç…§\n\nVisibility å¯¹äºå¯è§æ€§ä¸å‡†ç¡®\n\nScreen space issue: missing informaiton from unseensurfaces ä¸¢å¤±çœ‹ä¸è§éƒ¨åˆ†çš„ä¿¡æ¯\n\n    \n\n\nScreen Space Reflection (SSR)What is SSR?\nStill, one way to intoduce Global Illumination in RTR å®æ—¶æ¸²æŸ“ä¸­å®ç°å…¨å±€å…‰ç…§çš„ä¸€ç§æ–¹å¼\nPerforming ray tracing å±å¹•ç©ºé—´ä¸Šçš„å…‰çº¿è¿½è¸ª\nBut does not require 3D primitives (triangles, etc.) ä¸éœ€è¦ä¸‰ç»´ç©ºé—´ä¸­çš„å„ç§ä¿¡æ¯\n\nTwo fundametal tasks of SSR\nIntersection: between any ray and scene\nShading: contribution from intersected pixels to the shading point\n\nBasic SSR Algorithm - Mirror Reflection\nFor each fragment\n\nCompute reflection ray\nTrace along ray direction (using depth buffer)\nUse color of intersection point as reflection color\n\n\nLinear Raymarch (Find intersection point)\n\n    \n\n\n\nAt each step, check depth value\nQuality depends on step size\nCan be refined\n\n\nGenerate Depth Mip-Map\n\n    \n\n\n\nUse min values instead of average\n\n    \n\n\n\nå’Œæ­£å¸¸çš„ Mip-Map çš„åšæ³•ä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºï¼Œä¸Šä¸€å±‚çš„ 4 ä¸ªåƒç´ ä¸å†æ˜¯ä¸‹ä¸€å±‚çš„å¹³å‡å€¼ï¼Œè€Œæ˜¯æœ€å°å€¼ï¼Œä¹Ÿå°±æ˜¯æ·±åº¦ç¦»åœºæ™¯æœ€è¿‘çš„ä½ç½®\n\n\n\nâ€‹            \nWhy Depth Mipmap\nVery similar to the hierarchy(BVH, KD-tree) in 3D å¯¹åœºæ™¯å»ºç«‹ä¸€ä¸ªå±‚æ¬¡ç»“æ„\nEnabling faster rejecting of non-intersecting in a bunch å¾ˆå®¹æ˜“è·³è¿‡ä¸å¯èƒ½ç›¸äº¤çš„åƒç´ \nThe min operation guarantees a conservative logic è¿™ä¸ªæœ€å°çš„æ“ä½œå°±ä¼šå¾—åˆ°ä¸€ä¸ªä¿å®ˆçš„é€»è¾‘\nIf a ray does not even intersect a larger node, it will never intersect any child nodes of it å¦‚æœä¸€ä¸ªåƒç´ ä¸å’Œå…¶ä¸Šå±‚çš„åƒç´ ç›¸äº¤ï¼Œä¹Ÿä¸å¯èƒ½å’Œä¸‹å±‚çš„åƒç´ ï¼ˆå­èŠ‚ç‚¹ï¼‰ç›¸äº¤\n\n\n\n\n    \n\nmip = 0;while (level &gt; -1){    step through current cell;    if (above Z place) ++level;    if (below Z plane) --level;}\t\n\n\n\nProblem\nHidden Geometry Problem å¯¹åœºæ™¯çš„ç†è§£åªåˆ°å¤–é¢çš„â€œå£³â€\nEdge Cutoff ä¼šå‡ºç°æ˜æ˜¾çš„ cut\nEdge Fading æ ¹æ®åå°„å…‰èµ°çš„è·ç¦»åšè¡°å‡ï¼Œè™šåŒ–è¾¹ç¼˜\n\n\n\nShading using SSR\nAbsolutely no difference from path tracing ä»åœ¨ä¸‰ç»´åœºæ™¯ä¸­çš„å…‰çº¿è¿½è¸ªåˆ°åœºæ™¯ä¸­â€œå£³â€çš„å…‰çº¿è¿½è¸ª\n\nJust again assuming diffuse reflections / secondary lights\n\n\nRequirements\n\nSharp and blurry reflections\nContact hardening\nSpecular elgonation\nPer-pixel roughness and normal\n\n\nImprovements\n\nBRDF importance sampling\n\n\n\nReal-Time Physically-Based Materials (surface models)Microfacet BRDF å¾®è¡¨é¢PBR and PBR Materials\nPhysically-Based Rendering(PBR)\nEverything in rendering should be physically based\nMaterials, lighting, camera, light transport, etc.\nNot just materials, but usually referred to as materials :)\n\n\nPBR materials in RTR\nThe RTR community is much behind the offline community åœ¨å®æ—¶æ¸²æŸ“ä¸­çš„ PBR æè´¨è¦è½åäºç¦»çº¿æ¸²æŸ“\nâ€œPBâ€ in RTR is usually not actually physically based :) åœ¨å®æ—¶æ¸²æŸ“ä¸­æåˆ°çš„â€œPhysically-Basedâ€åŸºæœ¬éƒ½ä¸æ˜¯â€œPhysically-Basedâ€\nFor surfaces, mostly just micorfacet models (used wrong so not PBR) and disney principled (artist friendly but still not PBR)\nFor volumes, mostly focused on fast and approximate single scattering and multiple scattering (for clound, hair, skin, etc.)\n\n\n\nMicrofacet BRDF\n Fresnel term\nä»ä¸€ä¸ªè§’åº¦çœ‹è¿‡å»ï¼Œæœ‰å¤šå°‘èƒ½é‡è¢«åå°„ã€‚å½“ç«™åœ¨æ²³è¾¹ï¼š\nå‚ç›´æ°´é¢çœ‹ä¸‹å»åå°„çš„å…‰å°±ä¼šå°‘\nçœ‹æ°´é¢è¿œå¤„çš„åœ°æ–¹åå°„çš„å…‰ä¼šå¢åŠ \n\n\nAccurate: need to consider polarization ç²¾ç¡®çš„æ–¹ç¨‹å¼éœ€è¦è€ƒè™‘åˆ°æåŒ–\nApproximate: Schlickâ€™s approximation ç®€å•çš„ä¼°è®¡\n\n åŸºç¡€åå°„ç‡ \n\n\n\n: shadowing-masking term: distribution of normals NDF(Normal Distribution Function) æ³•çº¿çš„åˆ†å¸ƒ\nConcentrated &lt;==&gt; flossy\nSpread &lt;==&gt; diffuse\n\nNormal Distribution Function (NDF)\nhas noting to do with the normal distribution in stats ä¸åŒäºç»Ÿè®¡å­¦ä¸­çš„æ­£æ€åˆ†å¸ƒ\nVarious models to describe it: Beckmann, GGX, etc.\n\nBeckmann NDF\n\nSimilar to a Gaussian\n\nBut defined on the slope space å¡åº¦ç©ºé—´\n\n    \n\n\n\nä½¿ç”¨  ä½œä¸ºå‚æ•°å¯ä»¥æ°¸è¿œä¿è¯ä¸å­˜åœ¨é¢æœä¸‹çš„å¾®è¡¨é¢\n\n\n\n\n\n: roughness of the surface (the samller, the more like mirror/specular) ç›¸å½“äºæ­£å¤ªåˆ†å¸ƒçš„æ ‡å‡†å·®\n: angle between half vector  and normal \nGGX (or Trowbridge-Reitz)\nTypical characteristic: long tail æ˜æ˜¾çš„ç‰¹ç‚¹ï¼šâ€œé•¿å°¾â€\nåœ¨ grazing angle çš„æ—¶å€™è¿˜æ˜¯æœ‰èƒ½é‡\n\nExtending GGXGTR (Generalized Trowbridge-Reitz), even longer tails æ›´é•¿çš„â€œæ‹–å°¾â€\nShadowing-Masking TermOr, the geometry term \n\nAccount for self-occlusion of microfacets è§£å†³çš„æ˜¯å¾®è¡¨é¢ä¹‹é—´è‡ªé®æŒ¡çš„é—®é¢˜ä»¥åŠ grazing angles çš„é—®é¢˜\nShadowing â€“ light, masking â€“ eye ä» light çš„è§’åº¦çœ‹ï¼Œå¾®è¡¨é¢è‡ªé®æŒ¡çš„ç°è±¡â€”â€”Shadowing ä»çœ¼ç›çš„è§’åº¦çœ‹ï¼Œçœ‹ä¸åˆ°å¾®è¡¨é¢çš„ç°è±¡â€”â€”Masking\nProvide darkening esp. around grazing angles éœ€è¦æä¾›ä¸€ä¸ªå˜æš—çš„æ“ä½œ\n\nA commonly used shadowing-masking term\nThe Smith shadowing-masking term\nDecupling shadowing and masking å°† shadowing å’Œ masking åˆ†å¼€\n\n\nKulla-Conty Approximation for Multiple Bounces\nMissing energy èƒ½é‡æŸå¤±\n\nEspecially prominent when roughness is high éšç€ç²—è¶…åº¦å¢å¤§èƒ½é‡æŸå¤±è¶Šæ˜æ˜¾\nå¾®è¡¨é¢è¶Šç²—ç³™åº¦ï¼Œæ²Ÿå£‘è¶Šå¤§ï¼Œå½“å…‰çº¿æ‰“åˆ°å¾®è¡¨é¢çš„æ—¶å€™ï¼Œåå°„çš„å…‰è¶Šå®¹æ˜“è¢«å…¶ä»–çš„å¾®è¡¨é¢æŒ¡ä½ï¼ŒæŸå¤±çš„èƒ½é‡è¶Šå¤š\n\n\nAdding back the missing energy\n\nHeitz et al. 2016 åŸºäºæ¨¡æ‹Ÿçš„æ–¹æ³•\nBut can be too slow for RTR\n\n\nThe Kulla-Conty Approximation\n\nWhatâ€™s the overall energy of an outgoing 2D BRDF lobe[1]?\n\n \n\n\nKey Idea è®¾è®¡äº†ä¸€ç§ BRDFï¼Œä½¿å¾—ä¸¢å¤±çš„èƒ½é‡æ­£æ˜¯åŸæ¥ä¸¢æ‰çš„éƒ¨åˆ†\n\nWe can design an additional lobe that intergrates to  æœ‰å¤šå°‘èƒ½é‡è¢«é®æŒ¡æ‰\nThe outgoing BRDF lobe can be different for different incident dir.\nConsider reciprocity, it should be of the form \nTherefor,  \nPrecompute / tabulate\n\n\nWhat if the BRDF has color?\n\næœ‰é¢œè‰²æ„å‘³ç€æœ‰èƒ½é‡è¢«å¸æ”¶ï¼Œæ„å‘³ç€èƒ½é‡æœ‰æŸå¤±\nSo weâ€™ll just need to compute the overall energy loss ç”±äºé¢œè‰²é€ æˆçš„èƒ½é‡æŸå¤±\n\n\nDefine the average Frensel (how much energy is reflected) ä¸ç®¡å…¥å°„è§’å¤šå¤§ï¼Œè®¡ç®—å¹³å‡æ¯æ¬¡åå°„ä¼šæŸå¤±å¤šå°‘èƒ½é‡  \n\nTherefor, the proportion of energy (color) that æœ€åèƒ½çœ‹åˆ°çš„èƒ½é‡çš„æ„æˆ\n\nYou can directly see:  \nAfter one bounce then be seen:  \nâ€¦\nAfter  bounces then be seen:  \n\n\nAdding everything up, we have the color term çº§æ•°æ±‚å’Œå¾—åˆ°æœ€ç»ˆçš„ç»“æœ\n\nWhich will be directly multiplied on the uncolored  additional BRDF\n\n  \n\n\n\n\nShading Microfacet Models using Linearly Transformed Cosines (LTC)\nSolves the shading of microfacet models\n\nMainly on GGX, though others are also fine\nNo shadows ä¸è€ƒè™‘é˜´å½±\nUnder polgon shaped lighting å¤šè¾¹å½¢å…‰æº\nSplit Sum æœ¬è´¨ä¸Šæ˜¯åšç¯å¢ƒå…‰ä¸‹çš„ Shading\n\n\nKey Idea\n\nAny outgoing 2D BRDF lobe can be transformed to a cosine\nThe shape of the light can be transformed along\nIntegration the transformed light on a cosine lobe is analytic è½¬æ¢åçš„ç§¯åˆ†æ˜¯æœ‰ è§£æè§£ çš„\n\n\nObservations ä»»ä½• cosine çš„ lobe éƒ½å¯ä»¥é€šè¿‡  å˜æ¢ï¼Œå˜æ¢æˆ BRDF çš„ lobe\n\nBRDF  Cosine\nDirection: \nDomain to integrate: \n\n\n\n\n    \n\n\n\nApproach\n\nA simple change of variable æ›¿æ¢å˜é‡ \n\n\n\næ¸²æŸ“æ–¹ç¨‹æœ‰ä¸‰ä¸ªéƒ¨åˆ†ï¼šå…¥å°„å…‰ã€Cosineã€BRDFï¼Œè¡¨ç¤ºæŠŠ Cosine å’Œ BRDF åˆåˆ°äº†ä¸€èµ·ï¼Œåœ¨å¤šè¾¹å½¢è¦†ç›–çš„ç«‹ä½“è§’å†…è¿›è¡Œç§¯åˆ†\né€šè¿‡è¿™ä¸ªå˜æ¢æŠŠ  å˜æˆ Cosine\nå¼•å…¥ Jacobi é¡¹\nç»™å®šä¸€ä¸ª GGX æ¨¡å‹çš„æ³•çº¿åˆ†å¸ƒï¼Œå·²çŸ¥å‡ºå°„çš„ BRDF çš„ lobeï¼Œå˜æ¢æˆ Cosineï¼›ä»ä¸åŒçš„æ–¹å‘è§‚å¯Ÿå¾—åˆ°ä¸åŒçš„ BRDF çš„ lobeï¼Œæ¯ä¸€ç§ lobe éƒ½è¦å˜æ¢æˆ Cosineï¼Œå¯¹äºå¸¸è§çš„ lobe å¯ä»¥é¢„è®¡ç®—ä¸€ä¸ªå˜æ¢çŸ©é˜µ\nå„é¡¹å¼‚æ€§çš„è¡¨é¢å¯ä»¥ç”¨ LTCï¼Œå„é¡¹å¼‚æ€§ï¼šæœ‰ä¸€æ ¹å…‰çº¿æ‰“å…¥åï¼Œæ ¹æ®ä¸åŒçš„è§‚å¯Ÿæ–¹å‘ï¼Œä¼šæœ‰ä¸åŒçš„ BRDF\n\n\nDisneyâ€™s Principled BRDF\nMotivation\n\nNo physically-based materials are good at rep. all real materials å¾®è¡¨é¢æ¨¡å‹å¹¶ä¸èƒ½è¡¨ç¤ºæ‰€æœ‰çš„æè´¨\nPhysically-based materials are not artist friendly å¯¹â€œè‰ºæœ¯å®¶â€æ¥è¯´éå¸¸ä¸å‹å¥½\ne.g. â€œthe complex index of refraction â€\n\n\n\n\n\n\n    \n\n* A table showing the effects of **individual** parameters\n    * subsurface æ¬¡è¡¨é¢æ•£å°„ æ¯” Diffuse è¿˜è¦å¹³çš„æ•ˆæœ\n    * metallic é‡‘å±æ€§\n    * specular ç›¸å½“äº Blinn-Phong æ¨¡å‹ä¸­çš„ï¼Œæ§åˆ¶é•œé¢åå°„åŒºåŸŸçš„å¤§å°\n    * specular Tint å¯ä»¥è¡¨ç¤ºé•œé¢åå°„çš„é¢œè‰²\n    * roughness ç²—ç³™ç¨‹åº¦\n    * anisotropy å„é¡¹å¼‚æ€§\n    * sheen é›¾åŒ–æ•ˆæœ\n    * sheen Tint é›¾åŒ–æ•ˆæœï¼ˆé¢œè‰²ï¼‰\n    * clearcoat æ¸…æ¼†\n    * clearcoat Gloss æ¸…æ¼†ï¼ˆå…‰æ»‘ç¨‹åº¦ï¼‰\n\nNon-Photorealistic Rendering (NPR éçœŸå®æ„Ÿæ¸²æŸ“ï¼‰\nCharacteristics of NPR\n\nStarts from photorealistic rendering\nExploits abstraction\nStrengthens important parts\n\n\nApplications of NPR\n\nArt è‰ºæœ¯\nVisualization å¯è§†åŒ–\nInstruciton è¯´æ˜ä¹¦\nEducation\nEntertainment å¨±ä¹\nâ€¦\n\n\n\nOutline Rendering\nOutlines are not just contours ä¸ä»…ä»…æ˜¯è½®å»“\n[B]oundary / border edge è¾¹ç•Œï¼›è¾¹ç¼˜\n[C]rease æŠ˜ç—•\n[M]aterial edge æè´¨çš„è¾¹ç•Œ\n[S]ilhouette edge å‰ªå½±ï¼›æœ‰å¤šä¸ªé¢å…±äº«çš„è¾¹ç•Œ\nå¿…é¡»æ˜¯ç‰©ä½“çš„å¤–è½®å»“è¾¹ç•Œ\næœ‰å¤šä¸ªé¢å…±äº«çš„è¾¹ç•Œ\n\n\n\n\n\n\n\nOutline Rendering â€“ Shading [Silhouette]Darken the surface where the shading normal is perpendicular to viewing direciton è§‚å¯Ÿçš„æ–¹å‘å’Œç‰©ä½“ä¸ŠæŸä¸€ç‚¹çš„æ³•çº¿æ–¹å‘å‡ ä¹å‚ç›´çš„è¾¹å°±æ˜¯ [Silhouette] è¾¹ï¼Œä½†ä¼šé€ æˆæè¾¹ç²—ç»†ä¸ä¸€æ ·\nOutline Rendering â€“ GeometryBackface fattening\n\nRender frontface normally \nâ€œFattenâ€ backfaces, then render again èƒŒå‘è§‚å¯Ÿè€…çš„é¢ä¸Šçš„ä¸‰è§’é¢ç‰‡éƒ½æ‰©å¤§ï¼Œç„¶åè¿›è¡Œæ¸²æŸ“\nExtension: fatten along vertex normals\n\nOutline Rendering â€“ ImageEdge detection in images\n\nUsually use a Sobel detector\n\nColor blocks å¤§é‡çš„è‰²å—\nHard shading: thresholding on shading åœ¨ shading çš„è¿‡ç¨‹ä¸­é˜ˆå€¼åŒ–\nPosterization: thresholding on the final image color åœ¨æœ€åçš„å›¾åƒä¸Šé˜ˆå€¼åŒ–\nMay not be binary é˜ˆå€¼åŒ–ä¸ä¸€å®šåªæ˜¯äºŒå€¼åŒ–\n\nSome Note\nNPR is art driven\nBut you need the ability to â€œtranslateâ€ artistsâ€™ needs into rendering insights\nCommunicaiton is important\nSometimes, per character, even per part\n\nReal-Time Ray Tracing (RTRT)In 2018, NVIDA announced GeForce RTX series (Turing architecture) æœ‰äº† RTX ä¹‹åï¼Œå…è®¸æˆ‘ä»¬æ¯ç§’è¿½è¸ªæ›´å¤šçš„å…‰çº¿ ï¼ˆtensor core åŠ é€Ÿç¥ç»ç½‘ç»œæ„ŸçŸ¥ï¼›RT core åŠ é€Ÿå…‰çº¿è¿½è¸ªï¼‰ï¼Œæ¯ç§’é’Ÿèƒ½å¤Ÿè¿½è¸ª 10G çš„å…‰çº¿ï¼Œç„¶è€Œå®é™…åº”ç”¨ä¸­ï¼šåªèƒ½ä¸€ä¸ªåƒç´ ç”¨ä¸€ä¸ªæ ·æœ¬é‡‡æ ·ï¼Œå¾—åˆ°å…‰çº¿è¿½è¸ªçš„ç»“æœ\n1 SPP(sample per pixel) path tracing = 1 rasterization (primary) + 1 ray (primary visibility) + 1 ray (secondary bounce) + (secondary visibility)\n\nrasterization å…‰æ …åŒ–å’Œ primary ray çš„ç»“æœæ˜¯ç­‰ä»·çš„ï¼Œä½†æ˜¯å…‰æ …åŒ–å¯ä»¥æ›´å¿«\n1 SPP å™ªå£°æ˜¯ä¸€ä¸ªå¤¸å¼ çš„ç»“æœ\næ‰€ä»¥ RTX å…³é”®çš„æŠ€æœ¯æ˜¯ Denosing é™å™ª\n\nGoals with 1 SPP\n\nQuality (no overblur, no artifacts, keep all details â€¦)\nSpeed (less than 2ms to denoise one frame)\n\nIndustrial Solution Temporal\n\nSuppose the previous frame is denoised and reuse it è®¤ä¸ºå½“å‰å¸§çš„å‰ä¸€å¸§æ˜¯å·²ç»æ»¤æ³¢å¥½äº†çš„\nUse motion vectors to find previous locations\nEnssentially increased SPP\n\nG-Buffers\n\nThe auxiliary infomation acquired FOR FREE* during rendering åœ¨æ¸²æŸ“åœºæ™¯çš„è¿‡ç¨‹ä¸­â€œå…è´¹â€å¾—åˆ°çš„ä¸€äº›ä¿¡æ¯ï¼Œä½† FOR FREE* å¹¶ä¸æ˜¯ 100% çš„â€œå…è´¹â€\nUsually, per pixel depth, normal, world coordinate, etc.\nTherefore, only screen space info\n\nBack Projection\nPixel  in the current frame \n\nWhere was it in the last frame i - 1 ? è¦æ‰¾åˆ°ä¸Šä¸€å¸§åƒç´   åœ¨å“ªï¼Œä½†æ˜¯å¯ä»¥æ¢ä¸€ç§æè¿°\nWhat pixel in fram  contains the same place/point that you see through pixel  in frame ? åœ¨ä¸Šä¸€å¸§å“ªä¸€ä¸ªåƒç´ æ˜¯åœ¨å½“å‰å¸§æ‰€è§‚å¯Ÿåˆ°çš„ç‚¹\n\n\nBack projection \n\nif world coord  is available as a G-buffer, just take it ç¬¬ä¸€ç§æ–¹æ³•\nOtherwise, (still require  value) ç¬¬äºŒç§æ–¹æ³•\nMotion is known: , thus  ç‰©ä½“å¦‚æœå­˜åœ¨è¿åŠ¨\nProject world coord in frame  to its screen: \n\n\n\nTemporal Accum./Denoising\n\n: unfiltered\n: filtered\n\n\nThis frame (-th frame)\\bar{C}^{(i)} = \\alpha\\bar{C}^{(i)} + (1 - \\alpha)\\tilde{C}^{(i - 1)}, \\alpha \\in [0.1, 0.2]$$\n\n80% - 90% cobtributions from last frame(s)\n\nTemporal Failure\nTemporal info is not always available\n\nFailure case 1: switching scenes (burn-in period) åˆ‡æ¢åœºæ™¯æˆ–è€…ç¬¬ä¸€å¸§\nFailure case 2: walking backwards in a hallway (screen space issue) åœ¨èµ°å»Šä¸­å€’é€€é•œå¤´ï¼Œè¶Šæ¥è¶Šå¤šçš„ä¿¡æ¯ä¼šå‡ºç°åœ¨è§†é‡èŒƒå›´å†…\nFailure case 3: suddenly appearing background (disocclusion)\n\nAdjustments to Temporal Failure\n\nClamping: Clamp previous toward current æŠŠä¸Šä¸€å¸§çš„ç»“æœâ€œæ‹‰â€åˆ°å½“å‰å¸§\nDetection æ£€æµ‹åˆ°åº•è¦ä¸è¦ç”¨ä»¥å‰çš„ä¿¡æ¯\nUse e.g. object ID to detect temporal failure æ¯ä¸ªç‰©ä½“éƒ½ç»™å®šä¸€ä¸ªæ¸²æŸ“ ID\nTune , binary or continuously å¾®è°ƒ\nPossibly strengthen / enlarge spatial filtering \nä¼šé‡æ–°å¼•å…¥ä¸€äº›å™ªå£°\n\n\n\n\n\nSome Side Notes\n\nThe temporal accumulation is inspired by Temporal Anti-Aliasing(TAA) è¿™ä¸¤ä¸ªæ¦‚å¿µå‡ ä¹ç­‰åŒ\nThey are very similar\nTemporal reuse essentially increses the sampling rate\n\n\n\nImplementation of filteringSuppose we want to (low-pass) filter an image å¸Œæœ›ä¿ç•™ä½é¢‘ä¿¡æ¯\n\nTo remove (usually high-frequency) noise\nNow only focus on the spatial domain spatial domain ç©ºé—´åŸŸåŒºåˆ«äºé¢‘åŸŸ\n\nInputs\n\nA noisy image \nA filter kernel , could vary per pixel\n\nOutput - A filterd image \nLetâ€™s assume a Gaussian filter centered at pixel  (2D)\n\nAny peixl  in the neighborhood of  would contribute ä»é«˜æ–¯çš„  èŒƒå›´å†…å–ï¼ŒåŒ…æ‹¬æœ¬èº«\nBased on the distance between  and \n\n  \n\nç›®çš„æ˜¯åšå½’ä¸€åŒ– Test whether  is zero (for other kernels) å¯¹äºå…¶ä»–çš„æ»¤æ³¢æ ¸éœ€è¦åˆ¤æ–­ ä¸ä¸º 0ï¼Œé«˜æ–¯æ»¤æ³¢æ ¸å¿…å®šä¸ä¸º 0Color can be multi-channel\n\n\n\nBilateral filtering åŒè¾¹æ»¤æ³¢Observation The boundary &lt;-&gt; drastically changing colors è¾¹ç•Œå°±æ˜¯é¢œè‰²å˜æ¢éå¸¸å‰§çƒˆçš„åœ°æ–¹\nIdea\n\nHow to keep the boundary?\nLet pixel  contribute less if its color is too different to  å¦‚æœ  å’Œé¢œè‰²å·®è·å¾ˆå¤§ï¼Œå°±è®©  çš„è´¡çŒ®å˜å°\n\n\næ˜¯ä¸€ä¸ªç‚¹ï¼Œæ˜¯å¦ä¸€ä¸ªç‚¹\nJoint Bilateral filtering è”åˆåŒè¾¹æ»¤æ³¢\nGaussian filtering: 1 metric (distance) é«˜æ–¯æ»¤æ³¢æå‡ºäº†ä¸€ä¸ªæ ‡å‡†â€”â€”è·ç¦»\nBilateral filtering: 2 metric (position distance &amp; color distance) åŒè¾¹æ»¤æ³¢æå‡ºäº†ä¸¤ä¸ªæ ‡å‡†\n\n\n    \n\n\nSuppose we consider å‡è®¾è€ƒè™‘ G-Buffer ç”Ÿæˆçš„ä¸¤ç§ç§é¢å¤–çš„ä¿¡æ¯\n\nDepth\nNormal \nColor é¢œè‰²ä¸å±äº G-Buffer ç”Ÿæˆå‡ºæ¥çš„\n\nWhy we do not blur the boundary between\n\nA and B: depth\nB and C: normal\nD and E: color\n\nImplementing Large Filters\nFor samll filters, this is fine (e.g. )\nFor large filters, this can be prohibitively heavy (e.g. )\n\nSolution 1: Separate Passes\nConsider a 2D Gaussian filter\n\nSeprate it inro a horizontal pass () and a vertical pass () å¯¹äºä»»ä½•ä¸€ä¸ªåƒç´ æ¥è¯´ï¼Œéƒ½å–å®ƒå‘¨å›´  æˆ–çš„èŒƒå›´è¿›è¡Œé«˜æ–¯æ»¤æ³¢\n#queries:  æŸ¥è¯¢æ¬¡æ•°ä»  åˆ°\n\n\nä¸ºä»€ä¹ˆèƒ½å¤Ÿä»  åˆ°\nA 2D Guassian filter kernel is separable äºŒç»´çš„é«˜æ–¯å‡½æ•°çš„å®šä¹‰å°±æ˜¯å¯ä»¥æ‹†åˆ†çš„\n\nfiltering == convolution æ»¤æ³¢å°±æ˜¯å·ç§¯\n\n\nSolution 2: Progressively Growing Sizes\nA-trous wavelet\n\nMultiple passes, each is a  filter\nTher interval between samples is growing () (save e.g. ) æ ·æœ¬å’Œæ ·æœ¬ä¹‹é—´çš„é—´éš”éƒ½æ˜¯\n  \n\n\n\n\nWhy growing sizesï¼Ÿä¸ºä»€ä¹ˆè¦ç”¨é€æ¸å¢å¤§çš„ filterï¼Œè€Œä¸æ˜¯ç›´æ¥ä½¿ç”¨ä¸€ä¸ªå¤§çš„ filter\nApplying larger filter == removing lower frequencies ç”¨æ›´å¤§çš„ filter æ„å‘³ç€å»é™¤æ›´ä½çš„é¢‘ç‡ï¼Œç”¨è¶Šå°çš„ filter æ„å‘³ç€å»æ‰æ›´é«˜çš„é¢‘ç‡ï¼Œä¸æ–­çš„å»é™¤ä¸åŒçš„é¢‘ç‡\n\nWhy is it safe to skip samples? ä¸ºä»€ä¹ˆèƒ½å¤Ÿè·³ç€é‡‡æ ·\nSampling == repeating the spectrum é‡‡æ ·åœ¨é¢‘åŸŸå°±æ˜¯æ¬ç§»é¢‘è°±ï¼Œå°†æœ‰è§„åˆ™çš„é¢‘è°±æ®µæ¬ç§»åˆ°æ— è§„åˆ™çš„é¢‘è°±æ®µ\n\n\n\n   \n\n\nå¦‚å›¾æ‰€ç¤ºï¼Œé€šè¿‡ç¬¬ä¸€ä¸ª passï¼Œé«˜é¢‘ç‡éƒ¨åˆ†è¢«å¹²æ‰ï¼Œæ‰€æœ‰çš„é¢‘ç‡éƒ½é›†ä¸­åœ¨è“è‰²åŒºåŸŸå†…ï¼Œç¬¬äºŒä¸ª pass ç›¸å½“äºåšäº†ä¸€ä¸ªé‡‡æ ·ï¼Œä¹Ÿå°±æ˜¯æŠŠç¬¬ä¸€ä¸ª pass ç•™ä¸‹æ¥çš„é¢‘è°±å‘å·¦æˆ–å‘å³æ¬ç§»ä¸€æ¬¡\n\nOutlier RemovalFiltering is not aimighty\n\nSometimes the filtered result still noisy, even blocky\nMostly due to extremely bright pixels (outliers)\n\nOutlier Detection and Clamping\nFor each pixel, take a look at its e.g.  neighborhood\nCompute mean and variance è®¡ç®—å‡å€¼å’Œæ–¹å·®\nValue outside   outlier åœ¨èŒƒå›´ä¹‹å¤–çš„å°±æ˜¯ outlier\nClamp any value outside  to this range\nNote: this is NOT throwing away (zero out) the outlier å¹¶ä¸æ˜¯ä¸¢å¼ƒæ‰ outlierï¼Œè€Œæ˜¯æŠŠ outlier é™åˆ¶åˆ°ä¸€ä¸ªèŒƒå›´å†…\n\nSpatiotemporal Variance-Guided Filtring (SVGF)3 factors to guide filtering \n\n    \n\n\n\nDepth\n\n\nA and B are on the same plane, of similar color, so they should be contribute to each other. But the depth between A and B are very different\nåªæ˜¯æœ‰è¡°å‡çš„å½¢çŠ¶ä½†å¹¶ä¸æ˜¯é«˜æ–¯çš„å½¢å¼ï¼Œæ˜¯ä¸ºäº†é˜²æ­¢å‡ºç°é™¤ 0 çš„æƒ…å†µï¼Œæ§åˆ¶è¡°å‡å¿«æ…¢çš„å‚æ•°ï¼ŒA å’Œ B å…¶å®æ˜¯åœ¨åŒä¸€å¹³é¢ä¸Šï¼Œä½†æ˜¯å¦‚æœç”¨æ­£å¸¸çš„æ·±åº¦æ¯”è¾ƒ A å’Œ B çš„æ·±åº¦å·®è·ä¼šå¾ˆå¤§ï¼Œæ‰€ä»¥ä½¿ç”¨ä»–ä»¬æ‰€åœ¨çš„åˆ‡å¹³é¢ä¸Šçš„æ·±åº¦å·®å¼‚ã€‚ä»»ä¸€ç‚¹çš„æ·±åº¦çš„æ¢¯åº¦ï¼Œé‚£ä¹ˆ  å¯ä»¥è¡¨ç¤ºä¸ºæ·±åº¦çš„å˜åŒ–é‡\n\nNormal\n\n\nç‚¹ç§¯å¯ä»¥ç¡®å®šä¸¤ä¸ªå‘é‡çš„å·®å¼‚ï¼Œå˜åŒ–ç³»æ•°\nNote: in case normal maps exist, use macro normal æœ‰æ³•çº¿è´´å›¾çš„æƒ…å†µ\n\nColorB ç‚¹å¯èƒ½åˆšå¥½å–åˆ°å™ªå£°ä¸Šï¼Œéœ€è¦ç”¨ B ç‚¹æ ‡å‡†å·®ï¼Œæ‰€ä»¥è¦ç”¨åˆ° SVGF ä¸­çš„ Variance\nCaculate spatially in \nAlso averaged over time using motion vectors\nTake another  spatial filter before use å°±æ˜¯åœ¨ä½¿ç”¨å‰è®¡ç®—å‡ºæ¥çš„\n\n\n\nLuminance (grayscale color value)\n\nRecurrent AutoEncoder (RAE)Interactive Reconstruction of Monte Carlo Image Sequence using a Recurrent denoising AutoEncoder\n\nA post-processing network that does denosing \nWith help of G-buffers\nThe network automatically performs temporal accumulation\n\nKey architecture design\n\nAutoEncoder (or U-Net) structure\nRecurrent convolutional block\n\n\n    \n\n\nA Glimpse of Instustrail SolutionTemporal Anti-Aliasing (TAA)Why aliasing?\n\nNot enough samples per pixel during rasterization\nTherefor, the ultimate solution is to be use more samples\n\n\n    \n\n\n\n    \n\n\n\nMSAA (Multisample) vs SSAA (Supersampling)\nSSAA is straightforward\nRenderring at a larger resolutiont, then downsample æŠŠåœºæ™¯æŒ‰ç…§åŸæ¥å‡ å€çš„åˆ†è¾¨ç‡æ¸²æŸ“ï¼Œæ¸²æŸ“å®Œæˆåå†è¿›è¡Œé™é‡‡æ ·\nThe ultimate solution, but costly åŸºæœ¬ä¸Š 100% æ­£ç¡®\n\n\nMSAA: an improvement on performance åœ¨ SSAA åŸºç¡€ä¸Šåšäº†è¿‘ä¼¼æ˜¯çš„æ•ˆç‡èƒ½å¤Ÿæä¸Šå»\nThe same primitive is shaded only once æ¯ä¸ªä¸‰è§’å½¢åªé‡‡æ ·ä¸€æ¬¡ï¼Œé€šè¿‡ç»´æŠ¤ä¸€ä¸ªè¡¨æ¥å®ç°\nReuse samples across pixels\n\n\n\n\nState of the art image based anti-aliasing solution\nSMAA (Enhanced subpixel morphological AA)\nHistory: FXAA â†’ MLAA (Morphological AA) â†’ SMAA\n\n\nG-buffers should never be anti-aliased\n\nTemporal Super ResolutionSuper resolution (or super sampling)\n\nliteral understanding: increasing resolution ç»™ä¸€å¼ ä½åˆ†è¾¨ç‡çš„å›¾å˜æˆé«˜åˆ†è¾¨ç‡çš„å›¾\nSource 1 (DLSS 1.0): out of nowhere / completely guessed ä¿¡æ¯æ¥æºä»€ä¹ˆéƒ½æ²¡æœ‰ï¼Œå…¨é çŒœ\nSource 2 (DLSS 2.0): from temporal information\nMain Problem\nUpon temporal failure, clamping is no longer an option\nBecause we need a clear value for each smaller pixel\nTherefore, key is how to use temporal info samrter than clamping\n\n\nAn important practical issue\nIf DLSS itself runs at 30ms per frame, itâ€™s dead already\nNetwork inference performance optimization (classified)\n\n\n\n\n\nDeferred ShadingOriginally invented to save shading time èŠ‚çœ shading çš„æ—¶é—´\nConsider the rasterization process\n\nTriangles â†’ fragments â†’ depth test â†’ shade â†’ pixel\nEach fragment needs to be shaded (in what scenario?) åœ¨ä»€ä¹ˆæƒ…å†µä¸‹æ¯ä¸€ä¸ª fragment éƒ½éœ€è¦ shadingï¼Œä»è¿œåˆ°è¿‘æ¸²æŸ“å¯èƒ½ä¼šå‡ºç°\nComplexity: \n\nKey Observation\n\nMost fragment will not be seen in the final image å¾ˆå¤š fragment æœ€åä¸ä¼šè¢«çœ‹åˆ°ï¼Œä½†æ˜¯ä¸­é—´æŸä¸ªé˜¶æ®µå¯¹å…¶è¿›è¡Œäº†ç€è‰²\nDue to depth test / occlusion\nCane we only shade those visible fragments?\n\nModifying the rasterizaiton process\n\nJust rasterize the scene twice å…‰æ …åŒ–ä¸¤æ¬¡\nPass 1: no shading, just update the depth buffer ç¬¬ä¸€æ¬¡ä¸åšç€è‰²ï¼Œåªå¯¹æ·±åº¦ç¼“å­˜è¿›è¡Œæ›´æ–°\nPass 2 is the same (why does this guarantee shading visible fragment only?) ç¬¬äºŒæ¬¡å…‰æ …åŒ–å¼€å§‹åšç€è‰²\nImplicitly, this is assuming rasterzing the scene is way faster then shading all unseen fragments (usually trye) è·‘ä¸€è¾¹å…‰æ …åŒ–çš„æ—¶é—´è¦æ¯”æ¸²æŸ“å…¨éƒ¨ fragments çš„æ—¶é—´è¦å¿«\n\nIssue\n\nDifficult to do anti-aliasing ä¸èƒ½ç”¨ AA\nBut almost completely solved by TAA ä½†æ˜¯ TAA æ˜¯å¯ä»¥ç”¨çš„ ä¸ºä»€ä¹ˆï¼Ÿ\n\nTiled ShadingSubdivide the screen into tiles of e.g.  then shade each å»ºç«‹åœ¨ deferred shading çš„åŸºç¡€ä¸Šï¼ŒæŠŠå±å¹•åˆ†æˆå°å—ï¼Œæ¯ä¸ªå°å—å•ç‹¬åš shading\nNot all lights can illuminate a specific tile å…‰æºè¦†ç›–çš„èŒƒå›´æ˜¯éšç€è·ç¦»è¡°å‡çš„ï¼Œå¯ä»¥æŠŠè¦†ç›–èŒƒå›´æƒ³è±¡æˆçƒå½¢\n\n    \n\n\nClustered Shading\nFurther subdivide each tile into different depth segments\nEssentially subdividing the view frustum into a 3D grid\n\nå¤æ‚åº¦æ›´åŠ å‡å°‘ï¼Œä½†æ˜¯å®ç°è¶Šæ¥è¶Šå¤æ‚\nLevel of Detail (LoD) Solutions\n    \n    \n\n\nExample\n\nCascaded shadow maps è·ç¦» Camera è¶Šè¿œçš„åœ°æ–¹å°±å¯ä»¥ç”¨è¶Šç²—ç³™çš„ Shadow Map\nèŒƒå›´æœ‰ä¸€å®šçš„é‡å ï¼Œä¿è¯åˆ‡æ¢ä¸åŒå¤§å°çš„ Shadow Map æœ‰å¹³æ»‘çš„è¿‡åº¦\n\n\nCascaded LPV \nGeometric LoD\nBased on the distance to the camera, choose the right object ot show\nPopping artifacts? Leave it to TAA\nThis is Nanite in UE5 åŠ¨æ€çš„é€‰å– LoD çš„å®ç°\n\n\n\nKey Challenge\n\nTransition between different levels ä¸åŒå±‚çº§ä¹‹é—´çš„è½¬æ¢\nUsually need some overlapping and blending near boundaries\n\nGlobal Illumination SolutionsA possible solution to GI may include\n\nSSR for a rough GI approximation\nUpon SSR failure, switching to more complex ray tracing. \nEither hardware(RTRT) or software æˆ–è€…ç”¨ç¡¬ä»¶åš tracingï¼Œæˆ–è€…ç”¨è½¯ä»¶åš tracing\nSoftware ray tracing\nHQ SDF for individual objects that are closed-by è¿‘å¤„çš„ç”¨é«˜è´¨é‡çš„ SDFï¼ŒSDF å¯ä»¥è®©æˆ‘ä»¬å¿«é€Ÿçš„åœ¨ shader é‡Œé¢åš tracing\nLQ SDF for the entire scene è¿œå¤„çš„ç”¨ä½è´¨é‡çš„ SDF\nRSM if there are strong directional / point light éå¸¸å¼ºçš„æ–¹å‘å…‰æºæˆ–ç‚¹å…‰æºç”¨ RSM\nProbes that stores irradiance in a 3D grid (Dynamic Diffuse GI, DDGI)\n\n\nHardware ray tracing\nDoesnâ€™t have to use the original geometry, but low-poly proxies ç”¨ç®€åŒ–äº†çš„æ¨¡å‹ä»£æ›¿åŸå§‹æ¨¡å‹\nProbes (RTXGI)\n\n\n\n\n\nThe hightlighted solutions are mixed to get Lumen in UE5\nA lot of uncovered topics\nTexturing an SDF SDF è´´çº¹ç†\nTransparent material and order-independent transparency é€æ˜ç‰©ä½“æ¸²æŸ“é¡ºåº\nParticle rendering\nPost processing (depth of field, motion blur, etc.)\nRandom seed and blue noise å®æ—¶æ¸²æŸ“ä¸­æ€ä¹ˆåˆ©ç”¨éšæœºæ•°ç§å­ è“å™ªå£°\nFoveated rendering\nProbe based global illumination åŸºäºæ¢é’ˆçš„ GI\nReSTIR, Neural Radiance Caching, etc. æ›´å…ˆè¿›çš„å®æ—¶æ¸²æŸ“æŠ€æœ¯\nMany-light theory and light cuts\nParticipating media, SSSSS äº‘çƒŸé›¾ï¼Œæ¬¡è¡¨é¢æ•£å°„\nHair appearance\nâ€¦\n\n\n[1]  ç±»ä¼¼èŠ±ç“£çš„â€œç“£â€ï¼ŒBRDF æ˜¯å››ç»´çš„ï¼Œä½†æ˜¯ç»™å®šè§‚å¯Ÿæ–¹å‘ï¼Œä¼šåå°„å‡ºæ¥ä¸€ä¸ªç±»ä¼¼äºâ€œèŠ±ç“£â€çš„åˆ†å¸ƒ lobe: n. ï¼ˆè„‘ã€è‚ºç­‰çš„ï¼‰å¶ï¼›è£‚ç‰‡ï¼›è€³å‚ï¼›æ³¢ç“£\n","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES","å®æ—¶æ¸²æŸ“"]},{"title":"Triangles and Z-Buffer","url":"/2021/11/09/8/","content":"æŠ•å½±çŸ©é˜µ  é€è§†æŠ•å½±çŸ©é˜µæ¨å¯¼\n    \n\n\nå¯¹äºæ­£äº¤æŠ•å½±ï¼ˆOrthographic Projectionï¼‰éœ€è¦æŠŠé•¿æ–¹ä½“  è¿›è¡Œæ ‡å‡†åŒ–æˆæ­£æ–¹ä½“ï¼Œç›¸åº”çš„å˜æ¢çŸ©é˜µæ˜¯å…ˆè¿›è¡Œå¹³ç§»å˜æ¢ï¼ˆå°†é•¿æ–¹ä½“çš„ä¸­å¿ƒä¸åŸç‚¹é‡åˆï¼‰ï¼Œå†è¿›è¡Œç¼©æ”¾å˜æ¢ï¼ˆç”±äºæ ‡å‡†åŒ–çš„æ­£æ–¹ä½“çš„è¾¹é•¿æ˜¯ 2ï¼Œé•¿å®½é«˜è¦å½’ä¸€åŒ–åˆ° 2ï¼‰ï¼Œå³ï¼š\n\n\n\n\nå¯¹äºé€è§†æŠ•å½±ï¼ˆPerspective Projectionï¼‰ï¼Œæ€è·¯æ˜¯æŠŠè§†é”¥ä½“â€œæŒ¤å‹â€æˆé•¿æ–¹ä½“ï¼Œå†å¯¹é•¿æ–¹ä½“è¿›è¡Œå½’ä¸€åŒ–ã€‚äºæ˜¯è§†é”¥ä½“å†…çš„æ‰€æœ‰ç‚¹â€œæŒ¤å‹â€åˆ°è¿‘å¹³é¢ä¸Šï¼ˆå¯ä»¥æƒ³è±¡è§†è§’åœ¨è¿œå¹³é¢å¤–ä¾§ï¼Œæ–¹å‘å‚ç›´äºè¿œå¹³é¢ï¼‰ï¼Œå¯ä»¥æ ¹æ®ç›¸ä¼¼ä¸‰è§’å½¢åŸç†è®¡ç®—å‡ºâ€œæŒ¤å‹â€åçš„  å’Œåæ ‡\n\n\n\n\né‚£ä¹ˆâ€œæŒ¤å‹â€åçš„ç‚¹åœ¨é½æ¬¡åæ ‡ç³»ï¼ˆHomogeneous Coordinatesï¼‰ä¸‹å¯ä»¥è¡¨ç¤ºä¸ºï¼š\næ‰€ä»¥ä»è§†é”¥ä½“åˆ°é•¿æ–¹ä½“çš„çŸ©é˜µå˜æ¢  æ»¡è¶³ä¸‹é¢çš„ç­‰å¼ï¼š\n\nå³\nç¬¬ä¸‰è¡Œçš„æœªçŸ¥å€¼å¯ä»¥æ ¹æ®ä¸¤ä¸ªè®¾å®šè®¡ç®—å‡ºæ¥ï¼š\n\nè¿‘å¹³é¢ä¸Šçš„ä»»æ„ä¸€ç‚¹ç»è¿‡â€œæŒ¤å‹â€åçš„  åæ ‡ä¸å‘ç”Ÿå˜åŒ–ï¼Œè¿‘å¹³é¢ä¸Šçš„ç‚¹ä¸º ï¼ŒæŒ¤å‹åè¿˜æ˜¯ï¼Œä¹Ÿå¯ä»¥å†™æˆï¼Œæ‰€ä»¥ç¬¬ä¸‰è¡Œä¸€å®šæ»¡è¶³ä»¥ä¸‹ç­‰å¼ï¼š å¯ä»¥å¾—å‡ºï¼š\nè¿œå¹³é¢ä¸Šçš„ä»»æ„ä¸€ç‚¹ç»è¿‡â€œæŒ¤å‹â€åçš„  åæ ‡ä¹Ÿä¸ä¼šå‘ç”Ÿå˜åŒ–ï¼ŒåŒä¸Šå¯å¾—ï¼š\n\nè”ç«‹å¯å¾—ï¼šæ‰€ä»¥é€è§†æŠ•å½±çŸ©é˜µå¯ä»¥è¡¨ç¤ºä¸ºï¼š\nå¯¹äºå‡½æ•° get_projection_matrix ä¸­çš„å‚æ•°å¯ç”±ä¸‹å›¾è®¡ç®—å‡ºï¼š\n\n    \n\n\né•¿æ–¹ä½“çš„ä¸­å¿ƒä½äºåŸç‚¹ï¼Œåˆ™ï¼Œæ ¹æ®å¯¹ç§°æ€§ï¼Œæ ¹æ®çºµæ¨ªæ¯”å’Œå¯¹ç§°æ€§å¯å¾—ï¼Œï¼Œä»£å…¥å…¬å¼å³å¯\næ—‹è½¬ä¸æŠ•å½±ä»£ç Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar){    // TODO: Copy-paste your implementation from the previous assignment.    Eigen::Matrix4f projection;        float fov = eye_fov * M_PI / 180.0;    float t = std::abs(zNear) * std::tan(fov / 2.0);    float b = -t;    float r = t * aspect_ratio;    float l = -r;    float n = zNear;    float f = zFar;        Eigen::Matrix4f scale;    scale &lt;&lt; 1 / r - l, 0, 0, 0,        0, 1 / t - b, 0, 0,        0, 0, 1 / n - f, 0,        0, 0, 0, 1;        Eigen::Matrix4f translate;    translate &lt;&lt; 1, 0, 0, 0,        0, 1, 0, 0,        0, 0, 1, (n + f) / -2,        0, 0, 0, 1;        auto orthographic = scale * translate;    Eigen::Matrix4f orthographicToProjection;    orthographicToProjection &lt;&lt; n, 0, 0, 0,        0, n, 0, 0,        0, 0, n + f, -n * f,        0, 0, 1, 0;    projection = orthographic * orthographicToProjection;        return projection;}\n\nä¸‰ç»´ç©ºé—´ä¸­åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…\næ±‚å‡ºå‘é‡ï¼Œï¼Œ\nè®¡ç®—ï¼Œï¼Œ\nå¦‚æœå‰ä¹˜åä¸‰ä¸ªå‘é‡æ–¹å‘åŒå‘åˆ™è¯´æ˜  ç‚¹åœ¨ä¸‰è§’å½¢å†…éƒ¨ï¼Œå¦åˆ™åœ¨å¤–éƒ¨\n\nstatic bool insideTriangle(int x, int y, const Vector3f* _v){    // TODO : Implement this function to check if the point (x, y) is inside the triangle represented by _v[0], _v[1], _v[2]    Eigen::Vector2f side1;    side1 &lt;&lt; _v[1].x() - _v[0].x(), _v[1].y() - _v[0].y();    Eigen::Vector2f side2;    side2 &lt;&lt; _v[2].x() - _v[1].x(), _v[2].y() - _v[1].y();    Eigen::Vector2f side3;    side3 &lt;&lt; _v[0].x() - _v[2].x(), _v[0].y() - _v[2].y();        Eigen::Vector2f v1;    v1 &lt;&lt; x - _v[0].x(), y - _v[0].y();    Eigen::Vector2f v2;    v2 &lt;&lt; x - _v[1].x(), y - _v[1].y();    Eigen::Vector2f v3;    v3 &lt;&lt; x - _v[2].x(), y - _v[2].y();        float z1 = side1.x() * v1.y() - side1.y() * v1.x();    float z2 = side2.x() * v2.y() - side2.y() * v2.x();    float z3 = side3.x() * v3.y() - side3.y() * v3.x();        if ((z1 &gt; 0 &amp;&amp; z2 &gt; 0 &amp;&amp; z3 &gt; 0) || (z1 &lt; 0 &amp;&amp; z2 &lt; 0 &amp;&amp; z3 &lt; 0))    {        return true;    }    else    {        return false;    }}\n\nå…‰æ …åŒ–  è®¡ç®—é‡å¿ƒåæ ‡  è€ƒè™‘ä¸‰è§’å½¢ä¸‰ä¸ªé¡¶ç‚¹ ï¼Œï¼Œ ä»¥åŠå†…éƒ¨åæ ‡ç‚¹ ï¼Œå‡è®¾åˆä¸‰ä¸ªå€¼ï¼Œï¼Œ æ»¡è¶³ï¼šè§£æ–¹ç¨‹ç»„å¯å¾—\nstatic std::tuple&lt;float, float, float&gt; computeBarycentric2D(float x, float y, const Vector3f* v){    float xp = x, yp = y;    float xa = v[0].x(), ya = v[0].y();    float xb = v[1].x(), yb = v[1].y();    float xc = v[2].x(), yc = v[2].y();    float gamma = ((xb - xa) * (yp - ya) - (xp - xa) * (yb - ya)) /                   ((xb - xa) * (yc - ya) - (xc - xa) * (yb - ya));    float beta = (xp - xa - gamma * (xc - xa)) / (xb - xa);    float alpha = 1.0f - beta - gamma;    return {alpha, beta, gamma};}\n\n\n    \n\n\nå…‰æ …åŒ–ä¸€ä¸ªä¸‰è§’å½¢éœ€è¦æ‰«æä¸‰è§’å½¢æ‰€åœ¨çš„åŒ…å›´ç›’ï¼Œåˆ¤æ–­ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…éƒ¨ç„¶åé€šè¿‡ä¸­å¿ƒåæ ‡æ’å€¼\n\n    \n\n\næ‰€ä»¥åˆ¤æ–­æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…éƒ¨éœ€è¦åŠ \nif (insideTriangle(i + 0.5f, j + 0.5f, t.v)) {    ...}\n\nå·²çŸ¥é‡å¿ƒåæ ‡ ï¼Œï¼Œ çš„å€¼æ±‚æ·±åº¦å€¼  çš„å…¬å¼å¦‚ä¸‹ï¼ˆéœ€è¦åšé‡å¿ƒåæ ‡ - æ’å€¼æ ¡æ­£ [1][2]ï¼‰ï¼š å…¶ä¸­ï¼Œï¼Œ\né‡å¿ƒåæ ‡æ˜¯åœ¨ 2D ç©ºé—´é‡Œåšçš„ï¼Œä¸èƒ½ç”¨ä½œæ’å€¼ 3D ç©ºé—´çš„åæ ‡ï¼Œéœ€è¦ç»è¿‡æ’å€¼çŸ«æ­£æ‰å¯ä»¥\n//Screen space rasterizationvoid rst::rasterizer::rasterize_triangle(const Triangle&amp; t) {    auto v = t.toVector4();        // TODO : Find out the bounding box of current triangle.    // iterate through the pixel and find if the current pixel is inside the triangle    auto minX = std::min(v[0].x(), std::min(v[1].x(), v[2].x()));    auto minY = std::min(v[0].y(), std::min(v[1].y(), v[2].y()));    auto maxX = std::max(v[0].x(), std::max(v[1].x(), v[2].x()));    auto maxY = std::max(v[0].y(), std::max(v[1].y(), v[2].y()));    // If so, use the following code to get the interpolated z value.    // TODO : set the current pixel (use the set_pixel function) to the color of the triangle (use getColor function) if it should be painted.    for (int i = minX; i &lt;= maxX; i++) {        for (int j = minY; j &lt;= maxY; j++) {            if (insideTriangle(i + 0.5f, j + 0.5f, t.v)) {                float minDepth = FLT_MAX;                auto tup = computeBarycentric2D(i, j, t.v);                                float alpha, beta, gamma;                std::tie(alpha, beta, gamma) = tup;                float wReciprocal = 1.0 / (alpha / v[0].w() + beta / v[1].w() + gamma / v[2].w());                float zInterpolated = alpha * v[0].z() / v[0].w() + beta * v[1].z() / v[1].w() + gamma * v[2].z() / v[2].w();                zInterpolated *= wReciprocal;                minDepth = std::min(minDepth, zInterpolated);                auto index = get_index(i, j);                if (depth_buf[index] &gt; minDepth) {                    Eigen::Vector3f color = t.getColor();                    Vector3f point;                    point &lt;&lt; i, j, minDepth;                    depth_buf[index] = minDepth;                    set_pixel(point, color);                }            }        }    }}\n\n[1]  é€è§†æŠ•å½± - é‡å¿ƒåæ ‡ - æ’å€¼æ ¡æ­£[2]  Perspective-Correct Interpolation\n    \n    #refplus, #refplus li{ \n        padding:0;\n        margin:0;\n        list-style:none;\n    }ï¼›\n    \n    \n    \n    \n    document.querySelectorAll(\".refplus-num\").forEach((ref) => {\n        let refid = ref.firstChild.href.replace(location.origin+location.pathname,'');\n        let refel = document.querySelector(refid);\n        let refnum = refel.dataset.num;\n        let ref_content = refel.innerText.replace(`[${refnum}]`,'');\n        tippy(ref, {\n            content: ref_content,\n        });\n    });\n    \n    ","categories":["å›¾å½¢å­¦"],"tags":["Graphics","GAMES"]},{"title":"Linux å†…æ ¸ --offsetof å’Œ container_of","url":"/2021/11/12/9/","content":"#define offsetof(type, member)  ((size_t)&amp;((type *)0)-&gt;member)\n\n offsetofï¼šè·å–ç»“æ„ä½“ä¸­æˆå‘˜çš„åç§»ä½ç½®ï¼Œå°†åœ°å€ 0 å¼ºåˆ¶è½¬æ¢ä¸º type ç±»å‹çš„æŒ‡é’ˆï¼ˆç¼–è¯‘å™¨è®¤ä¸º 0 æ˜¯ä¸€ä¸ªæœ‰æ•ˆåœ°å€ï¼Œå³ 0 æ˜¯typeæŒ‡é’ˆçš„èµ·å§‹åœ°å€ï¼‰ï¼Œç„¶åå†å¼•ç”¨ member æˆå‘˜ï¼ˆå¯¹åº”çš„å°±æ˜¯ ((type *)0)-&gt;memberï¼Œå³åç§»åˆ°member æˆå‘˜çš„èµ·å§‹åœ°å€ï¼‰ï¼Œæœ€åå°† member æˆå‘˜çš„èµ·å§‹åœ°å€å¼ºåˆ¶è½¬æ¢ä¸º size_t ç±»å‹\n\nConsider this example:\nstruct Test &#123; char text[32]; int count;&#125;\n\nIf struct Test is allocated at the address 0xC000, then the address of text would be 0xC000, and the address of count would be 0xC020. However, if the base address is zero (which is not allowed by the standard), then the address of text would be zero, and the address of the count would be 0x20. Casting these addresses to size_t gives you the offset of the corresponding members.\n\n/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */#define container_of(ptr, type, member) (&#123;                   \\     const typeof(((type *)0)-&gt;member ) *__mptr = (ptr);    \\     (type *)((char *)__mptr - offsetof(type,member) );&#125;)\n\ncontainer_ofï¼šconst typeof(((type *)0)-&gt;member ) *__mptr = (ptr);é€šè¿‡ typeof å®šä¹‰ä¸€ä¸ª member æŒ‡é’ˆç±»å‹çš„æŒ‡é’ˆå˜é‡ __mptrï¼ˆå³__mptr æ˜¯æŒ‡å‘ member ç±»å‹çš„æŒ‡é’ˆï¼‰ï¼Œå¹¶å°† __mptr èµ‹å€¼ä¸º ptrï¼›(type *)((char *)__mptr - offsetof(type,member)); é€šè¿‡ offsetof å®è®¡ç®—å‡º member åœ¨typeä¸­çš„åç§»ï¼Œç„¶åç”¨ member çš„å®é™…åœ°å€ __mptr å‡å»åç§»ï¼Œå¾—åˆ° type çš„èµ·å§‹åœ°å€ï¼Œå³æŒ‡å‘ type ç±»å‹çš„æŒ‡é’ˆ\n","categories":["Linux"],"tags":["macro","linux"]}]