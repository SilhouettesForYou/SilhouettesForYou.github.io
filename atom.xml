<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Silhouettes For You</title>
  
  
  <link href="https://silhouettesforyou.github.io/atom.xml" rel="self"/>
  
  <link href="https://silhouettesforyou.github.io/"/>
  <updated>2024-08-05T01:36:44.140Z</updated>
  <id>https://silhouettesforyou.github.io/</id>
  
  <author>
    <name>Xiaoming</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Markov Decision Processes</title>
    <link href="https://silhouettesforyou.github.io/2024/07/30/990e4273260f/"/>
    <id>https://silhouettesforyou.github.io/2024/07/30/990e4273260f/</id>
    <published>2024-07-30T13:43:11.000Z</published>
    <updated>2024-08-05T01:36:44.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="18.623ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 8231.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="TeXAtom" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="4D" d="M28 9Q28 37 43 63T73 90Q77 90 83 84T103 70T141 57H146Q162 57 178 79T222 167Q266 279 295 371T334 513T349 598T358 651T371 677Q397 705 432 705Q442 705 445 699T452 666Q453 661 453 659Q475 538 509 405T568 207L574 192Q581 178 587 164T594 150Q596 150 635 189T693 248Q765 324 863 438T1024 626T1089 701Q1093 705 1100 705Q1111 705 1111 682Q1111 675 1108 660T1099 611T1086 540Q1041 277 1041 144Q1041 98 1044 75T1050 48T1059 42Q1064 41 1075 46Q1102 61 1121 61Q1137 61 1137 50Q1137 28 1087 0T1000 -29Q983 -29 972 -23T955 -9T945 16T942 45T941 83V96Q941 158 952 256T974 422L985 489Q984 489 939 436T821 300T698 164Q665 128 620 85T568 37Q564 34 558 34Q550 34 546 37T535 54Q512 91 496 127T450 259T389 498L384 518Q349 367 294 223T198 15Q155 -50 117 -50Q87 -50 61 -35T30 -6Q28 2 28 9Z"/></g></g><g data-mml-node="mo" transform="translate(1478.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mo" transform="translate(2534.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2923.6,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(3568.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(4013.2,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(4763.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(5207.9,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(5958.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(6403.6,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(6854.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(7299.2,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(7842.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><ul><li>有的地方写作<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="15.943ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 7046.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(389,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(1034,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1478.7,0)"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mn" transform="translate(502,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(2384.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2828.9,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(3578.9,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(4023.6,0)"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(4774.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(5219.2,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5670.2,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(6114.9,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(6657.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.459ex" height="1.645ex" role="img" focusable="false" viewbox="0 -705 645 727"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>: state space, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="6.274ex" height="1.97ex" role="img" focusable="false" viewbox="0 -705 2773.1 870.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mn" transform="translate(502,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mo" transform="translate(1183.3,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"/></g><g data-mml-node="mi" transform="translate(2128.1,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g></g></g></svg></mjx-container>: initial state<ul><li>在代码就是<code>s0 = mdp.reset()</code></li></ul></li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.697ex" height="1.62ex" role="img" focusable="false" viewbox="0 -716 750 716"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g></g></g></svg></mjx-container>: action space, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.232ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4080.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(750,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1139,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(1608,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2274.8,0)"><path data-c="2286" d="M84 346Q84 468 166 546T360 635Q361 635 370 635T395 635T430 636T475 636T524 636H679Q694 628 694 616Q694 607 681 597L522 596H470H441Q366 596 338 592T266 568Q244 557 224 542T179 500T139 433T124 346V341Q124 253 185 185Q244 121 328 103Q348 98 366 98T522 96H681Q694 86 694 76Q694 64 679 56H526Q510 56 480 56T434 55Q350 55 289 71T172 141Q84 223 84 346ZM104 -131T104 -118T118 -98H679Q694 -106 694 -118T679 -138H118Q104 -131 104 -118Z"/></g><g data-mml-node="mi" transform="translate(3330.6,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g></g></g></svg></mjx-container> applicable in each state 当前状态 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.023ex;" xmlns="http://www.w3.org/2000/svg" width="1.061ex" height="1.023ex" role="img" focusable="false" viewbox="0 -442 469 452"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g></g></g></svg></mjx-container> 下允许的动作</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.62ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3368.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mi" transform="translate(675,-150) scale(0.707)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g></g><g data-mml-node="mo" transform="translate(1099.1,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1488.1,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1957.1,0)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g><g data-mml-node="mo" transform="translate(2232.1,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(2510.1,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(2979.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>转移概率（trasition probabilities），对于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="14.773ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 6529.8 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(746.8,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"/></g><g data-mml-node="mi" transform="translate(1691.6,0)"><path data-c="1D446" d="M308 24Q367 24 416 76T466 197Q466 260 414 284Q308 311 278 321T236 341Q176 383 176 462Q176 523 208 573T273 648Q302 673 343 688T407 704H418H425Q521 704 564 640Q565 640 577 653T603 682T623 704Q624 704 627 704T632 705Q645 705 645 698T617 577T585 459T569 456Q549 456 549 465Q549 471 550 475Q550 478 551 494T553 520Q553 554 544 579T526 616T501 641Q465 662 419 662Q362 662 313 616T263 510Q263 480 278 458T319 427Q323 425 389 408T456 390Q490 379 522 342T554 242Q554 216 546 186Q541 164 528 137T492 78T426 18T332 -20Q320 -22 298 -22Q199 -22 144 33L134 44L106 13Q83 -14 78 -18T65 -22Q52 -22 52 -14Q52 -11 110 221Q112 227 130 227H143Q149 221 149 216Q149 214 148 207T144 186T142 153Q144 114 160 87T203 47T255 29T308 24Z"/></g><g data-mml-node="mo" transform="translate(2336.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2781.2,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(3588,0)"><path data-c="2208" d="M84 250Q84 372 166 450T360 539Q361 539 377 539T419 540T469 540H568Q583 532 583 520Q583 511 570 501L466 500Q355 499 329 494Q280 482 242 458T183 409T147 354T129 306T124 272V270H568Q583 262 583 250T568 230H124V228Q124 207 134 177T167 112T231 48T328 7Q355 1 466 0H570Q583 -10 583 -20Q583 -32 568 -40H471Q464 -40 446 -40T417 -41Q262 -41 172 45Q84 127 84 250Z"/></g><g data-mml-node="mi" transform="translate(4532.8,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(5282.8,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(5671.8,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(6140.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container><ul><li>也可以写作：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.035ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3993.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D443" d="M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z"/></g><g data-mml-node="mo" transform="translate(751,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1140,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(1609,0)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g><g data-mml-node="mo" transform="translate(1884,0) translate(0 -0.5)"><path data-c="7C" d="M139 -249H137Q125 -249 119 -235V251L120 737Q130 750 139 750Q152 750 159 735V-235Q151 -249 141 -249H139Z"/></g><g data-mml-node="mi" transform="translate(2162,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(2631,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(3075.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(3604.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>是概率化的（即 probabilistic state model），而非确定性的（deterministic）的</li><li>如果是确定性的，那就是一个经典的序列决策问题了</li></ul></li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.734ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3860.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(451,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(840,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(1309,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1753.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(2282.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2727.3,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(3196.3,0)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g><g data-mml-node="mo" transform="translate(3471.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>: reward function，可以为正（奖励）；也可以为负（惩罚）<ul><li>设计一个 MDP 环境，很大一部分是在设计 reward function</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.044ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2671.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(451,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(840,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(1309,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1753.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(2282.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>: 确定性的情况下</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.734ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3860.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(451,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(840,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mo" transform="translate(1309,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1753.7,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mo" transform="translate(2282.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(2727.3,0)"><path data-c="1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"/></g><g data-mml-node="mi" transform="translate(3196.3,0)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"/></g><g data-mml-node="mo" transform="translate(3471.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>: 是在不确定的情况下产生的奖励，就好像抛硬币，不知道下一次出现的是正面还是反面，这时就需要用概率分布来计算了</li></ul></li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="1.229ex" height="1.486ex" role="img" focusable="false" viewbox="0 -441 543 657"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g></g></g></svg></mjx-container>: discount factor<ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="9.525ex" height="1.995ex" role="img" focusable="false" viewbox="0 -666 4210.1 882"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(2654.3,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mn" transform="translate(3710.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container></li><li>一般又把这种 MDP 称之为 discounted reward MDP</li></ul></li><li>MDP 的求解是一个序列决策问题（sequence decision making）</li></ul><h3 id="Probabilistic-State-Model"><a href="#Probabilistic-State-Model" class="headerlink" title="Probabilistic State Model"></a>Probabilistic State Model</h3><ul><li>抛硬币：正面朝上的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.737ex" role="img" focusable="false" viewbox="0 -864.9 793.6 1209.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="553.6" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，反面朝上的概率也是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.737ex" role="img" focusable="false" viewbox="0 -864.9 793.6 1209.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="553.6" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></li><li>掷 2 个骰子计算点数和：和为 2 的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.595ex" height="2.773ex" role="img" focusable="false" viewbox="0 -864.9 1147.1 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(396.8,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g><rect width="907.1" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，和为 2 的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.595ex" height="2.773ex" role="img" focusable="false" viewbox="0 -864.9 1147.1 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(396.8,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(500,0)"/></g><rect width="907.1" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，和为 4 的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.595ex" height="2.771ex" role="img" focusable="false" viewbox="0 -864.2 1147.1 1224.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(396.8,394) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g><rect width="907.1" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0.43ex;" xmlns="http://www.w3.org/2000/svg" width="2.652ex" height="0.271ex" role="img" focusable="false" viewbox="0 -310 1172 120"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/></g></g></g></svg></mjx-container>，和为 12 的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="2.595ex" height="2.773ex" role="img" focusable="false" viewbox="0 -864.9 1147.1 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(396.8,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(500,0)"/></g><rect width="907.1" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></li><li>机械臂去拿一个东西：成功的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.79ex" role="img" focusable="false" viewbox="0 -872.7 793.6 1233.3"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><rect width="553.6" height="60" x="120" y="220"/></g></g></g></svg></mjx-container>，失败的概率是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.816ex;" xmlns="http://www.w3.org/2000/svg" width="1.795ex" height="2.773ex" role="img" focusable="false" viewbox="0 -864.9 793.6 1225.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(220,394) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mn" transform="translate(220,-345) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><rect width="553.6" height="60" x="120" y="220"/></g></g></g></svg></mjx-container></li><li>打开一个网页：404 的概率 1%，200 的概率 99%</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0.43ex;" xmlns="http://www.w3.org/2000/svg" width="2.652ex" height="0.271ex" role="img" focusable="false" viewbox="0 -310 1172 120"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/></g></g></g></svg></mjx-container></li></ul><h3 id="Discounted-Reward"><a href="#Discounted-Reward" class="headerlink" title="Discounted Reward"></a>Discounted Reward</h3><ul><li><p>如果 agent 在与环境交互中得到一些列的 reward <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.439ex;" xmlns="http://www.w3.org/2000/svg" width="8.68ex" height="1.439ex" role="img" focusable="false" viewbox="0 -442 3836.4 636"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(887.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msub" transform="translate(1332.2,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2219.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mo" transform="translate(2664.4,0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/></g></g></g></svg></mjx-container>，则有</p><p>  <mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -3.658ex;" xmlns="http://www.w3.org/2000/svg" width="35.736ex" height="8.448ex" role="img" focusable="false" viewbox="0 -2117 15795.2 3733.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtable"><g data-mml-node="mtr" transform="translate(0,1233)"><g data-mml-node="mtd" transform="translate(152.3,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g></g><g data-mml-node="mtd" transform="translate(921.3,0)"><g data-mml-node="mi"/><g data-mml-node="mo" transform="translate(277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1333.6,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mo" transform="translate(2443.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3443.6,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="msub" transform="translate(3986.6,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(5096.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msup" transform="translate(6096.6,0)"><g data-mml-node="mi"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mn" transform="translate(627.3,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msub" transform="translate(7127.4,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(8237.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msup" transform="translate(9237.4,0)"><g data-mml-node="mi"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mn" transform="translate(627.3,413) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="msub" transform="translate(10268.2,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="mo" transform="translate(11377.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(12378.2,0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-67)"><g data-mml-node="mtd" transform="translate(921.3,0)"/><g data-mml-node="mtd" transform="translate(921.3,0)"><g data-mml-node="mi"/><g data-mml-node="mo" transform="translate(277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1333.6,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(484,-150) scale(0.707)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(2408.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3408.9,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(3951.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(4340.9,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(5450.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(6450.9,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(6993.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(7382.9,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(8492.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(9492.9,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(10035.9,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msub" transform="translate(10424.9,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(484,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="mo" transform="translate(11534.7,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mo" transform="translate(12534.9,0)"><path data-c="22EF" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250ZM525 250Q525 274 542 292T585 310Q609 310 627 294T646 251Q646 226 629 208T586 190T543 207T525 250ZM972 250Q972 274 989 292T1032 310Q1056 310 1074 294T1093 251Q1093 226 1076 208T1033 190T990 207T972 250Z"/></g><g data-mml-node="mo" transform="translate(13706.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(14095.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(14484.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-1367)"><g data-mml-node="mtd"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="mi" transform="translate(616,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g><g data-mml-node="mtd" transform="translate(921.3,0)"><g data-mml-node="mi"/><g data-mml-node="mo" transform="translate(277.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msub" transform="translate(1333.6,0)"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(484,-150) scale(0.707)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g><g data-mml-node="mo" transform="translate(2345,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3345.3,0)"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="msub" transform="translate(3888.3,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="TeXAtom" transform="translate(616,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(451,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1229,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></g></g></g></svg></mjx-container></p><ul><li>递归定义，体现子问题的结构（可以使用动态规划）</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.471ex;" xmlns="http://www.w3.org/2000/svg" width="4.129ex" height="2.016ex" role="img" focusable="false" viewbox="0 -683 1824.9 891"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="TeXAtom" transform="translate(616,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(361,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1139,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container>的价值通过 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="5.357ex" height="2.034ex" role="img" focusable="false" viewbox="0 -683 2367.9 899"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="msub" transform="translate(543,0)"><g data-mml-node="mi"><path data-c="1D449" d="M52 648Q52 670 65 683H76Q118 680 181 680Q299 680 320 683H330Q336 677 336 674T334 656Q329 641 325 637H304Q282 635 274 635Q245 630 242 620Q242 618 271 369T301 118L374 235Q447 352 520 471T595 594Q599 601 599 609Q599 633 555 637Q537 637 537 648Q537 649 539 661Q542 675 545 679T558 683Q560 683 570 683T604 682T668 681Q737 681 755 683H762Q769 676 769 672Q769 655 760 640Q757 637 743 637Q730 636 719 635T698 630T682 623T670 615T660 608T652 599T645 592L452 282Q272 -9 266 -16Q263 -18 259 -21L241 -22H234Q216 -22 216 -15Q213 -9 177 305Q139 623 138 626Q133 637 76 637H59Q52 642 52 648Z"/></g><g data-mml-node="TeXAtom" transform="translate(616,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mo" transform="translate(361,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mn" transform="translate(1139,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></g></svg></mjx-container> 折到现在</li><li>因为要最大化 discounted reward，所以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.489ex;" xmlns="http://www.w3.org/2000/svg" width="5.377ex" height="1.995ex" role="img" focusable="false" viewbox="0 -666 2376.6 882"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D6FE" d="M31 249Q11 249 11 258Q11 275 26 304T66 365T129 418T206 441Q233 441 239 440Q287 429 318 386T371 255Q385 195 385 170Q385 166 386 166L398 193Q418 244 443 300T486 391T508 430Q510 431 524 431H537Q543 425 543 422Q543 418 522 378T463 251T391 71Q385 55 378 6T357 -100Q341 -165 330 -190T303 -216Q286 -216 286 -188Q286 -138 340 32L346 51L347 69Q348 79 348 100Q348 257 291 317Q251 355 196 355Q148 355 108 329T51 260Q49 251 47 251Q45 249 31 249Z"/></g><g data-mml-node="mo" transform="translate(820.8,0)"><path data-c="3C" d="M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z"/></g><g data-mml-node="mn" transform="translate(1876.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 会隐式地得到一个更短路径<ul><li>另外一个角度是：aciton 会有 cost</li></ul></li></ul></li></ul><h2 id="Grid-World"><a href="#Grid-World" class="headerlink" title="Grid World"></a>Grid World</h2><center>    <img src="/2024/07/30/990e4273260f/grid-world.png" alt></center>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="强化学习" scheme="https://silhouettesforyou.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RL" scheme="https://silhouettesforyou.github.io/tags/RL/"/>
    
    <category term="MDP" scheme="https://silhouettesforyou.github.io/tags/MDP/"/>
    
    <category term="tutorials" scheme="https://silhouettesforyou.github.io/tags/tutorials/"/>
    
  </entry>
  
  <entry>
    <title>现代 C++ 核心特性解析</title>
    <link href="https://silhouettesforyou.github.io/2024/07/18/ba744a9761cc/"/>
    <id>https://silhouettesforyou.github.io/2024/07/18/ba744a9761cc/</id>
    <published>2024-07-18T10:10:24.000Z</published>
    <updated>2024-08-12T15:56:36.227Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>本书是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++ 11 到 C++ 20 引入的核心特性。书中不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理</p><span id="more"></span><h2 id="01- 新基础类型"><a href="#01- 新基础类型" class="headerlink" title="01 新基础类型"></a>01 新基础类型 </h2><h3 id="整数类型 long-long"><a href="# 整数类型 long-long" class="headerlink" title="整数类型 long long"></a> 整数类型<code>long long</code></h3><ul><li><code>long long</code><strong>至少 </strong> 表示 64 位的整数</li><li><code>long</code>不能比 <code>int</code> 短，所以可以相等</li><li><code>long</code>就是 <code>long int</code>，同理<code>long long</code> 就是<code>long long int</code></li><li>初始化可以添加 <code>l</code> 或<code>L</code>后缀，<code>long long x = 65536LL;</code></li><li>可以用于枚举类型或位域<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">longlong_enum</span> : <span class="hljs-type">long</span> <span class="hljs-type">long</span> &#123;<br>    x1,<br>    x2<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">longlong_struct</span> &#123; <span class="hljs-comment">// 位域可以用来解析协议</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x1 : <span class="hljs-number">8</span>,<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x2 : <span class="hljs-number">24</span>,<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> x3 : <span class="hljs-number">32</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><div class="note note-secondary">            <p><code>long long</code>格式化输出可以使用 <code>%lld</code>、<code>%llu</code>，<code>int</code> 格式化输出可以使用 <code>%d</code>，<code>short</code> 格式化输出可以使用<code>%h</code>，应该是 half 的意思</p>          </div><h3 id="新字符串类型 char16-t 和 char32-t"><a href="# 新字符串类型 char16-t 和 char32-t" class="headerlink" title="新字符串类型 char16_t 和 char32_t"></a>新字符串类型 <code>char16_t</code> 和<code>char32_t</code></h3><ul><li>分别对应 Unicode 的 UTF-16 和 UTF-32</li><li>UTF-32 编码简单但是占用内存多<ul><li>所有字符都映射</li></ul></li><li>UTF-16 占用内存少但是不够用<ul><li>常用字符做唯一映射</li><li>其余字符采用了一种特殊的方法表示 Unicode 字符</li></ul></li><li>UTF-8 一般序列化到磁盘中，不存在内存中<ul><li>变长编码</li><li>查找和获取大小比较麻烦</li></ul></li><li><code>wchar_t</code>存在的问题<ul><li>在 Windows 上 <code>wchat_t</code> 是 16 位，而在 Linux 和 macOS 上 <code>wchat_t</code> 是 32 位的</li><li>无法保证相同的代码在不同平台上有相同的行为</li><li><code>char16_t</code>和 <code>char32_t</code> 解决了这个问题</li></ul></li><li><code>char8_t</code>字符类型 <span class="label label-primary">C++ 20</span><ul><li>使用 <code>char</code> 类型来处理 UTF-8 字符虽然可行，但是也会带来一些困扰，比如当库函数需要同时处理多种字符时必须采用不同的函数名称，以区分普通字符和 UTF-8 字符</li><li><code>char8_t</code>可以代替 <code>char</code> 作为 UTF-8 的字符类型</li></ul></li></ul><h2 id="02- 内联和嵌套命名空间"><a href="#02- 内联和嵌套命名空间" class="headerlink" title="02 内联和嵌套命名空间"></a>02 内联和嵌套命名空间</h2><p>C++11 标准增强了命名空间的特性，提出了内联命名空间的概念。内联命名空间能够把空间内函数和类型导出到父命名空间中，这样即使不指定子命名空间也可以使用其空间内的函数和类型了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Parent &#123;<br>    <span class="hljs-keyword">namespace</span> Child1 &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Child1: foo()&quot;</span> &lt;&lt; std::endl; &#125;<br>    &#125;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">namespace</span> Child2 &#123;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123; std::cout &lt; <span class="hljs-string">&quot;Child2: foo()&quot;</span>&lt;&lt; std::endl; &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Parent::Child1::<span class="hljs-built_in">foo</span>();<br>    Parent::<span class="hljs-built_in">foo</span>(); <span class="hljs-comment">// 兼容老代码，删掉 Child2 命名空间效果是一样的</span><br>&#125; <br></code></pre></td></tr></table></figure><ul><li><p>嵌套命名空间的简化语法 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A::B::C &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内联命名空间 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> A::B::<span class="hljs-keyword">inline</span> C &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">namespace</span> A::<span class="hljs-keyword">inline</span> B::C &#123;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">foo</span> <span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="03-auto 占位符"><a href="#03-auto 占位符" class="headerlink" title="03 auto 占位符"></a>03 <code>auto</code>占位符</h2><ul><li><p>C++ 98 开始就有了，平常定义的变量都是 <code>auto</code> 的，也可以不写</p></li><li><p>C++ 11 开始赋予了新的含义</p></li><li><p>声明多个变量时，从左往右推导，必须一致</p></li><li><p>条件表达式推导出更强的类型 e.g. <code>auto i = true ? 5 : 8.8</code> <code>i</code>的类型为<code>double</code></p></li><li><p>初始化静态成员变量必须加<code>const</code> <span class="label label-info">C++ 11</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sometype</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>C++ 17 标准中，<code>auto</code>可以在没有 <code>const</code> 的情况下使用 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sometype</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">auto</span> i = <span class="hljs-number">5</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>C++ 20 之前，无法在函数形参列表中使用 <code>auto</code> 声明形参 e.g. <code>void echo(auto str) &#123; ... &#125;</code></p><ul><li><code>auto</code>可以为 lambda 表达式声明形参 <span class="label label-warning">C++ 14</span></li></ul></li><li><p>如果 <code>auto</code> 声明的变量时按值初始化，则推导出的类型会忽略 cv 限定符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span> j = i;       <span class="hljs-comment">// auto 推导类型为 int，而非 const int</span><br><span class="hljs-keyword">auto</span> &amp;m = i;      <span class="hljs-comment">// auto 推导类型为 const int，m 推导类型为 const int&amp;</span><br><span class="hljs-keyword">auto</span> *k = &amp;i;     <span class="hljs-comment">// auto 推导类型为 const int，k 推导类型为 const int*</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> n = j; <span class="hljs-comment">// auto 推导类型为 int，n 的类型为 const int</span><br></code></pre></td></tr></table></figure><ul><li>对于值类型的推导只是值上的关系，没有内存的关联</li><li>但是对于引用或指针涉及到了内存的关联，需要保留 cv 限定符</li></ul></li><li><p>使用 <code>auto</code> 声明变量初始化时，目标对象如果是引用，则引用属性会被忽略</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> &amp;j = i;<br><span class="hljs-keyword">auto</span> m = j; <span class="hljs-comment">// auto 推导类型为 int，而非 int&amp;</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>auto</code> 和万能引用声明变量时，对于左值会将 <code>auto</code> 推导为应用类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">auto</span>&amp;&amp; m = i; <span class="hljs-comment">// auto 推导类型为 int&amp;，这里涉及引用折叠的概念（遇左则左）</span><br><span class="hljs-keyword">auto</span>&amp;&amp; j = <span class="hljs-number">5</span>; <span class="hljs-comment">// auto 推导类型为 int</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>auto</code> 声明变量，如果对象目标是一个数组或者函数，则 <code>auto</code> 会被推导为对应的指针类型</p></li><li><p>当 <code>auto</code> 关键字与列表初始化组合时  <span class="label label-success">C++ 17</span></p><ul><li>直接使用列表初始化，列表中必须为单元素，否则无法编译，<code>auto</code>类型被推导为单元素的类型</li><li>用等号加初始化列表，列表中可以包含单个或多个元素，<code>auto</code>类型别推导为 <code>std::initializer_list&lt;T&gt;</code>，其中<code>T</code> 是元素类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x1 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;   <span class="hljs-comment">// x1 类型为 std::initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> x2 = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2.0</span> &#125;; <span class="hljs-comment">// 编译失败，花括号中元素类型不同</span><br><span class="hljs-keyword">auto</span> x3&#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;      <span class="hljs-comment">// 编译失败，不是单个元素</span><br><span class="hljs-keyword">auto</span> x4 = &#123; <span class="hljs-number">3</span> &#125;;      <span class="hljs-comment">// x4 类型为 std::initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> x5&#123; <span class="hljs-number">3</span> &#125;;         <span class="hljs-comment">// x5 类型为 int</span><br></code></pre></td></tr></table></figure></li></ul><div class="note note-info">            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Base::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Derived::f()&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br>Base* d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">auto</span> b = *d;<br>b.<span class="hljs-built_in">f</span>();<br></code></pre></td></tr></table></figure><p>由于 <code>auto b = *d;</code> 是按值赋值的，因此 <code>auto</code> 会直接推导为 <code>Base</code>。代码自然会调用<code>Base</code> 的复制构造函数，也就是说 <code>Derived</code> 被切割（Sliced）成了 <code>Base</code>，如果是<code>auto &amp;b1 = *d</code> 或者 <code>auto *b2 = d</code> 则会触发多态的性质</p>          </div><ul><li><p>返回类型声明为 <code>auto</code> 的推导 e.g. <code>auto sum(int a, int b) &#123; return a + b; &#125;</code> <span class="label label-warning">C++ 14</span></p><ul><li><p>如果有多重返回值，那么需要保证返回值类型是相同的，否则会编译失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">long</span> a, <span class="hljs-type">long</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回 int 类型</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a + b; <span class="hljs-comment">// 返回 long 类型</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>可以把 <code>auto</code> 写到 lambda 表达式的形参中，这样就得到了一个泛型的 lambda 表达式 <span class="label label-warning">C++ 14</span></p></li><li><p>非类型模板形参占位符 <span class="label label-success">C++ 17</span></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">auto</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>   std::cout &lt;&lt; N &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-built_in">f</span>&lt;<span class="hljs-number">5</span>&gt;();   <span class="hljs-comment">// N 为 int 类型</span><br>   <span class="hljs-built_in">f</span>&lt;<span class="hljs-string">&#x27;c&#x27;</span>&gt;(); <span class="hljs-comment">// N 为 char 类型</span><br>   <span class="hljs-built_in">f</span>&lt;<span class="hljs-number">5.0</span>&gt;(); <span class="hljs-comment">// 编译失败，模板参数不能为 double</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="04-decltype 说明符"><a href="#04-decltype 说明符" class="headerlink" title="04 decltype 说明符"></a>04 <code>decltype</code>说明符</h2><ul><li>使用 <code>decltype</code> 说明符可以获取对象或者表达式的类型，其语法与 <code>typeof</code> 类似 <span class="label label-info">C++ 11</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> a1, <span class="hljs-type">int</span> a2)</span> -&gt; <span class="hljs-type">int</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 11 标准中，<code>auto</code>作为占位符不能是编译器对函数返回类型进行推导，必须使用返回类型后置的形式指定返回类型，如果想泛化这个函数，需要使用到函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">T <span class="hljs-title">sum</span><span class="hljs-params">(T a1, T a2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br><span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>但是如果传递不同类型的实参，则无法编译通过 e.g. <code>auto x2 = sum(5, 10.5);</code>，只能增加模板类型来解决了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> R, <span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function">R <span class="hljs-title">sum</span><span class="hljs-params">(T1 a1, T2 a2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br><span class="hljs-keyword">auto</span> x3 = <span class="hljs-built_in">sum</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">5</span>, <span class="hljs-number">10.5</span>);<br></code></pre></td></tr></table></figure><p>这时可以使用 <code>decltype</code> 进行优化 <span class="label label-info">C++ 11</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a1, T2 a2)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(a1 + a2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <ul><li><code>decltype(a1 + a2)</code>的作用域是这个函数，也就是说表达式里面的变量必须是在函数中的形参 </li><li> 编译阶段进行推导</li></ul>          </div><p>C++ 14 标准已经支持对 <code>auto</code> 声明的返回类型进行推导了 <span class="label label-warning">C++ 14</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T1, <span class="hljs-keyword">class</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a1, T2 a2)</span> </span>&#123; <span class="hljs-comment">// 直接去掉 decltype 说明符即可</span><br>    <span class="hljs-keyword">return</span> a1 + a2;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>auto</code>作为返回类型的占位符还存在一些问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">return_ref</span><span class="hljs-params">(T&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">static_assert</span>(std::is_reference_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">return_ref</span>(x1))&gt;); <span class="hljs-comment">// 编译错误，返回值不为引用类型</span><br></code></pre></td></tr></table></figure><p>这里 <code>auto</code> 被推导为值类型，参考 <code>auto</code> 占位符规则，如果想正确地返回引用类型，则需要使用 <code>decltype</code> 说明符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">return_ref</span><span class="hljs-params">(T&amp; t)</span> -&gt; <span class="hljs-title">decltype</span><span class="hljs-params">(t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">static_assert</span>(std::is_reference_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">return_ref</span>(x1))&gt;); <span class="hljs-comment">// 编译成功</span><br></code></pre></td></tr></table></figure><ul><li><p>推导规则 <code>decltype(e)</code>，<code>e</code>的类型为<code>T</code></p><ul><li>如果 <code>e</code> 是一个未加括号的标识符表达式（结构化绑定除外）或者未加括号的类成员访问，则 <code>decltype(e)</code> 推断出的类型是 <code>e</code> 的类型 <code>T</code>。如果并不存在这样的类型，或者<code>e</code> 是一组重载函数，则无法进行推导 <span class="label label-light">没有候选或者候选太多</span><ul><li>如果加上括号则推断出的是引用类型</li></ul></li><li>如果 <code>e</code> 是一个函数调用或者仿函数调用，那么 <code>decltype(e)</code> 推断出的类型是其返回值的类型</li><li>如果 <code>e</code> 是一个类型为 <code>T</code> 的左值，则 <code>decltype(e)</code> 是<code>T&amp;</code></li><li>如果 <code>e</code> 是一个类型为 <code>T</code> 的将亡值，则 <code>decltype(e)</code> 是<code>T&amp;&amp;</code></li><li>除去以上情况，则 <code>decltype(e)</code> 是<code>T</code></li></ul></li><li><p>cv 限定符的推导</p><ul><li><p>通常情况下，<code>decltype(e)</code>所推导的类型会同步 <code>e</code> 的 cv 限定符</p></li><li><p>当 <code>e</code> 是未加括号的成员变量时，父对象表达式的 cv 限定符会被忽略，不能同步推导结果，只有加括号时 cv 限定符会同步到推断结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">double</span> x;<br>&#125;<br><span class="hljs-type">const</span> A* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">A</span>();<br><span class="hljs-keyword">decltype</span>(a-&gt;x); <span class="hljs-comment">//  decltype(a-&gt;x) 推导类型为 double，const 属性被忽略</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><code>decltype(auto)</code> <span class="label label-warning">C++ 14</span></p><ul><li>告诉编译器用 <code>decltype</code> 推导表达式规则来推导<code>auto</code></li><li><code>decltype(auto)</code>必须单独声明，不能结合指针、引用以及 cv 限定符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i;<br><span class="hljs-function"><span class="hljs-type">int</span>&amp;&amp; <span class="hljs-title">f</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">auto</span> x1a = i;                     <span class="hljs-comment">// x1a 推导类型为 int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) x1d = i;           <span class="hljs-comment">// x1d 推导类型为 int</span><br><span class="hljs-keyword">auto</span> x2a = (i);                   <span class="hljs-comment">// x2a 推导类型为 int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) x2d = (i);         <span class="hljs-comment">// x2d 推导类型为 int&amp;</span><br><span class="hljs-keyword">auto</span> x3a = <span class="hljs-built_in">f</span>();                   <span class="hljs-comment">// x3a 推导类型为 int</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) x3d = <span class="hljs-built_in">f</span>();         <span class="hljs-comment">// x3d 推导类型为 int&amp;&amp;</span><br><span class="hljs-keyword">auto</span> x4a = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;              <span class="hljs-comment">// x 推导类型为 std::initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) x4d = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;    <span class="hljs-comment">// 编译失败，&#123; 1, 2 &#125; 不是表达式</span><br><span class="hljs-keyword">auto</span> *x5a = &amp;i;                   <span class="hljs-comment">// x5a 推导类型为 int*</span><br><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) *x5d = &amp;i;         <span class="hljs-comment">// x 编译失败，decltype(auto) 必须单独声明</span><br></code></pre></td></tr></table></figure><ul><li><p><code>auto</code>和 <code>decltype(auto)</code> 的用法几乎相同，只是在推导规则上遵循 <code>decltype</code> 而已</p></li><li><p>之前代码 <code>return_ref</code> 想返回一个引用类型，但是如果直接使用 <code>auto</code>，则一定会返回一个值类型，解决方案是采用后置的方式声明返回类型，现在可以通过<code>decltype(auto)</code> 也可以解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) <span class="hljs-title">return_ref</span><span class="hljs-params">(T&amp; t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">static_assert</span>(std::is_reference_v&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">return_ref</span>(x1))&gt;); <span class="hljs-comment">// 编译成功</span><br></code></pre></td></tr></table></figure></li><li><p><code>decltype(auto)</code>作为非理性模板形参占位符</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">decltype</span>(<span class="hljs-keyword">auto</span>) N&gt;</span><br><span class="hljs-function"> <span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; N &lt;&lt; std::endl;<br> &#125;<br> <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> x = <span class="hljs-number">11</span>;<br> <span class="hljs-type">static</span> <span class="hljs-type">int</span> y = <span class="hljs-number">7</span>;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">f</span>&lt;x&gt;();   <span class="hljs-comment">// N 为 const int 类型</span><br>    <span class="hljs-built_in">f</span>&lt;(x)&gt;(); <span class="hljs-comment">// N 为 const int&amp; 类型</span><br>    <span class="hljs-built_in">f</span>&lt;y&gt;();   <span class="hljs-comment">// 编译失败，因为 y 不是一个常量，编译器无法对函数模板进行实例化</span><br>    <span class="hljs-built_in">f</span>&lt;(y)&gt;(); <span class="hljs-comment">// N 为 int&amp; 类型，恰好对于静态对象而言内存地址时固定的，所以可以通过编译</span><br> &#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="05- 函数返回类型后置"><a href="#05- 函数返回类型后置" class="headerlink" title="05 函数返回类型后置"></a>05 函数返回类型后置 <span class="label label-info">C++ 11</span></h2><ul><li><p>返回类型比较复杂的是时候，比如返回一个函数指针类型，使用返回类型后置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bar_impl</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span><span class="hljs-params">(*bar)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function">bar <span class="hljs-title">foo1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> bar_impl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">foo2</span><span class="hljs-params">()</span> -&gt; <span class="hljs-title">int</span> <span class="hljs-params">(*)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> bar_impl;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了返回类型后置，返回类型就可以用 <code>auto</code> 占位符，再后置函数指针类型，不需要写<code>typedef</code></p></li><li><p>推导函数模板返回类型</p></li></ul><h2 id="06- 右值引用"><a href="#06- 右值引用" class="headerlink" title="06 右值引用"></a>06 右值引用 </h2><h3 id="左值和右值"><a href="# 左值和右值" class="headerlink" title="左值和右值"></a> 左值和右值</h3><ul><li><code>i++</code>：先把 <code>i</code> 的值取出来存到临时变量中，再把 <code>i</code> 加一，最后返回的是临时变量的值，属于右值（将亡值）</li><li><code>++i</code>：自增后将自己返回，属于左值</li><li>但凡能取地址<code>&amp;</code>，就是左值</li><li>通常字面量都是一个右值，除了字符串字面量以外<ul><li>字符串是一块连续的内存，通常存在静态数据去里面</li></ul></li></ul><h3 id="左值引用"><a href="# 左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><div class="note note-warning">            <ul><li>指针最危险的地方在于可以运算</li><li>C++ 是弱类型语言，类型之前可以随意转换</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> &amp;x1 = <span class="hljs-number">7</span>; <span class="hljs-comment">// 编译错误</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;x2 = <span class="hljs-number">11</span>; <span class="hljs-comment">// 编译成功</span><br></code></pre></td></tr></table></figure><ul><li>非常量左值的引用对象必须是一个左值<ul><li><span class="label label-warning">引用一块内存首先要有一块内存，如果引用右值，内存都不知道在哪，肯定就有问题了</span></li></ul></li><li>常量左值引用的对象可以是左值，也可以是右值</li><li>在函数形参列表中有着很大的作用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123;&#125;<br>    X&amp; <span class="hljs-keyword">operator</span> = (<span class="hljs-type">const</span> X&amp;) &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br><br><span class="hljs-function">X <span class="hljs-title">make_X</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    X x1;<br>    X x2;<br>    <span class="hljs-function">X <span class="hljs-title">x3</span><span class="hljs-params">(make_X())</span></span>;<br>    x3 = <span class="hljs-built_in">make_X</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果将类 <code>X</code> 的复制构造函数和复制赋值构造函数形参类型的常量性删除，则 <code>X x3(make_X());</code> 和<code>x3 = make_X();</code>会报错，因为非常量左值引用无法绑定到右值上</li><li>缺点是一旦使用了常量左值应用，就无法在函数内部修改该对象的内容</li></ul><div class="note note-warning">            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">X <span class="hljs-title">make_X</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">X</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p>C++ 17 之后编译器有做拷贝优化，虽然返回值是右值，函数返回类型是左值，因为做了拷贝优化所以不会报错</p>          </div><h3 id="右值引用"><a href="# 右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><ul><li>右值引用可以延长右值的声明周期</li><li>右值引用可以减少对象复制，提升程序性能</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigMemoryPool</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> PoolSize = <span class="hljs-number">4096</span>;<br>    <span class="hljs-built_in">BigMemoryPool</span>() : <span class="hljs-built_in">pool_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[PoolSize]) &#123;&#125;<br>    ~<span class="hljs-built_in">BigMemoryPool</span>()<br>    &#123;<br>        <span class="hljs-keyword">if</span> (pool_ != <span class="hljs-literal">nullptr</span>) &#123;<br>            <span class="hljs-keyword">delete</span>[] pool_;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 移动构造器</span><br>    <span class="hljs-built_in">BigMemoryPool</span>(BigMemoryPool&amp;&amp; other)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;move big memory pool.&quot;</span> &lt;&lt; std::endl;<br>        pool_ = other.pool_;<br>        other.pool_ = <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <span class="hljs-comment">// 复制构造器</span><br>    <span class="hljs-built_in">BigMemoryPool</span>(<span class="hljs-type">const</span> BigMemoryPool&amp; other) : <span class="hljs-built_in">pool_</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[PoolSize])<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy big memory pool.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">memcpy</span>(pool_, other.pool_, PoolSize);<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">char</span> *pool_;<br>&#125;;<br><br><span class="hljs-function">BigMemoryPool <span class="hljs-title">get_pool</span><span class="hljs-params">(<span class="hljs-type">const</span> BigMemoryPool&amp; pool)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> pool;<br>&#125;<br><br><span class="hljs-function">BigMemoryPool <span class="hljs-title">make_pool</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BigMemoryPool pool;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get_pool</span>(pool);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BigMemoryPool my_pool = <span class="hljs-built_in">make_pool</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>调用复制构造函数会严重影响运行性能</li><li>对于复制构造函数而言形参是一个左值引用，函数的实参必须是一个具名的左值，不能破坏实参对象的前提下复制目标对象</li><li>移动构造函数接受的是一个右值，通过转移实参对象的数据以达成构造目标对象的目的，也就是说实参对象是会被修改的<ul><li>传过来的参数用过之后就没有用了</li></ul></li><li>编译器生成的移动构造函数和复制构造函数并没有什么区别</li><li>编写移动语义的函数时建议确保函数不会抛出异常</li><li>如果无法保证移动构造函数不会抛出异常，可以使用 <code>noexcept</code> 说明符限制该函数。这样当函数抛出异常的时候，程序不会再继续执行而是调用 <code>std::terminate</code> 中止执行</li></ul><h3 id="值类别"><a href="# 值类别" class="headerlink" title="值类别"></a>值类别</h3><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2024/07/18/ba744a9761cc/lvalue-rvalue.png"></div></div></div><ul><li><p>左值和右值实际上指的是表达式，表达式的结果就是值</p></li><li><p>将亡值产生</p><ul><li><p>使用类型转换将泛左值转换为该类型的右值引用</p></li><li><p>临时量实质化 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">X</span>().a;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>纯右值转换到临时对象的过程</li><li>每当纯右值出现在一个需要泛左值的地方时，临时量实质化都会发生——创建一个临时对象并且使用纯右值对其进行初始化</li><li>只要返回的是纯右值就不会调用类的构造函数了</li></ul></li></ul></li><li><p>在 C++11 标准中可以在不创建临时值的情况下显式地将左值通过 <code>static_cast</code> 转换为将亡值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> &amp;&amp;k = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&amp;&amp;&gt;(i);<br></code></pre></td></tr></table></figure></li><li><p>这个转换既不改变生命周期也不改变内存地址，最大作用是让左值使用移动语义</p></li><li><p>正确的使用场景是在一个右值被转换为左值后需要再次转换为右值</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">move_pool</span><span class="hljs-params">(BigMemoryPool &amp;&amp;pool)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;call move_pool&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-function">BigMemoryPool <span class="hljs-title">my_pool</span><span class="hljs-params">(pool)</span></span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">move_pool</span>(<span class="hljs-built_in">make_pool</span>());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无论一个函数的实参是左值还是右值，其形参都是一个左值，即使这个形参看上去是一个右值引用</li><li><code>BigMemoryPool my_pool(pool);</code> 还是会调用复制构造函数而非移动构造函数</li><li><code>BigMemoryPool my_pool(static_cast&lt;BigMemoryPool&amp;&amp;&gt;(pool));</code>则会调用移动构造函数进行构造</li><li>在 C++ 11 的标准库中还提供了一个函数模板 <code>std::move</code> 将左值转换为右值 e.g. <code>BigMemoryPool my_pool(std::move(pool));</code></li></ul><h3 id="万能引用和引用折叠"><a href="# 万能引用和引用折叠" class="headerlink" title="万能引用和引用折叠"></a>万能引用和引用折叠</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;&amp;i)</span> </span>&#123;&#125; <span class="hljs-comment">// i 为右值引用</span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">(T &amp;&amp;t)</span> </span>&#123;&#125; <span class="hljs-comment">// t 为万能引用</span><br></code></pre></td></tr></table></figure><ul><li><code>&amp;&amp;i</code>就是定义出来具体的参数，字面意思</li><li>而模板有实例化的过程，所以就是万能引用</li><li>所谓的万能引用就是发生类型推导</li></ul><table><thead><tr><th>模板类型</th><th><code>T</code>实际类型</th><th>最终类型</th></tr></thead><tbody><tr><td><code>T&amp;</code></td><td><code>R</code></td><td><code>R&amp;</code></td></tr><tr><td><code>T&amp;</code></td><td><code>R&amp;</code></td><td><code>R&amp;</code></td></tr><tr><td><code>T&amp;</code></td><td><code>R&amp;&amp;</code></td><td><code>R&amp;</code></td></tr><tr><td><code>T&amp;&amp;</code></td><td><code>R</code></td><td><code>R&amp;&amp;</code></td></tr><tr><td><code>T&amp;&amp;</code></td><td><code>R&amp;</code></td><td><code>R&amp;</code></td></tr></tbody></table><div class="note note-warning">            <p>“遇左则左”</p><ul><li>只要有左值引用参与进来，最后推导的结果就是一个左值引用 </li><li> 只有实际类型是一个非引用类型或者右值引用类型时，最后推导出来的才是一个右值引用</li></ul>          </div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">show_type</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(t).<span class="hljs-built_in">name</span>() &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">normal_forwarding</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">show_type</span>(t);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">get_string</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi world&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string s = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    <span class="hljs-built_in">normal_forwarding</span>(s);<br>    <span class="hljs-built_in">normal_forwarding</span>(<span class="hljs-built_in">get_string</span>()); <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>normal_forwarding(get_string());</code>因为 <code>normal_forwarding</code> 接受的是左值，而传入的是右值</p></li><li><p>可以将 <code>void normal_forwarding(T &amp;t)</code> 替换为 <code>void normal_forwarding (const T &amp;t)</code> 来解决这个问题</p><ul><li>常量左值引用是可以引用右值的</li><li>但是不能修改传入进来的数据了</li></ul></li><li><p>可以用引用折叠规则来处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">perfect_forwarding</span><span class="hljs-params">(T &amp;&amp;t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">show_type</span>(<span class="hljs-built_in">static_cast</span>&lt;T&amp;&amp;&gt;(t));<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 C++ 11 的标准库中提供了一个 <code>std::forward</code> 函数模板，在函数内部也是使用 <code>static_cast</code> 进行类型转换</p></li></ul><p><code>remove_reference</code>移除引用，根据不同的类型去匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span> &#123;<br>    <span class="hljs-keyword">using</span> type                 = _Ty;<br>    <span class="hljs-keyword">using</span> _Const_thru_ref_type = <span class="hljs-type">const</span> _Ty;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Ty&amp;&gt; &#123;<br>    <span class="hljs-keyword">using</span> type                 = _Ty;<br>    <span class="hljs-keyword">using</span> _Const_thru_ref_type = <span class="hljs-type">const</span> _Ty&amp;;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">remove_reference</span>&lt;_Ty&amp;&amp;&gt; &#123;<br>    <span class="hljs-keyword">using</span> type                 = _Ty;<br>    <span class="hljs-keyword">using</span> _Const_thru_ref_type = <span class="hljs-type">const</span> _Ty&amp;&amp;;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>std::forward</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> _Ty&amp;&amp; <span class="hljs-title">forward</span><span class="hljs-params">(<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;_Ty&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>std::move</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">_Ty</span>&gt;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp; <span class="hljs-title">move</span><span class="hljs-params">(_Ty&amp;&amp; _Arg)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-type">remove_reference_t</span>&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="针对局部变量和右值引用的隐式移动操作"><a href="# 针对局部变量和右值引用的隐式移动操作" class="headerlink" title="针对局部变量和右值引用的隐式移动操作"></a>针对局部变量和右值引用的隐式移动操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-built_in">X</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;copy ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-built_in">X</span>(X&amp;&amp;) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;move ctor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function">X <span class="hljs-title">get</span><span class="hljs-params">(X x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    X x = <span class="hljs-built_in">get</span>(X&#123;&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><code>-fno-elide-constructors</code>选项用于关闭返回值优化，才会出现三次输出</p>          </div><ul><li>如果没有移动构造函数，则会调用三次复制构造函数</li><li>如果定义了移动构造函数，会隐式地采用移动构造函数，调用三次移动构造函数</li><li>隐式移动操作针对右值引用和 <code>throw</code> 的情况进行了扩展 <span class="label label-primary">C++ 20</span></li><li>可隐式移动的对象必须是一个非易失或一个右值引用的非易失自动存储对象，在以下情况下可以使用移动代替复制<ul><li><code>return</code>或者 <code>co_return</code> 语句中的返回对象是函数或者 lambda 表达式中的对象或形参</li><li><code>throw 语 </code> 句中抛出的对象是函数或 <code>try</code> 代码块中的对象</li></ul></li></ul><h3 id="小结"><a href="# 小结" class="headerlink" title="小结"></a>小结 </h3><p> 对于这些优化空间，C++ 委员会已经对标准库进行了优化，比如常用的容器 <code>vector</code>、<code>list</code> 和<code>map</code>等均已支持移动构造函数和移动赋值运算符函数。另外，如 <code>make_pair</code>、<code>make_tuple</code> 以及 <code>make_shared</code> 等也都使用完美转发以提高程序的性能</p><h2 id="07-lambda- 表达式"><a href="#07-lambda- 表达式" class="headerlink" title="07 lambda 表达式"></a>07 lambda 表达式</h2><ul><li><p>语法定义：<font color="#FF204E">[captures]</font><font color="#A0153E">(params)</font> <font color="#58A399">specifiers</font> <font color="#A8CD9F">exception</font> <font color="#496989">-&gt; ret</font> <font color="#00224D">{body}</font></p><ul><li><font color="#FF204E"><code>[captures]</code></font>在大部分其他语言是不存在的，因为诸如 Java、C# 等语言是有 GC 机制的，不需要担心捕获对象的声明周期的问题</li><li><font color="#FF204E"><code>[captures]</code></font> —— 捕获列表，它可以捕获当前函数作用域的零个或多个变量，变量之间用逗号分隔。捕获列表的捕获方式有两种：按值捕获和引用捕获</li><li><font color="#A0153E"><code>(params)</code></font> —— 可选参数列表，语法和普通函数的参数列表一样，在不需要参数的时候可以忽略参数列表</li><li><font color="#58A399"><code>specifiers</code></font> —— 可选限定符，C++11 中可以用 <code>mutable</code>，它允许在 lambda 表达式函数体内改变按值捕获的变量，或者调用非<code>const</code> 的成员函数</li><li><font color="#A8CD9F"><code>exception</code></font> —— 可选异常说明符，可以使用 <code>noexcept</code> 来指明 lambda 是否会抛出异常</li><li><font color="#496989"><code>-&gt; ret</code></font> —— 可选返回值类型，不同于普通函数，lambda 表达式使用返回类型后置的语法来表示返回类型，如果没有返回值（<code>void</code>类型），可以忽略包括 <code>-&gt;</code> 在内的整个部分</li><li><font color="#00224D"><code>&#123; body &#125;</code></font> —— lambda 表达式的函数体，这个部分和普通函数的函数体一样</li></ul></li><li><p>不允许捕获全局变量和静态变量，因为可以直接使用</p></li><li><p><strong>lambda 表达式按值捕获每次调用都会保留上一次修改的值</strong>，具体参考 lambda 表达式实现原理</p></li><li><p>特殊的捕获方法</p><ul><li><code>[this]</code> —— 捕获 <code>this</code> 指针，捕获 <code>this</code> 指针可以使用 <code>this</code> 类型的成员变量和函数</li><li><code>[=]</code> —— 捕获 lambda 表达式定义作用域的全部变量的值，包括<code>this</code></li><li><code>[&amp;]</code> —— 捕获 lambda 表达式定义作用域的全部变量的引用，包括<code>this</code></li></ul></li><li><p>lambda 表达式的优势在于书写简单方便且易于维护</p></li><li><p>函数对象的优势在于使用更加灵活不受限制</p></li><li><p>lambda 表达式实现原理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>, y = <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">auto</span> foo = [=] &#123; <span class="hljs-keyword">return</span> x * y; &#125;;<br>    <span class="hljs-type">int</span> z = <span class="hljs-built_in">foo</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>用 CppInsights 输出其 GIMPLE 的中间代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">__lambda_5_16</span><br>    &#123;<br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-keyword">inline</span> <span class="hljs-comment">/*constexpr */</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> x * y;<br>        &#125;<br>        <br>    <span class="hljs-keyword">private</span>: <br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-type">int</span> y;<br>        <br>    <span class="hljs-keyword">public</span>:<br>        __lambda_5_16(<span class="hljs-type">int</span> &amp; _x, <span class="hljs-type">int</span> &amp; _y): x&#123;_x&#125;, y&#123;_y&#125; &#123;&#125;<br>    &#125;;<br><br>    __lambda_5_16 foo = __lambda_5_16&#123;x, y&#125;;<br>    <span class="hljs-type">int</span> z = foo.<span class="hljs-built_in">operator</span>()();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>lambda 表达式在编译期会由编译器自动生成一个闭包类，在运行时由这个闭包类产生一个对象，称为闭包。在 C++ 中，所谓的闭包可以简单地理解为一个匿名且可以包含定义时作用域上下文的函数对象</li><li>lambda 表达式是 C++11 提供的一块语法糖而已，lambda 表达式的功能完全能够手动实现，而且如果实现合理，代码在运行效率上也不会有差距，只不过实用 lambda 表达式让代码编写更加轻松了</li></ul></li><li><p>无状态的 lambda 表达式</p><ul><li><p>有状态会在匿名类中定义按值捕获的变量，从而在每次调用的时候都会保持变量上一次的状态</p></li><li><p>如果是无状态的 lambda 表达式，可以隐式转换为函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">void</span>(*)())</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">f</span>([] &#123;&#125;); &#125; <span class="hljs-comment">// 编译成功</span><br></code></pre></td></tr></table></figure></li><li><p>尽量让 lambda 表达式“纯粹”一些，不捕获外部变量</p></li></ul></li><li><p>在 STL 中使用 lambda 表达式</p><ul><li><code>std::sort</code>、<code>std::find_if</code></li></ul></li><li><p>广义捕获 <span class="label label-warning">C++ 14</span></p><ul><li><p>简单捕获</p></li><li><p>初始化捕获</p><ul><li>捕获表达式结果</li><li>自定义捕获变量名</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">auto</span> foo1 = [x = x + <span class="hljs-number">1</span>] &#123; <span class="hljs-keyword">return</span> x; &#125;; <span class="hljs-comment">// 两个 x 的作用域不一样</span><br>    <span class="hljs-keyword">auto</span> foo2 = [r = x + <span class="hljs-number">1</span>] &#123; <span class="hljs-keyword">return</span> r; &#125;; <span class="hljs-comment">// 推荐的写法</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::string x = <span class="hljs-string">&quot;hello c++ &quot;</span>;<br>    <span class="hljs-keyword">auto</span> foo = [x = std::<span class="hljs-built_in">move</span>(x)]&#123; <span class="hljs-keyword">return</span> x + <span class="hljs-string">&quot;world&quot;</span>; &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用 <code>std::move</code> 对捕获列表变量 x 进行初始化，这样避免了简单捕获的复制对象操作</li></ul></li><li><p>异步调用时复制 <code>this</code> 对象，防止 lambda 表达式被调用时因原始 <code>this</code> 对象被析构造成未定义的行为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;future&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Work</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">42</span>) &#123;&#125;<br>    <span class="hljs-function">std::future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spawn</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>([=]() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> value; &#125;);<br>    &#125;<br>&#125;;<br><span class="hljs-function">std::future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    Work tmp;<br>    <span class="hljs-keyword">return</span> tmp.<span class="hljs-built_in">spawn</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::future&lt;<span class="hljs-type">int</span>&gt; f = <span class="hljs-built_in">foo</span>();<br>    f.<span class="hljs-built_in">wait</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;f.get() = &quot;</span> &lt;&lt; f.<span class="hljs-built_in">get</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-secondary">            <p>输出结果 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">f.get() = 32766<br></code></pre></td></tr></table></figure><p><code>f.wait()</code> 调用之后，访问 <code>value</code> 这块内存的时候已经是未知的状态</p>          </div><p>解决方法就是可以将对象复制到 lambda 表达式内</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Work</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Work</span>() : <span class="hljs-built_in">value</span>(<span class="hljs-number">42</span>) &#123;&#125;<br>    <span class="hljs-function">std::future&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">spawn</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">async</span>([=, tmp = *<span class="hljs-keyword">this</span>]() -&gt; <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> tmp.value; &#125;);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>这种方式也不能解决所有问题，一个技术手段是不能解决所有问题的，需要在合适的场景下提出不同的解决方案</p>          </div></li></ul></li><li><p>泛型 lambda 表达式 <span class="label label-warning">C++ 14</span></p><ul><li>定义方式不用 <code>template</code> 关键字，只需要使用 <code>auto</code> 占位符即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> foo = [](<span class="hljs-keyword">auto</span> a) &#123; <span class="hljs-keyword">return</span> a; &#125;;<br>    <span class="hljs-type">int</span> three = <span class="hljs-built_in">foo</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">char</span> <span class="hljs-type">const</span>* hello = <span class="hljs-built_in">foo</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>常量 lambda 表达式 <span class="label label-success">C++ 17</span></p></li><li><p>捕获 <code>*this</code> 增强 <span class="label label-success">C++ 17</span></p><ul><li>不需要额外定义变量初始化捕获列表，直接使用 <code>*this</code> 就是一份拷贝</li></ul></li><li><p>捕获<code>[=, this]</code> <span class="label label-primary">C++ 20</span></p><ul><li>表达的意思和 <code>[=]</code> 相同，目的区分它与 <code>[=,*this]</code> 的不同</li><li>C++ 20 标准中还特别强调了要用 <code>[=, this]</code> 代替<code>[=]</code></li><li>希望捕获 <code>this</code> 时，把 <code>this</code> 写出来</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_std_vector</span> : std::false_type &#123; &#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_std_vector</span>&lt;std::vector&lt;T&gt;&gt; : std::true_type &#123; &#125;;<br><br><span class="hljs-keyword">auto</span> f = [](<span class="hljs-keyword">auto</span> vector) &#123;<br>    <span class="hljs-built_in">static_assert</span>(is_std_vector&lt;<span class="hljs-keyword">decltype</span>(vector)&gt;::value, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 静态断言失败，需要传入 vector&lt;T&gt; 类型</span><br><br><span class="hljs-keyword">auto</span> v = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;();<br><span class="hljs-built_in">f</span>(v); <span class="hljs-comment">// 正确</span><br></code></pre></td></tr></table></figure><ul><li><p>普通的函数模板可以轻松地通过形参模式匹配一个实参为 <code>vector</code> 的容器对象，但是对于 lambda 表达式，<code>auto</code>不具备这种表达能力，所以不得不实现 <code>is_std_vector</code>，并且通过<code>static_assert</code> 来辅助判断实参的真实类型是否为<code>vector</code></p></li><li><p>如果用 lambda 表达式想获取 <code>vector</code> 里面的 <code>T</code> 的类型就会更复杂</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [] (<span class="hljs-keyword">auto</span> vector) &#123;<br>    <span class="hljs-keyword">using</span> T = <span class="hljs-keyword">typename</span> <span class="hljs-keyword">decltype</span>(vector)::value_type;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>vector</code>容器类型会使用内嵌类型 <code>value_type</code> 表示存储对象的类型</li><li>不能保证面对的所有容器都会实现这一规则，所以依赖内嵌类型是不可靠的</li></ul></li><li><p>还有一个问题是 <code>decltype(obj)</code> 有时候并不能直接获取想要的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x) &#123;<br>    <span class="hljs-keyword">using</span> T = <span class="hljs-keyword">decltype</span>(x);<br>    T copy = x; <span class="hljs-comment">// 可以编译，但是语义错误</span><br>    <span class="hljs-keyword">using</span> Iterator = <span class="hljs-keyword">typename</span> T::iterator; <span class="hljs-comment">// 编译错误</span><br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>decltype(x)</code>推导出来的类型并不是 <code>std::vector</code>，而是<code>const std::vector &amp;</code>，所以<code>T copy = x;</code> 不是一个复制而是引用</p></li><li><p>对于一个引用类型来说，<code>T::iterator</code>也是不符合语法的，所以编译出错</p></li><li><p>可以将类型的 cv 以及引用属性删除</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f = [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; x) &#123;<br>    <span class="hljs-keyword">using</span> T = std::<span class="hljs-type">decay_t</span>&lt;<span class="hljs-keyword">decltype</span>(x)&gt;;<br>    T copy = x;<br>    <span class="hljs-keyword">using</span> Iterator = <span class="hljs-keyword">typename</span> T::iterator;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>模板语法的泛型 lambda 表达式 <span class="label label-primary">C++ 20</span></p><ul><li><code>[]&lt;template T&gt;(T t) &#123;&#125;</code></li></ul></li><li><p>可构造和可赋值的无状态 lambda 表达式 <span class="label label-primary">C++ 20</span></p><ul><li><p><code>std::sort</code>和 <code>std::find_if</code> 这样的函数需要一个函数对象或函数指针来辅助排序和查找，这种情况可以使用 lambda 表达式完成任务</p></li><li><p><code>std::map</code>的比较函数对象是通过模板参数确定的，这个时候需要的是一个类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> greater = [](<span class="hljs-keyword">auto</span> x, <span class="hljs-keyword">auto</span> y) &#123; <span class="hljs-keyword">return</span> x &gt; y; &#125;;<br>std::map&lt;std::string, <span class="hljs-type">int</span>, <span class="hljs-keyword">decltype</span>(greater)&gt; mymap; <span class="hljs-comment">// 需要的是类型所以用 `decltype`</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <ul><li>但是在 C++ 17 标准中是不可行的，因为 lambda 表达式类型无法构造，lambda 表达式的默认构造函数已经被删除了 </li><li> 无状态的 lambda 表达式也没办法赋值，原因是复制赋值函数被删除了 </li><li> 使用 C++ 20 标准的编译环境来编译上面的代码是可行的</li></ul>          </div></li></ul></li></ul><h2 id="08- 非静态数据成员默认初始化"><a href="#08- 非静态数据成员默认初始化" class="headerlink" title="08 非静态数据成员默认初始化"></a>08 非静态数据成员默认初始化</h2><ul><li><p>声明非静态数据成员的同时直接对其使用 <code>=</code> 或者 <code>&#123;&#125;</code> 初始化 <span class="label label-info">C++ 11</span></p></li><li><p>在此之前只有类型为整型或者枚举类型的常量静态数据成员才可以这样初始化</p></li><li><p>初始化列表对数据成员的初始化总是优先于声明时默认初始化</p></li><li><p>不要使用括号 <code>()</code> 对非静态数据成员进行初始化，因为这样会造成解析问题，所以会编译错误</p></li><li><p>不要用 <code>auto</code> 来声明和初始化非静态数据成员</p></li><li><p>位域的默认初始化 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">S</span> &#123;<br>    <span class="hljs-type">int</span> y : <span class="hljs-number">8</span> = <span class="hljs-number">11</span>;<br>    <span class="hljs-type">int</span> z : <span class="hljs-number">4</span> = &#123; <span class="hljs-number">7</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>int</code>数据的低 8 位被初始化为 11，紧跟它的高 4 位被初始化为 7</p></li></ul><h2 id="09- 列表初始化"><a href="#09- 列表初始化" class="headerlink" title="09 列表初始化"></a>09 列表初始化</h2><ul><li>列表初始化，使用大括号 <code>&#123;&#125;</code> 对变量进行初始化 <span class="label label-info">C++ 11</span></li><li>传统变量初始化的规则一样，它也区分为直接初始化和拷贝初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C</span> &#123;<br>    <span class="hljs-built_in">C</span>(std::string a, <span class="hljs-type">int</span> b) &#123;&#125;<br>    <span class="hljs-built_in">C</span>(<span class="hljs-type">int</span> a) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(C)</span> </span>&#123;&#125;<br><br><span class="hljs-function">C <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">5</span>&#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = &#123;<span class="hljs-number">5</span>&#125;;                <span class="hljs-comment">// 拷贝初始化</span><br>    <span class="hljs-type">int</span> x1&#123;<span class="hljs-number">8</span>&#125;;                  <span class="hljs-comment">// 直接初始化</span><br>    C x2 = &#123;<span class="hljs-number">4</span>&#125;;                 <span class="hljs-comment">// 拷贝初始化</span><br>    C x3&#123;<span class="hljs-number">2</span>&#125;;                    <span class="hljs-comment">// 直接初始化</span><br>    <span class="hljs-built_in">foo</span>(&#123;<span class="hljs-number">8</span>&#125;);                   <span class="hljs-comment">// 拷贝初始化</span><br>    <span class="hljs-built_in">foo</span>(&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">8</span>&#125;);          <span class="hljs-comment">// 拷贝初始化</span><br>    C x4 = <span class="hljs-built_in">bar</span>();               <span class="hljs-comment">// 拷贝初始化</span><br>    C *x5 = <span class="hljs-keyword">new</span> C&#123; <span class="hljs-string">&quot;hi&quot;</span>, <span class="hljs-number">42</span> &#125;;  <span class="hljs-comment">// 直接初始化</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>std::initializer_list</code>简单地说就是一个支持 <code>begin</code>、<code>end</code> 以及 <code>size</code> 成员函数的类模板</p><ul><li>实际上是一块连续的内存，也就是数组</li></ul></li><li><p>隐式缩窄转换问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">12345</span>;<br><span class="hljs-type">char</span> y = x; <span class="hljs-comment">// 将超过 char 大小的数据赋值给 char，明显是一个隐式缩窄转换</span><br></code></pre></td></tr></table></figure><ul><li>传统变量初始化中是没有问题的，代码能顺利通过编译</li><li>如果采用列表初始化，根据标准编译器通常会给出一个错误</li><li>隐式缩窄转换发生的情况 <font color="#A0153E"><strong>表示范围大的类型向表示范围小的类型转换就发生了缩窄</strong></font><ul><li>从浮点类型转换整数类型</li><li>从 <code>long double</code> 转换到 <code>double</code> 或<code>float</code>，或从 <code>double</code> 转换到<code>float</code>，除非转换源是常量表达式以及转换后的实际值在目标可以表示的值范围内</li><li>从整数类型或非强枚举类型转换到浮点类型，除非转换源是常量表达式，转换后的实际值适合目标类型并且能够将生成目标类型的目标值转换回原始类型的原始值</li><li>从整数类型或非强枚举类型转换到不能代表所有原始类型值的整数类型，除非源是一个常量表达式，其值在转换之后能够适合目标类型</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">999</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> y = <span class="hljs-number">999</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> z = <span class="hljs-number">99</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> cdb = <span class="hljs-number">99.9</span>;<br><span class="hljs-type">double</span> db = <span class="hljs-number">99.9</span>;<br><span class="hljs-type">char</span> c1 = x; <span class="hljs-comment">// 编译成功，传统变量初始化支持隐式缩窄转换</span><br><span class="hljs-type">char</span> c2&#123; x &#125;; <span class="hljs-comment">// 编译失败，可能是隐式缩窄转换，对应规则 4</span><br><span class="hljs-type">char</span> c3&#123; y &#125;; <span class="hljs-comment">// 编译失败，确定是隐式缩窄转换，999 超出 char 能够适应的范围，对应规则 4</span><br><span class="hljs-type">char</span> c4&#123; z &#125;; <span class="hljs-comment">// 编译成功，99 在 char 能够适应的范围内，对应规则 4</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uc1 = &#123; <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 编译成功，5 在 unsigned char 能够适应的范围内，</span><br><span class="hljs-comment">// 对应规则 4</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> uc2 = &#123; <span class="hljs-number">-1</span> &#125;; <span class="hljs-comment">// 编译失败，unsigned char 不能够适应负数，对应规则 4</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> ui1 = &#123; <span class="hljs-number">-1</span> &#125;; <span class="hljs-comment">// 编译失败，unsigned int 不能够适应负数，对应规则 4</span><br><span class="hljs-type">signed</span> <span class="hljs-type">int</span> si1 = &#123; (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)<span class="hljs-number">-1</span> &#125;; <span class="hljs-comment">// 编译失败，signed int 不能够适应 -1 所对应的</span><br><span class="hljs-comment">//unsigned int，通常是 4294967295，对应规则 4</span><br><span class="hljs-type">int</span> ii = &#123; <span class="hljs-number">2.0</span> &#125;; <span class="hljs-comment">// 编译失败，int 不能适应浮点范围，对应规则 1</span><br><span class="hljs-type">float</span> f1&#123; x &#125;; <span class="hljs-comment">// 编译失败，float 可能无法适应整数或者互相转换，对应规则 3</span><br><span class="hljs-type">float</span> f2&#123; <span class="hljs-number">7</span> &#125;; <span class="hljs-comment">// 编译成功，7 能够适应 float，且 float 也能转换回整数 7，对应规则 3</span><br><span class="hljs-type">float</span> f3&#123; cdb &#125;; <span class="hljs-comment">// 编译成功，99.9 能适应 float，对应规则 2</span><br><span class="hljs-type">float</span> f4&#123; db &#125;; <span class="hljs-comment">// 编译失败，可能是隐式缩窄转无法表达 double，对应规则 2</span><br></code></pre></td></tr></table></figure></li><li><p>如果有一个类同时拥有满足列表初始化的构造函数，且其中一个是以 <code>std::initializer_list</code> 为参数，那么编译器将优先以 <code>std::initializer_list</code> 为参数构造函数</p></li><li><p>指定初始化 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br>Point p&#123; .x = <span class="hljs-number">4</span>, .y = <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">// z = 0</span><br></code></pre></td></tr></table></figure><ul><li><p>并不是什么对象都能够指定初始化</p><ul><li><p>对象必须是一个聚合类型</p></li><li><p>指定的数据成员必须是非静态数据成员 <font color="#A8CD9F">静态数据成员不属于某个对象</font></p></li><li><p>每个非静态数据成员最多只能初始化一次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point p&#123; .y = <span class="hljs-number">4</span>, .y = <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">// 编译失败，y 不能初始化多次</span><br></code></pre></td></tr></table></figure></li><li><p>非静态数据成员的初始化必须按照声明的顺序进行</p><ul><li>在 C 语言中，乱序的指定初始化是合法的，但 C++ 不行</li><li>C++ 中的数据成员会按照声明的顺序构造，按照顺序指定初始化会让代码更容易阅读</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point p&#123; .y = <span class="hljs-number">4</span>, .x = <span class="hljs-number">2</span> &#125;; <span class="hljs-comment">// C++ 编译失败，C 编译正常</span><br></code></pre></td></tr></table></figure></li><li><p>针对联合体中的数据成员只能初始化一次，不能同时指定</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">u</span> &#123;<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* b;<br>&#125;;<br>u f = &#123; .a = <span class="hljs-number">1</span> &#125;; <span class="hljs-comment">// 编译成功</span><br>u g = &#123; .b = <span class="hljs-string">&quot;a&quot;</span> &#125;; <span class="hljs-comment">// 编译成功</span><br>u h = &#123; .a = <span class="hljs-number">1</span>, .b = <span class="hljs-string">&quot;a&quot;</span> &#125;; <span class="hljs-comment">// 编译失败，同时指定初始化联合体中的多个数据成员</span><br></code></pre></td></tr></table></figure></li><li><p>不能嵌套指定初始化数据成员</p><ul><li>C 语言中也是允许的</li><li>C++ 标准认为这个特性很少有用，所以直接禁止了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Line</span> &#123;<br>    Point a;<br>    Point b;<br>&#125;;<br>Line l&#123; .a.y = <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 编译失败，.a.y = 5 访问了嵌套成员，不符合 C++ 标准</span><br></code></pre></td></tr></table></figure><ul><li><p>如果确实想嵌套指定初始化，可以换一种形式来达到目的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Line l&#123; .a &#123; .y = <span class="hljs-number">5</span> &#125; &#125;;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>一旦使用指定初始化，就不能混用其他方法对数据成员初始化了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Point p&#123; .x = <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 编译失败，混用数据成员的初始化</span><br></code></pre></td></tr></table></figure></li><li><p>指定初始化不能初始化数组的某一位置 <font color="#A8CD9F">C++ 标准中给出的禁止理由非常简单，它的语法和 lambda 表达式冲突了</font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arr[<span class="hljs-number">3</span>] = &#123; [<span class="hljs-number">1</span>] = <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 编译失败</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="10- 默认和删除函数"><a href="#10- 默认和删除函数" class="headerlink" title="10 默认和删除函数"></a>10 默认和删除函数</h2><ul><li>在没有自定义构造函数的情况下，编译器会为类添加默认的构造函数<ul><li>默认构造函数</li><li>析构函数</li><li>复制构造函数</li><li>复制赋值运算符函数</li><li>移动构造函数 <span class="label label-info">C++ 11</span></li><li>移动赋值运算符函数 <span class="label label-info">C++ 11</span></li></ul></li><li>添加默认特殊成员函数也会带来一些问题<ul><li>声明任何构造函数都会抑制默认构造函数的添加 <font color="#A8CD9F">显示的定义了非默认构造函数，编译器不再为类提供默认构造函数</font></li><li>一旦用自定义构造函数代替默认构造函数，类就将转变为 <font color="#A0153E"><strong> 非平凡类型</strong></font><ul><li><font color="#496989">如果自定义了构造函数（即使是默认构造函数），有可能编译器只能看到声明，看不到实现，就没办法做一些优化处理了</font></li><li>平凡类型可以想象为 C 的结构体</li></ul></li><li>没有明确的办法彻底禁止特殊成员函数的生成 <font color="#A8CD9F"> C++ 11 之前</font></li></ul></li></ul><p>禁止重载函数的某些版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">long</span> &amp;)</span></span>; <span class="hljs-comment">// 访问属性设置为 private，目的不想让其被重载</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::foo; <span class="hljs-comment">// 将父类中所有 `foo` 函数全部导入</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Derived d;<br>    d.<span class="hljs-built_in">foo</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    d.<span class="hljs-built_in">foo</span>(<span class="hljs-number">5</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>无法通过编译。因为 <code>using</code> 说明符无法将基类的私有成员函数引入子类当中</li><li>C++ 11 标准提供了一种方法能够简单有效又精确地控制默认特殊成员函数的添加和删除</li><li>在声明函数的尾部添加 <code>= default</code> 和<code>= delete</code></li><li>相对于使用 <code>private</code> 限制函数访问，使用 <code>= delete</code> 更加彻底，它从编译层面上抑制了函数的生成，所以无论调用者是什么身份（包括类的成员函数），都无法调用被删除的函数</li><li>显式删除不仅适用于类的成员函数，对于普通函数同样有效 <font color="#A8CD9F">应用于普通函数的意义就不大了</font></li><li>显式删除还可以用于类的 <code>new</code> 运算符和类析构函数<ul><li>作用于 <code>new</code> 运算符可以阻止该类在堆上动态创建对象</li></ul></li><li>在类的构造函数上同时使用 <code>explicit</code> 和<code>= delete</code>是一个不明智的做法，它常常会造成代码行为混乱难以理解，应尽量避免这样做</li></ul><h2 id="11- 非受限联合类型"><a href="#11- 非受限联合类型" class="headerlink" title="11 非受限联合类型"></a>11 非受限联合类型</h2><ul><li>C++ 中的联合类型（<code>union</code>）可以说是节约内存的一个典型代表</li><li>在联合类型中多个对象可以共享一片内存，相应的这片内存也只能由一个对象使用</li><li>过去的 C++ 标准规定，联合类型的成员变量的类型不能是一个非平凡类型，也就是说它的成员类型不能有自定义构造函数</li><li>在 C++11 中如果有联合类型中存在非平凡类型，那么这个联合类型的特殊成员函数将被隐式删除，也就是说必须至少提供联合类型的构造和析构函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    <span class="hljs-built_in">U</span>() &#123;&#125; <span class="hljs-comment">// 存在非平凡类型成员，必须提供构造函数</span><br>    ~<span class="hljs-built_in">U</span>() &#123;&#125; <span class="hljs-comment">// 存在非平凡类型成员，必须提供析构函数</span><br>    <span class="hljs-type">int</span> x1;<br>    <span class="hljs-type">float</span> x2;<br>    std::string x3;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; x4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    U u;<br>    u.x3 = <span class="hljs-string">&quot;hello world&quot;</span>; <span class="hljs-comment">// 因为非平凡类型 x3 并没有被构造，所以在赋值操作的时候必然会出错</span><br>    std::cout &lt;&lt; u.x3;<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    <span class="hljs-built_in">U</span>() : <span class="hljs-built_in">x3</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">U</span>() &#123; x3.~<span class="hljs-built_in">basic_string</span>(); &#125;<br>    <span class="hljs-type">int</span> x1;<br>    <span class="hljs-type">float</span> x2;<br>    std::string x3;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; x4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    U u;<br>    u.x3 = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    std::cout &lt;&lt; u.x3;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在构造函数中添加了初始化列表来构造 <code>x3</code>，在析构函数中手动调用了<code>x3</code> 的析构函数</li><li>联合类型在析构的时候编译器并不知道当前激活的是哪个成员，所以无法自动调用成员的析构函数</li><li>但是如果初始化 <code>x4</code> 又会出现问题，所以继续修改代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">U</span> &#123;<br>    <span class="hljs-built_in">U</span>() &#123;&#125;<br>    ~<span class="hljs-built_in">U</span>() &#123;&#125;<br>    <span class="hljs-type">int</span> x1;<br>    <span class="hljs-type">float</span> x2;<br>    std::string x3;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; x4;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    U u;<br><br>    <span class="hljs-keyword">new</span>(&amp;u.x3) std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    std::cout &lt;&lt; u.x3 &lt;&lt; std::endl;<br>    u.x3.~<span class="hljs-built_in">basic_string</span>();<br><br>    <span class="hljs-keyword">new</span>(&amp;u.x4) std::vector&lt;<span class="hljs-type">int</span>&gt;;<br>    u.x4.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">58</span>);<br>    std::cout &lt;&lt; u.x4[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>    u.x4.~<span class="hljs-built_in">vector</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>上面的代码用了 placement new 的技巧来初始化构造 <code>x3</code> 和<code>x4</code>对象</p></li><li><p>在使用完对象后手动调用对象的析构函数</p></li><li><p>通过这样的方法保证了联合类型使用的灵活性和正确性</p></li><li><p>联合类型其实就是 C 语言的遗产</p></li><li><p>可以使用 <code>std::variant</code> 来代替联合类型 <span class="label label-success">C++ 17</span></p><ul><li>是 <font color="#A8CD9F"> 类型安全 </font> 的联合类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;variant&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; v, w;<br>    v = <span class="hljs-number">42</span>; <span class="hljs-comment">// v contains int</span><br>    <span class="hljs-type">int</span> i = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(v);<br>    <span class="hljs-built_in">assert</span>(<span class="hljs-number">42</span> == i); <span class="hljs-comment">// succeeds</span><br>    w = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">int</span>&gt;(v);<br>    w = std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-number">0</span>&gt;(v); <span class="hljs-comment">// same effect as the previous line</span><br>    w = v; <span class="hljs-comment">// same effect as the previous line</span><br> <br>    <span class="hljs-comment">// std::get&lt;double&gt;(v); // error: no double in [int, float]</span><br>    <span class="hljs-comment">// std::get&lt;3&gt;(v);      // error: valid index values are 0 and 1</span><br> <br>    <span class="hljs-comment">// 类型安全就是可以抛出异常并且捕获</span><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        std::<span class="hljs-built_in">get</span>&lt;<span class="hljs-type">float</span>&gt;(w); <span class="hljs-comment">// w contains int, not float: will throw</span><br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::bad_variant_access&amp; ex)<br>    &#123;<br>        std::cout &lt;&lt; ex.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std::literals;<br> <br>    <span class="hljs-function">std::variant&lt;std::string&gt; <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// converting constructors work when unambiguous</span><br>    x = <span class="hljs-string">&quot;def&quot;</span>; <span class="hljs-comment">// converting assignment also works when unambiguous</span><br> <br>    <span class="hljs-function">std::variant&lt;std::string, <span class="hljs-type">void</span> <span class="hljs-type">const</span>*&gt; <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span>;<br>    <span class="hljs-comment">// casts to void const* when passed a char const*</span><br>    <span class="hljs-built_in">assert</span>(std::<span class="hljs-built_in">holds_alternative</span>&lt;<span class="hljs-type">void</span> <span class="hljs-type">const</span>*&gt;(y)); <span class="hljs-comment">// succeeds</span><br>    y = <span class="hljs-string">&quot;xyz&quot;</span>s;<br>    <span class="hljs-built_in">assert</span>(std::<span class="hljs-built_in">holds_alternative</span>&lt;std::string&gt;(y)); <span class="hljs-comment">// succeeds</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="12- 委托构造函数"><a href="#12- 委托构造函数" class="headerlink" title="12 委托构造函数"></a>12 委托构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() : <span class="hljs-built_in">a_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b_</span>(<span class="hljs-number">0.</span>) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(<span class="hljs-number">0.</span>) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommonInit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-type">double</span> b_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>构造函数构造对象时，确保构造路径只有一条，否则如果漏改了某些构造函数会出现问题</li><li>大量重复代码</li><li>所有的构造函数都依赖同一个初始函数</li></ul><p>如果成员初始化都在 <code>CommonInit</code> 里面也会有其他问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Y</span> &#123;<br>    Y <span class="hljs-keyword">operator</span>= (Y) = <span class="hljs-keyword">delete</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() &#123; <span class="hljs-built_in">CommonInit</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) &#123; <span class="hljs-built_in">CommonInit</span>(a, <span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) &#123; <span class="hljs-built_in">CommonInit</span>(<span class="hljs-number">0</span>, b); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) &#123; <span class="hljs-built_in">CommonInit</span>(a, b); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommonInit</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b)</span> </span>&#123;<br>        a_ = a;<br>        b_ = b;<br>        c_ = <span class="hljs-string">&quot;hello world&quot;</span>;<br>        y_ = <span class="hljs-built_in">Y</span>(); <span class="hljs-comment">// 赋值构造函数被 delete 了，编译报错</span><br>    &#125;<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-type">double</span> b_;<br>    std::string c_;<br>    Y y_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>c_</code>并不是初始化，而是赋值操作</p><ul><li>对象的初始化在构造函数主题执行之前，也就是初始化列表阶段就已经执行了</li><li>用 <code>CommonInit</code>“初始化”<code>c_</code> 其实对其进行了两次操作：一次初始化，另一次的赋值</li></ul></li><li><p>有些情况时不能使用函数主体对成员对象进行赋值的</p><ul><li>禁用了赋值运算符的数据成员 e.g. <code>class Y</code></li></ul></li><li><p>委托构造函数 <span class="label label-info">C++ 11</span></p><ul><li>某个类型的一个构造函数可以委托同类型的另一个构造函数对对象惊醒初始化</li><li>前者为委托构造函数</li><li>后者为代理构造函数</li><li>委托构造函数会将控制权交给代理构造函数，在代理构造函数执行完成之后，再执行委托构造函数的主体</li><li>路径是唯一了</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0.</span>) &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">X</span>(a, <span class="hljs-number">0.</span>) &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, b) &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommonInit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-type">double</span> b_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>Note</p><ul><li><p>每个构造函数都可以委托另一个构造函数为代理</p></li><li><p>不要递归循环委托</p><ul><li>最好的习惯就是指定一个 <font color="#A0153E"><strong> 主构造函数</strong></font>，其他构造函数都委托到这个主构造函数</li><li><font color="#496989">就一个负重前行就可以了，不用折腾别的构造函数了</font></li></ul></li><li><p>如果一个构造函数为委托构造函数，那么其初始化列表里就不能对数据成员和基类进行初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() : <span class="hljs-built_in">a_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b_</span>(<span class="hljs-number">0</span>) &#123; <span class="hljs-built_in">CommonInit</span>(); &#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) : <span class="hljs-built_in">X</span>(), <span class="hljs-built_in">a_</span>(a) &#123;&#125; <span class="hljs-comment">// 编译错误，委托构造函数不能在初始化列表初始化成员变量</span><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">X</span>(), <span class="hljs-built_in">b_</span>(b) &#123;&#125;<span class="hljs-comment">// 编译错误，委托构造函数不能在初始化列表初始化成员变量</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CommonInit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-type">double</span> b_;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>根据 C++ 标准规定，一旦类型有一个构造函数完成执行，那么就会认为其构造的对象已经构造完成</li><li>代理构造函数执行完成以后，编译器认为对象已经构造成功，再次执行初始化列表必然会导致不可预知的问题，所以 C++ 标准禁止了这样的语法</li></ul></li><li><p>委托构造函数的执行顺序是先执行代理构造函数的初始化列表，然后执行代理构造函数的主体，最后执行委托构造函数的主体</p></li><li><p>如果在代理构造函数执行完成后，委托构造函数主体抛出了异常，则自动调用该类型的析构函数</p></li></ul></li><li><p><strong>委托模板构造函数 </strong> 是指一个构造函数将控制权委托到同类型的一个模板构造函数，<font color="#A8CD9F">就是代理构造函数是一个函数模板</font></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-title">X</span><span class="hljs-params">(T first, T last)</span> : l_(first, last) &#123;</span> &#125;<br>    std::list&lt;<span class="hljs-type">int</span>&gt; l_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>(std::vector&lt;<span class="hljs-type">short</span>&gt;&amp;);<br>    <span class="hljs-built_in">X</span>(std::deque&lt;<span class="hljs-type">int</span>&gt;&amp;);<br>&#125;;<br><br>X::<span class="hljs-built_in">X</span>(std::vector&lt;<span class="hljs-type">short</span>&gt;&amp; v) : <span class="hljs-built_in">X</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &#123; &#125;<br>X::<span class="hljs-built_in">X</span>(std::deque&lt;<span class="hljs-type">int</span>&gt;&amp; v) : <span class="hljs-built_in">X</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>()) &#123; &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;<span class="hljs-type">short</span>&gt; a&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    std::deque&lt;<span class="hljs-type">int</span>&gt; b&#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-function">X <span class="hljs-title">x1</span><span class="hljs-params">(a)</span></span>;<br>    <span class="hljs-function">X <span class="hljs-title">x2</span><span class="hljs-params">(b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>捕获委托构造函数的异常</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">X</span>() <span class="hljs-keyword">try</span> : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a) <span class="hljs-keyword">try</span> : <span class="hljs-built_in">X</span>(a, <span class="hljs-number">0.</span>) &#123;&#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">double</span> b) : <span class="hljs-built_in">X</span>(<span class="hljs-number">0</span>, b) &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">double</span> b) : <span class="hljs-built_in">a_</span>(a), <span class="hljs-built_in">b_</span>(b) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-number">1</span>; &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a_;<br>    <span class="hljs-type">double</span> b_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        X x;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">int</span> e) &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;catch: &quot;</span> &lt;&lt; e &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>使用 Function-try-block 的代码格式，也可以应用到普通函数上</p>          </div><ul><li>委托参数较少的构造函数<ul><li>通常情况下将参数较少的构造函数委托给参数较多的构造函数</li><li>也可以从参数较多的构造函数委托参数较少的构造函数，例如完成一些最基础的初始化工作</li></ul></li></ul><h2 id="13- 继承构造函数"><a href="#13- 继承构造函数" class="headerlink" title="13 继承构造函数"></a>13 继承构造函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123;&#125;;<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">x_</span>(x), <span class="hljs-built_in">y_</span>(<span class="hljs-number">0.</span>) &#123;&#125;<br>    <span class="hljs-built_in">Base</span>(<span class="hljs-type">double</span> y) : <span class="hljs-built_in">x_</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">y_</span>(y) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunc</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x_;<br>    <span class="hljs-type">double</span> y_;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() &#123;&#125;;<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">Base</span>(x, y) &#123;&#125;<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">Base</span>(x) &#123;&#125;<br>    <span class="hljs-built_in">Derived</span>(<span class="hljs-type">double</span> y) : <span class="hljs-built_in">Base</span>(y) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunc</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>一个类有很多构造入口就不是一个很好的设计</p></li><li><p><code>Derived</code>并不会自动继承 <code>Base</code> 里面所有的构造函数，所以要把基类所有的构造函数都要重新写一遍</p></li><li><p>C++ 中可以使用 <code>using</code> 关键字将基类的函数引入派生类</p></li><li><p>C++ 11 将 <code>using</code> 关键字的能力进行了扩展，使其能够引入基类的构造函数</p></li><li><p>派生类 <code>Derived</code> 使用 <code>using Base::Base</code> 让编译器为自己生成转发到基类的构造函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base::Base;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SomeFunc</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>Note</p><ul><li><p>派生类是隐式继承基类的构造函数，所以只有在程序中使用了这些构造函数，编译器才会为派生类生成继承构造函数的代码</p></li><li><p>派生类不会继承基类的默认构造函数和复制构造函数</p><ul><li>继承基类的默认构造函数和默认复制构造函数的做法是多余的</li></ul></li><li><p>继承构造函数不会影响派生类默认构造函数的隐式声明，也就是说对于继承基类构造函数的派生类，编译器依然会为其自动生成默认构造函数的代码</p></li><li><p>在派生类中声明签名相同的构造函数会禁止继承相应的构造函数</p></li><li><p>派生类继承多个签名相同的构造函数会导致编译失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base1</span>(<span class="hljs-type">int</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base1(int x)&quot;</span> &lt;&lt; std::endl; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base2</span>(<span class="hljs-type">int</span>) &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Base2(int x)&quot;</span> &lt;&lt; std::endl; &#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base1, Base2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Base1::Base1;<br>    <span class="hljs-keyword">using</span> Base2::Base2;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Derived <span class="hljs-title">d</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译器不知道用哪个</li><li>最好的解决办法就是不要搞多继承</li></ul></li><li><p>继承构造函数的基类构造函数不能为私有</p><ul><li><code>protected</code>是可以的</li></ul></li><li><p>继承基类构造函数时，不会继承默认参数</p></li></ul></li></ul><h2 id="14- 强枚举类型"><a href="#14- 强枚举类型" class="headerlink" title="14 强枚举类型"></a>14 强枚举类型</h2><ul><li><p>枚举类型的弊端</p><ul><li><p>一个枚举类型不允许分配到另外一种枚举类型</p></li><li><p>整型也无法隐式转换成枚举类型，枚举类型却可以隐式转换为整型</p></li><li><p>枚举类型会把其内部的枚举标识符导出到枚举被定义的作用域，这样重复定义的概率就变大了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">HighSchool</span> &#123;<br>    student,<br>    teacher,<br>    principal<br>&#125;;<br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">University</span> &#123;<br>    student,<br>    professor,<br>    principal<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>principal</code>重定义了</p></li><li><p>无法指定枚举类型的底层类型</p><ul><li>不同的编译器对于相同枚举类型可能会有不同的底层类型</li></ul></li></ul></li><li><p>强枚举类型 <span class="label label-info">C++ 11</span></p><ul><li>枚举标识符属于强枚举类型的作用域</li><li>枚举标识符不会隐式转换为整型</li><li>能指定强枚举类型的底层类型，底层类型默认为 int 类型</li><li>在枚举定义的 <code>enum</code> 关键字之后加上 <code>class</code> 关键字</li><li>相同类型可以比较，不同类型比较没有意义</li><li>可以通过 <code>static_cast</code> 对其进行强制类型转换</li></ul></li><li><p>列表初始化有底层类型枚举对象 <span class="label label-success">C++ 17</span></p><ul><li><p>从 C++ 17 标准开始，对有底层类型的枚举类型对象可以直接使用列表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color c&#123; <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 编译成功</span><br>    Color c1 = <span class="hljs-number">5</span>; <span class="hljs-comment">// 编译失败</span><br>    Color c2 = &#123; <span class="hljs-number">5</span> &#125;; <span class="hljs-comment">// 编译失败</span><br>    <span class="hljs-function">Color <span class="hljs-title">c3</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 编译失败</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>没有指定底层类型的枚举类型是无法使用列表初始化的</p></li><li><p>同所有的列表初始化一样，它禁止缩窄转换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> : <span class="hljs-type">char</span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color c&#123; <span class="hljs-number">7.11</span> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用 <code>using</code> 打开强枚举类型 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">ColorToString</span><span class="hljs-params">(Color c)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">switch</span> (c)<br>    &#123;<br>        <span class="hljs-keyword">using</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span>;<br>        <span class="hljs-keyword">case</span> Red: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Red&quot;</span>;<br>        <span class="hljs-keyword">case</span> Green: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Green&quot;</span>;<br>        <span class="hljs-keyword">case</span> Blue: <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blue&quot;</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;none&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="15- 扩展的聚合类型"><a href="#15- 扩展的聚合类型" class="headerlink" title="15 扩展的聚合类型"></a>15 扩展的聚合类型 </h2><h3 id="聚合类型"><a href="# 聚合类型" class="headerlink" title="聚合类型"></a> 聚合类型</h3><ul><li>没有用户提供的构造函数</li><li>没有私有和受保护的非静态数据成员<ul><li>可以类比于 C 结构体中的数据成员，因为都是<code>public</code></li></ul></li><li>没有虚函数</li><li><font color="#A8CD9F">必须是公开的基类，不能是私有或者受保护的基类</font></li><li><font color="#A8CD9F">必须是非虚继承</font></li></ul><div class="note note-warning">            <ul><li>基类是否是聚合类型与派生类是否为聚合类型没有关系 </li><li> 在标准库 <code>&lt;type_traits&gt;</code> 中提供了一个聚合类型的甄别办法<code>is_aggregate</code>，判断目标类型是否为聚合类型</li></ul>          </div><h3 id="聚合类型的初始化"><a href="# 聚合类型的初始化" class="headerlink" title="聚合类型的初始化"></a>聚合类型的初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStringWithIndex</span> : <span class="hljs-keyword">public</span> std::string &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> index_ = <span class="hljs-number">0</span>;<br>&#125;;<br><br>std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream &amp;o, <span class="hljs-type">const</span> MyStringWithIndex&amp; s) &#123;<br>    o &lt;&lt; s.index_ &lt;&lt; <span class="hljs-string">&quot;:&quot;</span> &lt;&lt; s.<span class="hljs-built_in">c_str</span>();<br>    <span class="hljs-keyword">return</span> o;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyStringWithIndex s&#123; &#123;<span class="hljs-string">&quot;hello world&quot;</span>&#125;, <span class="hljs-number">11</span> &#125;;<br>    std::cout &lt;&lt; s &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>MyStringWithIndex</code>是聚合类型，<code>&#123;&quot;hello world&quot;&#125;</code>是基类初始化方式，<code>11</code>是派生类的初始化方式</p></li><li><p><code>&#123;&quot;hello world&quot;&#125;</code>的大括号也可以省略，即<code>MyStringWithIndex s&#123; &quot;hello world&quot;, 11 &#125;</code></p></li><li><p>如果派生类存在多个基类，那么其初始化的顺序与继承的顺序相同</p></li><li><p>基类中的构造函数如果是受保护的关系，它不允许在聚合类型初始化中被调用</p><ul><li>需要为派生类提供一个默认构造函数，就不是聚合类型了</li></ul></li><li><p>用户 <font color="#A0153E"><strong> 提供 </strong></font> 的构造函数和用户 <font color="#A0153E"><strong> 声明 </strong></font> 的构造函数是有区别的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-built_in">X</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Y</span> &#123;<br>    <span class="hljs-built_in">Y</span>() = <span class="hljs-keyword">delete</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; std::boolalpha &lt;&lt; <span class="hljs-string">&quot;std::is_aggregate_v&lt;X&gt; : &quot;</span> &lt;&lt; std::is_aggregate_v&lt;X&gt; &lt;&lt; std::endl;<br>    std::cout &lt;&lt; std::boolalpha &lt;&lt; <span class="hljs-string">&quot;std::is_aggregate_v&lt;Y&gt; : &quot;</span> &lt;&lt; std::is_aggregate_v&lt;Y&gt; &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>C++ 17 认为类中存在用户声明的构造函数是聚合类型，所以 <code>X</code> 和<code>Y</code>都是聚合类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Y y1; <span class="hljs-comment">// 编译失败，使用了删除函数</span><br>Y y2&#123;&#125;; <span class="hljs-comment">// 编译成功，聚合类型初始化</span><br></code></pre></td></tr></table></figure><ul><li>这个问题很容易在真实的开发过程中被忽略，从而导致意想不到的结果</li><li>所以在 C++ 20 标准中禁止聚合类型使用用户声明的构造函数 <span class="label label-primary">C++ 20</span><ul><li>用 C++20 环境编译后 <code>X</code> 和<code>Y</code>都不是聚合类型了</li></ul></li></ul></li><li><p>使用带小括号的列表初始化聚合类型对象 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">float</span> f;<br>&#125;;<br><span class="hljs-function">X <span class="hljs-title">x</span><span class="hljs-params">(<span class="hljs-number">11</span>, <span class="hljs-number">7.0f</span>)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>带大括号的列表初始化是不支持缩窄转换，但是带小括号的列表初始化却是支持缩窄转换的</li></ul></li></ul><center>    <img src="/2024/07/18/ba744a9761cc/c++-aggregate-type.png" alt></center><h2 id="16-override 和 final"><a href="#16-override 和 final" class="headerlink" title="16 override 和 final"></a>16 <code>override</code>和 <code>final</code></h2><h3 id="重写、重载和隐藏"><a href="# 重写、重载和隐藏" class="headerlink" title="重写、重载和隐藏"></a> 重写、重载和隐藏</h3><ul><li>重写（override）：在 C++ 中是指派生类覆盖了基类的虚函数，这里的覆盖必须满足有相同的函数签名和返回类型，也就是说有相同的函数名、形参列表以及返回类型</li><li>重载（overload）：它通常是指在同一个类中有两个或者两个以上函数，它们的函数名相同，但是函数签名不同，也就是说有不同的形参</li><li>隐藏（overwrite）：隐藏是指基类成员函数，无论它是否为虚函数，当派生类出现同名函数时，如果派生类函数签名不同于基类函数，则基类函数会被隐藏。如果派生类函数签名与基类函数相同，则需要确定基类函数是否为虚函数，如果是虚函数，则这里的概念就是重写；否则基类函数也会被隐藏<ul><li>如果还想使用基类函数，可以使用 <code>using</code> 关键字将其引入派生类</li></ul></li></ul><h3 id="override 说明符"><a href="#override 说明符" class="headerlink" title="override 说明符"></a><code>override</code>说明符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">some_func</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">baz</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sone_func</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 拼写错误</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;x)</span> </span>&#123;&#125; <span class="hljs-comment">// 函数签名不一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 函数签名不一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">baz</span><span class="hljs-params">()</span> </span>&#123;&#125; <span class="hljs-comment">// 基类成员函数不是虚函数</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <ul><li>派生类 <code>Derived</code> 的 4 个函数都没有触发重写操作 </li><li> 稍不注意就会无法重写基类虚函数 </li><li> 即使写错了代码，编译器也可能不会提示任何错误信息，直到程序编译成功后，运行测试才会发现其中的逻辑问题</li></ul>          </div><ul><li>C++ 11 标准提供了 <code>override</code> 说明符 <span class="label label-info">C++ 11</span><ul><li><code>override</code>说明符必须放到虚函数的尾部</li><li>告诉诉编译器这个虚函数需要覆盖基类的虚函数</li><li>编译器发现该虚函数不符合重写规则，会给出错误提示</li><li>基类如果改了成员函数，派生类却不知道，这个时候加上 <code>override</code> 编译器就能检查出来了</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sone_func</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">override</span> &amp;x</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> bar() <span class="hljs-keyword">override</span> &#123;&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> baz() <span class="hljs-keyword">override</span> &#123;&#125;</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;;</span></span><br></code></pre></td></tr></table></figure><h3 id="final 说明符"><a href="#final 说明符" class="headerlink" title="final 说明符"></a><code>final</code>说明符</h3><ul><li>可以为基类声明纯虚函数来迫使派生类继承并且重写这个纯虚函数</li><li>C++ 11 标准引入 final 说明符来阻止派生类去继承基类的虚函数 <span class="label label-info">C++ 11</span></li><li><code>override</code>和 <code>final</code> 可以同时出现</li><li>类定义的时候声明了<code>final</code>，那么这个类将不能作为基类被其他类继承</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-keyword">final</span> </span>&#123;&#125;;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived2</span> : <span class="hljs-keyword">public</span> Derived &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;&#125;; <span class="hljs-comment">// 编译报错</span><br>&#125;;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>C++ 11 标准中，<code>override</code>和 <code>final</code> 并没有被作为保留的关键字，其中 <code>override</code> 只有在虚函数尾部才有意义，而 <code>final</code> 只有在虚函数尾部以及类声明的时候才有意义 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">override</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">final</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">override</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">final</span> = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 这样的代码都是可以的，为了兼容老代码</p>          </div><h2 id="17- 基于范围的 for 循环"><a href="#17- 基于范围的 for 循环" class="headerlink" title="17 基于范围的 for 循环"></a>17 基于范围的 <code>for</code> 循环</h2><ul><li><p>C++ 11 标准引入了基于范围的 <code>for</code> 循环特性，该特性隐藏了迭代器的初始化和更新过程 <span class="label label-info">C++ 11</span></p></li><li><p><code>for (range_declaration : range_expression) loop_statement</code>，必须满足下面 2 个条件之一</p><ul><li>对象类型定义了 <code>begin</code> 和<code>end</code>成员函数</li><li>定义了以对象类型为参数的 <code>begin</code> 和<code>end</code>普通函数</li></ul></li><li><p>对于复杂的对象使用引用，而对于基础类型使用值，因为这样能够减少内存的复制</p></li><li><p>如果不会在循环过程中修改引用对象，那么推荐在范围声明中加上 <code>const</code> 限定符，免得犯错误</p></li><li><p>C++ 11 标准中基于范围的 <code>for</code> 循环相当于以下伪代码 <span class="label label-info">C++ 11</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-keyword">auto</span> &amp;&amp; __range = range_expression;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> __begin = begin_expr, __end = end_expr; __begin != __end; ++__begin) &#123;<br>        range_declaration = *__begin;<br>        loop_statement<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>auto __begin = begin_expr, __end = end_expr;</code>表明了 <code>begin</code> 和<code>end</code>必须类型相同，但是没有必要</p></li><li><p>C++ 17 标准对基于范围的 <code>for</code> 循环的实现进行了改进 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-keyword">auto</span> &amp;&amp; __range = range_expression;<br>    <span class="hljs-keyword">auto</span> __begin = begin_expr;<br>    <span class="hljs-keyword">auto</span> __end = end_expr;<br>    <span class="hljs-keyword">for</span> (; __begin != __end; ++__begin) &#123;<br>        range_declaration = *__begin;<br>        loop_statement<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>对于 <code>auto &amp;&amp; __range = range_expression;</code>，如果<code>range_expression</code> 是一个纯右值，那么右值引用会扩展其生命周期，保证其整个 <code>for</code> 循环过程中访问的安全性。但如果 <code>range_ expression</code> 是一个泛左值，那结果可就不确定了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; data_;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt;&amp; <span class="hljs-title">items</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> data_; &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-function">T <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;<br>    T t;<br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">items</span>()) &#123;&#125; <span class="hljs-comment">// 未定义行为</span><br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>因为 <code>foo().items()</code> 返回的是一个泛左值类型 <code>std::vector&lt;int&gt;&amp;</code>，也就是在<code>foo().items()</code> 表达式的一瞬间是有用的，之后就找不到了，所以出现了 UB</p>          </div><p>对于这种情况将数据复制出来是一种解决方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">T thing = <span class="hljs-built_in">foo</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; x : <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">items</span>()) &#123;&#125;<br></code></pre></td></tr></table></figure><p>在 C++ 20 标准中，基于范围的 for 循环增加了对初始化语句的支持 <span class="label label-primary">C++ 20</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (T thing = <span class="hljs-built_in">foo</span>(); <span class="hljs-keyword">auto</span>&amp; x : <span class="hljs-built_in">foo</span>().<span class="hljs-built_in">items</span>()) &#123;&#125;<br></code></pre></td></tr></table></figure><h2 id="18- 支持初始化语句的 if 和 switch"><a href="#18- 支持初始化语句的 if 和 switch" class="headerlink" title="18 支持初始化语句的 if 和 switch"></a>18 支持初始化语句的 <code>if</code> 和<code>switch</code></h2><ul><li>支持初始化语句的 <code>if</code> 和<code>switch</code> <span class="label label-success">C++ 17</span><ul><li><code>if</code>控制结构可以在执行条件语句之前先执行一个初始化语句 <code>if (init; condition) &#123;&#125;</code></li><li>其中 <code>init</code> 是初始化语句，<code>conditio</code>n 是条件语句，它们之间使用分号分隔</li><li>变量的作用于不会泄露到外面</li><li><code>switch</code>在通过条件判断确定执行的代码分支之前也可以接受一个初始化语句</li></ul></li></ul><h2 id="19-static-assert 声明"><a href="#19-static-assert 声明" class="headerlink" title="19 static_assert 声明"></a>19 <code>static_assert</code>声明</h2><ul><li><p>运行时断言</p><ul><li>静态断言出现之前</li><li>只有在程序运行时才会起作用</li><li>直接终止程序，没有必要直接终止程序</li><li>Release 断言都要关掉的</li><li>性能上也会有问题</li></ul></li><li><p>静态断言<code>static_assert</code> <span class="label label-info">C++ 11</span></p><ul><li>所有处理必须在编译期间执行，不允许有空间或时间上的运行时成本</li><li>它必须具有简单的语法</li><li>断言失败可以显示丰富的错误诊断信息</li><li>它可以在命名空间、类或代码块内使用</li><li>失败的断言会在编译阶段报错</li><li>第一个实参必须是常量表达式，因为编译器无法计算运行时才能确定结果的表达式</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> : <span class="hljs-keyword">public</span> A &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> &#123;&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<br>    <span class="hljs-built_in">static_assert</span>(std::is_base_of&lt;A, T&gt;::value, <span class="hljs-string">&quot;T is not base of A&quot;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(argc &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;argc &gt; 0&quot;</span>); <span class="hljs-comment">// 使用错误，argc&gt;0 不是常量表达式</span><br>    E&lt;C&gt; x; <span class="hljs-comment">// 使用正确，但由于 A 不是 C 的基类，所以触发断言</span><br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &gt;= <span class="hljs-number">4</span>, <span class="hljs-string">&quot;sizeof(int) &gt;= 4&quot;</span>); <span class="hljs-comment">// 使用正确，表达式返回真，不会触发失败断言</span><br>    E&lt;B&gt; y; <span class="hljs-comment">// 使用正确，A 是 B 的基类，不会触发失败断言</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>要使用单参数的<code>static_assert</code> <span class="label label-success">C++ 17</span></li></ul></li></ul><h2 id="20- 结构化绑定"><a href="#20- 结构化绑定" class="headerlink" title="20 结构化绑定"></a>20 结构化绑定</h2><ul><li>C++ 11 标准中同样引入了元组的概念，通过元组 C++ 也能返回多个值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;tuple&gt;</span></span><br><span class="hljs-function">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">return_multiple_values</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">11</span>, <span class="hljs-number">7</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    std::<span class="hljs-built_in">tie</span>(x, y) = <span class="hljs-built_in">return_multiple_values</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot; y=&quot;</span> &lt;&lt; y &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不使用 <code>std::tie(x, y)</code> 而是直接使用 <code>std::tuple(x, y)</code> 来接受返回值，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">tuple</span>(x, y) = <span class="hljs-built_in">return_multiple_values</span>();<br></code></pre></td></tr></table></figure><p>因为 <code>std::tuple</code> 构造函数参数不是引用，无法修改实参的值，而且返回的是一个临时对象，这一行语句结束后临时对象就失效，所以可以使用引用的形式接受返回值，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::<span class="hljs-built_in">tuple</span>&lt;<span class="hljs-type">int</span>&amp;, <span class="hljs-type">int</span>&gt;(x, y) = <span class="hljs-built_in">return_multiple_values</span>();<br></code></pre></td></tr></table></figure><p>这样对比下来发现 <code>x</code> 的值改变了，<code>y</code>的值没有改变</p><ul><li>C++ 11 必须指定 <code>return_multiple_values</code> 函数的返回值类型，提前声明变量</li><li>可以使用 <code>auto</code> 的新特性来简化返回类型的声明 <span class="label label-warning">C++ 14</span></li><li>结构化绑定是指将一个或者多个名称绑定到初始化对象中的一个或者多个子对象（或者元素）上，相当于给初始化对象的子对象（或者元素）起了别名 <span class="label label-success">C++ 17</span></li></ul><h3 id="深入理解结构化绑定"><a href="# 深入理解结构化绑定" class="headerlink" title="深入理解结构化绑定"></a>深入理解结构化绑定</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BindTest</span> &#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br>    std::string b = <span class="hljs-string">&quot;hello structured binding&quot;</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    BindTest bt;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>[x, y] = bt;<br>    <span class="hljs-keyword">auto</span>&amp; [x1, y1] = bt;<br>    <span class="hljs-keyword">auto</span> [x2, y2] = bt;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过解语法糖后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">BindTest</span> &#123;<br>  <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br>  std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::allocator&lt;<span class="hljs-type">char</span>&gt; &gt; b = std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::allocator&lt;<span class="hljs-type">char</span>&gt; &gt;(<span class="hljs-string">&quot;hello structured binding&quot;</span>, std::<span class="hljs-built_in">allocator</span>&lt;<span class="hljs-type">char</span>&gt;());<br>  <span class="hljs-comment">// inline constexpr BindTest(const BindTest &amp;) noexcept(false) = default;</span><br>  <span class="hljs-comment">// inline constexpr ~BindTest() noexcept = default;</span><br>  <span class="hljs-comment">// inline constexpr BindTest() noexcept(false) = default;</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    BindTest bt = <span class="hljs-built_in">BindTest</span>();<br><br>    <span class="hljs-comment">// const auto[x, y] = bt;</span><br>    <span class="hljs-type">const</span> BindTest __bt11 = <span class="hljs-built_in">BindTest</span>(bt);<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp; x = __bt11.a;<br>    <span class="hljs-type">const</span> std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::allocator&lt;<span class="hljs-type">char</span>&gt; &gt; &amp; y = __bt11.b;<br><br>    <span class="hljs-comment">// auto&amp; [x1, y1] = bt;</span><br>    BindTest &amp; __bt13 = bt;<br>    <span class="hljs-type">int</span> &amp; x1 = __bt13.a;<br>    std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::allocator&lt;<span class="hljs-type">char</span>&gt; &gt; &amp; y1 = __bt13.b;<br><br>    <span class="hljs-comment">// auto [x2, y2] = bt;</span><br>    BindTest __bt15 = <span class="hljs-built_in">BindTest</span>(bt);<br>    <span class="hljs-type">int</span> &amp; x2 = __bt15.a;<br>    std::basic_string&lt;<span class="hljs-type">char</span>, std::char_traits&lt;<span class="hljs-type">char</span>&gt;, std::allocator&lt;<span class="hljs-type">char</span>&gt; &gt; &amp; y2 = __bt15.b;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>绑定后的变量和原来的结构体中的数据不是同一块内存，是匿名构造了一个新的对象，然后引用原来对象中的数据成员，可以理解为原来对象成员变量的别名</p></li><li><p>只有匿名对象是原来对象的引用，才能够修改原来对象的数据</p></li><li><p>使用结构化绑定无法忽略对象的子对象或者元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">auto</span> [x] = t; <span class="hljs-comment">// 编译报错</span><br></code></pre></td></tr></table></figure><ul><li><p>在 C++ 11 标准下可以使用 <code>std::tie</code> 加<code>std::ignore</code>解决</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>std::<span class="hljs-built_in">tie</span>(x, std::ignore) = t;<br>std::<span class="hljs-built_in">tie</span>(y, std::ignore) = t;<br></code></pre></td></tr></table></figure></li><li><p>但是结构化绑定的别名无法在同一个作用域中重复使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> t = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">42</span>, <span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">auto</span>[x, std::ignore] = t;<br><span class="hljs-keyword">auto</span>[y, std::ignore] = t; <span class="hljs-comment">// 编译错误，std::ignore 无法重复声明</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="结构化绑定的 -3- 中类型"><a href="# 结构化绑定的 -3- 中类型" class="headerlink" title="结构化绑定的 3 中类型"></a>结构化绑定的 3 中类型</h3><ul><li>绑定到原生数组</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">3</span>]&#123; <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">auto</span>[x, y, z] = a;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[x, y, z]=[&quot;</span><br>        &lt;&lt; x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span><br>        &lt;&lt; y &lt;&lt; <span class="hljs-string">&quot;, &quot;</span><br>        &lt;&lt; z &lt;&lt; <span class="hljs-string">&quot;]&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>绑定到结构体和类对象</p><ul><li><p>类或者结构体中的非静态数据成员个数必须和标识符列表中的别名的个数相同</p></li><li><p>这些数据成员必须是公有的</p><ul><li>C++ 20 标准规定结构化绑定的限制不再强调必须为公开数据成员 <span class="label label-primary">C++ 20</span></li></ul></li><li><p>这些数据成员必须是在同一个类或者基类中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindBase1</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">11.7</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindTest1</span> : <span class="hljs-keyword">public</span> BindBase1 &#123;&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindBase2</span> &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindTest2</span> : <span class="hljs-keyword">public</span> BindBase2 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">11.7</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindBase3</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">42</span>;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BindTest3</span> : <span class="hljs-keyword">public</span> BindBase3 &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> b = <span class="hljs-number">11.7</span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    BindTest1 bt1;<br>    BindTest2 bt2;<br>    BindTest3 bt3;<br>    <span class="hljs-keyword">auto</span>[x1, y1] = bt1; <span class="hljs-comment">// 编译成功</span><br>    <span class="hljs-keyword">auto</span>[x2, y2] = bt2; <span class="hljs-comment">// 编译成功</span><br>    <span class="hljs-keyword">auto</span>[x3, y3] = bt3; <span class="hljs-comment">// 编译错误</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>定的类和结构体中不能存在匿名联合体</p></li></ul></li><li><p>绑定到元组和类元组的对象</p><ul><li><font color="#A8CD9F">类元组就是像元组一样的东西 </font>，满足元组抽象的几种条件；对于元组或者类元组类型<code>T</code> <font color="#A8CD9F"> 就跟 C++ 20 中的协程一样，只要按照某种模式写就行了</font><ul><li>需要满足 <code>std::tuple_size&lt;T&gt;::value</code> 是一个符合语法的表达式，并且该表达式获得的整数值与标识符列表中的别名个数相同 <font color="#A8CD9F">能取到大小</font></li><li>类型 <code>T</code> 还需要保证 <code>std::tuple_element&lt;i, T&gt;::type</code> 也是一个符合语法的表达式，其中 <code>i</code> 是小于 <code>std::tuple_size&lt;T&gt;::value</code> 的整数，表达式代表了类型 <code>T</code> 中第 <code>i</code> 个元素的类型 <font color="#A8CD9F">能取到类型</font></li><li>类型 <code>T</code> 必须存在合法的成员函数模板 <code>get&lt;i&gt;()</code> 或者函数模板 <code>get&lt;i&gt;(t)</code>，其中<code>i</code> 是小于 <code>std::tuple_size&lt;T&gt;::value</code> 的整数，<code>t</code>是类型 <code>T</code> 的实例，<code>get&lt;i&gt;()</code>和 <code>get&lt;i&gt;(t)</code> 返回的是实例 <code>t</code> 中第 <code>i</code> 个元素的值 <font color="#A8CD9F">能取到值</font></li></ul></li></ul></li></ul><h2 id="21-noexcept 关键字"><a href="#21-noexcept 关键字" class="headerlink" title="21 noexcept 关键字"></a>21 <code>noexcept</code>关键字</h2><ul><li><p>异常不仅是语法层的概念</p></li><li><p>很多语言都把异常作为逻辑的一部分</p></li><li><p>返回一个<code>optional</code>，而不是抛异常，这样在发生异常的时候可以有选择的处理：是继续取里面的值还是向上传递</p></li><li><p><code>optional</code>是一个返回值，需要调用者去关心，去处理，但是异常就可能不受到关心</p></li><li><p>移动构造函数中包含着一个严重的异常陷阱</p><ul><li>在 C++ 11 之前，由于没有移动语义，只能将原始容器的数据复制到新容器中。如果在数据复制的过程中复制构造函数发生了异常，那么可以丢弃新的容器，保留原始的容器</li><li>但是有了移动语义，原始容器的数据会逐一地移动到新容器中，如果数据移动的途中发生异常，那么原始容器也将无法继续使用，因为已经有一部分数据移动到新的容器中</li></ul></li><li><p>C++ 标准委员会提出了 <code>noexcept</code> 说明符 <span class="label label-info">C++ 11</span></p><ul><li><p>它既是一个说明符，也是一个运算符</p></li><li><p>作为说明符，它能够用来说明函数是否会抛出异常</p><ul><li><code>noexcept</code>只是告诉编译器不会抛出异常，但函数不一定真的不会抛出异常</li><li>在声明了 <code>noexcept</code> 的函数中抛出异常时，程序会调用 <code>std::terminate</code> 去结束程序的生命周期</li></ul></li><li><p>作为运算符，<code>noexcept</code>还能接受一个返回布尔的常量表达式</p><ul><li>当表达式 <span class="hint--info hint--rounded hint--top" data-hint="evaluate 翻译为结果更合理，即表达式计算结果" ontouchstart> 评估 </span> 为<code>true</code>的时候，其行为和不带参数一样，表示函数不会抛出异常</li><li>当表达式 <span class="hint--info hint--rounded hint--top" data-hint="evaluate" ontouchstart> 评估 </span> 为<code>false</code>的时候，则表示该函数有可能会抛出异常</li><li>由于 <code>noexcept</code> 对表达式的评估是在编译阶段执行的，因此表达式必须是一个常量表达式</li><li>广泛应用于模板当中，看到编译阶段执行，大概率给模板使用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;o)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(std::is_fundamental&lt;T&gt;::value)</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只有在 <code>T</code> 是一个基础类型时复制函数才会被声明为<code>noexcept</code>，因为基础类型的复制是不会发生异常的，</li><li>如果 <code>T</code> 是复杂类型么调用其复制构造函数是有可能发生异常的，直接声明 <code>noexcept</code> 会导致当函数遇到异常的时候程序被终止</li><li><code>noexcept</code>运算符能够准确地判断函数是否有声明不会抛出异常</li><li>还希望在类型 <code>T</code> 的复制构造函数保证不抛出异常的情况下都使用 <code>noexcept</code> 声明</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">copy</span><span class="hljs-params">(<span class="hljs-type">const</span> T &amp;o)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(<span class="hljs-keyword">noexcept</span>(T(o)))</span> </span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>只不过两个 <code>noexcept</code> 关键字发挥了不同的作用<ul><li>第二个关键字是运算符，它判断 <code>T(o)</code> 是否有可能抛出异常</li><li>第一个 <code>noexcept</code> 关键字则是说明符，它接受第二个运算符的返回值，以此决定 <code>T</code> 类型的复制函数是否声明为不抛出异常</li></ul></li></ul></li></ul></li></ul><h3 id="用 noexcept 来解决移动构造问题"><a href="# 用 noexcept 来解决移动构造问题" class="headerlink" title="用 noexcept 来解决移动构造问题"></a>用 <code>noexcept</code> 来解决移动构造问题 </h3><p> 现在 <code>noexcept</code> 运算符可以判断目标类型的移动构造函数是否有可能抛出异常。如果没有抛出异常的可能，那么函数可以选择进行移动操作；否则将使用传统的复制操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noexcept</span>(T(std::move(a))) &amp;&amp; <span class="hljs-keyword">noexcept</span>(a.<span class="hljs-keyword">operator</span>=(std::move(b)))</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>检查类型 <code>T</code> 的移动构造函数和移动赋值函数是否都不会抛出异常</li><li>通过移动构造函数和移动赋值函数移动对象 <code>a</code> 和<code>b</code></li><li>但是只进行了移动交换，当交换的两个对象在移动时可能抛出异常情况下，需要使用拷贝交换而不是移动交换</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noexcept</span>(T(std::move(a))) &amp;&amp; <span class="hljs-keyword">noexcept</span>(a.<span class="hljs-keyword">operator</span>=(std::move(b)))</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">T</span>(std::<span class="hljs-built_in">move</span>(a))) &amp;&amp; <span class="hljs-built_in">noexcept</span>(a.<span class="hljs-keyword">operator</span>=(std::<span class="hljs-built_in">move</span>(b))));<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br></code></pre></td></tr></table></figure><p>只是不能让用，但是还是没有解决问题，最终的交换函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-built_in">X</span>() &#123;&#125;<br>    <span class="hljs-built_in">X</span>(X&amp;&amp;) <span class="hljs-keyword">noexcept</span> &#123;&#125;<br>    <span class="hljs-built_in">X</span>(<span class="hljs-type">const</span> X&amp;) &#123;&#125;<br>    X <span class="hljs-keyword">operator</span>= (X&amp;&amp;) <span class="hljs-keyword">noexcept</span> &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>    X <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> X&amp;) &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X1</span> &#123;<br>    <span class="hljs-built_in">X1</span>() &#123;&#125;<br>    <span class="hljs-built_in">X1</span>(X1&amp;&amp;) &#123;&#125;<br>    <span class="hljs-built_in">X1</span>(<span class="hljs-type">const</span> X1&amp;) &#123;&#125;<br>    X1 <span class="hljs-keyword">operator</span>= (X1&amp;&amp;) &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>    X1 <span class="hljs-keyword">operator</span>= (<span class="hljs-type">const</span> X1&amp;) &#123; <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap_impl</span><span class="hljs-params">(T&amp; a, T&amp; b, std::integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">true</span>&gt;)</span> <span class="hljs-keyword">noexcept</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std::<span class="hljs-built_in">move</span>(tmp);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap_impl</span><span class="hljs-params">(T&amp; a, T&amp; b, std::integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-literal">false</span>&gt;)</span> </span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">tmp</span><span class="hljs-params">(a)</span></span>;<br>    a = b;<br>    b = tmp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(T&amp; a, T&amp; b)</span> <span class="hljs-title">noexcept</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noexcept</span>(swap_impl(a, b, std::integral_constant&lt;<span class="hljs-type">bool</span>, <span class="hljs-keyword">noexcept</span>(T(std::move(a))) &amp;&amp;</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">noexcept</span>(a.<span class="hljs-keyword">operator</span>=(std::move(b)))&gt;()))</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br>    <span class="hljs-built_in">swap_impl</span>(a, b, std::<span class="hljs-built_in">integral_constant</span>&lt;<span class="hljs-type">bool</span>, <span class="hljs-built_in">noexcept</span>(<span class="hljs-built_in">T</span>(std::<span class="hljs-built_in">move</span>(a))) &amp;&amp; <span class="hljs-built_in">noexcept</span>(a.<span class="hljs-keyword">operator</span>=(std::<span class="hljs-built_in">move</span>(b)))&gt;());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    X x1, x2;<br>    <span class="hljs-built_in">swap</span>(x1, x2);<br>    X1 x3, x4;<br>    <span class="hljs-built_in">swap</span>(x3, x4);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>noexcept(T(std::move(a))) &amp;&amp; noexcept(a.operator=(std:: move(b)))</code>这段代码完全可以使用 <code>std::is_nothrow_move_constructible&lt;T&gt;::value &amp;&amp; std::is_nothrow_move_ assignable&lt;T&gt;::value</code> 来代替</p><h3 id="noexcept 和 throw"><a href="#noexcept 和 throw" class="headerlink" title="noexcept 和 throw()"></a><code>noexcept</code>和<code>throw()</code></h3><div class="note note-warning">            <p><code>throw()</code>什么都不抛，就是没有异常</p>          </div><ul><li><code>throw()</code>能用的地方 <code>noexcept</code> 也可以用，反过来不行</li><li>如果一个函数在声明了 <code>noexcept</code> 的基础上抛出了异常，那么程序将不需要展开堆栈，它不会调用 <code>std::unexpected</code>，而是调用<code>std::terminate</code> 结束程序</li><li><code>throw()</code>则需要展开堆栈，并调用<code>std::unexpected</code></li><li>在 C++ 17 标准中，<code>throw()</code>成为 <code>noexcept</code> 的一个别名，<code>throw()</code>和 <code>noexcept</code> 拥有了同样的行为和实现 <span class="label label-success">C++ 17</span></li><li>在 C++ 20 中 <code>throw()</code> 被标准移除 <span class="label label-primary">C++ 20</span></li></ul><h3 id="默认使用 noexcept 的函数"><a href="# 默认使用 noexcept 的函数" class="headerlink" title="默认使用 noexcept 的函数"></a>默认使用 <code>noexcept</code> 的函数</h3><ul><li>默认构造函数、默认复制构造函数、默认赋值函数、默认移动构造函数和默认移动赋值函数会默认带有 <code>noexcept</code> 声明<ul><li>对应的函数在类型的基类和成员中也具有 <code>noexcept</code> 声明，否则其对应函数将不再默认带有 <code>noexcept</code> 声明</li><li>自定义实现的函数默认也不会带有 <code>noexcept</code> 声明</li></ul></li><li>类型的析构函数以及 <code>delete</code> 运算符默认带有 <code>noexcept</code> 声明<ul><li>即使自定义实现的析构函数也会默认带有 <code>noexcept</code> 声明</li></ul></li></ul><h3 id="使用 noexcept 的时机"><a href="# 使用 noexcept 的时机" class="headerlink" title="使用 noexcept 的时机"></a>使用 <code>noexcept</code> 的时机</h3><ul><li>一定不会出现异常的函数。通常情况下，这种函数非常简短，例如求一个整数的绝对值、对基本类型的初始化等</li><li>目标是提供不会失败或者不会抛出异常的函数时可以使用 <code>noexcept</code> 声明<ul><li>对于保证不会抛出异常的函数而言，即使有错误发生，函数也更倾向用返回错误码的方式而不是抛出异常 是 <font color="#A8CD9F"> 异常太粗暴了</font></li></ul></li></ul><h2 id="22- 类型别名和别名模板"><a href="#22- 类型别名和别名模板" class="headerlink" title="22 类型别名和别名模板"></a>22 类型别名和别名模板</h2><ul><li><p>往往会使用 <code>typedef</code> 为较长的类型名定义一个别名</p><ul><li>实际上 C 语言中是比较常用的如<code>struct xxx</code>、<code>union xxx</code></li><li>C++ 中 <code>struct xxx</code>、<code>union xxx</code> 定义后 <code>xxx</code> 就是类名，不需要 <code>typedef</code> 了</li></ul></li><li><p>新的定义类型别名的方法，使用 <code>using</code> 关键字 <span class="label label-info">C++ 11</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*func1)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-keyword">using</span> func2 = <span class="hljs-built_in">void</span>(*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><p>对比 <code>typedef</code> 更加清晰</p></li></ul><div class="row">  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong><code>typedef</code>模板别名</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">int_map</span> &#123;<br>    <span class="hljs-keyword">typedef</span> std::map&lt;<span class="hljs-type">int</span>, T&gt; type;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">typename</span> int_map&lt;T&gt;::type int2other; <span class="hljs-comment">// 必须带有 typename 关键字，否则编译错误</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    int_map&lt;std::string&gt;::type int2string;<br>    int2string[<span class="hljs-number">11</span>] = <span class="hljs-string">"7"</span>;<br>&#125;<br></code><div class="code-widget-light code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>        <p>在上面这段代码中，类模板 X 没有确定模板形参 T 的类型，所以 <code>int_map<T>::type</T></code> 是一个未决类型，也就是说 <code>int_map<T>::type</T></code> 既有可能是一个类型，也有可能是一个静态成员变量，编译器是无法处理这种情况的。这里的 <code>typename</code> 关键字告诉编译器应该将 <code>int_map<T>::type</T></code> 作为类型来处理</p>      </div>    </div>  </div>  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong><code>using</code>模板别名</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">using</span> int_map = std::map&lt;<span class="hljs-type">int</span>, T&gt;;<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;<br>    <span class="hljs-keyword">typename</span> int_map&lt;T&gt;::type int2other; <span class="hljs-comment">// 编译成功，别名模板不会有任何问题</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    int_map&lt;std::string&gt;::type int2string;<br>    int2string[<span class="hljs-number">11</span>] = <span class="hljs-string">"7"</span>;<br>&#125;<br></code><div class="code-widget-light code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>        <p>别名模板不会有 <code>::type</code> 的困扰，当然也不会有这样的问题了。当然，为了保证与老代码的兼容性，<code>typedef</code>的方案依然存在。别名模板的模板元编程函数使用 <code>_t</code> 作为其名称的后缀以示区分</p>      </div>    </div>  </div></div><h2 id="23- 指针字面量 nullptr"><a href="#23- 指针字面量 nullptr" class="headerlink" title="23 指针字面量 nullptr"></a>23 指针字面量<code>nullptr</code></h2><ul><li><p><code>NULL</code>是一个宏，在 C++ 11 标准之前其本质就是 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NULL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></li><li><p>使用 0 代表不同类型的特殊规则给 C++ 带来了二义性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">char</span> *)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;char *&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-built_in">f</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">f</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">char</span> *&gt;(<span class="hljs-literal">NULL</span>));<br></code></pre></td></tr></table></figure><blockquote><p><code>f(NULL)</code>会造成 UB</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-function">std::string <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p><code>false</code>被隐式转换为 0，<code>true</code>不能隐式转换成 1，所以 <code>std::string s2(true)</code> 在 MSVC 中编译报错</p></blockquote></li><li><p><code>nullptr</code>表示空指针的字面量 <span class="label label-info">C++ 11</span></p><ul><li><p>它是一个 <code>std::nullptr_t</code> 类型的纯右值</p></li><li><p>不允许运用在算术表达式中或者与非指针类型进行比较（除了空指针常量 0）</p></li><li><p>可以隐式转换为各种指针类型，但是无法隐式转换到非指针类型</p></li><li><p>可以为函数模板或者类设计一些空指针类型的特化版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">widget</span> &#123;<br>    <span class="hljs-built_in">widget</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;template&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">widget</span>&lt;std::<span class="hljs-type">nullptr_t</span>&gt; &#123;<br>    <span class="hljs-built_in">widget</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">widget&lt;T&gt;* <span class="hljs-title">make_widget</span><span class="hljs-params">(T)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">widget</span>&lt;T&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> w1 = <span class="hljs-built_in">make_widget</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">auto</span> w2 = <span class="hljs-built_in">make_widget</span>(<span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="24- 三向比较"><a href="#24- 三向比较" class="headerlink" title="24 三向比较"></a>24 三向比较</h2><ul><li><p>C++ 20 标准新引入了一个名为“太空飞船”（spaceship）的运算符<code>&lt;=&gt;</code> <span class="label label-primary">C++ 20</span></p></li><li><p>运算符 <code>&lt;=&gt;</code> 的返回值只能与 0 和自身类型来比较，如果同其他数值比较，编译器会报错</p></li><li><p>三向比较的返回类型：<code>std::strong_ordering</code>、<code>std::weak_ordering</code>以及<code>std::partial_ordering</code></p><ul><li><code>std::strong_ordering</code> 表达的是一种可替换性<ul><li>对于基本类型中的 <code>int</code> 类型，三向比较返回的是<code>std::strong_ordering</code></li><li>默认情况下自定义类型是不存在三向比较运算符函数的，需要用户显式默认声明</li></ul></li><li><code>std::weak_ordering</code> 表达的是不可替换性<ul><li>基础类型中并没有，但是它常常发生在用户自定义类中，比如一个大小写不敏感的字符串类</li></ul></li><li><code>std::partial_ordering</code> 表示进行比较的两个操作数没有关系<ul><li>基础类型中的浮点数</li><li>浮点的集合中存在一个特殊的 NaN（not a number），它和其他浮点数值是没关系的</li></ul></li></ul></li><li><p>对基础类型的支持</p><ul><li><p>对两个算术类型的操作数进行一般算术转换，然后进行比较</p><ul><li>整型的比较结果为<code>std::strong_ordering</code></li><li>浮点型的比较结果为<code>std::partial_ordering</code></li></ul></li><li><p>对于无作用域枚举类型和整型操作数，枚举类型会转换为整型再进行比较，无作用域枚举类型无法与浮点类型比较</p></li><li><p>对两个相同枚举类型的操作数比较结果，如果枚举类型不同，则无法编译</p></li><li><p>对于其中一个操作数为 <code>bool</code> 类型的情况，另一个操作数必须也是 <code>bool</code> 类型，否则无法编译</p></li><li><p>不支持作比较的两个操作数为数组的情况，会导致编译出错</p></li><li><p>对于其中一个操作数为指针类型的情况，需要另一个操作数是同样类型的指针，或者是可以转换为相同类型的指针，比如数组到指针的转换、派生类指针到基类指针的转换等</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr1[<span class="hljs-number">5</span>];<br><span class="hljs-type">char</span> arr2[<span class="hljs-number">5</span>];<br><span class="hljs-type">char</span>* ptr = arr2;<br><span class="hljs-keyword">auto</span> r = ptr &lt;=&gt; arr1;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>C++20 标准规定，如果用户为自定义类型声明了三向比较运算符，那么编译器会为其自动生成 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和<code>&gt;=</code>这 4 种运算符函数</p></li><li><p>现在 C++ 20 标准已经推荐使用 <code>&lt;=&gt;</code> 和<code>==</code>运算符自动生成其他比较运算符函数</p><ul><li>有了 <code>&lt;=&gt;</code> 可以生成 <code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和<code>&gt;=</code></li><li>有了 <code>==</code> 可以生成<code>!=</code></li></ul></li><li><p>在用户自定义类型中，实现了 <code>&lt;</code>、<code>==</code> 运算符函数的数据成员类型，在该类型的三向比较中将自动生成合适的比较代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Legacy</span> &#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Legacy&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> n == rhs.n;<br>    &#125;<br><br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-type">const</span> Legacy&amp; rhs) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> n &lt; rhs.n;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeWay</span> &#123;<br>    Legacy m;<br>    std::strong_ordering <span class="hljs-built_in">operator</span>&lt;=&gt;(<span class="hljs-type">const</span> TreeWay &amp;) <span class="hljs-type">const</span> = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br>TreeWay t1, t2;<br><span class="hljs-type">bool</span> r = t1 &lt; t2;<br></code></pre></td></tr></table></figure><p>结构体 <code>TreeWay</code> 的三向比较操作会调用结构体 <code>Legacy</code> 中的 <code>&lt;</code> 和<code>==</code>运算符来完成</p></li></ul><h2 id="25- 线程局部存储"><a href="#25- 线程局部存储" class="headerlink" title="25 线程局部存储"></a>25 线程局部存储</h2><ul><li><p>线程局部存储是指对象内存在线程开始后分配，线程结束时回收且每个线程有该对象自己的实例</p></li><li><p><code>thread_local</code>说明符可以用来声明线程生命周期的对象</p><ul><li>能与 <code>static</code> 或<code>extern</code>结合，分别指定内部或外部链接</li><li>和 <code>static</code> 类似，但是在多线程访问时 <code>thread_local</code> 修饰的变量在每个线程中是独立的，<code>static</code>修饰的变量在线程之间是一份内存</li></ul></li><li><p>使用取地址运算符 <code>&amp;</code> 取到的线程局部存储变量的地址是运行时被计算出来的，它不是一个常量，也就是说无法和 <code>constexpr</code> 结合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">thread_local</span> <span class="hljs-type">int</span> tv;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> sv;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *sp = &amp;sv; <span class="hljs-comment">// 编译成功，sv 的地址在编译时确定</span><br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> *tp = &amp;tv; <span class="hljs-comment">// 编译失败，tv 的地址在运行时确定</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>线程局部存储对象的初始化和销毁。在同一个线程中，一个线程局部存储对象只会初始化一次</p></li><li><p>对象的销毁也只会发生一次，通常发生在线程退出的时刻</p></li></ul><h2 id="26- 扩展的 inline 说明符"><a href="#26- 扩展的 inline 说明符" class="headerlink" title="26 扩展的 inline 说明符"></a>26 扩展的 <code>inline</code> 说明符</h2><ul><li>在 C++ 17 标准之前，非常量静态成员变量的声明和定义必须分开进行<ul><li><code>include</code>是单纯的宏替换 <font color="#A8CD9F">以小博大，谓之“宏”</font></li></ul></li><li>C++ 17 增强了 <code>inline</code> 说明符的能力，它允许我们内联定义静态变量 <span class="label label-success">C++ 17</span></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">inline</span> <span class="hljs-type">static</span> std::string text&#123;<span class="hljs-string">&quot;hello&quot;</span>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    X::text += <span class="hljs-string">&quot; world&quot;</span>;<br>    std::cout &lt;&lt; X::text &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><div class="note note-secondary">            <p>针对于 <code>inline</code> 函数，有时候并不一定需要用户手动去指定，编译器会做优化；也就是说编译器也会决定哪些函数是可以内联的，很多时候能覆盖绝大多数的场景</p>          </div><h2 id="27- 常量表达式"><a href="#27- 常量表达式" class="headerlink" title="27 常量表达式"></a>27 常量表达式</h2><div class="row">  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong>宏定义或这常量定义</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> index0 = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> index1 1</span><br><br><span class="hljs-comment">// case 语句</span><br><span class="hljs-keyword">switch</span> (argc) &#123;<br>    <span class="hljs-keyword">case</span> index0:<br>        std::cout &lt;&lt; <span class="hljs-string">"index0"</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> index1:<br>        std::cout &lt;&lt; <span class="hljs-string">"index1"</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        std::cout &lt;&lt; <span class="hljs-string">"none"</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x_size = <span class="hljs-number">5</span> + <span class="hljs-number">8</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y_size 6 + 7</span><br><span class="hljs-comment">// 数组长度</span><br><span class="hljs-type">char</span> buffer[x_size][y_size] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">// 枚举成员</span><br><span class="hljs-keyword">enum</span> &#123;<br>    enum_index0 = index0,<br>    enum_index1 = index1,<br>&#125;;<br><br>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; tp = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'3'</span>);<br><span class="hljs-comment">// 非类型的模板参数</span><br><span class="hljs-type">int</span> x1 = std::<span class="hljs-built_in">get</span>&lt;index0&gt;(tp);<br><span class="hljs-type">char</span> x2 = std::<span class="hljs-built_in">get</span>&lt;index1&gt;(tp);<br></code><div class="code-widget copy-btn code-widget-light" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>        <ul>          <li>C++ 程序员应该尽量少使用宏，因为预处理器对于宏只是简单的字符替换，完全没有类型检查，而且宏使用不当出现的错误难以排查</li>          <li>可以用模板代替</li>        </ul>      </div>    </div>  </div>  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong>将宏或常量改为函数调用</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_index0</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_index1</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_x_size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">5</span> + <span class="hljs-number">8</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get_y_size</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">6</span> + <span class="hljs-number">7</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> index0 = <span class="hljs-built_in">get_index0</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> index1 get_index1()</span><br><br><span class="hljs-comment">// case 语句</span><br><span class="hljs-keyword">switch</span> (argc) &#123;<br>    <span class="hljs-keyword">case</span> index0:<br>        std::cout &lt;&lt; <span class="hljs-string">"index0"</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> index1:<br>        std::cout &lt;&lt; <span class="hljs-string">"index1"</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">default</span>:<br>        std::cout &lt;&lt; <span class="hljs-string">"none"</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x_size = <span class="hljs-built_in">get_x_size</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> y_size get_y_size()</span><br><span class="hljs-comment">// 数组长度</span><br><span class="hljs-type">char</span> buffer[x_size][y_size] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">// 枚举成员</span><br><span class="hljs-keyword">enum</span> &#123;<br>    enum_index0 = index0,<br>    enum_index1 = index1,<br>&#125;;<br><br>std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">char</span>&gt; tp = std::<span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">4</span>, <span class="hljs-string">'3'</span>);<br><span class="hljs-comment">// 非类型的模板参数</span><br><span class="hljs-type">int</span> x1 = std::<span class="hljs-built_in">get</span>&lt;index0&gt;(tp);<br><span class="hljs-type">char</span> x2 = std::<span class="hljs-built_in">get</span>&lt;index1&gt;(tp);<br></code><div class="code-widget-light code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>        <p>无法通过编译，无论是宏定义的函数调用，还是通过函数返回值初始化 <code>const</code> 变量都是在运行时确定的</p>      </div>    </div>  </div></div><div class="note note-secondary">            <p>C 语言中可支持在栈上开辟变长数组（VLA），C++ 没有必要</p>          </div><ul><li>C 语言 <code>&lt;limit.h&gt;</code> 中定义了各种整型类型的最大值和最小值，是通过宏定义的</li><li>C++ 为了避免宏的使用，在 <code>&lt;limit&gt;</code> 中采用模板特化的方式来定义最值，返回的是函数计算后的值，但是必须在运行时计算，仍然会导致常量无法确定的问题<ul><li><code>char buffer[std::numeric_limits&lt;unsigned char&gt;::max()] = &#123;0&#125;;</code> 编译报错</li></ul></li><li>C++ 11 标准中定义一个新的关键字<code>constexpr</code>，它能够有效地定义常量表达式 <span class="label label-info">C++ 11</span></li></ul><h3 id="constexpr 值和函数"><a href="#constexpr 值和函数" class="headerlink" title="constexpr 值和函数"></a><code>constexpr</code>值和函数 </h3><p><code>constexpr</code> 值即常量表达式值，是一个用 <code>constexpr</code> 说明符声明的变量或者数据成员，它要求该值必须在编译期计算 <font color="#A0153E"><strong>常量表达式值必须由常量表达式初始化</strong></font></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 正常使用</span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x1 = <span class="hljs-number">42</span>;<br><span class="hljs-type">char</span> buffer1[x1] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-comment">// 将 constexpr 替换为 const 也可以正常使用</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x2 = <span class="hljs-number">42</span>;<br><span class="hljs-type">char</span> buffer2[x2] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> x3 = <span class="hljs-number">42</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> x4 = x3; <span class="hljs-comment">// 定义和初始化成功，但是编译器并不一定把它作为一个编译期需要确定的值</span><br><span class="hljs-type">char</span> buffer[x4] = &#123; <span class="hljs-number">0</span> &#125;; <span class="hljs-comment">// 编译失败，x4 无法作为数组长度</span><br><br><span class="hljs-type">int</span> x5 = <span class="hljs-number">42</span>;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x6 = x5; <span class="hljs-comment">// 编译失败，x6 无法用 x5 初始化</span><br><span class="hljs-type">char</span> buffer[x6] = &#123; <span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><ul><li><p><code>constexpr</code>是一个加强版的<code>const</code>，它不仅要求常量表达式是常量，并且要求是一个编译阶段就能够确定其值的常量</p></li><li><p>常量和常量是不一样的</p><ul><li>编译器 / 编译时常量<ul><li>数值类型，<code>bool</code>类型，字符串类型</li></ul></li><li>运行期 / 运行时常量</li></ul></li><li><p><code>constexpr</code>函数，常量表达式函数的返回值可以在编译阶段就计算出来</p><ul><li>函数必须返回一个值，所以它的返回值类型不能是<code>void</code></li><li>函数体必须只有一条语句：<code>return expr</code>，其中 <code>expr</code> 必须也是一个常量表达式。如果函数有形参，则将形参替换到 <code>expr</code> 中后，<code>expr</code>仍然必须是一个常量表达式</li><li>函数使用之前必须有定义</li><li>函数必须用 <code>constexpr</code> 声明</li></ul></li><li><p>虽然常量表达式函数的返回值可以在编译期计算出来，但是这个行为并不是确定的</p><ul><li>当带形参的常量表达式函数接受了一个非常量实参时，常量表达式函数可能会退化为普通函数</li></ul></li><li><p><code>constexpr</code>构造函数</p><ul><li><p>构造函数必须用 <code>constexpr</code> 声明</p></li><li><p>构造函数初始化列表中必须是常量表达式</p></li><li><p>构造函数的函数体必须为空（这一点基于构造函数没有返回值，所以不存在<code>return expr</code>）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">X</span><span class="hljs-params">()</span> : x1(<span class="hljs-number">5</span>) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> : x1(i) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x1;<br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x1;<br>&#125;;<br><br><span class="hljs-keyword">constexpr</span> X x;<br><span class="hljs-type">char</span> buffer[x.<span class="hljs-built_in">get</span>()] = &#123; <span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><ul><li>称这样的类为字面量类类型（literal class type）</li><li><code>constexpr</code>会自动给函数带上 <code>const</code> 属性</li><li>常量表达式构造函数拥有和常量表达式函数相同的退化特性，当它的实参不是常量表达式的时候，构造函数可以退化为普通构造函数</li></ul></li><li><p>使用 <code>constexpr</code> 声明自定义类型的变量，必须确保这个自定义类型的析构函数是平凡的，否则也是无法通过编译的</p><ul><li>自定义类型中不能有用户自定义的析构函数</li><li>析构函数不能是虚函数</li><li>基类和成员的析构函数必须都是平凡的</li></ul></li><li><p><code>constexpr</code>说明符则支持声明浮点类型的常量表达式值，而且标准还规定其精度必须至少和运行时的精度相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? x + <span class="hljs-built_in">sum</span>(x - <span class="hljs-number">1</span>) : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> x = <span class="hljs-built_in">sum</span>(<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常量表达式函数的增强"><a href="# 常量表达式函数的增强" class="headerlink" title="常量表达式函数的增强"></a>常量表达式函数的增强 <span class="label label-warning">C++ 14</span></h3><ul><li><p>函数体允许声明变量，除了没有初始化、<code>static</code>和 <code>thread_local</code> 变量</p></li><li><p>函数允许出现 <code>if</code> 和<code>switch</code>语句，不能使用 <code>goto</code> 语句</p></li><li><p>函数允许所有的循环语句，包括<code>for</code>、<code>while</code>、<code>do-while</code></p></li><li><p>函数可以修改生命周期和常量表达式相同的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">next</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ++x;<br>&#125;<br><br><span class="hljs-type">char</span> buffer[<span class="hljs-built_in">next</span>(<span class="hljs-number">5</span>)] = &#123; <span class="hljs-number">0</span> &#125;;<br></code></pre></td></tr></table></figure><p><code>x</code>的声明周期和常量的生命周期一致</p></li><li><p>函数的返回值可以声明为<code>void</code></p></li><li><p><code>constexpr</code>声明的成员函数不再具有 <code>const</code> 属性</p></li><li><p>除了在常量表达式函数特性方面做了增强，也在标准库方面做了增强，包括 <code>&lt;complex&gt;</code>、<code>&lt;chrono&gt;</code>、<code>&lt;array&gt;</code>、<code>&lt;initializer_list&gt;</code>、<code>&lt;utility&gt;</code> 和<code>&lt;tuple&gt;</code></p></li></ul><h3 id="constexprlambda- 表达式和内联属性"><a href="#constexprlambda- 表达式和内联属性" class="headerlink" title="constexprlambda 表达式和内联属性"></a><code>constexpr</code>lambda 表达式和内联属性</h3><ul><li><p>lambda 表达式在条件允许的情况下都会隐式声明为<code>constexpr</code> <span class="label label-success">C++ 17</span></p></li><li><p>当 lambda 表达式不满足 <code>constexpr</code> 的条件时也没有关系，变成运行时的 lambda 表达式，只要用在合适的地方就可以了</p></li><li><p>可以强制要求 lambda 表达式是一个常量表达式，用 <code>constexpr</code> 去声明它即可</p><ul><li>可以检查 lambda 表达式是否有可能是一个常量表达式，如果不能则会编译报错</li></ul></li><li><p><code>constexpr</code>声明静态成员变量时，也被赋予了该变量的内联属性 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">X</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> num&#123; <span class="hljs-number">5</span> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>C++ 11 中 <code>num</code> 只有声明没有定义，实际上是编译器直接将 <code>X::num</code> 替换为 <code>5</code>，如果对<code>num</code> 取地址，即 <code>&amp;X::num</code> 连接器会提示 <code>X::num</code> 缺少定义</li><li>C++ 17 中 <code>num&#123; 5 &#125;</code> 既是声明也是定义</li></ul></li></ul><h3 id="if-constexpr"><a href="#if-constexpr" class="headerlink" title="if constexpr"></a><code>if constexpr</code></h3><div class="note note-warning">            <p>该特性只有在使用模板的时候才具有实际意义，如果是普通函数，那直接可以写出分支中的语句即可；模板的类型只有实例化的时候才会出现不同的分支情况，使用 <code>if constexpr</code> 才有意义</p>          </div><ul><li><code>if constexpr</code>的条件必须是编译期能确定结果的常量表达式</li><li>条件结果一旦确定，编译器将只编译符合条件的代码块</li><li><code>if constexpr</code>不支持短路规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">is_same_value</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a == b;<br>&#125;<br><br><span class="hljs-keyword">template</span>&lt;&gt; <span class="hljs-type">bool</span> <span class="hljs-built_in">is_same_value</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b) &#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(a - b) &lt; <span class="hljs-number">0.0001</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> x = <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> + <span class="hljs-number">0.1</span> - <span class="hljs-number">0.3</span>;<br>    std::cout &lt;&lt; std::boolalpha;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;is_same_value(5, 5) : &quot;</span> &lt;&lt; <span class="hljs-built_in">is_same_value</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>) &lt;&lt;<br>    std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;x == 0.0 : &quot;</span> &lt;&lt; (x == <span class="hljs-number">0.</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;is_same_value(x, 0.) : &quot;</span> &lt;&lt; <span class="hljs-built_in">is_same_value</span>(x, <span class="hljs-number">0.</span>) &lt;&lt;<br>    std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">is_same_value(5, 5) : true<br>x == 0.0 : false<br>is_same_value(x, 0.) : true<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p><code>float</code>有效位数是 7 位，一般用 <code>0.0000001</code> 比较；<code>double</code>有效位数是 15 位，所以要多写几位，如 <code>0.000000000000001</code> 比较</p>          </div><p>使用 <code>if constexpr</code> 表达式，代码会简化很多而且更加容易理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-type">bool</span> <span class="hljs-title">is_same_value</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same&lt;T, <span class="hljs-type">double</span>&gt;::value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(a - b) &lt; <span class="hljs-number">0.0001</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> a == b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意这样一种陷阱</p><div class="row">  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong>正常情况</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">minus</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same&lt;T, <span class="hljs-type">double</span>&gt;::value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(a - b) &lt; <span class="hljs-number">0.0001</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> a - b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a - b);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-built_in">minus</span>(<span class="hljs-number">5.6</span>, <span class="hljs-number">5.11</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">minus</span>(<span class="hljs-number">5.60002</span>, <span class="hljs-number">5.600011</span>) &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-built_in">minus</span>(<span class="hljs-number">6</span>, <span class="hljs-number">5</span>) &lt;&lt; std::endl;<br>&#125;<br></code><div class="code-widget-light code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>      </div>    </div>  </div>  <div class="col-sm-6">    <div class="card">      <div class="card-body">        <p class="card-title"><strong>缺少 <code>else</code> 分支</strong></p>        <figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt; <span class="hljs-keyword">auto</span> <span class="hljs-title">minus</span><span class="hljs-params">(T a, T b)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_same&lt;T, <span class="hljs-type">double</span>&gt;::value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">abs</span>(a - b) &lt; <span class="hljs-number">0.0001</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0.</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> a - b;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(a - b);<br>    &#125;<br>&#125;<br></code><div class="code-widget-light code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>C++</div></pre></td></tr></tbody></table></figure>        <p>可能会导致函数有多个不同的返回类型；当实参类型为 <code>double</code> 的时，<code>if</code>的代码块会被正常地编译，代码块内部的返回结果类型为<code>double</code>，而代码块外部返回类型为<code>int</code>。编译器遇到了两个不同的返回类型，只能报错</p>      </div>    </div>  </div></div><h3 id="constexpr 其他特性"><a href="#constexpr 其他特性" class="headerlink" title="constexpr 其他特性"></a><code>constexpr</code>其他特性 <span class="label label-primary">C++ 20</span></h3><ul><li><p>允许 <code>constexpr</code> 虚函数</p><ul><li><code>constexpr</code>的虚函数可以覆盖重写普通虚函数</li><li>普通虚函数也可以覆盖重写 <code>constexpr</code> 的虚函数</li><li><font color="#A8CD9F">大不了就退化</font></li></ul></li><li><p>允许在 <code>constexpr</code> 函数中出现<code>try-catch</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">try</span> &#123; <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-built_in">catch</span> (...) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="#A8CD9F"><code>try-catch</code>和 <code>if-else</code> 是一个意思</font></p></li><li><p>允许在 <code>constexpr</code> 中进行平凡的默认初始化</p><ul><li>应该养成声明对象时随手初始化的习惯，避免让代码出现未定义的行为</li></ul></li><li><p>允许在 <code>constexpr</code> 中更改联合类型的有效成员</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">union</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-type">float</span> f;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">use</span><span class="hljs-params">()</span> </span>&#123;<br>    Foo foo&#123;&#125;;<br>    foo.i = <span class="hljs-number">3</span>;<br>    foo.f = <span class="hljs-number">1.2f</span>; <span class="hljs-comment">// C++20 之前编译失败</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 <code>consteval</code> 声明立即函数，对于无法在编译期执行计算的情况则让编译器直接报错</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r = <span class="hljs-built_in">sqr</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 编译成功</span><br><span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> r2 = <span class="hljs-built_in">sqr</span>(x); <span class="hljs-comment">// 编译失败</span><br></code></pre></td></tr></table></figure><ul><li>lambda 表达式也可以使用 <code>consteval</code> 说明符</li></ul></li><li><p>使用 <code>constinit</code> 检查常量初始化，要用于具有静态存储持续时间的变量声明上，它要求变量具有常量初始化程序</p><ul><li><p><code>constinit</code>说明符作用的对象是必须具有静态存储持续时间的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> x = <span class="hljs-number">11</span>; <span class="hljs-comment">// 编译成功，全局变量具有静态存储持续</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constinit</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> y = <span class="hljs-number">42</span>; <span class="hljs-comment">// 编译成功，静态变量具有静态存储持续</span><br>    <span class="hljs-keyword">constinit</span> <span class="hljs-type">int</span> z = <span class="hljs-number">7</span>; <span class="hljs-comment">// 编译失败，局部变量是动态分配的</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>constinit</code>要求变量具有常量初始化程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cpp&quot;</span>; &#125;<br><span class="hljs-keyword">constinit</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str1 = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// 编译错误，f() 不是一个常量初始化程序，编译的时候不能确定其值</span><br><span class="hljs-keyword">constinit</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str2 = <span class="hljs-built_in">g</span>(); <span class="hljs-comment">// 编译成功，编译的时候可以确定其值</span><br></code></pre></td></tr></table></figure></li><li><p>虽然 <code>constinit</code> 说明符一直在强调常量初始化，但是初始化的对象并不要求具有常量属性</p></li></ul></li><li><p><code>std::is_constant_evaluated</code>是 C++ 20 新加入标准库的函数，它用于检查当前表达式是否是一个常量求值环境</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;type_traits&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">double</span> b, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">is_constant_evaluated</span>() &amp;&amp; x &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">double</span> r = <span class="hljs-number">1.0</span>, p = b;<br>        <span class="hljs-type">unsigned</span> u = (<span class="hljs-type">unsigned</span>)x;<br>        <span class="hljs-keyword">while</span> (u != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (u &amp; <span class="hljs-number">1</span>) r *= p;<br>            u /= <span class="hljs-number">2</span>;<br>            p *= p;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">pow</span>(b, (<span class="hljs-type">double</span>)x);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">double</span> kilo = <span class="hljs-built_in">power</span>(<span class="hljs-number">10.0</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 常量求值</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">double</span> mucho = <span class="hljs-built_in">power</span>(<span class="hljs-number">10.0</span>, n); <span class="hljs-comment">// 非常量求值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>明显常量求值</p><ul><li>常量表达式，这个类别包括很多种情况，比如数组长度、<code>case</code>表达式、非类型模板实参等</li><li><code>if constexpr</code>语句中的条件</li><li><code>constexpr</code>变量的初始化程序</li><li>立即函数调用</li><li>约束概念表达式</li><li>可在常量表达式中使用或具有常量初始化的变量初始化程序</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-keyword">struct</span> <span class="hljs-title class_">X</span> &#123;&#125;;<br>X&lt;std::<span class="hljs-built_in">is_constant_evaluated</span>()&gt; x; <span class="hljs-comment">// 非类型模板实参，函数返回 true，最终类型为 X&lt;true&gt;</span><br><span class="hljs-type">int</span> y;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> n = std::<span class="hljs-built_in">is_constant_evaluated</span>() ? <span class="hljs-number">13</span> : <span class="hljs-number">17</span>; <span class="hljs-comment">// n 是 13</span><br>    <span class="hljs-type">int</span> m = std::<span class="hljs-built_in">is_constant_evaluated</span>() ? <span class="hljs-number">13</span> : <span class="hljs-number">17</span>; <span class="hljs-comment">// m 可能是 13 或者 17，取决于函数环境</span><br>    <span class="hljs-type">char</span> arr[n] = &#123;&#125;; <span class="hljs-comment">// char[13]</span><br>    <span class="hljs-keyword">return</span> m + <span class="hljs-built_in">sizeof</span>(arr);<br>&#125;<br><span class="hljs-type">int</span> p = <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// m 是 13；p 结果如下 26</span><br><span class="hljs-type">int</span> q = p + <span class="hljs-built_in">f</span>(); <span class="hljs-comment">// m 是 17；q 结果如下 56</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="28- 确定的表达式求值顺序"><a href="#28- 确定的表达式求值顺序" class="headerlink" title="28 确定的表达式求值顺序"></a>28 确定的表达式求值顺序</h2><ul><li><p>在 C++ 17 之前是没有具体说明的，所以编译器可以以任何顺序对子表达式进行求值</p><ul><li><code>foo(a, b, c)</code>，这里的 <code>foo</code>、<code>a</code>、<code>b</code> 和<code>c</code>的求值顺序是没有确定的</li></ul></li><li><p>函数表达式一定会在函数的参数之前求值 <span class="label label-success">C++ 17</span></p><ul><li><code>foo(a, b, c)</code>，<code>foo</code>一定会在 <code>a</code>、<code>b</code> 和<code>c</code>之前求值</li><li>但是参数之间的求值顺序依然没有确定</li></ul></li><li><p>对于后缀表达式和移位操作符而言，表达式求值总是从左往右</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">E1[E2]<br>E1.E2<br>E1.*E2<br>E1-&gt;*E2<br>E1&lt;&lt;E2<br>E1&gt;&gt;E2<br></code></pre></td></tr></table></figure><p>在上面的表达式中，子表达式求值 <code>E1</code> 总是优先于<code>E2</code></p></li><li><p>对于赋值表达式，这个顺序又正好相反，它的表达式求值总是从右往左</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">E1=E2<br>E1+=E2<br>E1-=E2<br>E1*=E2<br>E1/=E2<br>...<br></code></pre></td></tr></table></figure><p>在上面的表达式中，子表达式求值 <code>E2</code> 总是优先于<code>E1</code></p></li><li><p>对于 <code>new</code> 表达式，C++ 17 也做了规定 <span class="label label-success">C++ 17</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">new</span> <span class="hljs-built_in">T</span>(E)<br></code></pre></td></tr></table></figure><ul><li>这里 <code>new</code> 表达式的内存分配总是优先于 <code>T</code> 构造函数中参数 <code>E</code> 的求值</li><li>涉及重载运算符的表达式的求值顺序应由与之相应的内置运算符的求值顺序确定，而不是函数调用的顺序规则</li></ul></li></ul><div class="note note-warning">            <ul><li>尽量不要使函数调用产生副作用，否则会很难确认实参的真实值 </li><li> 通过变成规范避免产生这种问题 </li><li> 在函数中不要既要修改又要访问</li></ul>          </div><h2 id="29- 字面量优化"><a href="#29- 字面量优化" class="headerlink" title="29 字面量优化"></a>29 字面量优化</h2><ul><li><p>标准库中引入了 <code>std::hexfloat</code> 和<code>std::defaultfloat</code>来修改浮点输入和输出的默认格式化 <span class="label label-info">C++ 11</span></p><ul><li><code>std::hexfloat</code>可以将浮点数格式化为十六进制的字符串</li><li><code>std::defaultfloat</code>可以将格式还原到十进制</li></ul></li><li><p>二进制整数字面量也有前缀 <code>0b</code> 和<code>0B</code> <span class="label label-warning">C++ 14</span></p><ul><li>十六进制 <code>0x</code>，<code>0X</code> 和八进制<code>0</code></li></ul></li><li><p>一个用单引号作为整数分隔符的特性 <span class="label label-warning">C++ 14</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> x = <span class="hljs-number">123&#x27;456</span>;<br><span class="hljs-built_in">static_assert</span>(x == <span class="hljs-number">0x1e&#x27;240</span>);<br><span class="hljs-built_in">static_assert</span>(x == <span class="hljs-number">036&#x27;11&#x27;00</span>);<br><span class="hljs-built_in">static_assert</span>(x == <span class="hljs-number">0b11&#x27;110&#x27;001&#x27;001&#x27;000&#x27;000</span>);<br></code></pre></td></tr></table></figure><ul><li>单引号整数分隔符对于十进制、八进制、十六进制、二进制整数都是有效的</li><li><font color="#A8CD9F"><code>&#39;</code>加哪都可以</font></li></ul></li><li><p>原生字符串字面量 raw string <span class="label label-info">C++ 11</span></p><ul><li>原生字符串字面量声明是<code>R&quot;(raw_characters)&quot;</code>，特殊字符不需要转义了</li></ul></li><li><p>用户自定义字面量 <span class="label label-info">C++ 11</span></p><ul><li>可以通过自定义后缀将整数、浮点数、字符和字符串转化为特定的对象</li><li>字面量运算符函数的语法规则<ul><li>由返回类型、<code>operator</code>关键字、标识符以及函数形参组成的</li><li><code>retrun_type operator &quot;&quot; identifier (params)</code></li><li>在 C++ 11 的标准中，双引号和紧跟的标识符中间必须有空格</li><li>标识符可以紧跟在双引号后 <span class="label label-warning">C++ 14</span></li><li>还能使用 C++ 的保留字作为标识符 <span class="label label-warning">C++ 14</span></li><li>建议用户定义的字面量运算符函数的标识符应该以下画线开始</li></ul></li><li>整数字面量运算符函数有 3 种不同的形参类型<ul><li><code>unsigned long long</code></li><li><code>const char *</code></li><li>形参为空<ul><li>使用模板参数实现：<code>operator &quot;&quot;identifier&lt;char…c&gt;()</code></li></ul></li><li>编译器会将整数字面量转换为对应的无符号 <code>long long</code> 类型或者常量字符串类型，然后将其作为参数传递给运算符函数</li></ul></li><li>浮点数字面量运算符函数有 3 种形参类型<ul><li><code>long double</code></li><li><code>const char *</code></li><li>形参为空</li></ul></li><li>字符串字面量运算符函数<ul><li>形参类型列表为<code>const char * str, size_t len</code><ul><li><code>str</code>为字符串字面量的具体内容</li><li><code>len</code>是字符串字面量的长度</li></ul></li><li>字符字面量运算符函数也只有一种形参类型<code>char</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w1(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w2(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str) &#123;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w3(<span class="hljs-type">long</span> <span class="hljs-type">double</span> n) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br>std::string <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w4(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str, <span class="hljs-type">size_t</span> len) &#123;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-type">char</span> <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w5(<span class="hljs-type">char</span> n) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">if</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> n) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> x1 = <span class="hljs-number">123</span>_w1;<br>    <span class="hljs-keyword">auto</span> x2_1 = <span class="hljs-number">123</span>_w2;<br>    <span class="hljs-keyword">auto</span> x2_2 = <span class="hljs-number">12.3</span>_w2;<br>    <span class="hljs-keyword">auto</span> x3 = <span class="hljs-number">12.3</span>_w3;<br>    <span class="hljs-keyword">auto</span> x4 = <span class="hljs-string">&quot;hello world&quot;</span>_w4;<span class="hljs-keyword">auto</span> x5 = <span class="hljs-string">&#x27;a&#x27;</span>_w5;<span class="hljs-keyword">auto</span> x6 = <span class="hljs-number">123</span><span class="hljs-keyword">if</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>字面量运算符函数使用模板参数的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">char</span>…c&gt; std::string <span class="hljs-keyword">operator</span> <span class="hljs-string">&quot;&quot;</span> _w() &#123;<br>    std::string str;<br>    <span class="hljs-comment">//(str.push_back(c), …); // C++17 的折叠表达式</span><br>    <span class="hljs-keyword">using</span> unused = <span class="hljs-type">int</span>[]; <span class="hljs-comment">// 为了避免歧义，导致编译器报错，如果使用</span><br>    unused&#123; (str.<span class="hljs-built_in">push_back</span>(c), <span class="hljs-number">0</span>) … &#125;;<br>    <span class="hljs-comment">// int[]&#123; (str.push_back(c), 0) …  &#125;; 类似结构化绑定，会导致编译器报错</span><br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-number">123</span>_w;<br>    <span class="hljs-keyword">auto</span> y = <span class="hljs-number">12.3</span>_w;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>unused&#123; (str.push_back(c), 0) … &#125;;</code>如果使用的是 <code>123_w</code> 实际上可以展开为 <code>unused&#123; (str.push_back(1), 0), (str.push_back(2), 0), (str.push_back(3), 0)</code>，每个表达式的结果都是<code>0</code>，因为使用了逗号表达式，所以<code>unused</code> 最终没有用到，目的是驱动这个表达式的计算</p></li></ul></li></ul><h2 id="alignas 和 alignof"><a href="#alignas 和 alignof" class="headerlink" title="alignas 和 alignof"></a><code>alignas</code>和<code>alignof</code></h2><ul><li><p><code>alignof</code>运算符可以用于获取类型的对齐字节长度</p></li><li><p><code>alignas</code>说明符可以用来改变类型的默认对齐字节长度</p></li><li><p>在 <code>alignof</code> 运算符被引入之前，常用 <code>offsetof</code> 来间接实现 <code>alignof</code> 的功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ALIGNOF(type, result) \</span><br><span class="hljs-meta">  struct type##_alignof_trick&#123; char c; type member; &#125;; \</span><br><span class="hljs-meta">  result = offsetof(type##_alignof_trick, member)</span><br><br><span class="hljs-type">int</span> x1 = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">ALIGNOF</span>(<span class="hljs-type">int</span>, x1);<br></code></pre></td></tr></table></figure><p>其中 <code>offsetof</code> 在 mscv 中实现也是一个宏 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> offsetof(s, m) ((::size_t)&amp;reinterpret_cast<span class="hljs-string">&lt;char const volatile&amp;&gt;</span>((((s*)0)-&gt;m)))</span><br></code></pre></td></tr></table></figure><p><code>reinterpret_cast&lt;char const volatile&amp;&gt;</code>是编译器优化所用，理解时可以去掉，就是相对于地址 0 的偏移</p></li><li><p>使用 <code>alignof</code> 运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x1 = <span class="hljs-built_in">alignof</span>(<span class="hljs-type">int</span>);<br><span class="hljs-keyword">auto</span> x2 = <span class="hljs-built_in">alignof</span>(<span class="hljs-built_in">void</span>(*)());<br><span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> x3 = <span class="hljs-built_in">alignof</span>(a); <span class="hljs-comment">// *C++ 标准不支持这种用法</span><br></code></pre></td></tr></table></figure><ul><li>C++ 标准规定 <code>alignof</code> 必须是针对类型的</li><li>GCC 扩展了这条规则，<code>alignof</code>除了能接受一个类型外还能接受一个变量</li><li>使用 MSVC 如果想获得变量的对齐，可以使用编译器的扩展关键字<code>__alignof</code></li><li>可以通过 <code>alignof</code> 获得类型 <code>std::max_align_t</code> 的对齐字节长度</li><li>C++ 11 定义了<code>std::max_align_t</code>，它是一个平凡的标准布局类型，其对齐字节长度要求至少与每个标量类型一样严格</li><li>所有的标量类型都适应 <code>std::max_align_t</code> 的对齐字节长度</li><li><code>new</code>和 m<code>alloc</code>之类的分配函数返回的指针需要适合于任何对象，也就是说内存地址至少与 <code>std::max_align_t</code> 严格对齐</li></ul></li><li><p>使用 <code>alignas</code> 说明符</p><ul><li>该说明符可以接受类型或者常量表达式 <font color="#A0153E">该常量表达式计算的结果必须是一个 2 的幂值，否则是无法通过编译的</font></li><li></li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本书是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++ 11 到 C++ 20 引入的核心特性。书中不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
    <category term="Modern C++" scheme="https://silhouettesforyou.github.io/tags/Modern-C/"/>
    
    <category term="笔记" scheme="https://silhouettesforyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>术语</title>
    <link href="https://silhouettesforyou.github.io/2024/07/18/6aa64a608435/"/>
    <id>https://silhouettesforyou.github.io/2024/07/18/6aa64a608435/</id>
    <published>2024-07-18T09:21:18.000Z</published>
    <updated>2024-07-30T13:36:05.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">    <div class="fold">      <div class="fold-title fold-light collapsed" data-toggle="collapse" href="#collapse-cb17943d" role="button" aria-expanded="false" aria-controls="collapse-cb17943d">        <div class="fold-arrow">▶</div>generic composition      </div>      <div class="fold-collapse collapse" id="collapse-cb17943d">        <div class="fold-content">          <p>“generic composition”可以拆分为两部分来解释，即“generic”和“composition”。</p><p><strong>Generic</strong>：</p><ul><li>含义：通用的、普遍的。</li><li>应用领域：</li><li>计算机编程：用于描述可以处理不同种类数据类型的程序或类。</li><li>商业领域：许多公司选择采用通用的配件或原材料来生产物品，以扩大市场并保证生产成本的可控性。</li><li>药品：非处方药品也被称为 Generic 药品，即它们没有品牌名称，但成分与一些有品牌的药品一致，具有同样的疗效。</li></ul><p><strong>Composition</strong>：</p><ul><li>含义：</li><li>抽象的行为：作曲、创作、写作。</li><li>具体的成果：作文、作品。</li><li>其他：构图、布置、妥协、和解。</li><li>词源：直接源自拉丁语的 compositus，意为合成物。</li><li>实用场景：</li><li>学习作曲艺术。</li><li>土壤的化学成分。</li><li>董事会的组成。</li><li>贝多芬的音乐作品。</li></ul><p>结合两者，<strong>generic composition</strong>可能指的是一种通用的或普遍的创作、组合或构成方式。在编程中，它可能指的是一种通用的、能够处理多种数据类型的程序结构或代码组成。在艺术或写作中，它可能指的是一种通用的创作方法或技巧，适用于多种题材或领域。在商业或产品设计中，它可能指的是一种通用的产品组合或设计，能够满足广泛的市场需求。</p><p>总之，“generic composition”是一个结合了“通用性”和“创作、组合”含义的短语，其具体含义和应用领域需要根据上下文来判断。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-light collapsed" data-toggle="collapse" href="#collapse-9e634efd" role="button" aria-expanded="false" aria-controls="collapse-9e634efd">        <div class="fold-arrow">▶</div>traits technique      </div>      <div class="fold-collapse collapse" id="collapse-9e634efd">        <div class="fold-content">          <p>traits technique（特性萃取技术）是一种在编程中广泛使用的技术，特别是在 C++ 的泛型编程（Generic Programming）中。这项技术主要用于提取“被传进的对象”对应的返回类型，让同一个接口能够实现对应的功能。下面是对 traits technique 的详细解释：</p><ul><li><strong>基本概念 </strong>：<ul><li>Traits 技术，也被称为特性萃取技术，它允许程序员为不同的类型定义不同的行为或属性。</li><li> 在 C++ 中，traits 通常用于模板元编程，帮助编译器在编译时确定类型信息，从而优化代码的执行效率。</li></ul></li><li><strong>主要应用 </strong>：<ul><li> 当算法和容器是分离的，并且需要通过迭代器进行链接时，traits 技术可以帮助算法确定被传入对象的类型，从而调用适当的方法。</li><li>Traits 技术在 STL（Standard Template Library，标准模板库）中被广泛应用，用于隐藏一些实现细节，并协助调用合适的方法。</li></ul></li><li><strong>实现方式 </strong>：<ul><li>Traits 通常使用 enum、typedef 和模板（部分）特化（template specialization）等技术来实现。</li><li>Enum 用于将在不同类型间变化的标示统一成一个。</li><li>Typedef 则用于定义模板类支持特性的形式。</li><li> 模板（部分）特化被用于提供针对特定类型的正确的或更合适的版本。</li><li>通过这些技术，traits 可以提取类中定义的特性，并根据不同的特性提供不同的实现。</li></ul></li><li><strong>作用 </strong>：<ul><li>Traits technique 可以使代码更加灵活，支持多种数据类型。</li><li> 通过萃取技术，可以隐藏一些复杂的实现细节，使得接口更加简洁明了。</li><li>Traits technique 还可以提高代码的可读性和可维护性，降低出错的可能性。</li></ul></li></ul><p>总结来说，traits technique 是一种强大的编程技术，它允许程序员为不同的类型定义不同的行为或属性，并在编译时确定类型信息以优化代码执行效率。在 C++ 的泛型编程中，traits technique 被广泛应用，并成为了许多高效库和框架的基石。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-light collapsed" data-toggle="collapse" href="#collapse-ed26cd80" role="button" aria-expanded="false" aria-controls="collapse-ed26cd80">        <div class="fold-arrow">▶</div>In-Place Transformations      </div>      <div class="fold-collapse collapse" id="collapse-ed26cd80">        <div class="fold-content">          <p>“In-Place Transformations”（原地变换）在计算机科学中，通常指的是一种算法设计技巧，它指的是在变换数据或执行操作时，尽可能地使用少量的额外空间，甚至是不使用任何额外空间，而是在原数据上进行直接修改。这样的算法设计可以有效地减少内存使用，提高算法的效率。</p><p>以下是关于“In-Place Transformations”的详细说明：</p><ul><li><strong>定义 </strong>：<ul><li> 原地变换是一种算法策略，其中输入数据在算法执行过程中被直接修改，以产生所需的输出。这意味着算法不需要额外的空间（或仅需要极少的额外空间）来存储中间结果或最终输出。</li></ul></li><li><strong>特点 </strong>：<ul><li><strong> 空间效率 </strong>：原地变换的主要优点之一是它们能够显著减少内存使用。这在处理大型数据集或内存受限的环境中尤为重要。</li><li><strong> 直接修改 </strong>：由于直接在原数据上进行操作，原地变换通常比非原地变换更快，因为它们避免了数据的复制和移动。</li><li><strong> 挑战性 </strong>：设计原地变换算法通常比设计非原地变换算法更具挑战性，因为需要仔细考虑如何在不引入额外空间的情况下进行数据的修改和重新组织。</li></ul></li><li><strong> 示例 </strong>：<ul><li><strong> 矩阵转置 </strong>：矩阵的原地转置是一个常见的原地变换示例。在某些情况下，可以通过使用循环和交换元素的方式，在不分配额外内存的情况下实现矩阵的转置。</li><li><strong> 数组排序 </strong>：许多排序算法（如快速排序、堆排序等）也可以被设计为原地算法，它们通过在数组中直接交换元素来排序，而不需要额外的数组来存储中间结果。</li></ul></li><li><strong> 注意事项 </strong>：<ul><li> 虽然原地变换具有显著的优点，但在某些情况下，它们可能不适合使用。例如，如果算法需要保留原始数据的副本以供后续使用，则无法使用原地变换。</li><li>原地变换算法的正确性通常更加难以验证和调试，因为它们直接修改了原始数据。</li></ul></li></ul><p>总之，“In-Place Transformations”是一种重要的算法设计策略，它可以帮助我们更加有效地利用内存和计算资源，特别是在处理大型数据集或内存受限的环境中。然而，设计原地变换算法需要仔细考虑和精心规划，以确保算法的正确性和效率。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-light collapsed" data-toggle="collapse" href="#collapse-843260ee" role="button" aria-expanded="false" aria-controls="collapse-843260ee">        <div class="fold-arrow">▶</div>Trivial Types      </div>      <div class="fold-collapse collapse" id="collapse-843260ee">        <div class="fold-content">          <p>Trivial types（平凡类型）在 C++ 中是一个重要的概念，特别是在处理对象复制和内存布局时。以下是对 Trivial types 的详细解释：</p><ul><li><strong>定义 </strong>：<ul><li>Trivial types 指的是在内存中表示连续的一片空间，可以像内置类型或者 C 的结构体、联合体一样进行操作的对象。它可以是一个类（class）或结构体（struct）。</li><li> 它拥有编译器生成的默认构造、析构、拷贝构造和赋值运算符，这些函数都是平凡的（即它们没有执行任何额外的操作，仅仅是按照内存布局进行复制或销毁）。</li></ul></li><li><strong>特性 </strong>：<ul><li> 平凡类型的对象可以直接拷贝到 <code>char</code> 或<code>unsigned char</code>数组，然后再拷贝回来，其类型仍然保持不变。这意味着它们可以安全地进行序列化和反序列化。</li><li>平凡类型通常用于需要对数据进行底层操作和通过 <code>memcpy</code> 等内存复制函数进行快速复制的情况。</li></ul></li><li><strong>条件 </strong>：<ul><li> 一个类型要被认为是 Trivial type，它必须满足以下条件：</li><li>有默认构造、析构、拷贝构造、赋值运算符，这些函数可以是编译器自动生成的，也可以是用户显式地通过 <code>default</code> 关键字声明的。</li><li>没有虚函数、虚基类和虚继承。</li></ul></li><li><strong>与其他类型的关系 </strong>：<ul><li>Trivial types 是标准布局类型（Standard Layout Types）的一个子集，它们除了满足标准布局类型的条件外，还需要满足上述的平凡性条件。</li><li>POD（Plain Old Data）类型在 C++11 之前是一个更广泛的概念，它包含了 Trivial types 和标准布局类型。但从 C++11 开始，POD 的概念逐渐被更细致的 Trivial types 和 Standard-Layout types 概念所替代。</li></ul></li><li><strong> 用途 </strong>：<ul><li> 由于其平凡性，Trivial types 在内存管理和对象复制方面提供了很大的灵活性。它们可以直接通过内存操作函数（如 <code>memcpy</code>、<code>memmove</code>）进行复制，而无需考虑对象的内部结构和状态。</li><li> 这种类型在与其他语言或系统交互时特别有用，因为它们具有确定的内存布局和简单的复制语义。</li></ul></li><li><strong>示例 </strong>：<ul><li> 一个只包含基础数据类型（如 <code>int</code>、<code>float</code>）和 / 或平凡类型的数组作为成员的类，可以被视为一个 Trivial type。</li></ul></li></ul><p> 总之，Trivial types 是 C++ 中一个非常重要的概念，它们在内存管理、对象复制以及与其他系统交互等方面具有重要的作用。</p>        </div>      </div>    </div>    <div class="fold">      <div class="fold-title fold-light collapsed" data-toggle="collapse" href="#collapse-c972cc4a" role="button" aria-expanded="false" aria-controls="collapse-c972cc4a">        <div class="fold-arrow">▶</div>Thread Engine      </div>      <div class="fold-collapse collapse" id="collapse-c972cc4a">        <div class="fold-content">          <p>Thread Engine（线程引擎）在计算机科学中是一个负责管理和调度线程执行的组件或系统。它对于实现多线程编程、提高程序并发执行效率至关重要。</p>        </div>      </div>    </div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="日常" scheme="https://silhouettesforyou.github.io/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
    <category term="翻译" scheme="https://silhouettesforyou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="Terminology" scheme="https://silhouettesforyou.github.io/tags/Terminology/"/>
    
  </entry>
  
  <entry>
    <title>Reinforcement Learning II</title>
    <link href="https://silhouettesforyou.github.io/2024/07/16/3c18f3adbff3/"/>
    <id>https://silhouettesforyou.github.io/2024/07/16/3c18f3adbff3/</id>
    <published>2024-07-16T03:24:28.000Z</published>
    <updated>2024-07-30T14:33:14.271Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0036.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0037.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0038.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0039.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0040.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0041.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0042.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0043.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0044.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0045.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0046.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0047.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0048.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0049.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0050.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0051.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0052.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0053.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0054.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0055.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0056.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0057.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0058.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0059.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0060.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0061.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0062.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0063.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0064.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0065.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0066.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0067.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0068.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0069.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0070.jpg" style="width: 100%" alt>    <img src="/2024/07/16/3c18f3adbff3/Reinforcement Learning_page-0071.jpg" style="width: 100%" alt></center>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="强化学习" scheme="https://silhouettesforyou.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RL" scheme="https://silhouettesforyou.github.io/tags/RL/"/>
    
    <category term="数学" scheme="https://silhouettesforyou.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://silhouettesforyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="手写" scheme="https://silhouettesforyou.github.io/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>Reinforcement Learning I</title>
    <link href="https://silhouettesforyou.github.io/2024/07/16/436fe966f14f/"/>
    <id>https://silhouettesforyou.github.io/2024/07/16/436fe966f14f/</id>
    <published>2024-07-16T03:18:55.000Z</published>
    <updated>2024-07-30T14:33:21.259Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0001.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0002.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0003.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0004.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0005.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0006.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0007.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0008.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0009.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0010.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0011.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0012.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0013.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0014.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0015.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0016.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0017.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0018.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0019.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0020.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0021.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0022.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0023.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0024.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0025.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0026.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0027.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0028.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0029.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0030.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0031.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0032.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0033.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0034.jpg" style="width: 100%" alt>    <img src="/2024/07/16/436fe966f14f/Reinforcement Learning_page-0035.jpg" style="width: 100%" alt></center>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="强化学习" scheme="https://silhouettesforyou.github.io/categories/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="RL" scheme="https://silhouettesforyou.github.io/tags/RL/"/>
    
    <category term="数学" scheme="https://silhouettesforyou.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="笔记" scheme="https://silhouettesforyou.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="手写" scheme="https://silhouettesforyou.github.io/tags/%E6%89%8B%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>笔试题</title>
    <link href="https://silhouettesforyou.github.io/2024/07/13/b58e8789ec87/"/>
    <id>https://silhouettesforyou.github.io/2024/07/13/b58e8789ec87/</id>
    <published>2024-07-13T03:58:49.000Z</published>
    <updated>2024-08-05T01:36:44.137Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="反转链表"><a href="# 反转链表" class="headerlink" title="反转链表"></a>反转链表 </h2><p> 描述 <br> 给定一个单链表的头结点 pHead（该头节点是有值的，比如在下图，它的 val 是 1)，长度为 n，反转该链表后，返回新链表的表头。</p><p>数据范围：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="13.048ex" height="1.819ex" role="img" focusable="false" viewbox="0 -666 5767.1 804"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2711.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mn" transform="translate(3767.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container></p><p>要求：空间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，时间复杂度<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。</p><p>如当输入链表 <code>{1, 2, 3}</code> 时，<br>经反转后，原链表变为 <code>{3, 2, 1}</code>，所以对应的输出为<code>{3, 2, 1}</code>。<br> 以上转换过程如下图所示：</p><center>    <img src="/2024/07/13/b58e8789ec87/4A47A0DB6E60853DEDFCFDF08A5CA249.png" style="width: 35%" alt></center><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> *  ListNode(int x) : val(x), next(nullptr) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode 类 </span><br><span class="hljs-comment">     * @return ListNode 类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">ReverseList</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span> || head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> p = head-&gt;next;<br>        head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">while</span> (p) {<br>            <span class="hljs-keyword">auto</span> q = p-&gt;next;<br>            p-&gt;next = head;<br>            head = p;<br>            p = q;<br>        }<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="二叉树遍历"><a href="# 二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><ul><li>前序遍历：根节点、左子节点、右子节点</li><li>中序遍历：左子节点、根节点、右子节点</li><li>后序遍历：左子节点、右子节点、根节点</li></ul><div class="note note-warning">            <p>根据根节点的位置确定遍历的类别</p>          </div><h3 id="前序遍历"><a href="# 前序遍历" class="headerlink" title="前序遍历"></a>前序遍历 </h3><p> 给你二叉树的根节点 root ，返回它节点值的前序遍历。</p><p>数据范围：二叉树的节点数量满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="11.917ex" height="1.819ex" role="img" focusable="false" viewbox="0 -666 5267.1 804"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2711.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mn" transform="translate(3767.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container>，二叉树节点的值满足<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.312ex;" xmlns="http://www.w3.org/2000/svg" width="14.659ex" height="1.882ex" role="img" focusable="false" viewbox="0 -694 6479.1 832"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(777.8,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mi" transform="translate(1833.6,0)"><path data-c="1D463" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/></g><g data-mml-node="mi" transform="translate(2318.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"/></g><g data-mml-node="mi" transform="translate(2847.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mo" transform="translate(3423.3,0)"><path data-c="2264" d="M674 636Q682 636 688 630T694 615T687 601Q686 600 417 472L151 346L399 228Q687 92 691 87Q694 81 694 76Q694 58 676 56H670L382 192Q92 329 90 331Q83 336 83 348Q84 359 96 365Q104 369 382 500T665 634Q669 636 674 636ZM84 -118Q84 -108 99 -98H678Q694 -104 694 -118Q694 -130 679 -138H98Q84 -131 84 -118Z"/></g><g data-mml-node="mn" transform="translate(4479.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(500,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1000,0)"/><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z" transform="translate(1500,0)"/></g></g></g></svg></mjx-container>，树的各节点的值各不相同</p><center>    <img src="/2024/07/13/b58e8789ec87/FE67E09E9BA5661A7AB9DF9638FB1FAC.png" style="width: 10%" alt></center><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode {</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct TreeNode *left;</span><br><span class="hljs-comment"> *  struct TreeNode *right;</span><br><span class="hljs-comment"> *  TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode 类 </span><br><span class="hljs-comment">     * @return int 整型 vector</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        vector&lt;<span class="hljs-type">int</span>&gt; res;<br>        <span class="hljs-keyword">if</span> (!root)<br>            <span class="hljs-keyword">return</span> res;<br>        stack&lt;TreeNode*&gt; container;<br>        container.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span> (!container.<span class="hljs-built_in">empty</span>()) {<br>            <span class="hljs-keyword">auto</span> node = container.<span class="hljs-built_in">top</span>();<br>            res.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            container.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (node-&gt;right) container.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            <span class="hljs-keyword">if</span> (node-&gt;left) container.<span class="hljs-built_in">push</span>(node-&gt;left);<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="合并两个有序数组"><a href="# 合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组 </h2><p> 给你两个按非递减顺序排列的整数数组 <code>nums1</code> 和<code>nums2</code>，另有两个整数 <code>m</code> 和<code>n</code>，分别表示 <code>nums1</code> 和<code>nums2</code>中的元素数目。</p><p>请你合并 <code>nums2</code> 到<code>nums1</code>中，使合并后的数组同样按非递减顺序排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 <code>nums1</code> 中。为了应对这种情况，<code>nums1</code>的初始长度为 <code>m+n</code>，其中前<code>m</code> 个元素表示应合并的元素，后 <code>n</code> 个元素为 <code>0</code>，应忽略。<code>nums2</code> 的长度为<code>n</code>。</p><div class="note note-info">            <p>示例 1：</p><p>输入：<code>nums1=[1,2,3,0,0,0],m=3,nums2=[2,5,6],n=3</code><br>输出：<code>[1,2,2,3,5,6]</code><br>解释：需要合并 <code>[1,2,3]</code> 和<code>[2,5,6]</code>。<br>合并结果是 <code>[1,2,2,3,5,6]</code>，其中斜体加粗标注的为<code>nums1</code> 中的元素。</p>          </div><div class="note note-info">            <p>示例 2：</p><p>输入：<code>nums1=[1],m=1,nums2=[],n=0</code><br>输出：<code>[1]</code><br>解释：需要合并 <code>[1]</code> 和<code>[]</code>。<br>合并结果是<code>[1]</code>。</p>          </div><div class="note note-info">            <p>示例 3：</p><p>输入：<code>nums1=[0],m=0,nums2=[1],n=1</code><br>输出：<code>[1]</code><br>解释：需要合并的数组是 <code>[]</code> 和<code>[1]</code>。<br>合并结果是 <code>[1]</code>。<br> 注意，因为 <code>m=0</code>，所以<code>nums1`` 中没有元素。nums1</code> 中仅存的 <code>0</code> 仅仅是为了确保合并结果可以顺利存放到 <code>nums1</code> 中。</p>          </div><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> p = m + n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span>) {<br>                nums1[p] = nums2[j];<br>                p--;<br>                j--;<br>            }<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums2[j] &gt;= nums1[i]) {<br>                nums1[p] = nums2[j];<br>                p--;<br>                j--;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                <span class="hljs-built_in">swap</span>(nums1[i], nums1[p]);<br>                p--;<br>                i--;<br>            }<br>        }<br>    }<br>};<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, <span class="hljs-type">int</span> m, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, <span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; <span class="hljs-comment">// nums1 的有效部分的最后一个元素的索引</span><br>        <span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; <span class="hljs-comment">// nums2 的最后一个元素的索引</span><br>        <span class="hljs-type">int</span> k = m + n - <span class="hljs-number">1</span>; <span class="hljs-comment">// 合并后数组的最后一个位置的索引</span><br><br>        <span class="hljs-comment">// 从后往前合并</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &gt;= <span class="hljs-number">0</span>) {<br>            <span class="hljs-keyword">if</span> (nums1[i] &gt; nums2[j]) {<br>                nums1[k--] = nums1[i--];<br>            } <span class="hljs-keyword">else</span> {<br>                nums1[k--] = nums2[j--];<br>            }<br>        }<br><br>        <span class="hljs-comment">// 如果 nums2 中还有剩余的元素，继续放入 nums1</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span>) {<br>            nums1[k--] = nums2[j--];<br>        }<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="完全平方数"><a href="# 完全平方数" class="headerlink" title="完全平方数"></a>完全平方数 </h2><p> 给你一个整数 <code>n</code> ，返回 和为 <code>n</code> 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><div class="note note-info">            <p>示例 1：</p><p>输入：n = 12<br>输出：3<br>解释：12 = 4 + 4 + 4</p>          </div><div class="note note-info">            <p>示例 2：</p><p>输入：n = 13<br>输出：2<br>解释：13 = 4 + 9</p>          </div><h3 id="思路及算法"><a href="# 思路及算法" class="headerlink" title="思路及算法"></a>思路及算法 </h3><p> 我们可以依据题目的要求写出状态表达式：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.785ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1673 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1284,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>表示最少需要多少个数的平方来表示整数<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>。</p><p>这些数必然落在区间<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.683ex" height="2.473ex" role="img" focusable="false" viewbox="0 -843 2953.7 1093"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="msqrt" transform="translate(1222.7,0)"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(0,-17)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="600" height="60" x="853" y="723"/></g><g data-mml-node="mo" transform="translate(2675.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>。我们可以枚举这些数，假设当前枚举到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container>，那么我们还需要取若干数的平方，构成<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="5.466ex" height="2.348ex" role="img" focusable="false" viewbox="0 -833.9 2416 1037.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(567.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(1567.4,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>。此时我们发现该子问题和原问题类似，只是规模变小了。这符合了动态规划的要求，于是我们可以写出状态转移方程。</p><p><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -1.996ex;" xmlns="http://www.w3.org/2000/svg" width="23.318ex" height="5.712ex" role="img" focusable="false" viewbox="0 -1642.5 10306.7 2524.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1284,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(1950.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3006.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3728.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="munderover" transform="translate(4729,0)"><g data-mml-node="mo"><path data-c="6D" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"/><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(833,0)"/><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(1111,0)"/></g><g data-mml-node="TeXAtom" transform="translate(236,-637.9) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(412,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1190,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="TeXAtom" transform="translate(409.9,869) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(0,74.9)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="345" height="42.4" x="853" y="832.5"/></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(6562.7,0)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1506.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(2506.4,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,413) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3355,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></g></svg></mjx-container></p><p>其中 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.284ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3661.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(939,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(1439,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2105.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3161.6,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container> 为边界条件，实际上我们无法表示数字 0，只是为了保证状态转移过程中遇到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container> 恰为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.243ex;" xmlns="http://www.w3.org/2000/svg" width="2.71ex" height="2.398ex" role="img" focusable="false" viewbox="0 -952.5 1198 1060"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msqrt"><g transform="translate(853,0)"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(0,92.5)"><path data-c="221A" d="M95 178Q89 178 81 186T72 200T103 230T169 280T207 309Q209 311 212 311H213Q219 311 227 294T281 177Q300 134 312 108L397 -77Q398 -77 501 136T707 565T814 786Q820 800 834 800Q841 800 846 794T853 782V776L620 293L385 -193Q381 -200 366 -200Q357 -200 354 -197Q352 -195 256 15L160 225L144 214Q129 202 113 190T95 178Z"/></g><rect width="345" height="60" x="853" y="832.5"/></g></g></g></svg></mjx-container> 的情况合法。</p><p>同时因为计算 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.785ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1673 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1284,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时所需要用到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.471ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 3744 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1506.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="msup" transform="translate(2506.4,0)"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mn" transform="translate(445,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3355,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的状态仅有，必然小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，因此我们只需要从小到大地枚举<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 来计算 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.785ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1673 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"/></g><g data-mml-node="mo" transform="translate(550,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(939,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1284,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 即可。</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>{<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>            <span class="hljs-type">int</span> minn = INT_MAX;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j * j &lt;= i; j++) {<br>                minn = <span class="hljs-built_in">min</span>(minn, f[i - j * j]);<br>            }<br>            f[i] = minn + <span class="hljs-number">1</span>;<br>        }<br>        <span class="hljs-keyword">return</span> f[n];<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="把数字翻译成字符串"><a href="# 把数字翻译成字符串" class="headerlink" title="把数字翻译成字符串"></a>把数字翻译成字符串 </h2><p> 有一种将字母编码成数字的方式：’a’-&gt;1, ‘b-&gt;2’, … , ‘z-&gt;26’。</p><p>现在给一串数字，返回有多少种可能的译码结果</p><h3 id="思路及算法 -1"><a href="# 思路及算法 -1" class="headerlink" title="思路及算法"></a>思路及算法 </h3><p> 动态规划算法的基本思想是：将待求解的问题分解成若干个相互联系的子问题，先求解子问题，然后从这些子问题的解得到原问题的解；对于重复出现的子问题，只在第一次遇到的时候对它进行求解，并把答案保存起来，让以后再次遇到时直接引用答案，不必重新求解。动态规划算法将问题的解决方案视为一系列决策的结果</p><p>思路：</p><p>对于普通数组 1-9，译码方式只有一种，但是对于 11-19，21-26，译码方式有可选择的两种方案，因此我们使用动态规划将两种方案累计。</p><p>具体做法：</p><p>step 1：用辅助数组 <code>dp</code> 表示前 <code>i</code> 个数的译码方法有多少种。<br>step 2：对于一个数，我们可以直接译码它，也可以将其与前面的 1 或者 2 组合起来译码：如果直接译码，则 <code>dp[i] = dp[i − 1]</code>；如果组合译码，则<code>dp[i] = dp[i − 2]</code>。<br>step 3：对于只有一种译码方式的，选上种<code>dp[i−1]</code> 即可，对于满足两种译码方式（10，20 不能）则是 <code>dp[i − 1] + dp[i − 2]</code><br>step 4：依次相加，最后的<code>dp[length]</code> 即为所求答案。</p><p>图示：</p><center>    <img src="/2024/07/13/b58e8789ec87/00A76CA12306902C5E5628EFD49A6CBC.gif" style="width: 100%" alt></center><h3 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(string nums)</span> </span>{<br>        <span class="hljs-comment">// 排除 0</span><br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-string">"0"</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 排除只有一种可能的 10 和 20</span><br>        <span class="hljs-keyword">if</span>(nums == <span class="hljs-string">"10"</span> || nums == <span class="hljs-string">"20"</span>)  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 当 0 的前面不是 1 或 2 时，无法译码，0 种</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">length</span>(); i++){<br>            <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-string">'0'</span>)<br>                <span class="hljs-keyword">if</span>(nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">'1'</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">'2'</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        }<br>        <span class="hljs-comment">// 辅助数组初始化为 1</span><br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.length() + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;  <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= nums.<span class="hljs-built_in">length</span>(); i++){<br>            <span class="hljs-comment">// 在 11-19，21-26 之间的情况</span><br>            <span class="hljs-keyword">if</span>((nums[i - <span class="hljs-number">2</span>] == <span class="hljs-string">'1'</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] != <span class="hljs-string">'0'</span>) || (nums[i - <span class="hljs-number">2</span>] == <span class="hljs-string">'2'</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &gt; <span class="hljs-string">'0'</span> &amp;&amp; nums[i - <span class="hljs-number">1</span>] &lt; <span class="hljs-string">'7'</span>))<br>               dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">else</span><br>                dp[i] = dp[i - <span class="hljs-number">1</span>];<br>        }<br>        <span class="hljs-keyword">return</span> dp[nums.<span class="hljs-built_in">length</span>()];<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="最小区间"><a href="# 最小区间" class="headerlink" title="最小区间"></a>最小区间 </h2><p> 你有 <code>k</code> 个非递减排列的整数列表。找到一个最小区间，使得 <code>k</code> 个列表中的每个列表至少有一个数包含在其中。</p><p>我们定义如果 <code>b - a &lt; d - c</code> 或者在 <code>b - a == d - c</code> 时<code>a &lt; c</code>，则区间 <code>[a, b]</code> 比<code>[c, d]</code>小。</p><div class="note note-info">            <p>示例 1：</p><p>输入：<code>nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]</code><br>输出：<code>[20,24]</code><br>解释：<br>列表 1：<code>[4, 10, 15, 24, 26]</code>，<code>24</code>在区间 <code>[20,24]</code> 中。<br>列表 2：<code>[0, 9, 12, 20]</code>，<code>20</code>在区间 <code>[20,24]</code> 中。<br>列表 3：<code>[5, 18, 22, 30]</code>，<code>22</code>在区间 <code>[20,24]</code> 中。</p>          </div><div class="note note-info">            <p>示例 2：</p><p>输入：<code>nums = [[1,2,3],[1,2,3],[1,2,3]]</code><br>输出：<code>[1,1]</code></p>          </div><h3 id="思路"><a href="# 思路" class="headerlink" title="思路"></a>思路 </h3><p> 给定 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个列表，需要找到最小区间，使得每个列表都至少有一个数在该区间中。该问题可以转化为，从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个列表中各取一个数，使得这 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个数中的最大值与最小值的差最小。</p><p>假设这 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个数中的最小值是第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个列表中的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container>，对于任意<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex;" xmlns="http://www.w3.org/2000/svg" width="4.73ex" height="2.106ex" role="img" focusable="false" viewbox="0 -716 2090.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(689.8,0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"/></g><g data-mml-node="mi" transform="translate(1745.6,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，设第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container> 个列表中被选为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个数之一的数是 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则为了找到最小区间，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 应该取第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container> 个列表中大于等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container> 的最小的数，这是一个贪心的策略。贪心策略的正确性简单证明如下：假设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.052ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 465 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g></g></g></svg></mjx-container> 也是第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewbox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g></g></g></svg></mjx-container> 个列表中的数，且 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="5.178ex" height="1.686ex" role="img" focusable="false" viewbox="0 -540 2288.6 745"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mo" transform="translate(742.8,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(1798.6,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>，则有<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="13.297ex" height="1.783ex" role="img" focusable="false" viewbox="0 -583 5877.4 788"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g><g data-mml-node="mo" transform="translate(687.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1687.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g><g data-mml-node="mo" transform="translate(2537.2,0)"><path data-c="3E" d="M84 520Q84 528 88 533T96 539L99 540Q106 540 253 471T544 334L687 265Q694 260 694 250T687 235Q685 233 395 96L107 -40H101Q83 -38 83 -20Q83 -19 83 -17Q82 -10 98 -1Q117 9 248 71Q326 108 378 132L626 250L378 368Q90 504 86 509Q84 513 84 520Z"/></g><g data-mml-node="mi" transform="translate(3593,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(4305.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(5305.4,0)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container>，同时包含<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.052ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 465 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D467" d="M347 338Q337 338 294 349T231 360Q211 360 197 356T174 346T162 335T155 324L153 320Q150 317 138 317Q117 317 117 325Q117 330 120 339Q133 378 163 406T229 440Q241 442 246 442Q271 442 291 425T329 392T367 375Q389 375 411 408T434 441Q435 442 449 442H462Q468 436 468 434Q468 430 463 420T449 399T432 377T418 358L411 349Q368 298 275 214T160 106L148 94L163 93Q185 93 227 82T290 71Q328 71 360 90T402 140Q406 149 409 151T424 153Q443 153 443 143Q443 138 442 134Q425 72 376 31T278 -11Q252 -11 232 6T193 40T155 57Q111 57 76 -3Q70 -11 59 -11H54H41Q35 -5 35 -2Q35 13 93 84Q132 129 225 214T340 322Q352 338 347 338Z"/></g></g></g></svg></mjx-container>的区间一定不会小于同时包含 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.464ex;" xmlns="http://www.w3.org/2000/svg" width="1.109ex" height="1.464ex" role="img" focusable="false" viewbox="0 -442 490 647"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container>的区间。因此，其余 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.076ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2243.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(743.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1743.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 个列表中应该取大于等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.294ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 572 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"/></g></g></g></svg></mjx-container> 的最小的数。</p><p>由于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个列表都是升序排列的，因此对每个列表维护一个指针，通过指针得到列表中的元素，指针右移之后指向的元素一定大于或等于之前的元素。</p><p>使用最小堆维护 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个指针指向的元素中的最小值，同时维护堆中元素的最大值。初始时，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>个指针都指向下标 0，最大元素即为所有列表的下标 0 位置的元素中的最大值。每次从堆中取出最小值，根据最大值和最小值计算当前区间，如果当前区间小于最小区间则用当前区间更新最小区间，然后将对应列表的指针右移，将新元素加入堆中，并更新堆中元素的最大值。</p><p>如果一个列表的指针超出该列表的下标范围，则说明该列表中的所有元素都被遍历过，堆中不会再有该列表中的元素，因此退出循环。</p><h3 id="Solution-5"><a href="#Solution-5" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">smallestRange</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; nums)</span> </span>{<br>        <span class="hljs-type">int</span> rangeLeft = <span class="hljs-number">0</span>, rangeRight = INT_MAX;<br>        <span class="hljs-type">int</span> size = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">next</span><span class="hljs-params">(size)</span></span>;<br>        <br>        <span class="hljs-keyword">auto</span> cmp = [&amp;](<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; u, <span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v) {<br>            <span class="hljs-keyword">return</span> nums[u][next[u]] &gt; nums[v][next[v]];<br>        };<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-keyword">decltype</span>(cmp)&gt; <span class="hljs-built_in">pq</span>(cmp);<br>        <span class="hljs-type">int</span> minValue = <span class="hljs-number">0</span>, maxValue = INT_MIN;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) {<br>            pq.<span class="hljs-built_in">emplace</span>(i);<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, nums[i][<span class="hljs-number">0</span>]);<br>        }<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {<br>            <span class="hljs-type">int</span> row = pq.<span class="hljs-built_in">top</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            minValue = nums[row][next[row]];<br>            <span class="hljs-keyword">if</span> (maxValue - minValue &lt; rangeRight - rangeLeft) {<br>                rangeLeft = minValue;<br>                rangeRight = maxValue;<br>            }<br>            <span class="hljs-keyword">if</span> (next[row] == nums[row].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) {<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            ++next[row];<br>            maxValue = <span class="hljs-built_in">max</span>(maxValue, nums[row][next[row]]);<br>            pq.<span class="hljs-built_in">emplace</span>(row);<br>        }<br><br>        <span class="hljs-keyword">return</span> {rangeLeft, rangeRight};<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="Water"><a href="#Water" class="headerlink" title="Water"></a>Water</h2><p>给定四个空杯子，容量分别为 S1 S2 S3 S4，允许进行以下操作：</p><ol><li>将某个杯子接满水</li><li>将某个杯子里的水全部倒掉</li><li>将杯子 A 中的水倒进杯子 B，直到 A 倒空或者 B 被倒满</li></ol><p>问最少要多少步操作才能使得这四个杯子装的水分别为 T1 T2 T3 T4</p><div class="note note-info">            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入例子：<br>0 2 3 4<br>0 1 2 4<br><br>输出例子：<br>6<br><br>例子说明：<br>    (0,0,0,0) -&gt;<br>    (0,2,0,0) -&gt;<br>    (0,2,3,0) -&gt;<br>    (0,2,0,3) -&gt;<br>    (0,0,2,3) -&gt;<br>    (0,2,2,3) -&gt;<br>    (0,1,2,4)<br></code></pre></td></tr></table></figure>          </div><h3 id="Solution-6"><a href="#Solution-6" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">bool</span> mem[<span class="hljs-number">64</span>][<span class="hljs-number">64</span>][<span class="hljs-number">64</span>][<span class="hljs-number">64</span>] = {<span class="hljs-literal">false</span> };<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">equal</span><span class="hljs-params">(<span class="hljs-type">int</span> s[<span class="hljs-number">4</span>], <span class="hljs-type">int</span> T[<span class="hljs-number">4</span>])</span> </span>{<br>    <span class="hljs-keyword">return</span> (s[<span class="hljs-number">0</span>] == T[<span class="hljs-number">0</span>]) &amp;&amp; (s[<span class="hljs-number">1</span>] == T[<span class="hljs-number">1</span>]) &amp;&amp; (s[<span class="hljs-number">2</span>] == T[<span class="hljs-number">2</span>]) &amp;&amp; (s[<span class="hljs-number">3</span>] == T[<span class="hljs-number">3</span>]);<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> S[<span class="hljs-number">4</span>], <span class="hljs-type">int</span> T[<span class="hljs-number">4</span>])</span> </span>{<br>    queue&lt;tuple&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<br>    <span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">make_tuple</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    q.<span class="hljs-built_in">push</span>(x);<br>    mem[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>, cap[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span> };<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) {<br>        <span class="hljs-type">int</span> size = q.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (size--) {<br>            <span class="hljs-built_in">tie</span>(cap[<span class="hljs-number">0</span>], cap[<span class="hljs-number">1</span>], cap[<span class="hljs-number">2</span>], cap[<span class="hljs-number">3</span>]) = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">equal</span>(cap, T)) {<br>                <span class="hljs-keyword">return</span> step;<br>            }<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {<br>                <span class="hljs-keyword">switch</span> (i) {<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-comment">// 将某个杯子倒满</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j){<br>                            tmp = cap[j];<br>                            cap[j] = S[j];<br>                            x = <span class="hljs-built_in">make_tuple</span>(cap[<span class="hljs-number">0</span>], cap[<span class="hljs-number">1</span>], cap[<span class="hljs-number">2</span>], cap[<span class="hljs-number">3</span>]);<br>                            <span class="hljs-keyword">if</span>(!mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]]) {<br>                                mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]] = <span class="hljs-literal">true</span>;<br>                                q.<span class="hljs-built_in">push</span>(x);<br>                            }<br>                            cap[j] = tmp;<br>                        }<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-comment">// 将某个杯子倒空</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, tmp = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>                            tmp = cap[j];<br>                            cap[j] = <span class="hljs-number">0</span>;<br>                            x = <span class="hljs-built_in">make_tuple</span>(cap[<span class="hljs-number">0</span>], cap[<span class="hljs-number">1</span>], cap[<span class="hljs-number">2</span>], cap[<span class="hljs-number">3</span>]);<br>                            <span class="hljs-keyword">if</span>(!mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]]) {<br>                                mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]]=<span class="hljs-literal">true</span>;<br>                                q.<span class="hljs-built_in">push</span>(x);<br>                            }<br>                            cap[j] = tmp;<br>                        }<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-comment">// 将杯子 j 倒向杯子 z</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; ++j) {<br>                            <span class="hljs-type">int</span> tmp1,tmp2,need;<br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> z = <span class="hljs-number">0</span>; z &lt; <span class="hljs-number">4</span>; ++z){<br>                                <span class="hljs-keyword">if</span> (j == z) <span class="hljs-keyword">continue</span>;<br>                                tmp1 = cap[j], tmp2 = cap[z];<br>                                need = <span class="hljs-built_in">min</span>(cap[j], S[z]-cap[z]);<br>                                cap[j] -= need;<br>                                cap[z] += need;<br>                                x = <span class="hljs-built_in">make_tuple</span>(cap[<span class="hljs-number">0</span>], cap[<span class="hljs-number">1</span>], cap[<span class="hljs-number">2</span>], cap[<span class="hljs-number">3</span>]);<br>                                <span class="hljs-keyword">if</span> (!mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]]) {<br>                                    mem[cap[<span class="hljs-number">0</span>]][cap[<span class="hljs-number">1</span>]][cap[<span class="hljs-number">2</span>]][cap[<span class="hljs-number">3</span>]] = <span class="hljs-literal">true</span>;<br>                                    q.<span class="hljs-built_in">push</span>(x);<br>                                }<br>                                cap[j] = tmp1, cap[z] = tmp2;<br>                            }<br>                        }<br>                }<span class="hljs-comment">//end switch</span><br>            }<br>        }<span class="hljs-comment">//end inner while</span><br>        ++step;<br>    }<span class="hljs-comment">//end outer while</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-type">int</span> S[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>}, T[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>};<br>    cin &gt;&gt; S[<span class="hljs-number">0</span>] &gt;&gt; S[<span class="hljs-number">1</span>] &gt;&gt; S[<span class="hljs-number">2</span>] &gt;&gt; S[<span class="hljs-number">3</span>];<br>    cin &gt;&gt; T[<span class="hljs-number">0</span>] &gt;&gt; T[<span class="hljs-number">1</span>] &gt;&gt; T[<span class="hljs-number">2</span>] &gt;&gt; T[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">if</span> (S[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span> &amp;&amp; S[<span class="hljs-number">1</span>] == <span class="hljs-number">0</span> &amp;&amp; S[<span class="hljs-number">2</span>] == <span class="hljs-number">0</span> &amp;&amp; S[<span class="hljs-number">3</span>] == <span class="hljs-number">0</span> &amp;&amp; !<span class="hljs-built_in">equal</span>(S,T)) {<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">bfs</span>(S, T);<br>        cout &lt;&lt; ret &lt;&lt; endl;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="分割后处理"><a href="# 分割后处理" class="headerlink" title="分割后处理"></a>分割后处理 </h2><p> 研究地球空间科学的永强想研究海岸线的长度和海岸线面积之间的关系，为此他找来了很多航拍图像。在航拍图像上利用图像分割的方法，把图像的每个像素标记成陆地（1）和水面（0）。</p><p>示例图片：</p><center>    <img src="/2024/07/13/b58e8789ec87/96701CB32139973F4040BF07981AAB68.jpg" style="width: 50%" alt></center><p>现在永强想知道每张图中陆地部分的面积。</p><p>已知每张图最底部的一条边都是陆地，并且在一张图上陆地都是四邻域联通的。</p><p>但是永强发现分割的结果有很多的噪声，于是他定义了如下规则试图去除噪声：</p><ul><li>如果一个水面区域被陆地包围，则将这个区域记为陆地；</li><li>在 a 的基础上如果一个陆地区域不和底边的陆地相连，那么这是一个岛屿，不计入陆地的面积。</li></ul><div class="note note-info">            <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">输入例子：<br>5 6<br>1 0 0 1 0 0<br>0 0 1 0 1 0<br>1 1 1 1 1 0<br>1 0 0 1 1 1<br>1 1 1 1 1 1<br><br>输出例子：<br>21<br></code></pre></td></tr></table></figure>          </div><h3 id="思路 -1"><a href="# 思路 -1" class="headerlink" title="思路"></a>思路</h3><ul><li><p>从边缘且为水的位置开始遍历，将所有没有被陆地包围的水标记为 2</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1 2 2 1 2 2<br>2 2 1 0 1 2 <br>1 1 1 1 1 2 <br>1 0 0 1 1 1 <br>1 1 1 1 1 1<br></code></pre></td></tr></table></figure></li><li><p>将被陆地包围的水标记为 1（陆地）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1 2 2 1 2 2 <br>2 2 1 1 1 2 <br>1 1 1 1 1 2 <br>1 1 1 1 1 1 <br>1 1 1 1 1 1<br></code></pre></td></tr></table></figure></li><li><p>从下边缘且为陆地的位置开始遍历，标记所有陆地为 3，同时计算面积</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">1 2 2 3 2 2<br>2 2 3 3 3 2 <br>3 3 3 3 3 2 <br>3 3 3 3 3 3 <br>3 3 3 3 3 3<br></code></pre></td></tr></table></figure></li></ul><p>此时岛屿标记为 1，水标记为 2，陆地标记为 3</p><h3 id="Solution-7"><a href="#Solution-7" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">surround</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pic, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= pic.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= pic[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || pic[i][j] == <span class="hljs-number">1</span> || pic[i][j] == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>    pic[i][j] = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>};<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {<br>        <span class="hljs-built_in">surround</span>(pic, i + dx[k], j + dy[k]);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal_area</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; pic, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>{<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= pic.<span class="hljs-built_in">size</span>() || j &lt; <span class="hljs-number">0</span> || j &gt;= pic[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() || pic[i][j] == <span class="hljs-number">2</span> || pic[i][j] == <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span>;<br>    pic[i][j] = <span class="hljs-number">3</span>;<br>    result++;<br>    <span class="hljs-type">int</span> dx[<span class="hljs-number">4</span>] = {<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>};<br>    <span class="hljs-type">int</span> dy[<span class="hljs-number">4</span>] = {<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>};<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) {<br>        <span class="hljs-built_in">cal_area</span>(pic, i + dx[k], j + dy[k]);<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">int</span> m, n;<br>    cin &gt;&gt; m &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">pic</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt; (n, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){<br>            cin &gt;&gt; pic[i][j];<br>        }<br>    }<br>    <span class="hljs-comment">// 1. 从边缘且为水的位置开始遍历，将所有没有被陆地包围的水标记为 2</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){<br>            <span class="hljs-type">bool</span> edge = i == <span class="hljs-number">0</span> || i == m - <span class="hljs-number">1</span> || j == <span class="hljs-number">0</span> || j == n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (pic[i][j] == <span class="hljs-number">0</span> &amp;&amp; edge) {<br>                <span class="hljs-built_in">surround</span>(pic, i, j);<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 2. 将被陆地包围的水标记为 1（陆地）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){<br>            <span class="hljs-keyword">if</span> (pic[i][j] == <span class="hljs-number">0</span>) {<br>                pic[i][j] = <span class="hljs-number">1</span>;<br>            }<br>        }<br>    }<br>    <span class="hljs-comment">// 3. 从下边缘且为陆地的位置开始遍历，标记所有陆地为 3，同时计算面积</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) {<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++){<br>           <span class="hljs-type">bool</span> bottom = i == m - <span class="hljs-number">1</span>;<br>           <span class="hljs-keyword">if</span> (pic[i][j] == <span class="hljs-number">1</span> &amp;&amp; bottom) {<br>               <span class="hljs-built_in">cal_area</span>(pic, i, j);<br>            }<br>        }<br>    }<br>    cout &lt;&lt; result &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="删除有序链表中重复的元素"><a href="# 删除有序链表中重复的元素" class="headerlink" title="删除有序链表中重复的元素"></a>删除有序链表中重复的元素 </h2><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p> 删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次 <br> 例如：<br>给出的链表为 <code>1 → 1 → 2</code>, 返回<code>1 → 2</code><br> 给出的链表为<code>1 → 1 → 2 → 3 → 3</code>, 返回<code>1 → 2 → 3</code></p><h4 id="Solution-8"><a href="#Solution-8" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> * int val;</span><br><span class="hljs-comment"> * struct ListNode *next;</span><br><span class="hljs-comment"> * ListNode(int x) : val(x), next(nullptr) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode 类 </span><br><span class="hljs-comment">     * @return ListNode 类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = p-&gt;next;<br>        <span class="hljs-keyword">while</span> (q) {<br>            <span class="hljs-keyword">if</span> (p-&gt;val == q-&gt;val) {<br>                p-&gt;next = q-&gt;next;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                p = p-&gt;next;<br>            }<br>            q = q-&gt;next;<br>        }<br>        <span class="hljs-keyword">return</span> head;<br>    }<br>};<br></code></pre></td></tr></table></figure><h3 id="II"><a href="#II" class="headerlink" title="II"></a>II</h3><p>给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。<br>例如：<br>给出的链表为 <code>1 → 2 → 3 → 3 → 4 → 4 → 5</code>, 返回<code>1 → 2 → 5</code><br> 给出的链表为<code>1 → 1 → 1 → 2 → 3</code>, 返回<code>2 → 3</code></p><center>    <img src="/2024/07/13/b58e8789ec87/0A01E83A481A4919FAE203E7BB77FDD3.gif" style="width: 100%" alt></center><h4 id="Solution-9"><a href="#Solution-9" class="headerlink" title="Solution"></a>Solution</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct ListNode {</span><br><span class="hljs-comment"> *  int val;</span><br><span class="hljs-comment"> *  struct ListNode *next;</span><br><span class="hljs-comment"> *  ListNode(int x) : val(x), next(nullptr) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param head ListNode 类 </span><br><span class="hljs-comment">     * @return ListNode 类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span> p = head;<br>        <span class="hljs-keyword">auto</span> q = head-&gt;next;<br>        <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">nullptr</span>)<br>            <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-keyword">auto</span>* h = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        h-&gt;next = head;<br>        head = h;<br>        <span class="hljs-keyword">while</span> (q) {<br>            <span class="hljs-keyword">if</span> (p-&gt;val != q-&gt;val) {<br>                h = p;<br>                p = q;<br>                q = q-&gt;next;<br>            }<br>            <span class="hljs-keyword">else</span> {<br>                <span class="hljs-keyword">while</span> (q &amp;&amp; q-&gt;val == p-&gt;val) {<br>                    q = q-&gt;next;<br>                }<br>                h-&gt;next = p = q;<br>                <span class="hljs-keyword">if</span> (q) q = q-&gt;next;<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> head-&gt;next;<br>    }<br>};<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode* head)</span> </span>{<br>        <span class="hljs-comment">// 空链表</span><br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* res = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 在链表前加一个表头</span><br>        res-&gt;next = head; <br>        ListNode* cur = res;<br>        <span class="hljs-keyword">while</span>(cur-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="hljs-literal">NULL</span>){<br>            <span class="hljs-comment">// 遇到相邻两个节点值相同</span><br>            <span class="hljs-keyword">if</span>(cur-&gt;next-&gt;val == cur-&gt;next-&gt;next-&gt;val){<br>                <span class="hljs-type">int</span> temp = cur-&gt;next-&gt;val;<br>                <span class="hljs-comment">// 将所有相同的都跳过</span><br>                <span class="hljs-keyword">while</span> (cur-&gt;next != <span class="hljs-literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;val == temp) <br>                    cur-&gt;next = cur-&gt;next-&gt;next;<br>            }<br>            <span class="hljs-keyword">else</span> <br>                cur = cur-&gt;next;<br>        }<br>        <span class="hljs-comment">// 返回时去掉表头</span><br>        <span class="hljs-keyword">return</span> res-&gt;next; <br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="岛屿数量"><a href="# 岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量 </h2><p> 给一个 01 矩阵，1 代表是陆地，0 代表海洋， 如果两个 1 相邻，那么这两个 1 属于同一个岛。我们只考虑上下左右为相邻。<br>岛屿：相邻陆地可以组成一个岛屿（相邻：上下左右） 判断岛屿个数。<br>例如：<br>输入 <br><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -6.9ex;" xmlns="http://www.w3.org/2000/svg" width="17.724ex" height="14.932ex" role="img" focusable="false" viewbox="0 -3550 7834 6600"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mo"><path data-c="23A1" d="M319 -645V1154H666V1070H403V-645H319Z" transform="translate(0,2396)"/><path data-c="23A3" d="M319 -644V1155H403V-560H666V-644H319Z" transform="translate(0,-2406)"/><svg width="667" height="3202" y="-1351" x="0" viewbox="0 800.5 667 3202"><path data-c="23A2" d="M319 0V602H403V0H319Z" transform="scale(1,7.978)"/></svg></g><g data-mml-node="mtable" transform="translate(667,0)"><g data-mml-node="mtr" transform="translate(0,2800)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,1400)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,0)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-1400)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g><g data-mml-node="mtr" transform="translate(0,-2800)"><g data-mml-node="mtd"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(1500,0)"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="mtd" transform="translate(3000,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(4500,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="mtd" transform="translate(6000,0)"><g data-mml-node="mn"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g><g data-mml-node="mo" transform="translate(7167,0)"><path data-c="23A4" d="M0 1070V1154H347V-645H263V1070H0Z" transform="translate(0,2396)"/><path data-c="23A6" d="M263 -560V1155H347V-644H0V-560H263Z" transform="translate(0,-2406)"/><svg width="667" height="3202" y="-1351" x="0" viewbox="0 800.5 667 3202"><path data-c="23A5" d="M263 0V602H347V0H263Z" transform="scale(1,7.978)"/></svg></g></g></g></g></svg></mjx-container><br> 对应的输出为 3<br>（注：存储的 01 数据其实是字符’0’,’1’)</p><center>    <img src="/2024/07/13/b58e8789ec87/BDDE050B6E9BF2DEF012174FC5D24F61.gif" style="width: 100%" alt></center><h3 id="Solution-10"><a href="#Solution-10" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">size_t</span> height, <span class="hljs-type">size_t</span> width, vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; grid)</span> </span>{<br>        grid[i][j] = <span class="hljs-string">'0'</span>;<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; height &amp;&amp; grid[i + <span class="hljs-number">1</span>][j] == <span class="hljs-string">'1'</span>) {<span class="hljs-built_in">dfs</span>(i + <span class="hljs-number">1</span>, j, height, width, grid); }<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; width &amp;&amp; grid[i][j + <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) {<span class="hljs-built_in">dfs</span>(i, j + <span class="hljs-number">1</span>, height, width, grid); }<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i - <span class="hljs-number">1</span>][j] == <span class="hljs-string">'1'</span>) {<span class="hljs-built_in">dfs</span>(i - <span class="hljs-number">1</span>, j, height, width, grid); }<br>        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; grid[i][j - <span class="hljs-number">1</span>] == <span class="hljs-string">'1'</span>) {<span class="hljs-built_in">dfs</span>(i, j - <span class="hljs-number">1</span>, height, width, grid); }<br>    }<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 判断岛屿数量</span><br><span class="hljs-comment">     * @param grid char 字符型 vector&lt;vector&lt;&gt;&gt; </span><br><span class="hljs-comment">     * @return int 整型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt; &gt;&amp; grid)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> height = grid.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span> (height == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">size_t</span> width = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; height; i++) {<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = <span class="hljs-number">0</span>; j &lt; width; j++) {<br>                <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">'1'</span>) {<br>                    res++;<br>                    <span class="hljs-built_in">dfs</span>(i, j, height, width, grid);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> res;<br>    }<br>};<br></code></pre></td></tr></table></figure><h2 id="判断是不是完全二叉树"><a href="# 判断是不是完全二叉树" class="headerlink" title="判断是不是完全二叉树"></a>判断是不是完全二叉树 </h2><p> 给定一个二叉树，确定他是否是一个完全二叉树。</p><p>完全二叉树的定义：若二叉树的深度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container>，除第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container> 层外，其它各层的结点数都达到最大个数，第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container> 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.303ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 576 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g></g></g></svg></mjx-container> 层可能包含 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.83ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2576.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mn" transform="translate(1222.7,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(1722.7,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"/></g><g data-mml-node="mo" transform="translate(2298.7,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container> 个节点）</p><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2024/07/13/b58e8789ec87/3FDF585A954EFF629B41FD21BA20B0C9.png"></div><div class="group-image-wrap"><img src="/2024/07/13/b58e8789ec87/942721EB3583D230F79D69B3097D3416.png"></div><div class="group-image-wrap"><img src="/2024/07/13/b58e8789ec87/1D0ED443BD0A777690EF55BABCD978D5.png"></div></div></div><h3 id="Solution-11"><a href="#Solution-11" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * struct TreeNode {</span><br><span class="hljs-comment"> * int val;</span><br><span class="hljs-comment"> * struct TreeNode *left;</span><br><span class="hljs-comment"> * struct TreeNode *right;</span><br><span class="hljs-comment"> * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}</span><br><span class="hljs-comment"> * };</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param root TreeNode 类 </span><br><span class="hljs-comment">     * @return bool 布尔型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-comment">// write code here</span><br>        <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; (!root-&gt;left-&gt;left || !root-&gt;left-&gt;right) &amp;&amp; root-&gt;right &amp;&amp; (root-&gt;right-&gt;left || root-&gt;right-&gt;right)) <span class="hljs-comment">// 对应左子树不完全，右子树完全</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (root-&gt;left &amp;&amp; root-&gt;left-&gt;left &amp;&amp; !root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 对应只包含左子节点的情况</span><br>        <span class="hljs-keyword">if</span> (!root-&gt;left &amp;&amp; root-&gt;right) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 正常非完全的情况</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">isCompleteTree</span>(root-&gt;left) &amp;&amp; <span class="hljs-built_in">isCompleteTree</span>(root-&gt;right);<br>    }<br>};<br></code></pre></td></tr></table></figure><center>    <img src="/2024/07/13/b58e8789ec87/07986E476EB2CECD3C5F81D0BCADBE12.gif" style="width: 100%" alt></center><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {<br>  <span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isCompleteTree</span><span class="hljs-params">(TreeNode* root)</span> </span>{<br>        <span class="hljs-comment">// 空树一定是完全二叉树</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">NULL</span>) <br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        queue&lt;TreeNode*&gt; q;<br>        <span class="hljs-comment">// 根节点先访问</span><br>        q.<span class="hljs-built_in">push</span>(root); <br>        <span class="hljs-comment">// 定义一个首次出现的标记位</span><br>        <span class="hljs-type">bool</span> flag = <span class="hljs-literal">false</span>; <br>        <span class="hljs-comment">// 层次遍历</span><br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()){<br>            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) {<br>                TreeNode* cur = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-comment">// 标记第一次遇到空节点</span><br>                <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <br>                    flag = <span class="hljs-literal">true</span>; <br>                <span class="hljs-keyword">else</span>{<br>                    <span class="hljs-comment">// 后续访问已经遇到空节点了，说明经过了叶子</span><br>                    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;left);<br>                    q.<span class="hljs-built_in">push</span>(cur-&gt;right);<br>                }<br>            }<br>        }<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    }<br>};<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="面试" scheme="https://silhouettesforyou.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="LeetCode" scheme="https://silhouettesforyou.github.io/tags/LeetCode/"/>
    
    <category term="牛客网" scheme="https://silhouettesforyou.github.io/tags/%E7%89%9B%E5%AE%A2%E7%BD%91/"/>
    
    <category term="算法题" scheme="https://silhouettesforyou.github.io/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    <category term="动态规划" scheme="https://silhouettesforyou.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="链表" scheme="https://silhouettesforyou.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>满堂花醉三千客，一剑霜寒十四州</title>
    <link href="https://silhouettesforyou.github.io/2024/07/12/4b66769f26f4/"/>
    <id>https://silhouettesforyou.github.io/2024/07/12/4b66769f26f4/</id>
    <published>2024-07-12T06:04:27.000Z</published>
    <updated>2024-08-05T01:36:44.136Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210504_145824.jpg"></div><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210504_154932.jpg"></div><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210504_155105.jpg"></div></div></div><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210101_000016.jpg"></div><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210101_065231.jpg"></div><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210101_071616.jpg"></div></div><div class="group-image-row"><div class="group-image-wrap"><img src="/2024/07/12/4b66769f26f4/IMG_20210101_075135.jpg"></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="相册" scheme="https://silhouettesforyou.github.io/categories/%E7%9B%B8%E5%86%8C/"/>
    
    
    <category term="安徽" scheme="https://silhouettesforyou.github.io/tags/%E5%AE%89%E5%BE%BD/"/>
    
    <category term="台州" scheme="https://silhouettesforyou.github.io/tags/%E5%8F%B0%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>C++ 20 新特性</title>
    <link href="https://silhouettesforyou.github.io/2024/07/11/2ed7adeb8fce/"/>
    <id>https://silhouettesforyou.github.io/2024/07/11/2ed7adeb8fce/</id>
    <published>2024-07-11T10:04:16.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center>    <img src="/2024/07/11/2ed7adeb8fce/teaser-image.png" alt></center><span id="more"></span><h2 id="语言特性"><a href="# 语言特性" class="headerlink" title="语言特性"></a>语言特性 </h2><h3 id="三路比较运算符"><a href="# 三路比较运算符" class="headerlink" title="三路比较运算符"></a> 三路比较运算符 </h3><p> 三路比较运算符表达式的形式为：<code>左操作数 &lt;=&gt; 右操作数</code>，表达式返回一个对象，使得</p><ul><li>若左操作数 <code>&lt;</code> 右操作数则<code>(a &lt;=&gt; b) &lt; 0</code></li><li>若左操作数 <code>&gt;</code> 右操作数则<code>(a &lt;=&gt; b) &gt; 0</code></li><li>而若左操作数和右操作数相等 / 等价则<code>(a &lt;=&gt; b) == 0</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> foo = <span class="hljs-number">-0.0</span>;<br>    <span class="hljs-type">double</span> bar = <span class="hljs-number">0.0</span>;<br> <br>    <span class="hljs-keyword">auto</span> res = foo &lt;=&gt; bar;<br> <br>    <span class="hljs-keyword">if</span> (res &lt; <span class="hljs-number">0</span>)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;-0 小于 0&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (res &gt; <span class="hljs-number">0</span>)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;-0 大于 0&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// (res == 0)</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;-0 与 0 相等 &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="范围 for 中的初始化语句和初始化器"><a href="# 范围 for 中的初始化语句和初始化器" class="headerlink" title="范围 for 中的初始化语句和初始化器"></a>范围 <code>for</code> 中的初始化语句和初始化器 </h3><p> 继 C++ 17 中在 <code>if</code> 和<code>switch</code>语句中添加初始化器后，C++ 20 在范围 <code>for</code> 中也实现了这个功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n = v.<span class="hljs-built_in">size</span>(); <span class="hljs-keyword">auto</span> i : v) <span class="hljs-comment">// 初始化语句（C++20）</span><br>    std::cout &lt;&lt; --n + i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br></code></pre></td></tr></table></figure><h3 id="consteval"><a href="#consteval" class="headerlink" title="consteval"></a><code>consteval</code></h3><p><code>consteval</code>指定函数是立即函数（immediate function），即每次调用该函数必须产生编译时常量。如果不能在编译期间执行，则编译失败</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> n * n;<br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> r = <span class="hljs-built_in">sqr</span>(<span class="hljs-number">100</span>);  <span class="hljs-comment">// OK</span><br> <br><span class="hljs-type">int</span> x = <span class="hljs-number">100</span>;<br><span class="hljs-type">int</span> r2 = <span class="hljs-built_in">sqr</span>(x);  <span class="hljs-comment">// 错误：调用不产生常量</span><br> <br><span class="hljs-function"><span class="hljs-keyword">consteval</span> <span class="hljs-type">int</span> <span class="hljs-title">sqrsqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqr</span>(<span class="hljs-built_in">sqr</span>(n)); <span class="hljs-comment">// 在此点非常量表达式，但是 OK</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">dblsqr</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * <span class="hljs-built_in">sqr</span>(n); <span class="hljs-comment">// 错误：外围函数并非 consteval 且 sqr(n) 不是常量</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="constint"><a href="#constint" class="headerlink" title="constint"></a><code>constint</code></h3><p><code>constinit</code>断言变量拥有静态初始化，即零初始化与常量初始化，否则程序非良构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">g</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dynamic initialization&quot;</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-type">bool</span> p)</span> </span>&#123; <span class="hljs-keyword">return</span> p ? <span class="hljs-string">&quot;constant initializer&quot;</span> : <span class="hljs-built_in">g</span>(); &#125;<br> <br><span class="hljs-keyword">constinit</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> *c = <span class="hljs-built_in">f</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// OK</span><br><span class="hljs-comment">// constinit const char *d = f(false); // 错误</span><br></code></pre></td></tr></table></figure><h3 id="概念（concepts）"><a href="# 概念（concepts）" class="headerlink" title="概念（concepts）"></a>概念（concepts）</h3><p>概念（concepts）就是一种编译时谓词，指出一个或多个类型应如何使用，其能用于进行模板实参的编译时校验，以及基于类型属性的函数派发。</p><p>例如在老版本的 C++，如果想要定义一个只针对某个类型的函数模板，就只能通过类型萃取机制如 <code>enable_if_t</code> 写一些又臭又长的代码。例如想声明一个只针对整数的函数模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mod</span><span class="hljs-params">(std::<span class="hljs-type">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt;, T&gt; d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> d % <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果约束条件简单还行，但是如果条件复杂，则代码就会又臭又长，且难以进行复用。而在 C++ 20 中引入了 concepts，此时我们就可以用 concepts 来指定函数类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-keyword">concept</span> integral = std::is_integral_v&lt;T&gt;;<br> <br><span class="hljs-keyword">template</span> &lt;integral T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">mod</span><span class="hljs-params">(T d)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> d % <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="约束"><a href="# 约束" class="headerlink" title="约束"></a>约束 </h3><p> 约束是逻辑操作和操作数的序列，它了指定对模板实参的要求。它们可以在 <code>requires</code> 表达式中出现，也可以直接作为概念的主体。例如这里使用 <code>requires</code> 约束表达式写一个针对 utf-8 的 <code>string</code> 的约束类型<code>u8string_t</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> <span class="hljs-type">u8string_t</span> = <span class="hljs-built_in">requires</span> (T t)<br>&#123;<br>    t += <span class="hljs-string">u8&quot;&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>接着以这个约束类型声明一个模板函数 <code>print</code>，此时只能能够满足<code>u8string_t</code> 约束的类型才能够匹配当前模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-type">u8string_t</span> T&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">print</span><span class="hljs-params">(T t)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; t &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时以不同类型的 <code>string</code> 来尝试调用，此时只有 <code>u8string</code> 调用成功</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string str;<br>    u8string str_u8;<br>    u16string str_u16;<br>    u32string str_u32;<br><br>    <span class="hljs-built_in">print</span>(str);     <span class="hljs-comment">// 调用失败</span><br>    <span class="hljs-built_in">print</span>(str_u8);  <span class="hljs-comment">// 调用成功</span><br>    <span class="hljs-built_in">print</span>(str_u16); <span class="hljs-comment">// 调用失败</span><br>    <span class="hljs-built_in">print</span>(str_u32); <span class="hljs-comment">// 调用失败</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="协程"><a href="# 协程" class="headerlink" title="协程"></a>协程 </h3><p> 协程是能暂停执行以在之后恢复的函数。协程是无栈的：它们通过返回到调用方暂停执行，并且从栈分离存储恢复执行需要的数据。这样就可以编写异步执行的顺序代码（例如不使用显式的回调来处理非阻塞 I/O），还支持对惰性计算的无限序列上的算法及其他用途</p><p>如果函数的定义进行了下列操作之一，那么它是协程：</p><ul><li><code>co_await</code> 暂停执行，直到恢复</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">task&lt;&gt; <span class="hljs-built_in">tcp_echo_server</span>() &#123;<br>  <span class="hljs-type">char</span> data[<span class="hljs-number">1024</span>];<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    std::<span class="hljs-type">size_t</span> n = <span class="hljs-keyword">co_await</span> socket.<span class="hljs-built_in">async_read_some</span>(<span class="hljs-built_in">buffer</span>(data));<br>    <span class="hljs-function"><span class="hljs-keyword">co_await</span> <span class="hljs-title">async_write</span><span class="hljs-params">(socket, buffer(data, n))</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>co_yield</code> 暂停执行并返回一个值（协程无法<code>return</code>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">generator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">iota</span><span class="hljs-params">(<span class="hljs-type">int</span> n = <span class="hljs-number">0</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    <span class="hljs-keyword">co_yield</span> n++;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>co_return</code>完成执行并返回一个值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">lazy&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">co_return</span> <span class="hljs-number">7</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：协程不能使用变长实参，普通的 <code>return</code> 语句，或占位符返回类型（<code>auto</code>或 <code>Concept</code>）。<code>constexpr</code>函数、构造函数、析构函数及 <code>main</code> 函数不能是协程</p></blockquote><h3 id="模块"><a href="# 模块" class="headerlink" title="模块"></a>模块</h3><p>C++ 20 中正式引入了模块的概念，模块是一个用于在翻译单元间分享声明和定义的语言特性。它们可以在某些地方替代使用头文件。其主要优点如下：</p><ul><li>没有头文件</li><li>声明实现仍然可分离，但非必要</li><li>可以显式指定导出哪些类或函数</li><li>不需要头文件重复引入宏（<code>include guards</code>）</li><li>模块之间名称可以相同，并且不会冲突</li><li>模块只处理一次，编译更快（头文件每次引入都需要处理，需要通过 <code>pragma once</code> 约束）</li><li>预处理宏只在模块内有效</li><li>模块的引入与引入顺序无关</li></ul><h4 id="创建模块"><a href="# 创建模块" class="headerlink" title="创建模块"></a>创建模块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// helloworld.cpp</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">module</span> helloworld;  <span class="hljs-comment">// 模块声明</span><br><span class="hljs-keyword">import</span> &lt;iostream&gt;;         <span class="hljs-comment">// 导入声明</span><br> <br><span class="hljs-function"><span class="hljs-keyword">export</span> <span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;      <span class="hljs-comment">// 导出声明</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="导入模块"><a href="# 导入模块" class="headerlink" title="导入模块"></a>导入模块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// main.cpp</span><br><span class="hljs-keyword">import</span> helloworld;  <span class="hljs-comment">// 导入声明</span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">hello</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="库特性"><a href="# 库特性" class="headerlink" title="库特性"></a>库特性 </h2><h3 id="format"><a href="#format" class="headerlink" title="format"></a><code>format</code></h3><p> 文本格式化库提供 <code>printf</code> 函数族的安全且可扩展的替用品。有意使之补充既存的 C++ I/O 流库并复用其基础设施，例如对用户定义类型重载的流插入运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string message = std::format(<span class="hljs-string">&quot;The answer is &#123;&#125;.&quot;</span>, <span class="hljs-number">42</span>);<br>osyncstream<br><span class="hljs-keyword">template</span>&lt;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharT</span>,<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Traits</span> = std::char_traits&lt;CharT&gt;,<br>    <span class="hljs-keyword">class</span> Allocator = std::allocator&lt;CharT&gt;<br>&gt; <span class="hljs-keyword">class</span> basic_osyncstream: <span class="hljs-keyword">public</span> std::basic_ostream&lt;CharT, Traits&gt;<br></code></pre></td></tr></table></figure><p>类模板 <code>std::basic_osyncstream</code> 是<code>std::basic_syncbuf</code>的便利包装。它提供机制以同步写入同一流的线程（主要用于解决 <code>std::cout</code> 线程不安全问题）</p><p>用法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">&#123;<br>    <span class="hljs-function">std::osyncstream <span class="hljs-title">sync_out</span><span class="hljs-params">(std::cout)</span></span>; <span class="hljs-comment">// std::cout 的同步包装</span><br>    sync_out &lt;&lt; <span class="hljs-string">&quot;Hello, &quot;</span>;<br>    sync_out &lt;&lt; <span class="hljs-string">&quot;World!&quot;</span>;<br>    sync_out &lt;&lt; std::endl; <span class="hljs-comment">// 注意有冲入，但仍未进行</span><br>    sync_out &lt;&lt; <span class="hljs-string">&quot;and more!\n&quot;</span>;<br>&#125; <span class="hljs-comment">// 转移字符并冲入 std::cout</span><br></code></pre></td></tr></table></figure><h3 id="span"><a href="#span" class="headerlink" title="span"></a><code>span</code></h3><p><code>span</code>是对象的连续序列上的无所有权视图。其所描述的对象能指代对象的相接序列，序列的首元素在零位置。<code>span</code>能拥有静态长度，该情况下序列中的元素数已知并编码于类型中，或拥有动态长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;span&gt;</span></span><br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, std::<span class="hljs-type">size_t</span> N&gt; [[nodiscard]]<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> <span class="hljs-title">slide</span><span class="hljs-params">(std::span&lt;T,N&gt; s, std::<span class="hljs-type">size_t</span> offset, std::<span class="hljs-type">size_t</span> width)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">subspan</span>(offset, offset + width &lt;= s.<span class="hljs-built_in">size</span>() ? width : <span class="hljs-number">0U</span>);<br>&#125;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, std::<span class="hljs-type">size_t</span> N, std::<span class="hljs-type">size_t</span> M&gt; [[nodiscard]]<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">starts_with</span><span class="hljs-params">(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; prefix)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>() &gt;= prefix.<span class="hljs-built_in">size</span>() <br>        &amp;&amp; std::<span class="hljs-built_in">equal</span>(prefix.<span class="hljs-built_in">begin</span>(), prefix.<span class="hljs-built_in">end</span>(), data.<span class="hljs-built_in">begin</span>());<br>&#125;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, std::<span class="hljs-type">size_t</span> N, std::<span class="hljs-type">size_t</span> M&gt; [[nodiscard]]<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">ends_with</span><span class="hljs-params">(std::span&lt;T,N&gt; data, std::span&lt;T,M&gt; suffix)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> data.<span class="hljs-built_in">size</span>() &gt;= suffix.<span class="hljs-built_in">size</span>() <br>        &amp;&amp; std::<span class="hljs-built_in">equal</span>(data.<span class="hljs-built_in">end</span>() - suffix.<span class="hljs-built_in">size</span>(), data.<span class="hljs-built_in">end</span>(), <br>                      suffix.<span class="hljs-built_in">end</span>() - suffix.<span class="hljs-built_in">size</span>());<br>&#125;<br> <br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, std::<span class="hljs-type">size_t</span> N, std::<span class="hljs-type">size_t</span> M&gt; [[nodiscard]]<br><span class="hljs-function"><span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">contains</span><span class="hljs-params">(std::span&lt;T,N&gt; span, std::span&lt;T,M&gt; sub)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">search</span>(span.<span class="hljs-built_in">begin</span>(), span.<span class="hljs-built_in">end</span>(), sub.<span class="hljs-built_in">begin</span>(), sub.<span class="hljs-built_in">end</span>()) != span.<span class="hljs-built_in">end</span>();<br><span class="hljs-comment">//  return std::ranges::search(span, sub).begin() != span.end();</span><br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; seq)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; elem : seq) std::cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> a[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br>    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> b[] &#123; <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span> &#125;;<br> <br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> offset&#123;&#125;; ; ++offset) &#123;<br>        <span class="hljs-keyword">constexpr</span> std::<span class="hljs-type">size_t</span> width&#123;<span class="hljs-number">6</span>&#125;;<br>        <span class="hljs-keyword">auto</span> s = <span class="hljs-built_in">slide</span>(std::span&#123;a&#125;, offset, width);<br>        <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-built_in">print</span>(s);<br>    &#125;<br> <br>    <span class="hljs-built_in">static_assert</span>(<span class="hljs-built_in">starts_with</span>(std::span&#123;a&#125;, std::span&#123;a,<span class="hljs-number">4</span>&#125;)<br>        &amp;&amp; <span class="hljs-built_in">starts_with</span>(std::span&#123;a+<span class="hljs-number">1</span>, <span class="hljs-number">4</span>&#125;, std::span&#123;a+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)<br>        &amp;&amp; !<span class="hljs-built_in">starts_with</span>(std::span&#123;a&#125;, std::span&#123;b&#125;)<br>        &amp;&amp; !<span class="hljs-built_in">starts_with</span>(std::span&#123;a,<span class="hljs-number">8</span>&#125;, std::span&#123;a+<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;)<br>        &amp;&amp; <span class="hljs-built_in">ends_with</span>(std::span&#123;a&#125;, std::span&#123;a+<span class="hljs-number">6</span>,<span class="hljs-number">3</span>&#125;)<br>        &amp;&amp; !<span class="hljs-built_in">ends_with</span>(std::span&#123;a&#125;, std::span&#123;a+<span class="hljs-number">6</span>,<span class="hljs-number">2</span>&#125;)<br>        &amp;&amp; <span class="hljs-built_in">contains</span>(std::span&#123;a&#125;, std::span&#123;a+<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;)<br>        &amp;&amp; !<span class="hljs-built_in">contains</span>(std::span&#123;a,<span class="hljs-number">8</span>&#125;, std::span&#123;a,<span class="hljs-number">9</span>&#125;));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="endian"><a href="#endian" class="headerlink" title="endian"></a><code>endian</code></h3><p><code>endian</code>主要用于判断当前机器是大端还是小端（之前只能通过整型截断或者 <code>union</code> 判断，较为麻烦）</p><ul><li>若所有标量类型均为小端，则 <code>std::endian::native</code> 等于<code>std::endian::little</code></li><li>若所有标量类型均为大端，则 <code>std::endian::native</code> 等于<code>std::endian::big</code></li><li>若所有标量类型拥有等于 1 的 <code>sizeof</code>，则端序无影响，且<code>std::endian::little</code>，<code>std::endian::big</code> 及<code>std::endian::native</code>三个值相同</li><li>若平台使用混合端序，则 <code>std::endian::native</code> 既不等于 <code>std::endian::big</code> 亦不等于<code>std::endian::little</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bit&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::endian::native == std::endian::big)</span></span><br><span class="hljs-function">        std::cout &lt;&lt; &quot;big-endian\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">constexpr</span> (std::endian::native == std::endian::little)<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;little-endian\n&quot;</span>;<br>    <span class="hljs-keyword">else</span> std::cout &lt;&lt; <span class="hljs-string">&quot;mixed-endian\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jthread"><a href="#jthread" class="headerlink" title="jthread"></a><code>jthread</code></h3><p><code>jthread</code>即是通过 RAII 机制封装的 <code>thread</code>，其会在析构时自动调用<code>join</code> 防止线程 crash。同时其也是可中断的，可以搭配这些中断线程执行的相关类使用：</p><ul><li><code>stop_token</code>：查询线程是否中断</li><li><code>stop_source</code>：请求线程停止运行</li><li><code>stop_callback</code>：<code>stop_token</code>执行时，可以触发的回调函数</li></ul><h3 id="semaphore"><a href="#semaphore" class="headerlink" title="semaphore"></a>semaphore</h3><p>信号量是一个轻量级的同步原语，可用来实现任何其他同步概念如 <code>mutex</code>、<code>shared_mutex</code>、<code>latches</code>、<code>barriers</code> 等</p><p>根据 <code>LeastMaxValue</code> 不同，主要分为两种：</p><ul><li><code>counting_semaphore</code>（多元信号量）：<code>counting_semaphore</code>允许同一资源有多于一个同时访问，至少允许 <code>LeastMaxValue</code> 个同时的访问者</li><li><code>binary_semaphore</code>（二元信号量）：是 <code>counting_semaphore</code> 的特化的别名，其 <code>LeastMaxValue</code> 为 1 。实现可能将 <code>binary_semaphore</code> 实现得比 <code>counting_semaphore</code> 的默认实现更高效</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全局二元信号量实例</span><br><span class="hljs-comment">// 设置对象计数为零</span><br><span class="hljs-comment">// 对象在未被发信状态</span><br><span class="hljs-function">std::binary_semaphore <span class="hljs-title">smphSignal</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ThreadProc</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 通过尝试减少信号量的计数等待来自主程序的信号</span><br>    smphSignal.<span class="hljs-built_in">acquire</span>();<br> <br>    <span class="hljs-comment">// 此调用阻塞直至信号量的计数被从主程序增加</span><br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[thread] Got the signal&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 回应消息</span><br> <br>    <span class="hljs-comment">// 等待 3 秒以模仿某种线程正在进行的工作</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">3</span>s);<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[thread] Send the signal\n&quot;</span>; <span class="hljs-comment">// 消息</span><br> <br>    <span class="hljs-comment">// 对主程序回复发信</span><br>    smphSignal.<span class="hljs-built_in">release</span>();<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建某个背景工作线程，它将长期存在</span><br>    <span class="hljs-function">std::jthread <span class="hljs-title">thrWorker</span><span class="hljs-params">(ThreadProc)</span></span>;<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[main] Send the signal\n&quot;</span>; <span class="hljs-comment">// 消息</span><br> <br>    <span class="hljs-comment">// 通过增加信号量的计数对工作线程发信以开始工作</span><br>    smphSignal.<span class="hljs-built_in">release</span>();<br> <br>    <span class="hljs-comment">// release() 后随 acquire() 可以阻止工作线程获取信号量，所以添加延迟：</span><br>    std::this_thread::<span class="hljs-built_in">sleep_for</span>(<span class="hljs-number">50</span>ms);<br> <br>    <span class="hljs-comment">// 通过试图减少信号量的计数等待直至工作线程完成工作</span><br>    smphSignal.<span class="hljs-built_in">acquire</span>();<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;[main] Got the signal\n&quot;</span>; <span class="hljs-comment">// 回应消息</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="latch"><a href="#latch" class="headerlink" title="latch"></a><code>latch</code></h3><p><code>latch</code>是 <code>std::ptrdiff_t</code> 类型的向下计数器，它能用于同步线程。在创建时初始化计数器的值。其主要有以下特点：</p><ul><li>线程可能在 latch 上阻塞直至计数器减少到零。没有可能增加或重置计数器，这使得 latch 为单次使用的屏障</li><li>同时调用 latch 的成员函数，除了析构函数，不引入数据竞争</li><li>不同于 <code>std::barrier</code>，参与线程能减少<code>std::latch</code> 多于一次</li></ul><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a><code>barrier</code></h3><p>类模板 <code>barrier</code> 提供允许至多为期待数量的线程阻塞直至期待数量的线程到达该屏障。不同于 <code>latch</code>，屏障可重用：一旦到达的线程从屏障阶段的同步点除阻，则可重用同一屏障。屏障对象的生存期由屏障阶段的序列组成。每个阶段定义一个阶段同步点。在阶段中到达屏障的线程能通过调用<code>wait</code> 在阶段同步点上阻塞，而且将保持阻塞直至运行阶段完成步骤</p><p>屏障阶段由以下步骤组成：</p><ul><li>每次调用 <code>arrive</code> 或<code>arrive_and_drop</code>减少期待计数</li><li>期待计数抵达零时，运行阶段完成步骤。完成步骤调用完成函数对象，并除阻所有在阶段同步点上阻塞的线程。完成步骤的结束强先发生于所有从完成步骤所除阻的调用的返回<ul><li>对于特化 <code>std::barrier&lt;&gt;</code>（使用默认模板实参），完成步骤作为对<code>arrive</code> 或<code>arrive_and_drop</code>的导致期待计数抵达零的调用的一部分运行</li><li>对于其他特化，完成步骤在该阶段期间到达屏障的线程之一上运行。而若在完成步骤中调用屏障对象的 <code>wait</code> 以外的成员函数，则行为未定义</li></ul></li><li>完成步骤结束时，重置期待计数为构造中指定的值，可能为 <code>arrive_and_drop</code> 调用所调整，并开始下一阶段</li></ul><p>同时调用 <code>barrier</code> 的成员函数，除了析构函数，不引入数据竞争</p><h3 id="位运算库"><a href="# 位运算库" class="headerlink" title="位运算库"></a>位运算库 </h3><p><code>bit</code> 库封装了一些常用的位操作。包括：</p><p><code>bit_cast</code>：将一个类型的对象表示重解释为另一类型的对象表示<br><code>byteswap</code>：反转给定整数值中的字节<br><code>has_single_bit</code>：检查一个数是否为二的整数次幂<br><code>bit_ceil</code>：寻找不小于给定值的最小的二的整数次幂<br><code>bit_floor</code>：寻找不大于给定值的最大的二的整数次幂<br><code>bit_width</code>：寻找表示给定值所需的最小位数<br><code>rotl</code>：计算逐位左旋转的结果<br><code>rotr</code>：计算逐位右旋转的结果<br><code>countl_zero</code>：从最高位起计量连续的 0 位的数量<br><code>countl_one</code>：从最高位起计量连续的 1 位的数量<br><code>countr_zero</code>：从最低位起计量连续的 0 位的数量<br><code>countr_one</code>：从最低位起计量连续的 1 位的数量<br><code>popcount</code>：计量无符号整数中为 1 的位的数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> std &#123;<br>  <span class="hljs-comment">// bit_­cast</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> To, <span class="hljs-keyword">class</span> From&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> To <span class="hljs-title">bit_cast</span><span class="hljs-params">(<span class="hljs-type">const</span> From&amp; from)</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>  <span class="hljs-comment">// 位交换</span><br>  <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>  <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">byteswap</span> <span class="hljs-params">(T value)</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>  <span class="hljs-comment">// 2 的整数次幂</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> <span class="hljs-title">has_single_bit</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> T <span class="hljs-title">bit_ceil</span><span class="hljs-params">(T x)</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> T <span class="hljs-title">bit_floor</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> T <span class="hljs-title">bit_width</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>  <span class="hljs-comment">// 旋转</span><br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">rotl</span><span class="hljs-params">(T x, <span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword">constexpr</span> T <span class="hljs-title">rotr</span><span class="hljs-params">(T x, <span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>  <span class="hljs-comment">// 计数</span><br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">countl_zero</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">countl_one</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">countr_zero</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">countr_one</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br>  <span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> T&gt;</span><br><span class="hljs-function">    <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> <span class="hljs-title">popcount</span><span class="hljs-params">(T x)</span> <span class="hljs-keyword">noexcept</span></span>;<br> <br>  <span class="hljs-comment">// 端序</span><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">endian</span> &#123;<br>    little = <span class="hljs-comment">/* 见描述 */</span>,<br>    big    = <span class="hljs-comment">/* 见描述 */</span>,<br>    native = <span class="hljs-comment">/* 见描述 */</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ranges"><a href="#ranges" class="headerlink" title="ranges"></a><code>ranges</code></h3><p><code>ranges</code>提供处理元素范围的组件，包括各种视图适配器。其最大的作用就是让我们可以像组装函数一样组装算法，使代码更加高效、便利、可读。提供命名空间别名 <code>std::views</code>，作为<code>std::ranges::views</code> 的缩写</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ranges&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">const</span> ints = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-keyword">auto</span> even = [](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> == i % <span class="hljs-number">2</span>; &#125;;<br>    <span class="hljs-keyword">auto</span> square = [](<span class="hljs-type">int</span> i) &#123; <span class="hljs-keyword">return</span> i * i; &#125;;<br> <br>    <span class="hljs-comment">// 组合视图的“管道”语法：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : ints | std::views::<span class="hljs-built_in">filter</span>(even) | std::views::<span class="hljs-built_in">transform</span>(square)) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br> <br>    std::cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br> <br>    <span class="hljs-comment">// 传统的“函数式”组合语法：</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : std::views::<span class="hljs-built_in">transform</span>(std::views::<span class="hljs-built_in">filter</span>(ints, even), square)) &#123;<br>        std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;center&gt;
    &lt;img src=&quot;/2024/07/11/2ed7adeb8fce/teaser-image.png&quot; alt&gt;
&lt;/center&gt;</summary>
    
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
    <category term="C++ 20" scheme="https://silhouettesforyou.github.io/tags/C-20/"/>
    
    <category term="Modern C++" scheme="https://silhouettesforyou.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL with Xmake</title>
    <link href="https://silhouettesforyou.github.io/2024/06/20/355478969c9d/"/>
    <id>https://silhouettesforyou.github.io/2024/06/20/355478969c9d/</id>
    <published>2024-06-20T13:32:21.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center>    <img src="/2024/06/20/355478969c9d/opengl-libraries.png" alt></center><span id="more"></span><h3 id="目录结构"><a href="# 目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">|-- dependence<br>    |-- glew-2.1.0<br>    |-- glfw-3.4.bin.WIN32<br>    |-- glfw-3.4.bin.WIN64<br>        |-- include<br>        |-- ...<br>        |-- lib-static-ucrt<br>            |-- glfw3.dll<br>            |-- glfw3dll.dll<br>|-- src<br>    |-- HelloOpenGl.cpp<br>|-- xmake.lua<br></code></pre></td></tr></table></figure><h3 id="xmake- 配置"><a href="#xmake- 配置" class="headerlink" title="xmake 配置"></a>xmake 配置</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs lua">set_project(<span class="hljs-string">&quot;OpenGL Tutorial&quot;</span>)<br>add_rules(<span class="hljs-string">&quot;mode.debug&quot;</span>, <span class="hljs-string">&quot;mode.release&quot;</span>)<br><br>target(<span class="hljs-string">&quot;HelloOpenGL&quot;</span>)<br>    set_kind(<span class="hljs-string">&quot;binary&quot;</span>)<br>    add_files(<span class="hljs-string">&quot;src/*.cpp&quot;</span>)<br>    add_includedirs(<span class="hljs-string">&quot;/dependence/glfw-3.4.bin.WIN64/include&quot;</span>) <span class="hljs-comment">-- include 文件</span><br>    add_includedirs(<span class="hljs-string">&quot;/dependence/glew-2.1.0/include&quot;</span>)<br>    add_linkdirs(<span class="hljs-string">&quot;/dependence/glfw-3.4.bin.WIN64/lib-static-ucrt&quot;</span>) <span class="hljs-comment">-- gcc 编译的静态链接库目录</span><br>    add_linkdirs(<span class="hljs-string">&quot;/dependence/glew-2.1.0/lib/Release/Win32&quot;</span>)<br>    add_linkdirs(<span class="hljs-string">&quot;/dependence/glew-2.1.0/bin/Release/x64&quot;</span>)<br>    add_links(<span class="hljs-string">&quot;glfw3dll&quot;</span>, <span class="hljs-string">&quot;glew32&quot;</span>) <span class="hljs-comment">-- 链接 glfw 和 glew</span><br>    add_syslinks(<span class="hljs-string">&quot;opengl32&quot;</span>) <span class="hljs-comment">-- 链接系统库</span><br></code></pre></td></tr></table></figure><h3 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h3><ul><li>顶点着色器<ul><li>每个顶点运行一次</li><li>确定位置</li></ul></li><li>片段 / 像素着色器<ul><li>填充三角形的每个像素计算一次</li></ul></li><li>为什么索引缓冲是 <code>unsigned int</code> 无符号的</li><li>错误处理<ul><li><code>glGetError</code></li><li>宏定义</li></ul></li><li>uniform 变量</li><li>VAO vertex array object<ul><li>当空间中有多个对象、网格、顶点缓冲区等，每个都要进行绑定着色器、<strong>绑定顶点缓冲区 </strong>、<strong> 设置顶点布局 </strong>、<strong> 绑定索引缓冲区</strong>、调用 DrawCall 进行绘制</li><li>绑定顶点缓冲区之后还要声明顶点缓冲区的布局，不同的顶点缓冲区有不同的布局</li><li>实际上都是和 VAO 有关系</li><li>VAO 它将所有顶点绘制过程中的这些设置和绑定过程集中存储在一起</li><li>VAO 是否生效由配置文件类型决定的 The compalibility profile makes VAO object 0 a default object. The core OpenGL profile makes VAO object 0 not an object at all</li><li>什么时候使用 VAO<ul><li>如果使用核心配置，就必须使用自定义的 VAO</li><li>如果只使用兼容性配置，有一个默认的 VAO</li></ul></li></ul></li><li>着色器处理的步骤<ul><li>传入文件或者字符串，可以编译为着色器</li><li>绑定和解绑着色器</li><li>可以设置着色器中的不同的<code>uniform</code></li></ul></li><li>渲染器类<ul><li>调用 Draw Call 时需要顶点数组、索引缓冲区、着色器</li><li>解绑不是必要的，解绑只会浪费性能</li><li>正常会用材质替换着色器</li></ul></li><li>如何通过 OpenGL 将硬盘中的 png 图片显示到屏幕上（png 并不是引擎直接使用的格式，大多数引擎都有自己的纹理格式）<ul><li>将图像加载到内存中——<code>stb_image</code></li><li>获取像素的数组，然后传到显存中——OpenGL</li><li>通过着色器来读取纹理，并计算出真正的像素值——像素 / 片段着色器（绑定纹理）</li><li>在 OpenGL 中，用 slots 来绑定纹理，可以一次性绑定多个纹理<ul><li>在 Windows 上有 32 个 slots</li><li>在移动设备，Android 或 IOS 上可能会有 8 个 slots</li></ul></li><li>OpenGL 加载纹理是从左下角开始，即左下角的坐标是<code>(0, 0)</code>，正常加载的图片是从左上角开始遍历，所以加载图片后需要垂直翻转</li><li>纹理坐标<ul><li>指定每个顶点对应的纹理是什么，根据顶点对应的 <strong> 纹理坐标 </strong> 进行采样</li><li>片段着色器会根据要渲染的像素的位置，进行插值计算具体的颜色值</li></ul></li></ul></li><li>混合<ul><li>Blending determies how we combine our output color with what is already in our target buffer<ul><li>Output: the color we output from our fragment shader 从片段着色器中输出的颜色 <strong>SRC</strong></li><li>Target buffer: the buffer our fragment shader is drawing to 已经存在的缓冲区上的颜色 <strong>DEST</strong></li></ul></li><li>如何控制混合<ul><li><code>glEnable</code>、<code>glDisable</code></li><li><code>glBlendFunc(src, dest)</code><ul><li>src: how the src RGBA factor is computed (default is <code>GL_ONE</code>) 默认是 1，每个通道都是单独计算的</li><li>dest: how the dest RGBA factor is computed (default is <code>GL_ZERO</code>) 默认是 0，也就是说 src 会覆盖到 dest 上面</li></ul></li><li><code>glBlendEquation(mode)</code><ul><li>mode: how we combine the src and dest colors</li><li>Default value is <code>GL_FUNC_ADD</code></li></ul></li></ul></li></ul></li><li>投影矩阵<ul><li>投影就是在多维空间中确定坐标系</li><li>将场景中三维空间中的坐标转换到 NDC（Normalized Device Coordinates），即标准空间</li><li>在窗口中渲染的内容的坐标范围必须从左到右在 <code>[-1, 1]</code> 之间，从上到下在 <code>[-1, 1]</code> 之间</li><li>投影矩阵的作用就是决定坐标空间是什么样的<ul><li>无论是正交（Orthographic）处理后的顶点，还是透视（Perspective）处理后的顶点，最终都会映射到标准空间中</li></ul></li></ul></li><li>视图矩阵 相机的变换（位移和方向）</li><li>模型矩阵 对象的变换（位移、旋转、缩放，TRS）</li><li>ImGui<ul><li>测试框架<ul><li>声明周期</li><li>封装 ImGui</li></ul></li></ul></li><li>批渲染<ul><li>在一次 DrawCall 中渲染多个对象</li></ul></li></ul><center>    <img src="/2024/06/20/355478969c9d/batch-rendering.jpg" alt></center><h4 id="纹理的批渲染"><a href="# 纹理的批渲染" class="headerlink" title="纹理的批渲染"></a>纹理的批渲染</h4><ul><li>颜色是 uniform 变量可以放到顶点缓冲中，但是不能把纹理放到顶点缓冲区中</li><li>但是可以像颜色一样提供纹理索引，这个索引在渲染 Quad 时，从顶点着色器传到片段着色器</li><li>片段着色器用作纹理数组和采样数组这些 uniform 的索引</li></ul><p>C++ 代码中定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// (x, y, x) 表示坐标</span><br><span class="hljs-comment">// (r, g, b, a) 表示颜色</span><br><span class="hljs-comment">// (u, v) 表示纹理</span><br><span class="hljs-comment">// texture_index 就是上面说的纹理索引，对应纹理槽位</span><br><span class="hljs-type">float</span> vertices[] = &#123;<br>  x, y, z, r, g, b, a, u, v, texture_index_1,<br>  ...<br>  x, y, z, r, g, b, a, u, v, texture_index_2,<br>&#125;<br></code></pre></td></tr></table></figure><p>Shader 中的定义</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// vertex.shader</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec3</span> position;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">1</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> color;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">2</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> texCoord;<br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">in</span> <span class="hljs-type">float</span> texIndex;<br><br>...<br><br><span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> _color;<br><span class="hljs-keyword">out</span> <span class="hljs-type">vec2</span> _texCoord;<br><span class="hljs-keyword">out</span> <span class="hljs-type">float</span> _texIndex;<br><br><span class="hljs-comment">// fragment.shader</span><br><span class="hljs-keyword">layout</span> (<span class="hljs-keyword">location</span> = <span class="hljs-number">0</span>) <span class="hljs-keyword">out</span> <span class="hljs-type">vec4</span> color;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> textureSamplers[<span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">in</span> <span class="hljs-type">vec4</span> _color;<br><span class="hljs-keyword">in</span> <span class="hljs-type">vec2</span> _texCoord;<br><span class="hljs-keyword">in</span> <span class="hljs-type">float</span> _texIndex;<br><br><span class="hljs-type">void</span> main()<br>&#123;<br>  <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-type">int</span>(_texIndex);<br>  color = <span class="hljs-built_in">texture</span>(textureSamplers[<span class="hljs-keyword">index</span>], _texCoord); <span class="hljs-comment">// 根据索引进行采样</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将纹理和槽绑定，利用 uniform 传递数据到 shader</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">0</span>, texture1);<br><span class="hljs-built_in">glBindTextureUnit</span>(<span class="hljs-number">1</span>, texture2);<br><br><span class="hljs-keyword">auto</span> loc = <span class="hljs-built_in">glGetUniformLocation</span>(shader-&gt;<span class="hljs-built_in">GetRenderId</span>(), <span class="hljs-string">&quot;textureSamplers&quot;</span>);<br><span class="hljs-type">int</span> samplers[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span> &#125;;<br><span class="hljs-built_in">glUniform1iv</span>(loc, <span class="hljs-number">2</span>, samplers);<br></code></pre></td></tr></table></figure><h4 id="动态顶点缓冲"><a href="# 动态顶点缓冲" class="headerlink" title="动态顶点缓冲"></a>动态顶点缓冲 </h4><p> 预先分配好最大的顶点缓冲区的大小（比如 1KB）</p><ul><li>将顶点数组用结构化的方式表示</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vertex</span><br>&#123;<br>  <span class="hljs-type">float</span> Position[<span class="hljs-number">3</span>];<br>  <span class="hljs-type">float</span> Color[<span class="hljs-number">4</span>];<br>  <span class="hljs-type">float</span> TexCoords[<span class="hljs-number">2</span>];<br>  <span class="hljs-type">float</span> TexId;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>绑定缓冲数据时使用 <code>GL_DYNAMIC_DRAW</code> 类型</li><li>绑定顶点属性时 <code>offset</code> 使用内置函数 <code>offsetof</code> 来确定每种数据类型的偏移量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glBufferData</span>(GL_ARRAY_BUFFER, <span class="hljs-built_in">sizeof</span>(Vertex) * <span class="hljs-number">1000</span>, <span class="hljs-literal">nullptr</span>, GL_DYNAMIC_DRAW);<br>...<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(Vertex), (<span class="hljs-type">const</span> <span class="hljs-type">void</span>*)<span class="hljs-built_in">offsetof</span>(Vertex, Position));<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(Vertex), (<span class="hljs-type">const</span> <span class="hljs-type">void</span>*)<span class="hljs-built_in">offsetof</span>(Vertex, Color));<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(Vertex), (<span class="hljs-type">const</span> <span class="hljs-type">void</span>*)<span class="hljs-built_in">offsetof</span>(Vertex, TexCoords));<br><span class="hljs-built_in">glVertexAttribPointer</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, GL_FLOAT, GL_FALSE, <span class="hljs-built_in">sizeof</span>(Vertex), (<span class="hljs-type">const</span> <span class="hljs-type">void</span>*)<span class="hljs-built_in">offsetof</span>(Vertex, TexId));<br></code></pre></td></tr></table></figure><ul><li>动态绑定顶点缓冲</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 一个 quad 需要四个点</span><br><span class="hljs-function">std::array&lt;Vertex, 4&gt; <span class="hljs-title">CreateQuad</span><span class="hljs-params">(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> texId)</span></span><br><span class="hljs-function"></span>&#123;<br>  Vertex v0;<br>  ...<br>  Vertex v1;<br>  ...<br>  Vertex v2;<br>  ...<br>  Vertex v3;<br>  ...<br>  <span class="hljs-keyword">return</span> &#123; v0, v1, v2, v3 &#125;;<br>&#125;<br><br><span class="hljs-keyword">auto</span> q0 = <span class="hljs-built_in">CreateQuad</span>(<span class="hljs-number">-1.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">0.0f</span>);<br><span class="hljs-keyword">auto</span> q1 = <span class="hljs-built_in">CreateQuad</span>(<span class="hljs-number">0.5f</span>, <span class="hljs-number">-0.5f</span>, <span class="hljs-number">1.0f</span>);<br><br><span class="hljs-comment">// 通过内存拷贝的方式直接将 `std::array` 中的内容拷贝到一维数组中</span><br>Vertex vertices[<span class="hljs-number">8</span>];<br><span class="hljs-built_in">memcpy</span>(vertices, q0.<span class="hljs-built_in">data</span>(), q0.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex));<br><span class="hljs-built_in">memcpy</span>(vertices + q0.<span class="hljs-built_in">size</span>(), q1.<span class="hljs-built_in">data</span>(), q0.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex));<br>...<br><span class="hljs-built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vertices), vertices);<br></code></pre></td></tr></table></figure><h4 id="动态索引缓冲"><a href="# 动态索引缓冲" class="headerlink" title="动态索引缓冲"></a>动态索引缓冲</h4><ul><li>首先确定绘制的最大的 Quad 的数量<code>maxQuadCount</code></li><li>由 <code>maxQuadCount</code> 确定顶点数量（<code>maxQuadCount * 4</code>）和索引数量（<code>maxQuadCount * 6</code>）</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">uint32_t</span> indices[maxQuadCount * <span class="hljs-number">6</span>];<br><span class="hljs-type">uint32_t</span> offset = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; maxQuadCount * <span class="hljs-number">6</span>; i += <span class="hljs-number">6</span>)<br>&#123;<br>  indices[i + <span class="hljs-number">0</span>] = <span class="hljs-number">0</span> + offset;<br>  indices[i + <span class="hljs-number">1</span>] = <span class="hljs-number">1</span> + offset;<br>  indices[i + <span class="hljs-number">2</span>] = <span class="hljs-number">2</span> + offset;<br><br>  indices[i + <span class="hljs-number">3</span>] = <span class="hljs-number">2</span> + offset;<br>  indices[i + <span class="hljs-number">4</span>] = <span class="hljs-number">3</span> + offset;<br>  indices[i + <span class="hljs-number">5</span>] = <span class="hljs-number">0</span> + offset;<br><br>  offset += <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>更改 <code>CreateQuad</code> 函数，传入预先定义好大小的顶点数据结构数组，如<code>std::array&lt;Vertex, 1000&gt;</code>，同时增加顶点索引数量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">Vertex* <span class="hljs-title">CreateQuad</span><span class="hljs-params">(Vertex* target, <span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> textureId)</span></span><br><span class="hljs-function"></span>&#123;<br>  target-&gt;Position = &#123; x, y, <span class="hljs-number">0.0f</span> &#125;;<br>  target-&gt;Color = &#123; <span class="hljs-number">0.18f</span>, <span class="hljs-number">0.6f</span>, <span class="hljs-number">0.96f</span>, <span class="hljs-number">1.0f</span> &#125;;<br>  target-&gt;TexCoors = &#123; <span class="hljs-number">0.0f</span>, <span class="hljs-number">0.0f</span> &#125;;<br>  target-&gt;TexId = textureId;<br>  target++;<br>  ...<br><br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br><br><span class="hljs-type">size_t</span> indexCount = <span class="hljs-number">0</span><br>std::array&lt;Vertex, <span class="hljs-number">1000</span>&gt; vertices;<br>Vertex* buffer = vertices.<span class="hljs-built_in">data</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">0</span>; y &lt; <span class="hljs-number">5</span>; y++)<br>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">5</span>; x++)<br>  &#123;<br>    buffer = <span class="hljs-built_in">CreateQuad</span>(buffer, x, y, (x + y) % <span class="hljs-number">2</span>);<br>    indexCount += <span class="hljs-number">6</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-built_in">glBufferSubData</span>(GL_ARRAY_BUFFER, <span class="hljs-number">0</span>, vertices.<span class="hljs-built_in">size</span>() * <span class="hljs-built_in">sizeof</span>(Vertex), vertices.<span class="hljs-built_in">data</span>());<br>...<br><span class="hljs-built_in">glDrawElements</span>(GL_TRIANGLE, indexCount, GL_UNSIGNED_INT, <span class="hljs-literal">nullptr</span>);<br></code></pre></td></tr></table></figure><h3 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h3><ul><li><p><code>glGenBuffers</code>: Generate buffer object names 生成缓冲区的标识</p><ul><li><code>n</code>: Specifies the number of buffer object names to be generated 需要缓冲区标识的数量</li><li><code>buffers</code>: Specifies an array in which the generated buffer object names are stored 用于存放缓冲区标识</li></ul></li><li><p><code>glBindBuffer</code>： Bind a named buffer object 绑定缓冲区标识的对象类型</p><p><code>glBindBuffer</code> binds a buffer object to the specified buffer binding point. Calling <code>glBindBuffer</code> with target set to one of the accepted symbolic constants and buffer set to the name of a buffer object binds that buffer object name to the target. If no buffer object with name buffer exists, one is created with that name. When a buffer object is bound to a target, the previous binding for that target is automatically broken.<br><code>glBindBuffer</code>函数将缓冲对象绑定到 OpenGL 上下文环境中，调用 <code>glBindBuffer</code> 函数，需要将 target 设置为一个符号常量（指定缓冲对象的类型），将 buffer 设置为缓冲对象的标识符，这样就将缓冲对象和标识符进行绑定了。如果标识符没有关联缓冲对象，就创建一个缓冲对象。当缓冲对象已经确定好对象类型，之前绑定的类型就会失效</p><p>Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target (if supported for that target). Buffer object names and the corresponding buffer object contents are local to the shared object space of the current GL rendering context; two rendering contexts share buffer object names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions.<br>因为缓冲区对象标识符是无符号类型的整数（非负整数），如果标识符是 0 意味着缓冲区对象类型没有绑定任何缓冲区对象，这样可以将 buffer 参数设置为 0 表示从缓冲区对象类型和缓冲区解绑，同时也会清除原来缓冲区中的内容。</p><ul><li><code>target</code>: Specifies the target to which the buffer object is bound<ul><li><code>GL_ARRAY_BUFFER</code>: Vertex attributes</li><li><code>GL_ATOMIC_COUNTER_BUFFER</code>: Atomic counter storage</li><li><code>GL_COPY_READ_BUFFER</code>: Buffer copy source</li><li><code>GL_COPY_WRITE_BUFFER</code>: Buffer copy destination</li><li><code>GL_DISPATCH_INDIRECT_BUFFER</code>: Indirect compute dispatch commands</li><li><code>GL_DRAW_INDIRECT_BUFFER</code>: Indirect command arguments</li><li><code>GL_ELEMENT_ARRAY_BUFFER</code>: Vertex array indices</li><li><code>GL_PIXEL_PACK_BUFFER</code>: Pixel read target</li><li><code>GL_PIXEL_UNPACK_BUFFER</code>: Texture data source</li><li><code>GL_QUERY_BUFFER</code>: Query result buffer</li><li><code>GL_SHADER_STORAGE_BUFFER</code>: Read-write storage for shaders</li><li><code>GL_TEXTURE_BUFFER</code>: Texture data buffer</li><li><code>GL_TRANSFORM_FEEDBACK_BUFFER</code>: Transform feedback buffer</li><li><code>GL_UNIFORM_BUFFER</code>: Uniform block storage</li></ul></li><li><code>buffer</code>: Specifies the name of a buffer object</li></ul></li><li><p><code>glBufferData</code>: 用来把用户定义的数据复制到当前绑定缓冲的函数</p><ul><li><code>GLenum target</code>: 目标缓冲的类型</li><li><code>GLsizeiptr size</code>: 传输数据的大小（以字节为单位），一般用 <code>sizeof()</code> 函数</li><li><code>const void * data</code>: 实际数据</li><li><code>GLenum usage</code>: 显卡如何管理给定的数据<ul><li><code>GL_STATIC_DRAW</code>: 数据不会或几乎不会改变</li><li><code>GL_DYNAMIC_DRAW</code>: 数据会被改变很多</li><li><code>GL_STREAM_DRAW</code>: 数据每次绘制时都会改变</li></ul></li></ul></li><li><p><code>glVertexAttribPointer</code>: 将 CPU 的数组缓冲区绑定到 GPU 的顶点缓冲区</p><ul><li><code>GLuint index</code>: Specifies the index of the generic vertex attribute to be modified 顶点属性的位置</li><li><code>GLint size</code>: Specifies the number of components per generic vertex attribute. Must be 1, 2, 3, 4. Additionally, the symbolic constant <code>GL_BGRA</code> is accepted by <code>glVertexAttribPointer</code>. The initial value is 4 顶点每个属性的元素数量，一定是 1，2，3，4 中的一个数。<del>当 <code>type</code> 为<code>GL_BGRA</code>时，初始值是 4</del></li><li><code>GLenum type</code>: Specifies the data type of each component in the array. 顶点每个属性的元素的数据类型枚举</li><li><code>GLboolean normalized</code>: Specifies whether fixed-point data values should be normalized (<code>GL_TRUE</code>) or converted directly as fixed-point values (<code>GL_FALSE</code>) when they are accessed 如果设置为 <code>GL_TRUE</code>，所有数据都会被映射到<code>[0, 1]</code> 之间（对于有符号类型的数据是 <code>[-1, 1]</code> 之间）</li><li><code>GLsizei stride</code>: Specifies the byte offset between consecutive generic vertex attributes. If stride​ is 0, the generic vertex attributes are understood to be tightly packed in the array. The initial value is 0 在顶点若干属性中两个相同属性之间的步长，如果步长是 0</li><li><code>const void * pointer</code>: Specifies a offset of the first component of the first generic vertex attribute in the array in the data store of the buffer currently bound to the <code>GL_ARRAY_BUFFER</code> target. The initial value is 0. 每个顶点属性相对于起始属性的偏移量的指针的位置</li></ul></li><li><p><code>glGetError</code>: 返回错误标志的值。每个可检测的错误都分配有数字代码和符号名称。发生错误时，错误标志将设置为相应的错误代码值。在调用 <code>glGetError</code>（返回错误代码）之前，不会记录其他错误，并将标志重置为<code>GL_NO_ERROR</code>。如果对<code>glGetError</code> 的调用返回 <code>GL_NO_ERROR</code>，则自上次调用<code>glGetError</code> 或自 GL 初始化以来，没有可检测到的错误</p></li><li><p><code>glGenTextures</code>: generate texture names</p><p><code>glGenTextures</code> returns n texture names in textures. There is no guarantee that the names form a contiguous set of integers; however, it is guaranteed that none of the returned names was in use immediately before the call to <code>glGenTextures</code> 能够保证在调用 <code>glGenTextures</code> 前返回的标识符是没有被用过的</p><p>The generated textures have no dimensionality; they assume the dimensionality of the texture target to which they are first bound 生成的纹理是没有维度的，假定纹理的维度是第一次绑定的维度（不是很理解）</p><p>Texture names returned by a call to <code>glGenTextures</code> are not returned by subsequent calls, unless they are first deleted with <code>glDeleteTextures</code> 连续调用 <code>glGenTextures</code> 不会返回表示符了，除非先调用 <code>glDeleteTextures</code> 删除纹理</p></li><li><p><code>glBindTexture</code>： 将一个纹理标识符绑定到一个纹理对象上<br>Texture names and the corresponding texture contents are local to the shared object space of the current GL rendering context; two rendering contexts share texture names only if they explicitly enable sharing between contexts through the appropriate GL windows interfaces functions. 对于当前的 GL 渲染上下文中的共享对象空间，纹理名称以及它们对应的纹理内容是局部的；只有在显式开启上下文之间的共享，两个渲染上下文才可以共享纹理名称</p></li><li><p><code>glTexParameteri</code></p></li><li><p><code>glTexImage2D</code></p></li><li><p><code>glActiveTexture</code></p></li><li><p><code>glClear</code></p><ul><li>不调用 <code>glClear</code> 的话，下一帧的内容会和上一帧的内容重叠在一起，上一帧的物体还在原来的地方</li><li><code>glClearColor</code><ul><li>指定刷新颜色缓冲区时所用的颜色</li><li><code>glClearColor</code>只是设置缓冲区颜色，并不不会清除缓冲区的颜色，需要在设置好颜色之后调用 <code>glClear</code> 才会刷新缓冲区的颜色</li><li><code>glClearColor</code>并不是必须的</li></ul></li></ul></li><li><p><code>glUniform1iv</code></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;center&gt;
    &lt;img src=&quot;/2024/06/20/355478969c9d/opengl-libraries.png&quot; alt&gt;
&lt;/center&gt;</summary>
    
    
    
    <category term="Learning OpenGL" scheme="https://silhouettesforyou.github.io/categories/Learning-OpenGL/"/>
    
    
    <category term="OpenGL" scheme="https://silhouettesforyou.github.io/tags/OpenGL/"/>
    
    <category term="图形学" scheme="https://silhouettesforyou.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Lua 问题</title>
    <link href="https://silhouettesforyou.github.io/2024/06/19/92509e685a8f/"/>
    <id>https://silhouettesforyou.github.io/2024/06/19/92509e685a8f/</id>
    <published>2024-06-19T02:24:25.000Z</published>
    <updated>2024-07-23T12:46:53.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="int64 乘法问题"><a href="#int64 乘法问题" class="headerlink" title="int64 乘法问题"></a><code>int64</code>乘法问题</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = int64.new(<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">local</span> b = <span class="hljs-number">0.01</span><br><span class="hljs-built_in">print</span>(a + b) <span class="hljs-comment">-- 1000</span><br><span class="hljs-built_in">print</span>(a * b) <span class="hljs-comment">-- 0</span><br></code></pre></td></tr></table></figure><p>原因：</p><ul><li><code>int64</code>乘法会触发元方法<code>__mul</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">lua_pushstring(L, <span class="hljs-string">&quot;__mul&quot;</span>),<br>lua_pushcfunction(L, _int64mul);<br>lua_rawset(L, <span class="hljs-number">-3</span>); <span class="hljs-comment">// 指向栈顶</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> _int64mul(lua_State* L)<br>&#123;<br>    <span class="hljs-type">int64_t</span> lhs = toluas_checkint64(L, <span class="hljs-number">1</span>);    <br>    <span class="hljs-type">int64_t</span> rhs = toluas_checkint64(L, <span class="hljs-number">2</span>);<br>    toluas_pushint64(L, lhs * rhs);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>触发元方法后调用 <code>toluas_checkint64</code> 检查栈中的数值类型并做类型转换，当 <code>int64</code> 类型和 <code>number</code> 类型相乘时，会将其转换成整型——<code>(int64_t)0.01</code>，所以相乘的结果是<code>0</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int64_t</span> <span class="hljs-title function_">toluas_checkint64</span><span class="hljs-params">(lua_State* L, <span class="hljs-type">int</span> pos)</span><br>&#123;<br>    <span class="hljs-type">int64_t</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> type = lua_type(L, pos);<br>    <br>    <span class="hljs-keyword">switch</span>(type)<br>    &#123;<br>        <span class="hljs-keyword">case</span> LUA_TNUMBER:<br>            n = (<span class="hljs-type">int64_t</span>)lua_tonumber(L, pos);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> LUA_TSTRING:<br>            n = _long(L, pos);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> LUA_TUSERDATA:<br>            <span class="hljs-keyword">if</span> (_isint64(L, pos))<br>            &#123;<br>                n = *(<span class="hljs-type">int64_t</span>*)lua_touserdata(L, pos);<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> luaL_typerror(L, pos, <span class="hljs-string">&quot;long&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> n;<br>&#125;<br></code></pre></td></tr></table></figure><p>正确做法：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> a = int64.new(<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">local</span> b = <span class="hljs-number">0.01</span><br><span class="hljs-built_in">print</span>(a:toDouble() + b) <span class="hljs-comment">-- 1000.01</span><br><span class="hljs-built_in">print</span>(a:toDouble() * b) <span class="hljs-comment">-- 10</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> _int64todouble(lua_State* L)<br>&#123;<br>    <span class="hljs-keyword">if</span> (!toluas_isint64(L, <span class="hljs-number">1</span>))<br>    &#123;<br>        <span class="hljs-keyword">return</span> luaL_typerror(L, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;long&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">int64_t</span> n = toluas_toint64(L, <span class="hljs-number">1</span>);<br>    lua_pushnumber(L, (<span class="hljs-type">double</span>)n);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="Lua" scheme="https://silhouettesforyou.github.io/categories/Lua/"/>
    
    
    <category term="Lua" scheme="https://silhouettesforyou.github.io/tags/Lua/"/>
    
    <category term="bug" scheme="https://silhouettesforyou.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>Unreal 基础</title>
    <link href="https://silhouettesforyou.github.io/2024/06/10/f3b491abe2f8/"/>
    <id>https://silhouettesforyou.github.io/2024/06/10/f3b491abe2f8/</id>
    <published>2024-06-10T01:50:20.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="UPROPERTY- 和 UFUNCTION"><a href="#UPROPERTY- 和 UFUNCTION" class="headerlink" title="UPROPERTY()和 UFUNCTION()"></a><code>UPROPERTY()</code>和<code>UFUNCTION()</code></h3><h4 id="UPROPERTY"><a href="#UPROPERTY" class="headerlink" title="UPROPERTY()"></a><code>UPROPERTY()</code></h4><ul><li><code>BlueprintCallable</code>：可以在蓝图中被调用</li><li><code>BlueprintReadOnly</code>：可以被蓝图读取，但是不可被修改</li><li><code>BlueprintReadWrite</code>：可以被蓝图读取和修改</li><li><code>Category</code>：为属性添加分类标签</li><li><code>EditAnywhere</code>：该属性可以在属性窗口中修改</li><li><code>EditDefaultOnly</code>：可以在属性窗口中修改，但是只能在基类的属性窗口修改</li><li><code>VisibleAnywhere</code>：可以在属性窗口看见，但是不可修改</li><li><code>VisibleDefaultsOnly</code>：该属性只可在基类的属性窗口中看见而且不可修改</li><li><code>Meta</code>：可以用来设置一些元数据，如文档、关键字等，<code>meta=(AllowPrivateAccess=&quot;true&quot;)</code> 允许私有属性在编辑器中进行编辑</li><li><code>Transient</code>：该属性不会被序列化保存，通常用于临时数据或不希望被保存的数据</li><li><code>Replicated</code>：属性在网络中进行复制</li></ul><h4 id="UFUNCTION"><a href="#UFUNCTION" class="headerlink" title="UFUNCTION"></a><code>UFUNCTION</code></h4><p><code>UFUNCTION</code>是 Unreal Engine 中神功函数的宏，它用于标记某个函数是一个 Unreal Engine 托管的函数，并且可以在编辑器中惊醒访问和操作</p><p><code>UFUNCTION</code>宏提供了一系列参数，用于定义函数的属性和行为，例如是否是阑入可调用的，是否可在网络中复制等</p><ul><li><code>BlueprintCallable</code>：可以在蓝图或者关卡蓝图中调用</li><li><code>BlueprintPure</code>：生命该函数为纯函数，即不会修改对象的状态</li><li><code>BlueprintImplementableEvent</code>：这个函数在头文件声明但是应该在类蓝图或关卡蓝图中重写，应该和 <code>BlueprintCallable</code> 一起使用，这样蓝图就可以调用它。</li><li><code>Category</code>：指定在编辑器中现实的该函数所属的分类</li><li><code>Meta</code>：可以用来设置一些元数据，如文档、关键字等</li><li><code>Server**</code>、<code>Client</code>、<code>Reliable</code>：用于网络功能，指定该函数在服务端、客户端执行，以及指定该函数是否可靠传输</li><li><code>BlueprintNativeEvent</code>：这个函数可以在蓝图类中重写，同时拥有 C++ 实现，函数名为<code>FuncName_Implementtation</code></li></ul><h3 id="include 引入头文件与不完全声明"><a href="#include 引入头文件与不完全声明" class="headerlink" title="#include 引入头文件与不完全声明"></a><code>#include</code>引入头文件与不完全声明 </h3><p> 建议在源文件中引入其他头文件，而不是在头文件中引入其他头文件</p><ul><li>减少编译时间</li><li>比秒循环依赖</li><li>增强可维护性</li></ul><h3 id="打印 -LOG"><a href="# 打印 -LOG" class="headerlink" title="打印 LOG"></a>打印 LOG</h3><ul><li><p><code>UE_LOG</code></p><ul><li><code>UE_Log</code>宏是 Unreal Engine 重用日志记录的标准方式。它可以输出日志信息到控制台和日志文件，支持多种日志级别（如<code>Log</code>，<code>Warning</code>，<code>Error</code>）</li><li><code>UE_LOG(LogCategory, LogVerbosity, Format, ...)</code></li></ul></li><li><p><code>GEngine-&gt;AddOnScreenDebugMessage</code></p><ul><li><code>GEngine-&gt;AddOnScreenDebugMessage</code>可以在游戏屏幕上现实调试信息，通常用于快速查看和调试</li><li><code>GEngine-&gt;AddOnScreenDebugMessage(Key TimeToDisplay, Color, Message)</code></li></ul></li></ul><h3 id="控制输入"><a href="# 控制输入" class="headerlink" title="控制输入"></a>控制输入</h3><ul><li>Input Mapping Context<ul><li>定义了那些输入键触发那些输入动作的规则集合</li></ul></li><li>Input Action<ul><li>代表了玩家可以执行的某种动作</li></ul></li><li><code>EnhancedInputComponent</code><ul><li>更灵活</li><li>输入绑定优化</li><li>输入处理流程的改进</li></ul></li></ul><h3 id="Anim-Instnce- 与动画"><a href="#Anim-Instnce- 与动画" class="headerlink" title="Anim Instnce 与动画"></a>Anim Instnce 与动画 </h3><h3 id="AActor、APawn 和 ACharactor"><a href="#AActor、APawn 和 ACharactor" class="headerlink" title="AActor、APawn 和 ACharactor"></a><code>AActor</code>、<code>APawn</code> 和<code>ACharactor</code></h3><ul><li><code>UObject</code>：基础类 <code>UObject</code> 是所有非 Actor 类的基类，几乎所有的 Unreal Engine 对象都继承自<code>UObject</code></li><li><code>AActor</code>：继承自<code>UObject</code>，并且是所有场景中对象（角色、道具、灯光等）的基类</li><li><code>APawn</code>：可以被玩家或 AI 控制的对象，丹斯不需要复杂的运动和动画系统<ul><li>可控制性</li><li>控制器：<code>APawn</code>通常与 <code>AController</code> 或<code>APlayerController</code>关联，以实现移动和交互</li><li>不包含骨骼网格和动画</li></ul></li><li><code>ACharacter</code>是一种特殊类型的<code>APawn</code>，它包含用于行走、跳跃、游泳等运动功能。它是带有骨骼动画和动画系统的高级角色类<ul><li>骨骼网格和动画：<code>ACharacter</code>包含 ``USkeletallMeshComponent 和动画蓝图，用于角色的外观和动画</li><li>角色运动：包含<code>UCharacterMovementComponent</code>，支持复杂的角色运动</li><li>碰撞和胶囊体：默认包含一个胶囊碰撞体，用于角色的碰撞检测</li></ul></li></ul><h3 id="游戏是怎样运行的"><a href="# 游戏是怎样运行的" class="headerlink" title="游戏是怎样运行的"></a>游戏是怎样运行的</h3><ul><li><code>AGameModeBase</code><ul><li>这是游戏模式的基类，它定义了游戏的规则、逻辑和行为</li><li>可以通过创建自定义的游戏模式类来扩展它，并重写其中的方法来实现特定的游戏的逻辑</li></ul></li><li><code>AGameMode</code><ul><li><code>AGameMode</code>类是 <code>AGameModeBase</code> 的一个子类，它提供了更多的功能和控制权，例如玩家控制、团队管理、积分系统等</li><li>可以使用 <code>AGameMode</code> 类来实现更复杂的游戏逻辑和规则</li></ul></li><li>Game Session</li><li>Game State</li><li>Player State</li><li>Default Pawn Class</li><li>APlayerController</li><li>AHUD</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unreal" scheme="https://silhouettesforyou.github.io/tags/Unreal/"/>
    
    <category term="蓝图" scheme="https://silhouettesforyou.github.io/tags/%E8%93%9D%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>XLua 如何与 C# 进行交互</title>
    <link href="https://silhouettesforyou.github.io/2024/06/04/04dccfe10a89/"/>
    <id>https://silhouettesforyou.github.io/2024/06/04/04dccfe10a89/</id>
    <published>2024-06-04T06:50:00.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p>🔗 <a href="https://www.cnblogs.com/iwiniwin/p/15307368.html">深入 xLua 实现原理之 Lua 如何调用 C#</a></p></blockquote><p><a href="https://github.com/Tencent/xLua">xLua</a> 是腾讯的一个开源项目，为 Unity、 .Net、 Mono 等 C# 环境增加 Lua 脚本编程的能力。本文主要是探讨 xLua 下 Lua 调用 C# 的实现原理</p><h3 id="Lua- 与 -C- 数据通信机制"><a href="#Lua- 与 -C- 数据通信机制" class="headerlink" title="Lua 与 C# 数据通信机制"></a>Lua 与 C# 数据通信机制 </h3><p> 无论是 Lua 调用 C#，还是 C# 调用 Lua，都需要一个通信机制，来完成数据的传递。而 Lua 本身就是由 C 语言编写的，所以它出生自带一个和 C/C++ 的通信机制</p><p>Lua 和 C/C++ 的数据交互通过栈进行，操作数据时，首先将数据拷贝到”栈”上，然后获取数据，栈中的每个数据通过索引值进行定位，索引值为正时表示相对于栈底的偏移索引，索引值为负时表示相对于栈顶的偏移索引，索引值以 1 或 -1 为起始值，因此栈顶索引值永远为 -1， 栈底索引值永远为 1 。 “栈”相当于数据在 Lua 和 C/C++ 之间的中转地。每种数据都有相应的存取接口</p><p>而 C# 可以通过 P/Invoke 方式调用 Lua 的 dll，通过这个 dll 执行 Lua 的 C API。换言之 C# 可以借助 C/C++ 来与 Lua 进行数据通信。在 xLua 的 LuaDLL.cs 文件中可以找到许多 DllImport 修饰的数据入栈与获取的接口</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// LuaDLL.cs</span><br>[<span class="hljs-meta">DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lua_pushnumber</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">double</span> number</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lua_pushboolean</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">bool</span> <span class="hljs-keyword">value</span></span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-keyword">void</span> <span class="hljs-title">xlua_pushinteger</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">double</span> <span class="hljs-title">lua_tonumber</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> index</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">int</span> <span class="hljs-title">xlua_tointeger</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> index</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL, CallingConvention = CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">xlua_touint</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> index</span>)</span>;<br><br>[<span class="hljs-meta">DllImport(LUADLL,CallingConvention=CallingConvention.Cdecl)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">extern</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">lua_toboolean</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> index</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="传递 -C- 对象到 -Lua"><a href="# 传递 -C- 对象到 -Lua" class="headerlink" title="传递 C# 对象到 Lua"></a>传递 C# 对象到 Lua</h3><p>对于 <code>bool</code>，<code>int</code> 这样简单的值类型可以直接通过 C API 传递。但对于 C# 对象就不同了，Lua 这边没有能与之对应的类型，因此传递到 Lua 的只是 C# 对象的一个索引，具体实现请看下面的代码</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">RealStatePtr L, <span class="hljs-built_in">object</span> o</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-built_in">int</span> index = <span class="hljs-number">-1</span>;<br>    Type type = o.GetType();<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !UNITY_WSA || UNITY_EDITOR</span><br>    <span class="hljs-built_in">bool</span> is_enum = type.IsEnum;<br>    <span class="hljs-built_in">bool</span> is_valuetype = type.IsValueType;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-built_in">bool</span> is_enum = type.GetTypeInfo().IsEnum;<br>    <span class="hljs-built_in">bool</span> is_valuetype = type.GetTypeInfo().IsValueType;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-built_in">bool</span> needcache = !is_valuetype || is_enum;  <span class="hljs-comment">// 如果是引用或枚举，会进行缓存</span><br>    <span class="hljs-keyword">if</span> (needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, <span class="hljs-keyword">out</span> index) : reverseMap.TryGetValue(o, <span class="hljs-keyword">out</span> index)))  <span class="hljs-comment">// 如果有缓存</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == <span class="hljs-number">1</span>)  <br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 这里实在太经典了，weaktable 先删除，然后 GC 会延迟调用，当 index 会循环利用的时候，不注释这行将会导致重复释放</span><br>        <span class="hljs-comment">//collectObject(index);</span><br>    &#125;<br><br>    <span class="hljs-built_in">bool</span> is_first;<br>    <span class="hljs-built_in">int</span> type_id = getTypeId(L, type, <span class="hljs-keyword">out</span> is_first);<br><br>    <span class="hljs-comment">// 如果一个 type 的定义含本身静态 readonly 实例时，getTypeId 会 push 一个实例，这时候应该用这个实例</span><br>    <span class="hljs-keyword">if</span> (is_first &amp;&amp; needcache &amp;&amp; (is_enum ? enumMap.TryGetValue(o, <span class="hljs-keyword">out</span> index) : reverseMap.TryGetValue(o, <span class="hljs-keyword">out</span> index))) <br>    &#123;<br>        <span class="hljs-keyword">if</span> (LuaAPI.xlua_tryget_cachedud(L, index, cacheRef) == <span class="hljs-number">1</span>)   <br>        &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// C# 侧进行缓存</span><br>    index = addObject(o, is_valuetype, is_enum);<br>    <span class="hljs-comment">// 将代表对象的索引 push 到 lua</span><br>    LuaAPI.xlua_pushcsobj(L, index, type_id, needcache, cacheRef);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的两个 <code>if</code> 语句主要是对缓存的判断，如果要传递的对象已经被缓存过了就直接使用缓存的。如果这个对象是被第一次传递，则进行以下两步操作</p><ol><li><p>通过 <code>addObject</code> 将对象缓存在 <code>objects</code> 对象池中，并得到一个索引（通过这个索引可以获取到该对象）</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">addObject</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> obj, <span class="hljs-built_in">bool</span> is_valuetype, <span class="hljs-built_in">bool</span> is_enum</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> index = objects.Add(obj);<br>    <span class="hljs-keyword">if</span> (is_enum)<br>    &#123;<br>        enumMap[obj] = index;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!is_valuetype)<br>    &#123;<br>        reverseMap[obj] = index;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> index;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 <code>xlua_pushcsobj</code> 将代表对象的索引传递到 Lua</p></li></ol><p>参数 <code>key</code> 表示代表对象的索引，参数 <code>meta_ref</code> 表示代表对象类型的表的索引，它的值是通过 <code>getTypeId</code> 函数获得的，后面会详细讲到。参数 <code>need_cache</code> 表示是否需要在 Lua 侧进行缓存，参数 <code>cache_ref</code> 表示 Lua 侧缓存表的索引</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// xlua.c</span><br>LUA_API <span class="hljs-type">void</span> <span class="hljs-title function_">xlua_pushcsobj</span><span class="hljs-params">(lua_State *L, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> meta_ref, <span class="hljs-type">int</span> need_cache, <span class="hljs-type">int</span> cache_ref)</span> &#123;<br>    <span class="hljs-type">int</span>* pointer = (<span class="hljs-type">int</span>*)lua_newuserdata(L, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>    *pointer = key;<br>    <br>    <span class="hljs-keyword">if</span> (need_cache) cacheud(L, key, cache_ref);  <span class="hljs-comment">// Lua 侧缓存</span><br><br>    lua_rawgeti(L, LUA_REGISTRYINDEX, meta_ref);<br><br>    lua_setmetatable(L, <span class="hljs-number">-2</span>);  <span class="hljs-comment">// 为 userdata 设置元表</span><br>&#125;<br><br><span class="hljs-comment">// 将 key = userdata 存入缓存表</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">cacheud</span><span class="hljs-params">(lua_State *L, <span class="hljs-type">int</span> key, <span class="hljs-type">int</span> cache_ref)</span> &#123;<br>    lua_rawgeti(L, LUA_REGISTRYINDEX, cache_ref);<br>    lua_pushvalue(L, <span class="hljs-number">-2</span>);<br>    lua_rawseti(L, <span class="hljs-number">-2</span>, key);<br>    lua_pop(L, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>xlua_pushcsobj</code>的主要逻辑是，代表对象的索引被 <code>push</code> 到 Lua 后，Lua 会为其创建一个 <code>userdata</code>，并将这个<code>userdata</code> 指向对象索引，如果需要缓存则将 <code>userdata</code> 保存到缓存表中， 最后为 <code>userdata</code> 设置了元表。也就是说，C# 对象在 Lua 这边对应的就是一个<code>userdata</code>，利用对象索引保持与 C# 对象的联系。</p><h3 id="注册 -C- 类型信息到 -Lua"><a href="# 注册 -C- 类型信息到 -Lua" class="headerlink" title="注册 C# 类型信息到 Lua"></a>注册 C# 类型信息到 Lua</h3><p>为 <code>userdata</code>（特指 C# 对象在 Lua 这边对应的代理<code>userdata</code>，后面再出现的<code>userdata</code> 也是同样的含义，就不再赘述了）设置的元表，表示的实际是对象的类型信息。在将 C# 对象传递到 Lua 以后，还需要告知 Lua 该对象的类型信息，比如对象类型有哪些成员方法，属性或是静态方法等。将这些都注册到 Lua 后，Lua 才能正确的调用。这个元表是通过 <code>getTypeId</code> 函数生成的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getTypeId</span>(<span class="hljs-params">RealStatePtr L, Type type, <span class="hljs-keyword">out</span> <span class="hljs-built_in">bool</span> is_first, LOGLEVEL log_level = LOGLEVEL.WARN</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> type_id;<br>    is_first = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (!typeIdMap.TryGetValue(type, <span class="hljs-keyword">out</span> type_id)) <span class="hljs-comment">// no reference</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        is_first = <span class="hljs-literal">true</span>;<br>        Type alias_type = <span class="hljs-literal">null</span>;<br>        aliasCfg.TryGetValue(type, <span class="hljs-keyword">out</span> alias_type);<br>        LuaAPI.luaL_getmetatable(L, alias_type == <span class="hljs-literal">null</span> ? type.FullName : alias_type.FullName);<br><br>        <span class="hljs-keyword">if</span> (LuaAPI.lua_isnil(L, <span class="hljs-number">-1</span>)) <span class="hljs-comment">//no meta yet, try to use reflection meta</span><br>        &#123;<br>            LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (TryDelayWrapLoader(L, alias_type == <span class="hljs-literal">null</span> ? type : alias_type))<br>            &#123;<br>                LuaAPI.luaL_getmetatable(L, alias_type == <span class="hljs-literal">null</span> ? type.FullName : alias_type.FullName);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Fatal: can not load metatable of type:&quot;</span> + type);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 循环依赖，自身依赖自己的 class，比如有个自身类型的静态 readonly 对象。</span><br>        <span class="hljs-keyword">if</span> (typeIdMap.TryGetValue(type, <span class="hljs-keyword">out</span> type_id))<br>        &#123;<br>            LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-comment">// ...</span><br>            LuaAPI.lua_pushvalue(L, <span class="hljs-number">-1</span>);<br>            type_id = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);  <span class="hljs-comment">// 将元表添加到注册表中</span><br>            LuaAPI.lua_pushnumber(L, type_id);<br>            LuaAPI.xlua_rawseti(L, <span class="hljs-number">-2</span>, <span class="hljs-number">1</span>);   <span class="hljs-comment">// 元表 [1] = type_id</span><br>            LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>            <span class="hljs-keyword">if</span> (type.IsValueType())<br>            &#123;<br>                typeMap.Add(type_id, type);<br>            &#125;<br><br>            typeIdMap.Add(type, type_id);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> type_id;<br>&#125;<br></code></pre></td></tr></table></figure><p>函数主要逻辑是以类的名称为 <code>key</code> 通过 <code>luaL_getmetatable</code> 获取类对应的元表，如果获取不到，则通过 <code>TryDelayWrapLoader</code>函数生成。然后调用 <code>luaL_ref</code> 将获取到的元表添加到 Lua 注册表中，并返回 type_id。type_id 表示的就是元表在 Lua 注册表中的索引，通过这个索引可以在 Lua 注册表中取回元表。前面提到的 <code>xlua_pushcsobj</code>函数就是利用 <code>type_id</code> 即<code>meta_ref</code>，获取到元表，然后为 <code>userdata</code> 设置的元表。<br>下面来看元表具体是怎样生成的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">TryDelayWrapLoader</span>(<span class="hljs-params">RealStatePtr L, Type type</span>)</span><br>&#123;<br>    <span class="hljs-comment">// ...</span><br>    LuaAPI.luaL_newmetatable(L, type.FullName); <span class="hljs-comment">// 先建一个 metatable，因为加载过程可能会需要用到</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>    Action&lt;RealStatePtr&gt; loader;<br>    <span class="hljs-built_in">int</span> top = LuaAPI.lua_gettop(L);<br>    <span class="hljs-keyword">if</span> (delayWrap.TryGetValue(type, <span class="hljs-keyword">out</span> loader))  <span class="hljs-comment">// 如果有预先注册的类型元表生成器，则直接使用</span><br>    &#123;<br>        delayWrap.Remove(type);<br>        loader(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !GEN_CODE_MINIMIZE &amp;&amp; !ENABLE_IL2CPP &amp;&amp; (UNITY_EDITOR || XLUA_GENERAL) &amp;&amp; !FORCE_REFLECTION &amp;&amp; !NET_STANDARD_2_0</span><br>        <span class="hljs-keyword">if</span> (!DelegateBridge.Gen_Flag &amp;&amp; !type.IsEnum() &amp;&amp; !<span class="hljs-keyword">typeof</span>(Delegate).IsAssignableFrom(type) &amp;&amp; Utils.IsPublic(type))<br>        &#123;<br>            Type wrap = ce.EmitTypeWrap(type);<br>            MethodInfo method = wrap.GetMethod(<span class="hljs-string">&quot;__Register&quot;</span>, BindingFlags.Static | BindingFlags.Public);<br>            method.Invoke(<span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[] &#123; L &#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));<br>        &#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        Utils.ReflectionWrap(L, type, privateAccessibleFlags.Contains(type));<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (top != LuaAPI.lua_gettop(L))<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;top change, before:&quot;</span> + top + <span class="hljs-string">&quot;, after:&quot;</span> + LuaAPI.lua_gettop(L));<br>    &#125;<br><br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> nested_type <span class="hljs-keyword">in</span> type.GetNestedTypes(BindingFlags.Public))<br>    &#123;<br>        <span class="hljs-keyword">if</span> (nested_type.IsGenericTypeDefinition())  <span class="hljs-comment">// 过滤泛型类型定义</span><br>        &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        GetTypeId(L, nested_type);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TryDelayWrapLoader- 主要用来处理两种情况"><a href="#TryDelayWrapLoader- 主要用来处理两种情况" class="headerlink" title="TryDelayWrapLoader 主要用来处理两种情况"></a>TryDelayWrapLoader 主要用来处理两种情况</h4><ol><li>通过 <code>delayWrap</code> 判断，是否有为该类生成代码，如果有，直接使用生成函数进行填充元表（<code>loader</code>方法）。在 xLua 的生成代码中有一个 XLuaGenAutoRegister.cs 文件，在这个文件中会为对应的类注册初始化器，而这个初始化器负责将类对应的元表生成函数添加到 <code>delayWrap</code> 中。</li></ol><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// XLuaGenAutoRegister.cs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">XLua_Gen_Initer_Register__</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">wrapInit0</span>(<span class="hljs-params">LuaEnv luaenv, ObjectTranslator translator</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        translator.DelayWrapLoader(<span class="hljs-keyword">typeof</span>(TestXLua), TestXLuaWrap.__Register);  <span class="hljs-comment">// 将类型对应的元表填充函数__Register 添加到 delayWrap 中</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Init</span>(<span class="hljs-params">LuaEnv luaenv, ObjectTranslator translator</span>)</span><br>    &#123;<br>        wrapInit0(luaenv, translator);<br>        translator.AddInterfaceBridgeCreator(<span class="hljs-keyword">typeof</span>(System.Collections.IEnumerator), SystemCollectionsIEnumeratorBridge.__Create);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-title">XLua_Gen_Initer_Register__</span>()</span><br>    &#123;<br>            XLua.LuaEnv.AddIniter(Init);  <span class="hljs-comment">// 注册初始化器</span><br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>如果没有生成代码，通过反射填充元表（<code>ReflectionWrap</code>方法）</li></ol><h3 id="使用生成函数填充元表"><a href="# 使用生成函数填充元表" class="headerlink" title="使用生成函数填充元表"></a>使用生成函数填充元表 </h3><p> 以<code>LuaCallCSharp</code>修饰的 <code>TestXLua</code> 类为例来查看生成函数是如何生成的</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// TestXLua.cs</span><br>[<span class="hljs-meta">LuaCallCSharp</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestXLua</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">bool</span> b, <span class="hljs-built_in">string</span> c</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Generate Code 之后生成的 TestXLuaWrap.cs 如下所示</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestXLuaWrap</span> <br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __Register(RealStatePtr L)<br>    &#123;<br>        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>        System.Type type = <span class="hljs-keyword">typeof</span>(TestXLua);<br>        Utils.BeginObjectRegister(type, L, translator, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        Utils.RegisterFunc(L, Utils.METHOD_IDX, <span class="hljs-string">&quot;Test1&quot;</span>, _m_Test1);<br>        Utils.RegisterFunc(L, Utils.GETTER_IDX, <span class="hljs-string">&quot;Name&quot;</span>, _g_get_Name);<br>        Utils.RegisterFunc(L, Utils.SETTER_IDX, <span class="hljs-string">&quot;Name&quot;</span>, _s_set_Name);<br>        Utils.EndObjectRegister(type, L, translator, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,<br>            <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        Utils.BeginClassRegister(type, L, __CreateInstance, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        Utils.RegisterFunc(L, Utils.CLS_IDX, <span class="hljs-string">&quot;Test2&quot;</span>, _m_Test2_xlua_st_);<br>        Utils.EndClassRegister(type, L, translator);<br>    &#125;<br>    <br>    [<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> __CreateInstance(RealStatePtr L)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>            <span class="hljs-keyword">if</span>(LuaAPI.lua_gettop(L) == <span class="hljs-number">1</span>)<br>            &#123;<br>                TestXLua gen_ret = <span class="hljs-keyword">new</span> TestXLua();<br>                translator.Push(L, gen_ret);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>            <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;invalid arguments to TestXLua constructor!&quot;</span>);<br>        <br>    &#125;<br><br>    [<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _m_Test1(RealStatePtr L)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>            TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, <span class="hljs-number">1</span>);<br>            &#123;<br>                <span class="hljs-built_in">int</span> _a = LuaAPI.xlua_tointeger(L, <span class="hljs-number">2</span>);<br>                gen_to_be_invoked.Test1(_a);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>            <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>        &#125;<br>    &#125;<br>    <br>    [<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _m_Test2_xlua_st_(RealStatePtr L)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            &#123;<br>                <span class="hljs-built_in">int</span> _a = LuaAPI.xlua_tointeger(L, <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">bool</span> _b = LuaAPI.lua_toboolean(L, <span class="hljs-number">2</span>);<br>                <span class="hljs-built_in">string</span> _c = LuaAPI.lua_tostring(L, <span class="hljs-number">3</span>);<br>                TestXLua.Test2(_a, _b, _c);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>            <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>        &#125;<br>    &#125;<br>    <br>    [<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _g_get_Name(RealStatePtr L)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>        <br>            TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, <span class="hljs-number">1</span>);<br>            LuaAPI.lua_pushstring(L, gen_to_be_invoked.Name);<br>        &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>            <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    [<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _s_set_Name(RealStatePtr L)<br>    &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>        <br>            TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, <span class="hljs-number">1</span>);<br>            gen_to_be_invoked.Name = LuaAPI.lua_tostring(L, <span class="hljs-number">2</span>);<br>        <br>        &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>            <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="生成函数 -Register 主要是这样一个框架"><a href="# 生成函数 -Register 主要是这样一个框架" class="headerlink" title="生成函数__Register 主要是这样一个框架"></a>生成函数 <code>__Register</code> 主要是这样一个框架</h4><ol><li><p><code>Utils.BeginObjectRegister</code>，在对类的非静态值（例如成员变量，成员方法等）进行注册前做一些准备工作。主要是为元表添加 <code>__gc</code> 和<code>__tostring</code>元方法，以及准备好 <code>method</code> 表、<code>getter</code>表、<code>setter</code>表，后面调用 <code>RegisterFunc</code> 时，可以选择插入到对应的表中</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginObjectRegister</span>(<span class="hljs-params">Type type, RealStatePtr L, ObjectTranslator translator, <span class="hljs-built_in">int</span> meta_count, <span class="hljs-built_in">int</span> method_count, <span class="hljs-built_in">int</span> getter_count,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">int</span> setter_count, <span class="hljs-built_in">int</span> type_id = <span class="hljs-number">-1</span></span>)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (type_id == <span class="hljs-number">-1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;Fatal: must provide a type of type_id&quot;</span>);<br>        LuaAPI.xlua_rawgeti(L, LuaIndexes.LUA_REGISTRYINDEX, type_id);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.luaL_getmetatable(L, type.FullName);<br>        <span class="hljs-comment">// 如果 type.FullName 对应的元表是空，则创建一个新的元表，并设置到注册表中</span><br>        <span class="hljs-keyword">if</span> (LuaAPI.lua_isnil(L, <span class="hljs-number">-1</span>))<br>        &#123;<br>            LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>            LuaAPI.luaL_newmetatable(L, type.FullName);<br>        &#125;<br>    &#125;<br>    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());<br>    LuaAPI.lua_pushnumber(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 为元表设置标志</span><br><br>    <span class="hljs-keyword">if</span> ((type == <span class="hljs-literal">null</span> || !translator.HasCustomOp(type)) &amp;&amp; type != <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">decimal</span>))<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__gc&quot;</span>);<br>        LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);<br>        LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 为元表设置__gc 方法</span><br>    &#125;<br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__tostring&quot;</span>);<br>    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 为元表设置__tostring 方法</span><br><br>    <span class="hljs-keyword">if</span> (method_count == <span class="hljs-number">0</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, method_count);  <span class="hljs-comment">// 创建 method 表</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (getter_count == <span class="hljs-number">0</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, getter_count);  <span class="hljs-comment">// 创建 getter 表</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (setter_count == <span class="hljs-number">0</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, setter_count);  <span class="hljs-comment">// 创建 setter 表</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多个 <code>Utils.RegisterFunc</code>，将类的每个非静态值对应的包裹方法注册到不同的 Lua 表中。包裹方法是 Generate Code 时动态生成的，对于类的属性会生成两个包裹方法，分别是<code>get</code> 和<code>set</code>包裹方法</p><p> 例如成员方法 <code>Test1</code> 对应的包裹方法是 <code>_m_Test1</code>，并被注册到了<code>method</code> 表中。<code>Name</code>变量的 <code>_g_get_Name</code> 包裹方法被注册到<code>getter</code> 表，而 <code>_s_set_Name</code> 包裹方法被注册到 <code>setter</code> 表。这个包裹方法只是对原来方法的一层包裹，调用这个包裹方法本质上就是调用原来的方法。至于为什么需要生成包裹方法，后面会再讲到</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs RegisterFunc 根据不同的宏定义会有不同的版本，但大同小异</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">RegisterFunc</span>(<span class="hljs-params">RealStatePtr L, <span class="hljs-built_in">int</span> idx, <span class="hljs-built_in">string</span> name, LuaCSFunction func</span>)</span><br>&#123;<br>    idx = abs_idx(LuaAPI.lua_gettop(L), idx);<br>    LuaAPI.xlua_pushasciistring(L, name);<br>    LuaAPI.lua_pushstdcallcfunction(L, func);<br>    LuaAPI.lua_rawset(L, idx);  <span class="hljs-comment">// 将 idx 指向的表中添加键值对 name = func</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Utils.EndObjectRegister</code>，结束对类的非静态值的注册。主要逻辑是为元表生成 <code>__index</code> 元方法和 <code>__newindex</code> 元方法，这也是 Lua 调用 C# 的核心所在</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EndObjectRegister</span>(<span class="hljs-params">Type type, RealStatePtr L, ObjectTranslator translator, LuaCSFunction csIndexer,</span></span><br><span class="hljs-params"><span class="hljs-function">    LuaCSFunction csNewIndexer, Type base_type, LuaCSFunction arrayIndexer, LuaCSFunction arrayNewIndexer</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> top = LuaAPI.lua_gettop(L);<br>    <span class="hljs-built_in">int</span> meta_idx = abs_idx(top, OBJ_META_IDX);<br>    <span class="hljs-built_in">int</span> method_idx = abs_idx(top, METHOD_IDX);<br>    <span class="hljs-built_in">int</span> getter_idx = abs_idx(top, GETTER_IDX);<br>    <span class="hljs-built_in">int</span> setter_idx = abs_idx(top, SETTER_IDX);<br><br>    <span class="hljs-comment">//begin index gen</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__index&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, method_idx);  <span class="hljs-comment">// 1. 压入 methods 表</span><br>    LuaAPI.lua_pushvalue(L, getter_idx);  <span class="hljs-comment">// 2. 压入 getters 表</span><br><br>    <span class="hljs-keyword">if</span> (csIndexer == <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        LuaAPI.lua_pushstdcallcfunction(L, csIndexer);  <span class="hljs-comment">// 3. 压入 csindexer</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    translator.Push(L, type == <span class="hljs-literal">null</span> ? base_type : type.BaseType());  <span class="hljs-comment">// 4. 压入 base</span><br><br>    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  <span class="hljs-comment">// 5. 压入 indexfuncs</span><br>    <span class="hljs-keyword">if</span> (arrayIndexer == <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        LuaAPI.lua_pushstdcallcfunction(L, arrayIndexer);  <span class="hljs-comment">// 6. 压入 arrayindexer</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    LuaAPI.gen_obj_indexer(L);  <span class="hljs-comment">// 生成__index 元方法</span><br><br>    <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);<br>        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<span class="hljs-comment">//store in lua indexs function tables</span><br>        translator.Push(L, type);<br>        LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>        LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaIndexs][type] = __index 函数</span><br>        LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    LuaAPI.lua_rawset(L, meta_idx);<br>    <span class="hljs-comment">//end index gen</span><br><br>    <span class="hljs-comment">//begin newindex gen</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, setter_idx);<br><br>    <span class="hljs-keyword">if</span> (csNewIndexer == <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        LuaAPI.lua_pushstdcallcfunction(L, csNewIndexer);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    translator.Push(L, type == <span class="hljs-literal">null</span> ? base_type : type.BaseType());<br><br>    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br><br>    <span class="hljs-keyword">if</span> (arrayNewIndexer == <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// ...</span><br>        LuaAPI.lua_pushstdcallcfunction(L, arrayNewIndexer);<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    LuaAPI.gen_obj_newindexer(L);  <span class="hljs-comment">// 生成__newindex 元方法</span><br><br>    <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);<br>        LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<span class="hljs-comment">//store in lua newindexs function tables</span><br>        translator.Push(L, type);<br>        LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>        LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaNewIndexs][type] = __newindex 函数</span><br>        LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    LuaAPI.lua_rawset(L, meta_idx);<br>    <span class="hljs-comment">//end new index gen</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> <code>__index</code>元方法是通过调用 <code>gen_obj_indexer</code> 获得的，在调用该方法前会依次压入 6 个参数（代码注释中有标注），<code>gen_obj_indexer</code>内部又会再压入一个 <code>nil</code> 值，用于为 <code>baseindex</code> 提前占位。共 7 个参数会作为 <code>upvalue</code> 关联到闭包 <code>obj_indexer</code>。<code>obj_indexer</code> 函数就是 <code>__index</code> 元方法，它的逻辑是当访问 <code>userdata[key]</code> 时，先依次查询之前通过 <code>RegisterFunc</code> 填充的 <code>methods</code>，<code>getters</code> 等表中是否存有对应 <code>key</code> 的包裹方法，如果有则直接使用，如果没有则递归在父类中查找。<code>__newindex</code>元方法是通过调用 <code>gen_obj_newindexer</code> 获得的，与<code>__index</code> 的获得原理类似，这里就不再列出了</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// xlua.c</span><br>LUA_API <span class="hljs-type">int</span> <span class="hljs-title function_">gen_obj_indexer</span><span class="hljs-params">(lua_State *L)</span> &#123;<br>    lua_pushnil(L);<br>    lua_pushcclosure(L, obj_indexer, <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//upvalue --- [1]: methods, [2]:getters, [3]:csindexer, [4]:base, [5]:indexfuncs, [6]:arrayindexer, [7]:baseindex</span><br><span class="hljs-comment">//param   --- [1]: obj, [2]: key</span><br>LUA_API <span class="hljs-type">int</span> <span class="hljs-title function_">obj_indexer</span><span class="hljs-params">(lua_State *L)</span> &#123;        <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">1</span>))) &#123;  <span class="hljs-comment">// 如果 methods 中有 key，则使用 methods[key]</span><br>        lua_pushvalue(L, <span class="hljs-number">2</span>);<br>        lua_gettable(L, lua_upvalueindex(<span class="hljs-number">1</span>));<br>        <span class="hljs-keyword">if</span> (!lua_isnil(L, <span class="hljs-number">-1</span>)) &#123;<span class="hljs-comment">//has method</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        lua_pop(L, <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">2</span>))) &#123;  <span class="hljs-comment">// 如果 getters 中 key，则调用 getters[key]</span><br>        lua_pushvalue(L, <span class="hljs-number">2</span>);<br>        lua_gettable(L, lua_upvalueindex(<span class="hljs-number">2</span>));<br>        <span class="hljs-keyword">if</span> (!lua_isnil(L, <span class="hljs-number">-1</span>)) &#123;<span class="hljs-comment">//has getter</span><br>            lua_pushvalue(L, <span class="hljs-number">1</span>);<br>            lua_call(L, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        lua_pop(L, <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">6</span>)) &amp;&amp; lua_type(L, <span class="hljs-number">2</span>) == LUA_TNUMBER) &#123;  <span class="hljs-comment">// 如果 arrayindexer 中有 key 且 key 是数字，则调用 arrayindexer[key]</span><br>        lua_pushvalue(L, lua_upvalueindex(<span class="hljs-number">6</span>));<br>        lua_pushvalue(L, <span class="hljs-number">1</span>);<br>        lua_pushvalue(L, <span class="hljs-number">2</span>);<br>        lua_call(L, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">3</span>))) &#123;  <span class="hljs-comment">// 如果 csindexer 中有 key，则调用 csindexer[key]</span><br>        lua_pushvalue(L, lua_upvalueindex(<span class="hljs-number">3</span>));<br>        lua_pushvalue(L, <span class="hljs-number">1</span>);<br>        lua_pushvalue(L, <span class="hljs-number">2</span>);<br>        lua_call(L, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span> (lua_toboolean(L, <span class="hljs-number">-2</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        lua_pop(L, <span class="hljs-number">2</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">4</span>))) &#123;  <span class="hljs-comment">// 递归向上在 base 中查找</span><br>        lua_pushvalue(L, lua_upvalueindex(<span class="hljs-number">4</span>));<br>        <span class="hljs-keyword">while</span>(!lua_isnil(L, <span class="hljs-number">-1</span>)) &#123;<br>            lua_pushvalue(L, <span class="hljs-number">-1</span>);<br>            lua_gettable(L, lua_upvalueindex(<span class="hljs-number">5</span>));<br>            <span class="hljs-keyword">if</span> (!lua_isnil(L, <span class="hljs-number">-1</span>)) <span class="hljs-comment">// found</span><br>            &#123;<br>                lua_replace(L, lua_upvalueindex(<span class="hljs-number">7</span>)); <span class="hljs-comment">//baseindex = indexfuncs[base]</span><br>                lua_pop(L, <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            lua_pop(L, <span class="hljs-number">1</span>);<br>            lua_getfield(L, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;BaseType&quot;</span>);<br>            lua_remove(L, <span class="hljs-number">-2</span>);<br>        &#125;<br>        lua_pushnil(L);<br>        lua_replace(L, lua_upvalueindex(<span class="hljs-number">4</span>));<span class="hljs-comment">//base = nil</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!lua_isnil(L, lua_upvalueindex(<span class="hljs-number">7</span>))) &#123;  <br>        lua_settop(L, <span class="hljs-number">2</span>);<br>        lua_pushvalue(L, lua_upvalueindex(<span class="hljs-number">7</span>));  <br>        lua_insert(L, <span class="hljs-number">1</span>);<br>        lua_call(L, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 调用父类的__index，indexfuncs[base](obj, key)</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><code>Utils.BeginClassRegister</code>，在对类的静态值（例如静态变量，静态方法等）进行注册前做一些准备工作。主要是为类生成对应的 <code>cls_table</code> 表，以及提前创建好 <code>static_getter</code> 表与 <code>static_setter</code> 表，后续用来存放静态字段对应的 <code>get</code> 和<code>set</code>包裹方法。注意这里还会为 <code>cls_table</code> 设置元表<code>meta_table</code></p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">BeginClassRegister</span>(<span class="hljs-params">Type type, RealStatePtr L, LuaCSFunction creator, <span class="hljs-built_in">int</span> class_field_count,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-built_in">int</span> static_getter_count, <span class="hljs-built_in">int</span> static_setter_count</span>)</span><br>&#123;<br>    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>    LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, class_field_count);<br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;UnderlyingSystemType&quot;</span>);<br>    translator.PushAny(L, type);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);<br><br>    <span class="hljs-built_in">int</span> cls_table = LuaAPI.lua_gettop(L);<br><br>    SetCSTable(L, type, cls_table);<br><br>    LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-built_in">int</span> meta_table = LuaAPI.lua_gettop(L);<br>    <span class="hljs-keyword">if</span> (creator != <span class="hljs-literal">null</span>)<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__call&quot;</span>);<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> GEN_CODE_MINIMIZE</span><br>        translator.PushCSharpWrapper(L, creator);<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        LuaAPI.lua_pushstdcallcfunction(L, creator);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (static_getter_count == <span class="hljs-number">0</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, static_getter_count);   <span class="hljs-comment">// 创建好 static_getter 表</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (static_setter_count == <span class="hljs-number">0</span>)<br>    &#123;<br>        LuaAPI.lua_pushnil(L);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, static_setter_count);  <span class="hljs-comment">// 创建好 static_setter 表</span><br>    &#125;<br>    LuaAPI.lua_pushvalue(L, meta_table);<br>    LuaAPI.lua_setmetatable(L, cls_table);  <span class="hljs-comment">// 设置元表</span><br>&#125;<br></code></pre></td></tr></table></figure><p> <code>cls_table</code> 表是根据类的命名空间名逐层添加到注册表中的，主要是通过 <code>SetCSTable</code> 实现</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SetCSTable</span>(<span class="hljs-params">RealStatePtr L, Type type, <span class="hljs-built_in">int</span> cls_table</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> oldTop = LuaAPI.lua_gettop(L);<br>    cls_table = abs_idx(oldTop, cls_table);<br>    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br><br>    List&lt;<span class="hljs-built_in">string</span>&gt; path = getPathOfType(type);<br><br>    <span class="hljs-comment">// 对于 A.B.C 来说</span><br><br>    <span class="hljs-comment">// for 循环处理 A.B</span><br>    <span class="hljs-comment">// 1. 注册表 [xlua_csharp_namespace][A] = &#123;&#125; 且出栈 注册表 [xlua_csharp_namespace]</span><br>    <span class="hljs-comment">// 2. 注册表 [xlua_csharp_namespace][A][B] = &#123;&#125; 且出栈 注册表 [xlua_csharp_namespace][A]</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; path.Count - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, path[i]);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> != LuaAPI.xlua_pgettable(L, <span class="hljs-number">-2</span>))<br>        &#123;<br>            <span class="hljs-keyword">var</span> err = LuaAPI.lua_tostring(L, <span class="hljs-number">-1</span>);<br>            LuaAPI.lua_settop(L, oldTop);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;SetCSTable for [&quot;</span> + type + <span class="hljs-string">&quot;] error: &quot;</span> + err);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (LuaAPI.lua_isnil(L, <span class="hljs-number">-1</span>))  <span class="hljs-comment">// 如果 注册表 [xlua_csharp_namespace] 中没有 key path[i] , 则添加一个 path[i] = &#123;&#125; 键值对</span><br>        &#123;<br>            LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>            LuaAPI.lua_createtable(L, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>            LuaAPI.xlua_pushasciistring(L, path[i]);<br>            LuaAPI.lua_pushvalue(L, <span class="hljs-number">-2</span>);<br>            LuaAPI.lua_rawset(L, <span class="hljs-number">-4</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!LuaAPI.lua_istable(L, <span class="hljs-number">-1</span>))<br>        &#123;<br>            LuaAPI.lua_settop(L, oldTop);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot;SetCSTable for [&quot;</span> + type + <span class="hljs-string">&quot;] error: ancestors is not a table!&quot;</span>);<br>        &#125;<br>        LuaAPI.lua_remove(L, <span class="hljs-number">-2</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理 C</span><br>    <span class="hljs-comment">// 注册表 [xlua_csharp_namespace][A][B][C] = cls_table 且出栈 [xlua_csharp_namespace][A][B][C]</span><br>    LuaAPI.xlua_pushasciistring(L, path[path.Count - <span class="hljs-number">1</span>]);<br>    LuaAPI.lua_pushvalue(L, cls_table);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 在 注册表 [xlua_csharp_namespace] 中添加键值对 [type 对应的 lua 代理 userdata] = cls_table</span><br>    LuaAPI.xlua_pushasciistring(L, LuaEnv.CSHARP_NAMESPACE);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    ObjectTranslatorPool.Instance.Find(L).PushAny(L, type);<br>    LuaAPI.lua_pushvalue(L, cls_table);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 以 <code>A.B.C</code> 类为例，将在 Lua 注册表中添加以下表结构，而 Lua 注册表 <code>xlua_csharp_namespace</code> 实际上对应的就是 CS 全局表，所以要在 xLua 中访问 C# 类时才可以直接使用 <code>CS.A.B.C</code> 这样的形式</p> <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">Lua 注册表 = &#123;<br>    xlua_csharp_namespace = &#123;  <span class="hljs-comment">-- 就是 CS 全局表</span><br>        A = &#123;<br>            B = &#123;<br>                C = cls_table<br>            &#125;<br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多个 <code>Utils.RegisterFunc</code>，与<code>BeginObjectRegister</code> 到<code>EndObjectRegister</code>之间的 <code>RegisterFunc</code> 作用相同，将类的每个静态值对应的包裹方法注册到对应的 Lua 表中。静态变量对应的 get 和 set 包裹方法会被分别注册到 <code>static_getter</code> 表和 <code>static_setter</code> 表（只读的静态变量除外）</p></li><li><p><code>Utils.EndClassRegister</code>，结束对类的静态值的注册。与 <code>EndObjectRegister</code> 类似，但它是为 <code>cls_table</code> 的元表 <code>meta_tabl</code> 设置 <code>__index</code> 元方法和 <code>__newindex</code> 元方法</p> <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EndClassRegister</span>(<span class="hljs-params">Type type, RealStatePtr L, ObjectTranslator translator</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> top = LuaAPI.lua_gettop(L);<br>    <span class="hljs-built_in">int</span> cls_idx = abs_idx(top, CLS_IDX);<br>    <span class="hljs-built_in">int</span> cls_getter_idx = abs_idx(top, CLS_GETTER_IDX);<br>    <span class="hljs-built_in">int</span> cls_setter_idx = abs_idx(top, CLS_SETTER_IDX);<br>    <span class="hljs-built_in">int</span> cls_meta_idx = abs_idx(top, CLS_META_IDX);<br><br>    <span class="hljs-comment">//begin cls index</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__index&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, cls_getter_idx);<br>    LuaAPI.lua_pushvalue(L, cls_idx);<br>    translator.Push(L, type.BaseType());<br>    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  <br>    LuaAPI.gen_cls_indexer(L);<br><br>    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<span class="hljs-comment">//store in lua indexs function tables  </span><br>    translator.Push(L, type);<br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaClassIndexs][type] = __index 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>    LuaAPI.lua_rawset(L, cls_meta_idx);<br>    <span class="hljs-comment">//end cls index</span><br><br>    <span class="hljs-comment">//begin cls newindex</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, cls_setter_idx);<br>    translator.Push(L, type.BaseType());<br>    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    LuaAPI.gen_cls_newindexer(L);<br><br>    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<span class="hljs-comment">//store in lua newindexs function tables</span><br>    translator.Push(L, type);<br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaClassNewIndexs][type] = __newindex 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br><br>    LuaAPI.lua_rawset(L, cls_meta_idx);<br>    <span class="hljs-comment">//end cls newindex</span><br><br>    LuaAPI.lua_pop(L, <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>上述 6 个部分的代码量比较大，逻辑也比较复杂，到这里有必要做一个总结</p><p>生成代码会为类的非静态值都生成对应的包裹方法，并将包裹方法以 <code>key = func</code> 的形式注册到不同的表中。<code>userdata</code>元表的 <code>__index</code> 和<code>__newindex</code>负责从这不同的表中找到对应 <code>key</code> 的包裹方法，最终通过调用包裹方法实现对 C# 对象的控制</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- lua 测试代码</span><br><span class="hljs-keyword">local</span> obj = CS.TestXLua()<br>obj.Name = <span class="hljs-string">&quot;test&quot;</span>  <span class="hljs-comment">-- 赋值操作将触发 obj 元表的__newindex，__newindex 在 setter 表中找到 Name 对应的 set 包裹方法_s_set_Name，然后通过调用_s_set_Name 方法设置了 TestXLua 对象的 Name 属性为 &quot;test&quot;</span><br></code></pre></td></tr></table></figure><p>生成代码还会为每个类以命名空间为层次结构生成 <code>cls_table</code> 表。与类的非静态值相同，生成代码也会为类的静态值都生成对应的包裹方法并注册到不同的表中（注意这里有些区别，类的静态方法会被直接注册到 <code>cls_table</code> 表中）。而 <code>cls_table</code> 元表的 <code>__index</code> 和<code>__newindex</code>负责从这不同的表中找到对应 <code>key</code> 的包裹方法，最终通过调用包裹方法实现对 C# 类的控制</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- lua 测试代码</span><br>CS.TestXLua.Test2()  <span class="hljs-comment">-- CS.TestXLua 获取到 TestXLua 类对应的 cls_table，由于 Test2 是静态方法，在 cls_table 中可以直接拿到其对应的包裹方法_m_Test2_xlua_st_，然后通过调用_m_Test2_xlua_st_而间接调用了 TestXLua 类的 Test2 方法</span><br></code></pre></td></tr></table></figure><h3 id="使用反射填充元表"><a href="# 使用反射填充元表" class="headerlink" title="使用反射填充元表"></a>使用反射填充元表 </h3><p> 当没有生成代码时，会使用反射进行注册，与生成代码进行注册的逻辑基本相同。通过反射获取到类的各个静态值和非静态值，然后分别注册到不同的表中，以及填充 <code>__index</code> 和<code>__newindex</code>元方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ReflectionWrap</span>(<span class="hljs-params">RealStatePtr L, Type type, <span class="hljs-built_in">bool</span> privateAccessible</span>)</span><br>&#123;<br>    LuaAPI.lua_checkstack(L, <span class="hljs-number">20</span>);<br><br>    <span class="hljs-built_in">int</span> top_enter = LuaAPI.lua_gettop(L);<br>    ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>    <span class="hljs-comment">//create obj meta table</span><br>    LuaAPI.luaL_getmetatable(L, type.FullName);<br>    <span class="hljs-keyword">if</span> (LuaAPI.lua_isnil(L, <span class="hljs-number">-1</span>))<br>    &#123;<br>        LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>        LuaAPI.luaL_newmetatable(L, type.FullName);<br>    &#125;<br>    <span class="hljs-comment">// 为元表添加 xlua_tag 标志</span><br>    LuaAPI.lua_pushlightuserdata(L, LuaAPI.xlua_tag());<br>    LuaAPI.lua_pushnumber(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 元表 [xlua_tag] = 1</span><br>    <span class="hljs-built_in">int</span> obj_meta = LuaAPI.lua_gettop(L);  <br><br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> cls_meta = LuaAPI.lua_gettop(L);<br><br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> obj_field = LuaAPI.lua_gettop(L);<br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> obj_getter = LuaAPI.lua_gettop(L);<br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> obj_setter = LuaAPI.lua_gettop(L);<br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> cls_field = LuaAPI.lua_gettop(L);<br>    <span class="hljs-comment">//set cls_field to namespace</span><br>    SetCSTable(L, type, cls_field);<br>    <span class="hljs-comment">//finish set cls_field to namespace</span><br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> cls_getter = LuaAPI.lua_gettop(L);<br>    LuaAPI.lua_newtable(L);<br>    <span class="hljs-built_in">int</span> cls_setter = LuaAPI.lua_gettop(L);<br><br>    LuaCSFunction item_getter;<br>    LuaCSFunction item_setter;<br>    makeReflectionWrap(L, type, cls_field, cls_getter, cls_setter, obj_field, obj_getter, obj_setter, obj_meta,<br>        <span class="hljs-keyword">out</span> item_getter, <span class="hljs-keyword">out</span> item_setter, privateAccessible ? (BindingFlags.Public | BindingFlags.NonPublic) : BindingFlags.Public);<br><br>    <span class="hljs-comment">// init obj metatable</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__gc&quot;</span>);<br>    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);<br>    LuaAPI.lua_rawset(L, obj_meta);<br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__tostring&quot;</span>);<br>    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.ToStringMeta);<br>    LuaAPI.lua_rawset(L, obj_meta);<br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__index&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, obj_field);  <span class="hljs-comment">// 1.upvalue methods = obj_field</span><br>    LuaAPI.lua_pushvalue(L, obj_getter);  <span class="hljs-comment">// 2.upvalue getters = obj_getter</span><br>    translator.PushFixCSFunction(L, item_getter);  <span class="hljs-comment">// 3.upvalue csindexer = item_getter</span><br>    translator.PushAny(L, type.BaseType());  <span class="hljs-comment">// 压入 BaseType，4.upvalue base</span><br>    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  <span class="hljs-comment">// 5.upvalue indexfuncs = 注册表 [LuaIndexs]</span><br>    LuaAPI.lua_pushnil(L);  <span class="hljs-comment">// 6.upvalue arrayindexer = nil</span><br>    LuaAPI.gen_obj_indexer(L);  <span class="hljs-comment">// 生成__index 函数</span><br>    <span class="hljs-comment">//store in lua indexs function tables</span><br>    LuaAPI.xlua_pushasciistring(L, LuaIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);  <br>    translator.Push(L, type);  <span class="hljs-comment">// 压入 type</span><br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaIndexs][type] = __index 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, obj_meta); <span class="hljs-comment">// set __index  即 obj_meta[&quot;__index&quot;] = 生成的__index 函数</span><br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, obj_setter);<br>    translator.PushFixCSFunction(L, item_setter);<br>    translator.Push(L, type.BaseType());<br>    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    LuaAPI.lua_pushnil(L);<br>    LuaAPI.gen_obj_newindexer(L);<br>    <span class="hljs-comment">//store in lua newindexs function tables</span><br>    LuaAPI.xlua_pushasciistring(L, LuaNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    translator.Push(L, type);<br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaNewIndexs][type] = __newindex 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, obj_meta); <span class="hljs-comment">// set __newindex</span><br>                                    <span class="hljs-comment">//finish init obj metatable</span><br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;UnderlyingSystemType&quot;</span>);<br>    translator.PushAny(L, type);<br>    LuaAPI.lua_rawset(L, cls_field);  <span class="hljs-comment">// cls_field[&quot;UnderlyingSystemType&quot;] = type  ， 记录类的基础类型</span><br><br>    <span class="hljs-keyword">if</span> (type != <span class="hljs-literal">null</span> &amp;&amp; type.IsEnum())<br>    &#123;<br>        LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__CastFrom&quot;</span>);<br>        translator.PushFixCSFunction(L, genEnumCastFrom(type));<br>        LuaAPI.lua_rawset(L, cls_field);<br>    &#125;<br><br>    <span class="hljs-comment">//init class meta</span><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__index&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, cls_getter);<br>    LuaAPI.lua_pushvalue(L, cls_field);<br>    translator.Push(L, type.BaseType());<br>    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    LuaAPI.gen_cls_indexer(L);<br>    <span class="hljs-comment">//store in lua indexs function tables</span><br>    LuaAPI.xlua_pushasciistring(L, LuaClassIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    translator.Push(L, type);<br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 注册表 [LuaClassIndexs][type] = __index 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, cls_meta); <span class="hljs-comment">// set __index </span><br><br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__newindex&quot;</span>);<br>    LuaAPI.lua_pushvalue(L, cls_setter);<br>    translator.Push(L, type.BaseType());<br>    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    LuaAPI.gen_cls_newindexer(L);<br>    <span class="hljs-comment">//store in lua newindexs function tables</span><br>    LuaAPI.xlua_pushasciistring(L, LuaClassNewIndexsFieldName);<br>    LuaAPI.lua_rawget(L, LuaIndexes.LUA_REGISTRYINDEX);<br>    translator.Push(L, type);<br>    LuaAPI.lua_pushvalue(L, <span class="hljs-number">-3</span>);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// // 注册表 [LuaClassNewIndexs][type] = __newindex 函数</span><br>    LuaAPI.lua_pop(L, <span class="hljs-number">1</span>);<br>    LuaAPI.lua_rawset(L, cls_meta); <span class="hljs-comment">// set __newindex</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="调用 -C- 方法时参数的传递"><a href="# 调用 -C- 方法时参数的传递" class="headerlink" title="调用 C# 方法时参数的传递"></a>调用 C# 方法时参数的传递 </h3><p> 先来解决前面遗留的一个问题，对于类的静态值或是非静态值为什么都需要生成对应的包裹方法？其实包裹方法就是用来处理参数传递问题的。</p><p>为了正确的和 Lua 通讯，C 函数已经定义好了协议。这个协议定义了参数以及返回值传递方法：C 函数通过 Lua 中的栈来接受参数，参数以正序入栈（第一个参数首先入栈）。因此，当函数开始的时候，<code>lua_gettop(L)</code>可以返回函数收到的参数个数。第一个参数（如果有的话）在索引 1 的地方，而最后一个参数在索引 <code>lua_gettop(L)</code> 处。当需要向 Lua 返回值的时候，C 函数只需要把它们以正序压到堆栈上（第一个返回值最先压入），然后返回这些返回值的个数。在这些返回值之下的，堆栈上的东西都会被 Lua 丢掉。和 Lua 函数一样，从 Lua 中调用 C 函数可以有很多返回值。<br>也就是说，Lua 这边调用 C 函数时的参数会被自动的压栈，这套机制 Lua 内部已经实现好了。文章开头也提到，C# 可以借助 C/C++ 来与 Lua 进行数据通信，所以 C# 需要通过 C API 获取到 Lua 传递过来的参数，而这个逻辑就被封装在了包裹方法中。以 <code>TestXLua</code> 的<code>Test1</code>方法为例，它需要一个 <code>int</code> 参数。所以它的包裹方法需要通过 C API 获取到一个 <code>int</code> 参数，然后再使用这个参数去调用真正的方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _m_Test1(RealStatePtr L)<br>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, <span class="hljs-number">1</span>);<br>        &#123;<br>            <span class="hljs-built_in">int</span> _a = LuaAPI.xlua_tointeger(L, <span class="hljs-number">2</span>);  <span class="hljs-comment">// 获取到 int 参数</span><br>            gen_to_be_invoked.Test1(_a);  <span class="hljs-comment">// 调用真正的 Test1 方法</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>        <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也解释了为什么需要为类的属性生成对应的 <code>get</code> 和<code>set</code>方法，因为只有将 Lua 的访问或赋值操作转换成函数调用形式时，参数才能利用函数调用机制被自动的压栈，从而传递给 C#</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- lua 测试代码</span><br>obj.Name = <span class="hljs-string">&quot;test&quot;</span>  <span class="hljs-comment">-- 赋值操作</span><br>setter[<span class="hljs-string">&quot;Name&quot;</span>](<span class="hljs-string">&quot;test&quot;</span>)  <span class="hljs-comment">-- 函数调用形式</span><br></code></pre></td></tr></table></figure><p>这里再提一下函数重载的问题，因为 C# 是支持重载的，所以会存在多个同名函数，但参数不同的情况。对于这种情况，只能通过同名函数被调用时传递的参数情况来判断到底应该调用哪个函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">LuaCallCSharp</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TestXLua</span><br>&#123;<br>    <span class="hljs-comment">// 函数重载 Test1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span>&#123;<br>    &#125;<br>    <span class="hljs-comment">// 函数重载 Test1</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test1</span>(<span class="hljs-params"><span class="hljs-built_in">bool</span> b</span>)</span>&#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 为 Test1 生成的包裹方法</span><br>[<span class="hljs-meta">MonoPInvokeCallbackAttribute(typeof(LuaCSFunction))</span>]<br><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> _m_Test1(RealStatePtr L)<br>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>        TestXLua gen_to_be_invoked = (TestXLua)translator.FastGetCSObj(L, <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">int</span> gen_param_count = LuaAPI.lua_gettop(L);<br>        <span class="hljs-keyword">if</span>(gen_param_count == <span class="hljs-number">2</span>&amp;&amp; LuaTypes.LUA_TNUMBER == LuaAPI.lua_type(L, <span class="hljs-number">2</span>))  <span class="hljs-comment">// 根据参数数量与类型判断调用哪个方法</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> _a = LuaAPI.xlua_tointeger(L, <span class="hljs-number">2</span>);<br>            gen_to_be_invoked.Test1(_a);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(gen_param_count == <span class="hljs-number">2</span>&amp;&amp; LuaTypes.LUA_TBOOLEAN == LuaAPI.lua_type(L, <span class="hljs-number">2</span>))  <span class="hljs-comment">// 根据参数数量与类型判断调用哪个方法</span><br>        &#123; <br>            <span class="hljs-built_in">bool</span> _b = LuaAPI.lua_toboolean(L, <span class="hljs-number">2</span>);<br>            gen_to_be_invoked.Test1(_b);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span>(System.Exception gen_e) &#123;<br>        <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception:&quot;</span> + gen_e);<br>    &#125;<br>    <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;invalid arguments to TestXLua.Test1!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><p>C# 和 Lua 都是有自动垃圾回收机制的，并且相互是无感知的。如果传递到 Lua 的 C# 对象被 C# 自动回收掉了，而 Lua 这边仍毫不知情继续使用，则必然会导致无法预知的错误。所以基本原则是传递到 Lua 的 C#对象，C# 不能自动回收，只能 Lua 在确定不再使用后通知 C# 进行回收 <br> 为了保证 C# 不会自动回收对象，所有传递给 Lua 的对象都会被 <code>objects</code> 保持引用。真实传递给 Lua 的对象索引就是对象在 <code>objects</code> 中的索引 <br>Lua 这边为对象索引建立的<code>userdata</code> 会被保存在缓存表中，而缓存表的引用模式被设置为弱引用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br>LuaAPI.lua_newtable(L);  <span class="hljs-comment">// 创建缓存表</span><br>LuaAPI.lua_newtable(L);  <span class="hljs-comment">// 创建元表</span><br>LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__mode&quot;</span>);<br>LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;v&quot;</span>);<br>LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 元表 [__mode] = v，表示这张表的所有值皆为弱引用</span><br>LuaAPI.lua_setmetatable(L, <span class="hljs-number">-2</span>);  <span class="hljs-comment">// 为缓存表设置元表</span><br>cacheRef = LuaAPI.luaL_ref(L, LuaIndexes.LUA_REGISTRYINDEX);<br></code></pre></td></tr></table></figure><p>当 Lua 这边不再引用这个 <code>userdata</code> 时，<code>userdata</code>会被从缓存表中移除，Lua GC 时会回收这个 userdata，回收之前又会调用 <code>userdata</code> 元表的 <code>__gc</code> 方法，以此来通知 C#，”我 Lua 这边不再使用这个对象了，你该回收可以回收了”。在 <code>BeginObjectRegister</code>方法内部，会为 <code>userdata</code> 的元表添加 <code>__gc</code> 方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Utils.cs BeginObjectRegister 方法</span><br><span class="hljs-keyword">if</span> ((type == <span class="hljs-literal">null</span> || !translator.HasCustomOp(type)) &amp;&amp; type != <span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">decimal</span>))<br>&#123;<br>    LuaAPI.xlua_pushasciistring(L, <span class="hljs-string">&quot;__gc&quot;</span>);<br>    LuaAPI.lua_pushstdcallcfunction(L, translator.metaFunctions.GcMeta);<br>    LuaAPI.lua_rawset(L, <span class="hljs-number">-3</span>);  <span class="hljs-comment">// 为元表设置__gc 方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>translator.metaFunctions.GcMeta</code>实际上就是 <code>StaticLuaCallbacks</code> 的<code>LuaGC</code>方法</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// StaticLuaCallbacks.cs</span><br>[<span class="hljs-meta">MonoPInvokeCallback(typeof(LuaCSFunction))</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">LuaGC</span>(<span class="hljs-params">RealStatePtr L</span>)</span><br>&#123;<br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> udata = LuaAPI.xlua_tocsobj_safe(L, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (udata != <span class="hljs-number">-1</span>)<br>        &#123;<br>            ObjectTranslator translator = ObjectTranslatorPool.Instance.Find(L);<br>            <span class="hljs-keyword">if</span> (translator != <span class="hljs-literal">null</span> )<br>            &#123;<br>                translator.collectObject(udata);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e)<br>    &#123;<br>        <span class="hljs-keyword">return</span> LuaAPI.luaL_error(L, <span class="hljs-string">&quot;c# exception in LuaGC:&quot;</span> + e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>LuaGC</code>方法又会调用 <code>collectObject</code> 方法。在 <code>collectObject</code> 方法内部会将对象从 <code>objects</code> 移除，从而使对象不再被固定引用，能够被 C# GC 正常回收</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ObjectTranslator.cs</span><br><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collectObject</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> obj_index_to_collect</span>)</span><br>&#123;<br>    <span class="hljs-built_in">object</span> o;<br>    <br>    <span class="hljs-keyword">if</span> (objects.TryGetValue(obj_index_to_collect, <span class="hljs-keyword">out</span> o))<br>    &#123;<br>        objects.Remove(obj_index_to_collect);<br>        <br>        <span class="hljs-keyword">if</span> (o != <span class="hljs-literal">null</span>)<br>        &#123;<br>            <span class="hljs-built_in">int</span> obj_index;<br>            <span class="hljs-comment">//lua gc 是先把 weak table 移除后再调用__gc，这期间同一个对象可能再次 push 到 lua，关联到新的 index</span><br>            <span class="hljs-built_in">bool</span> is_enum = o.GetType().IsEnum();<br>            <span class="hljs-keyword">if</span> ((is_enum ? enumMap.TryGetValue(o, <span class="hljs-keyword">out</span> obj_index) : reverseMap.TryGetValue(o, <span class="hljs-keyword">out</span> obj_index))<br>                &amp;&amp; obj_index == obj_index_to_collect)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (is_enum)<br>                &#123;<br>                    enumMap.Remove(o);<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    reverseMap.Remove(o);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="C#" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
    <category term="xLua" scheme="https://silhouettesforyou.github.io/tags/xLua/"/>
    
  </entry>
  
  <entry>
    <title>ProtoBuf 的基本原理</title>
    <link href="https://silhouettesforyou.github.io/2024/06/04/77811b82e50c/"/>
    <id>https://silhouettesforyou.github.io/2024/06/04/77811b82e50c/</id>
    <published>2024-06-04T06:28:00.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note note-light">            <p>🔗 <a href="https://sunyunqiang.com/blog/protobuf_encode/">原文链接</a></p>          </div><p>Protobuf 是由 Google 设计的一种高效、轻量级的信息描述格式，起初是在 Google 内部使用，后来被开放出来，它具有语言中立、平台中立、高效、可扩展等特性，它非常适合用来做数据存储、RPC 数据交换等。与 json、xml 相比，Protobuf 的编码长度更短、传输效率更高，其实严格意义上讲，json、xml 并非是一种「编码」, 而只能称之为「格式」, json、xml 的内容本身都是字符形式，它们的编码采用的是 ASCII 编码，本文讲述 Protobuf 的底层编码原理，以便于了解 Protobuf 为什么编码长度短并且扩展性强，与此同时我们也将了解到它有哪些不足<br>Protobuf 的一个典型应用场景便是做通信的数据交换格式，它在通信管道上是以纯二进制的形式进行传输，发送端使用编码器将数据序列化为二进制，接收端使用解码器将收到的二进制流进行反序列化从而取得原始信息，因此当对通信管道进行抓包时无法获知数据的详细内容，事实上，同一段 Protobuf 的二进制数据流，在接收端使用不同的解码格式进行解码，可能得到完全不同的信息。在了解 Protobuf 的底层编码细节之前，需要首先了解 Protobuf 所用到的两种主要的编码方式，它们分别是 Varints 编码和 Zigzag 编码</p><h3 id="1-1-Varints- 编码"><a href="#1-1-Varints- 编码" class="headerlink" title="1.1 Varints 编码"></a>1.1 Varints 编码 </h3><p> 通常来说，普通的 int 数据类型，无论其值的大小，所占用的存储空间都是相等的，这点可以引起人们的思考，是否可以根据数值的大小来动态地占用存储空间，使得值比较小的数字占用较少的字节数，值相对比较大的数字占用较多的字节数，这便是变长整型编码的基本思想，采用变长整型编码的数字，其占用的字节数不是完全一致的，为了达到这一点，Varints 编码使用每个字节的最高有效位作为标志位，而剩余的 7 位以二进制补码的形式来存储数字值本身，当最高有效位为 1 时，代表其后还跟有字节，当最高有效位为 0 时，代表已经是该数字的最后的一个字节，在 Protobuf 中，使用的是 Base128 Varints 编码，之所以叫这个名字原因即是在这种方式中，使用 7 bit 来存储数字，在 Protobuf 中，Base128 Varints 采用的是小端序，即数字的低位存放在高地址，举例来看，对于数字 1, 我们假设 int 类型占 4 个字节，以标准的整型存储，其二进制表示应为</p><p>00000000 00000000 00000000 00000001</p><p>可见，只有最后一个字节存储了有效数值，前 3 个字节都是 0, 若采用 Varints 编码，其二进制形式为</p><p>00000001</p><p>因为其没有后续字节，因此其最高有效位为 0, 其余的 7 位以补码形式存放 1, 再比如数字 666, 其以标准的整型存储，其二进制表示为</p><p>00000000 00000000 00000010 10011010</p><p>而采用 Varints 编码，其二进制形式为</p><p>10011010 00000101</p><p>我们可以尝试来复原一下上面这个 Base128 Varints 编码的二进制串，首先看最高有效位，高 8 位的最高有效位为 1, 代表其后还跟有有效字节，低 8 位的最高有效位为 0, 代表其已是最后一个字节，由于 Protobuf 采用小端字节序存储数据，因此我们移除两个字节的最高有效位，并交换字节序便得到</p><p>1010011010</p><p>转换为十进制，即是数字 666</p><p>从上面的编码解码过程可以看出，可变长整型编码对于不同大小的数字，其所占用的存储空间是不同的，编码思想与 CPU 的间接寻址原理相似，都是用一比特来标识是否走到末尾，但采用这种方式存储数字，也有一个相对不好的点便是，无法对一个序列的数值进行随机查找，因为每个数字所占用的存储空间不是等长的，因此若要获得序列中的第 N 个数字，无法像等长存储那样在查找之前直接计算出 Offset, 只能从头开始顺序查找</p><h3 id="1-2-Zigzag- 编码"><a href="#1-2-Zigzag- 编码" class="headerlink" title="1.2 Zigzag 编码"></a>1.2 Zigzag 编码</h3><p>Varints 编码的实质在于去掉数字开头的 0, 因此可缩短数字所占的存储字节数，在上面的例子中，我们只举例说明了正数的 Varints 编码，但如果数字为负数，则采用 Varints 编码会恒定占用 10 个字节，原因在于负数的符号位为 1, 对于负数其从符号位开始的高位均为 1, 在 Protobuf 的具体实现中，会将此视为一个很大的无符号数，以 Go 语言的实现为例，对于 int32 类型的 pb 字段，对于如下定义的 proto</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = &quot;proto3&quot;;<br>package pbTest;<br><br>message Request &#123;<br>    int32 a = 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>Request 中包含类型为 int32 类型的字段，当 a 为负数时，其序列化之后将恒定占用 10 个字节，我们可以使用如下的测试代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := pbTest.Request&#123;<br>        A: <span class="hljs-number">-5</span>,<br>    &#125;<br>    bytes, err := proto.Marshal(&amp;a)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(fmt.Sprintf(<span class="hljs-string">&quot;%08b&quot;</span>, bytes))<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 int32 类型的数字 -5, 其序列化之后的二进制为</p><center>    <img src="/2024/06/04/77811b82e50c/protobuf-zig-zag.png" alt></center><p>究其原因在于 Protobuf 的内部将 int32 类型的负数转换为 uint64 来处理，转换后的 uint64 数值的高位全为 1, 相当于是一个 8 字节的很大的无符号数，因此采用 Base128 Varints 编码后将恒定占用 10 个字节的空间，可见 Varints 编码对于表示负数毫无优势，甚至比普通的固定 32 位存储还要多占 4 个字节。Varints 编码的实质在于设法移除数字开头的 0 比特，而对于负数，由于其数字高位都是 1, 因此 Varints 编码在此场景下失效，Zigzag 编码便是为了解决这个问题，Zigzag 编码的大致思想是首先对负数做一次变换，将其映射为一个正数，变换以后便可以使用 Varints 编码进行压缩，这里关键的一点在于变换的算法，首先算法必须是可逆的，即可以根据变换后的值计算出原始值，否则就无法解码，同时要求变换算法要尽可能简单，以避免影响 Protobuf 编码、解码的速度，我们假设 n 是一个 32 位类型的数字，则 Zigzag 编码的计算方式为</p><p><code>(n &lt;&lt; 1) ^ (n &gt;&gt; 31)</code></p><p>要注意这里左边是逻辑移位，右边是算术移位，右边的含义实际是得到一个全 1 （对于负数） 或全 0 （对于正数）的比特序列，因为对于任意一个位数为 η 的有符号数 n, 其最高位为符号位，剩下的 η - 1 位为数字位，将其算术右移 η - 1 位，由于是算术移位，因此右移时左边产生的空位将由符号位来填充，进行 η - 1 次算术右移之后便得到 η 位与原先的符号位相等的序列，然后对两边按位异或便得到 Zigzag 编码，我们用一个图示来直观地说明 Zigzag 编码的设计思想，为了简化，我们假定数字是 16 位的，先来看负数的情形，假设数字为 -5, 其在内存中的形式为</p><p>11111111 11111011</p><p>首先对其进行一次逻辑左移，移位后空出的比特位由 0 填充</p><p>11111111 11110110</p><p>然后对原数字进行 15 次算术右移，得到 16 位全为原符号位（即 1) 的数字</p><p>11111111 11111111</p><p>然后对逻辑移位和算术移位的结果按位异或，便得到最终的 Zigzag 编码</p><p>00000000 00001001</p><p>可以看到，对负数使用 Zigzag 编码以后，其高位的 1 全部变成了 0, 这样以来我们便可以使用 Varints 编码进行进一步地压缩，再来看正数的情形，对于 16 位的正数 5, 其在内存中的存储形式为</p><p>00000000 00000101</p><p>我们按照与负数相同的处理方法，可以得到其 Zigzag 编码为</p><p>00000000 00001010</p><p>从上面的结果来看，无论是正数还是负数，经过 Zigzag 编码以后，数字高位都是 0, 这样以来，便可以进一步使用 Varints 编码进行数据压缩，即 Zigzag 编码在 Protobuf 中并不单独使用，而是配合 Varints 编码共同来进行数据压缩，Google 在 Protobuf 的官方文档中写道：<br>Google Protobuf<br>If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes long – it is, effectively, treated like a very large unsigned integer. If you use one of the signed types, the resulting varint uses ZigZag encoding, which is much more efficient.</p><p>在上面的讨论中，我们了解了 Protobuf 所使用的 Varints 编码和 Zigzag 编码的编码原理，本节我们来讨论 Protobuf 的数据组织方式，首先来看一个例子，假设客户端和服务端使用 protobuf 作为数据交换格式，proto 的具体定义为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = &quot;proto3&quot;;<br>package pbTest;<br><br>message Request &#123;<br>    int32 age = 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>Request 中包含了一个名称为 name 的字段，客户端和服务端双方都用同一份相同的 proto 文件是没有任何问题的，假设客户端自己将 proto 文件做了修改，修改后的 proto 文件如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax = &quot;proto3&quot;;<br>package pbTest;<br><br>message Request &#123;<br>    int32 age_test = 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这种情形下，服务端不修改应用程序仍能够正确地解码，原因在于序列化后的 Protobuf 没有使用字段名称，而仅仅采用了字段编号，与 json xml 等相比，Protobuf 不是一种完全自描述的协议格式，即接收端在没有 proto 文件定义的前提下是无法解码一个 protobuf 消息体的，与此相对的，json xml 等协议格式是完全自描述的，拿到了 json 消息体，便可以知道这段消息体中有哪些字段，每个字段的值分别是什么，其实对于客户端和服务端通信双方来说，约定好了消息格式之后完全没有必要在每一条消息中都携带字段名称，Protobuf 在通信数据中移除字段名称，这可以大大降低消息的长度，提高通信效率，Protobuf 进一步将通信线路上消息类型做了划分，如下表所示</p><center>    <img src="/2024/06/04/77811b82e50c/protobuf-message-type.png" alt></center><p>对于 int32, int64, uint32 等数据类型在序列化之后都会转为 Varints 编码，除去两种已标记为 deprecated 的类型，目前 Protobuf 在序列化之后的消息类型 (wire-type) 总共有 4 种，Protobuf 除了存储字段的值之外，还存储了字段的编号以及字段在通信线路上的格式类型 (wire-type), 具体的存储方式为</p><p><code>field_num &lt;&lt; 3 | wire type</code></p><p>即将字段标号逻辑左移 3 位，然后与该字段的 wire type 的编号按位或，在上表中可以看到，wire type 总共有 6 种类型，因此可以用 3 位二进制来标识，所以低 3 位实际上存储了其后所跟的数据的 wire type, 接收端可以利用这些信息，结合 proto 文件来解码消息结构体，我们以上面 proto 为例来看一段 Protobuf 实际序列化之后的完整二进制数据，假设 age 为 5, 由于 age 在 proto 文件中定义的是 int32 类型，因此序列化之后它的 wire type 为 0, 其字段编号为 1, 因此按照上面的计算方式，即 1 &lt;&lt; 3 | 0, 所以其类型和字段编号的信息只占 1 个字节，即 00001000, 后面跟上字段值 5 的 Varints 编码，所以整个结构体序列化之后为</p><center>    <img src="/2024/06/04/77811b82e50c/protobuf-zig-zag-1.png" alt></center><p>有了字段编号和 wire type, 其后所跟的数据的长度便是确定的，因此 Protobuf 是一种非常紧密的数据组织格式，其不需要特别地加入额外的分隔符来分割一个消息字段，这可大大提升通信的效率，规避冗余的数据传输</p><h3 id="1-4- 总结"><a href="#1-4- 总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h3><ul><li>Protobuf 是一种高效的数据描述格式，具有平台无关、语言无关、可扩展等特点，适合做数据存储、RPC 的通信协议等场景</li><li>Protobuf 采用 Varints 编码和 Zigzag 编码来编码数据，其中 Varints 编码的思想是移除数字高位的 0, 用变长的二进制位来描述一个数字，对于小数字，其编码长度短，可提高数据传输效率，但由于它在每个字节的最高位额外采用了一个标志位来标记其后是否还跟有有效字节，因此对于大的正数，它会比使用普通的定长格式占用更多的空间，另外对于负数，直接采用 Varints 编码将恒定占用 10 个字节，Zigzag 编码可将负数映射为无符号的正数，然后采用 Varints 编码进行数据压缩，在各种语言的 Protobuf 实现中，对于 int32 类型的数据，Protobuf 都会转为 uint64 而后使用 Varints 编码来处理，因此当字段可能为负数时，我们应使用 sint32 或 sint64, 这样 Protobuf 会按照 Zigzag 编码将数据变换后再采用 Varints 编码进行压缩，从而缩短数据的二进制位数</li><li>Protobuf 不是完全自描述的信息描述格式，接收端需要有相应的解码器（即 proto 定义）才可解析数据格式，序列化后的 Protobuf 数据不携带字段名，只使用字段编号来标识一个字段，因此更改 proto 的字段名不会影响数据解析（但这显然不是一种好的行为）, 字段编号会被编码进二进制的消息结构中，因此我们应尽可能地使用小字段编号</li><li>Protobuf 是一种紧密的消息结构，编码后字段之间没有间隔，每个字段头由两部分组成：字段编号和 wire type, 字段头可确定数据段的长度，因此其字段之前无需加入间隔，也无需引入特定的数据来标记字段末尾，因此 Protobuf 的编码长度短，传输效率高</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="proto" scheme="https://silhouettesforyou.github.io/tags/proto/"/>
    
  </entry>
  
  <entry>
    <title>现代 C++ 基础</title>
    <link href="https://silhouettesforyou.github.io/2024/06/03/56ae950785e9/"/>
    <id>https://silhouettesforyou.github.io/2024/06/03/56ae950785e9/</id>
    <published>2024-06-03T06:11:57.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="Basics-Review"><a href="#Basics-Review" class="headerlink" title="Basics Review"></a>Basics Review</h3><h4 id="Array-Type"><a href="#Array-Type" class="headerlink" title="Array Type"></a>Array Type</h4><ul><li>Multidimensional array 多维数组<ul><li>除了第一维其它维必须明确指出大小（explicit size）</li><li>不可以全部 decay</li><li>Dynamic allocation<ul><li><code>malloc</code> in C and <code>new</code>/<code>new []</code> in C++</li><li><code>new</code>和 <code>malloc</code> 返回都是指针</li><li>释放</li></ul></li></ul></li></ul><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><ul><li><p>函数返回类型不能是函数或者数组（但是可以是它们的引用）</p><ul><li>不应该返回局部变量的指针或者引用（超出了局部变量生命周期的范围）<ul><li>e.g. <code>int&amp; Test() { int a = 1; return &amp;a;}</code></li></ul></li><li>声明为 <code>static</code> 的局部变量具有全局性</li></ul></li><li><p>Function pointers 函数指针</p><ul><li><p><code>void(*)(int)</code></p></li><li><p>clockwise/spiral rule</p></li><li><p>Type alias 用 C++ 11 中的<code>using</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">using</span> MyFuncType1 = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">float</span>);<br><span class="hljs-keyword">using</span> MyFuncType2 = <span class="hljs-built_in">int</span>(*)(<span class="hljs-type">int</span>);<br><span class="hljs-keyword">using</span> MyFuncType3 = <span class="hljs-built_in">int</span>(*)(MyFuncType1);<br></code></pre></td></tr></table></figure></li><li><p>C 语言中可以用 <code>typedef</code>，但是没有<code>using</code> 强大</p></li></ul></li></ul><h4 id="Attribute"><a href="#Attribute" class="headerlink" title="Attribute"></a>Attribute</h4><ul><li><code>[[attribute]]</code> C++ 11，<code>[[attribute("reason")]]</code> C++ 20</li><li><code>[[deprecated]]</code>和<code>[[deprecated("reason")]]</code> C++ 14</li><li><code>[[noreturn]]</code> C++ 11</li><li><code>[[maybe_unused]]</code> C++ 17</li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">[[nodiscard]] <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>{<span class="hljs-keyword">return</span> a + b; }<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">Add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// int res = Add(1, 2);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>}<br></code></pre></td></tr></table></figure><p>warning: 放弃具有 [[nodiscard]] 属性函数的返回值</p><h4 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h4><blockquote><p>一个被限制取值的类</p></blockquote><ul><li>比较像使用全局变量</li><li>同时进行整形运算也没有安全检查</li><li>C++ 11 引入了 scoped enumeration 提高安全性</li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// enum Day {Monday};</span><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Day</span> {Monday};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-comment">// int a = Monday;</span><br>    Day a = Day::Monday<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><ul><li>可以使用 <code>std::underlying_type&lt;Day&gt;::type</code> 或者<code>std::underlying_type_t&lt;Day&gt;</code> C++ 14 转成整数类型<ul><li>C++ 23 中也可以使用<code>std::to_underlying&lt;Day&gt;(day)</code></li></ul></li><li>可以使用 <code>Day day{1};</code> 初始化 C++ 17，但是不能直接赋值<code>Day day = 1;</code> 或<code>day = 1;</code></li><li>可以使用位操作符</li></ul><h4 id="Expression"><a href="#Expression" class="headerlink" title="Expression"></a>Expression</h4><ul><li>运算符和表达式三个重要概念<ul><li>Precedence 优先级</li><li>Associativity 结合性</li><li>Order 顺序</li></ul></li><li>From the view of compiler, an expression is in fact a tree, determined by associativity and precedence. e.g. <code>9 / 3 / 2 + 2 * 3</code><ul><li>Precedence is used to split terms first.</li><li>Associativity determines how the tree will grow.</li><li>Then, it’s order of expression evaluation that computes the whole tree. 但是顺序是不确定的<ul><li><code>f1() + f2() + f3()</code>，<code>f1()</code>，<code>f1()</code>，<code>f1()</code>哪一个先被 evaluated 是不确定的</li></ul></li></ul></li><li>There are some rules<ul><li>For <code>&amp;&amp;</code> and <code>||</code>, since they have short-circuit property, the first part will be fully evaluated.</li><li>For a function call, all parameters (including <code>a</code> for e.g. <code>a.Func()</code> or <code>a-&gt;Func()</code>) are fully evaluated before entering the function.</li><li>三目运算</li><li>逗号表达式</li><li>C++ 17<ul><li>Parameters in function are evaluated indeterminately, i.e. every sub-tree represented by te parameter is fully evaluated in a <strong>non-overlap</strong> way 不会以交叠的形式 evaluated</li><li>运算符重载，和 build-in 运算符的 evaluated 顺序一致，而不是被当作普通函数</li><li>More useful examples: chained call</li></ul></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string s = <span class="hljs-string">"I have it even works if you don't believe"</span>;<br>s.<span class="hljs-built_in">replace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-string">""</span>).<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"even"</span>), <span class="hljs-number">4</span>, <span class="hljs-string">"sometimes"</span>).<span class="hljs-built_in">replace</span>(s.<span class="hljs-built_in">find</span>(<span class="hljs-string">"you don't"</span>), <span class="hljs-number">9</span>, <span class="hljs-string">"I"</span>);<br></code></pre></td></tr></table></figure><h3 id="class"><a href="#class" class="headerlink" title="class"></a>class</h3><h4 id="Ctor-amp-Dtor"><a href="#Ctor-amp-Dtor" class="headerlink" title="Ctor & Dtor"></a>Ctor &amp; Dtor</h4><ul><li>拷贝构造函数</li><li>赋值构造函数</li><li>The recommended way is member initializer list:<ul><li><code>member1{...}, member2{...}, ... {/* function body */}</code></li><li><code>{}</code> is used since C++ 11</li></ul></li><li>默认构造函数建议使用<code>Class() = default;</code></li><li>如果成员变量有默认值，就不建议使用上面的构造函数的形式，而是直接用默认值初始化</li></ul><h4 id="Initialization-of-Object"><a href="#Initialization-of-Object" class="headerlink" title="Initialization of Object"></a>Initialization of Object</h4><ul><li>Since C++ 11, Uniform Initialization is introduced<ul><li>所有的初始化都可以用<code>{}</code></li><li>相比于 <code>()</code> 更安全 Narrowing Conversion 缩窄变换检查<ul><li>the converted type cannot represent all values<ul><li><code>uint32_t</code>类型用 <code>uint16_t</code> 初始化，编译器会报错</li></ul></li><li>the facilitates type safety</li></ul></li></ul></li><li>Value initialization: No parameter for initialization <code>T a()</code>， <code>T a{}</code>， <code>new T{}</code>， <code>new T()</code></li><li>Direct initialization: <code>T a(x, y, ...)</code>，<code>T(x, y, ...)</code>，<code>new T(x, y, ...)</code>，<code>T a{x, y, ...}</code></li><li>Copy initialization: <code>T a = xx;</code>，<code>T a[] = { xx, ...};</code><ul><li>Ctors that use <code>explicit</code> cannot use this way</li><li>Before C++ 17, this also requires available copy ctor.</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {<span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>{}};<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">(A a)</span> </span>{}<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    A a = <span class="hljs-number">1</span>;    <span class="hljs-comment">// error</span><br>    A a = <span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">Func</span>(<span class="hljs-number">1</span>);    <span class="hljs-comment">// error</span><br>    <span class="hljs-built_in">Func</span>(<span class="hljs-built_in">A</span>(<span class="hljs-number">1</span>)); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>}<br></code></pre></td></tr></table></figure><ul><li>List initialization</li><li>Aggregate initialization</li></ul><h4 id="Member-Functions"><a href="#Member-Functions" class="headerlink" title="Member Functions"></a>Member Functions</h4><ul><li>所有的成员函数都隐式有一个 <code>this</code> 指针</li><li>如果期望函数不能更改成员变量，可以使用 <code>const</code> 关键字 make <code>this</code> to be <code>const</code></li><li>静态成员函数<ul><li>没有 <code>this</code> 指针</li></ul></li></ul><h4 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h4><ul><li><code>private</code>、<code>protected</code>、<code>public</code>，默认是<code>private</code></li><li><code>protected</code>用在继承中</li><li>友元</li></ul><h4 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h4><ul><li>子类 / 派生类、父类 / 基类</li><li>子类 / 派生类可以访问父类中所有 <code>public</code> 和<code>protected</code>成员</li><li>继承和组合</li><li>派生类可以隐式的转化成基类</li></ul><h5 id="Slicing-Problem"><a href="#Slicing-Problem" class="headerlink" title="Slicing Problem"></a>Slicing Problem</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Student student1{...}, student2{...};<br>    Person&amp; student1Ref = student1;<br>    student1Ref = student2;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><ul><li>There exists implicit conversion in <code>student1Ref = student2</code> so actually it calls <code>Person::operator=(const Person&amp;)</code></li><li>Can decorating <code>operator=</code> with <code>virtual</code> help<ul><li><code>Person::operator=</code> needs <code>const Person&amp;</code> but <code>Student::operator=</code> accepts <code>const Student&amp;</code> 参数都不一样，虚函数都不生效</li></ul></li><li>This is called “slicing” because such operation will only affect the base slice but not the initial object as whole 只影响了一小片</li><li>Polymorphic base class should hide their copy &amp; move functions if it has data member, otherwise deleting them 对于具有多态属性的基类，应该隐藏它们的拷贝和移动函数</li><li>Make copy &amp; move functions <code>protected</code> so derived class can call them</li></ul><h5 id="Multiple-Inheritance"><a href="#Multiple-Inheritance" class="headerlink" title="Multiple Inheritance"></a>Multiple Inheritance</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elephant</span> {};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seal</span> {};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElephantSeal</span> : <span class="hljs-keyword">public</span> Elephant, <span class="hljs-keyword">public</span> Seal {};<br></code></pre></td></tr></table></figure><ul><li>Dreaded diamond</li><li>C++ introduces virtual inheritance<ul><li>All virtual bases will be merged and seen as the same</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> {<span class="hljs-keyword">public</span>: <span class="hljs-type">int</span> weight; };<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Elephant</span> : <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Animal {};<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Seal</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal {}; <span class="hljs-comment">// virtual 和 public 顺序是不重要的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ElephantSeat</span> : <span class="hljs-keyword">public</span> Elephant, <span class="hljs-keyword">public</span> Seal {};<br></code></pre></td></tr></table></figure><ul><li>That is, you define many ABCs, which tries to reduce data members and non-pure-virtual member functions as much as you can 定义很多抽象类，尽可能减少成员变量和非纯虚函数的数量，最好是没有</li><li>They usually denote “-able” functionality 这样展现出来的就是就有某种能力</li></ul><h4 id="Polymorphism- 多态"><a href="#Polymorphism- 多态" class="headerlink" title="Polymorphism 多态"></a>Polymorphism 多态</h4><ul><li>you can use the base class to load the derived object and call its own methods 使用基类的指针 / 引用，承载派生类的对象，从而调用派生类的方法</li><li>virtual pointer and virtual table</li><li>Every object whose class has a virtual method will have a virtual pointer, which points to virtual table of its class 每个类中都有一个指向虚表的指针，虚表内容就是声明为 <code>virtual</code> 函数的地址</li><li>In C++ 11, it’s recommended to use <code>override</code> 子类没有 <code>override</code> 编译器会报错</li><li><code>final</code> It means override, and the derived class cannot override again 继承链中的最后一个节点<ul><li><code>class A final {...};</code> 让类不能被继承</li><li>去虚化，编译优化</li></ul></li><li><code>abstract class</code> 抽象类<ul><li>抽象类不能被实例化</li><li>可以是使用抽象类的指针，指向的都是派生类的对象</li><li>C++ 通过纯虚函数实现抽象类 <code>virtual void PrintInfo() const = 0;</code></li><li>派生类继承自抽象类必须实现纯虚函数，否则仍然是抽象类</li><li>Don’t call <strong>any</strong> virtual function and any function that calls virtual function in ctor &amp; dtor 在构造函数和析构函数中不要调用任何虚函数，也不要掉调用任何可能调用虚函数的函数</li><li>You should usually make dtor of base class <code>virtual</code> 通常将析构函数声明为虚函数<ul><li>deleting <code>Base*</code> that cast from <code>Derived*</code> will lead to correct dtor 派生类指针赋给基类，当调用 <code>delete</code> 时，如果不基类不是虚析构函数，就会调用基类的析构函数</li></ul></li><li>构造函数不能是纯虚函数</li></ul></li></ul><h4 id="Some-Covert-Facts-in-Inheritance"><a href="#Some-Covert-Facts-in-Inheritance" class="headerlink" title="Some Covert Facts in Inheritance"></a>Some Covert Facts in Inheritance</h4><ul><li><code>override</code>不止表示复写虚函数的含义，对于非虚函数的复写也叫“override”</li><li><code>private</code> inheritance usually denotes the relation of <strong>has-a</strong></li><li>虚函数的返回类型可以有些许改变：you can use <code>Base*</code> to both accept <code>Base*</code> and <code>Derived*</code> 复写虚函数的返回值可以是指向基类的指针，也可以是指向派生类的指针<ul><li>智能指针不能有“协变”</li></ul></li><li>当虚方法有默认参数的时候，用什么类型的指针调用时，就会返回该类型内的默认值<ul><li>默认的参数在编译期间被识别，虚表是在运行时跳转的</li></ul></li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parent::Go</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>)</span> </span>{std::cout &lt;&lt; <span class="hljs-string">"Base's go with i = "</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>; }<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Child::Go</span><span class="hljs-params">(<span class="hljs-type">int</span> i = <span class="hljs-number">4</span>)</span> </span>{std::cout &lt;&lt; <span class="hljs-string">"Derived's go with i ="</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">"\n"</span>; }<br><br>Child child;<br>child.<span class="hljs-built_in">Go</span>(); <span class="hljs-comment">// Derived's go with i = 4</span><br>Parent&amp; childRef = child;<br>childRef.<span class="hljs-built_in">Go</span>();  <span class="hljs-comment">// Base's go with i = 2</span><br></code></pre></td></tr></table></figure><ul><li>可以更改虚方法的访问属性（但是不建议）</li></ul><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a><code>struct</code></h3><ul><li>和 <code>class</code> 基本上一样，除了 <code>struct</code> 默认的访问控制是<code>public</code><ul><li>不应该有成员函数，最多有 ctor、dtor 和运算符重载</li><li>With these constraints (except for ctor), <code>struct</code> will be an aggregate, which can use aggregate initialization<ul><li>Since C++ 20, aggregate can also use <strong>designated initialization</strong> 指定初始化</li></ul></li></ul></li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Priority</span> {<span class="hljs-type">int</span> cal; }<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>{<br>    <span class="hljs-type">int</span> x, y;<br>    Priority priority[<span class="hljs-number">2</span>];<br>}<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Point p{.x = <span class="hljs-number">1</span>, .y = <span class="hljs-number">2</span>, .priority = {{ .val = <span class="hljs-number">1</span>}, {.val = <span class="hljs-number">2</span> } } };<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><h3 id="Function-Overloading- 函数重载"><a href="#Function-Overloading- 函数重载" class="headerlink" title="Function Overloading 函数重载"></a>Function Overloading 函数重载</h3><ul><li>C++ 中就是相同的函数名不同的参数<ul><li>C 中是禁止的</li></ul></li><li>This is done by compilers using a technique called <strong>name mangling</strong></li><li>Operator Overloading 运算符重载<ul><li><code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>%</code>，<code>|</code>，<code>&amp;</code>，<code>^</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>：推荐使用在全局函数中</li><li><code>+=</code>，<code>-=</code>，<code>*=</code>，<code>/=</code>，<code>|=</code>，<code>&amp;=</code>，<code>^=</code>，<code>&lt;&lt;=</code>，<code>&gt;&gt;=</code>：必须是成员函数 since the first operand must be a “named” object; return reference (i.e. <code>*this</code>)</li><li>Prefix<code>++</code> &amp; Prefix<code>--</code>：必须是成员函数 return <code>*this</code></li><li>Postfix<code>++</code> &amp; Postfix<code>--</code> have an unused parameter int, which is used to distinguish the prefix and postfix</li><li><code>*</code>，<code>-&gt;</code>：usually used in e.g. some wrapper of pointers</li><li><code>&amp;&amp;</code>，<code>||</code>：short-circuit 特性会失效</li><li><code>&lt;=&gt;</code>：三路比较运算符</li><li><code>()</code></li><li><code>[]</code><ul><li>Since C++ 23, you can use multidimensional subscript in <code>operator[]</code></li></ul></li></ul></li></ul><h3 id="Lambda-Expression"><a href="#Lambda-Expression" class="headerlink" title="Lambda Expression"></a>Lambda Expression</h3><ul><li>本质上是一个匿名的 <code>struct</code>，重载了<code>operator() const</code> 方法</li><li>Basic format: <code>auto func = [captures](params) -&gt; ReturnType {function body;};</code><ul><li>Captures are actually members of the <code>struct</code></li><li>ReturnType, params and function are for <code>operator()</code></li><li>Every lambda expression has its unique type</li><li>不传任何参数 <code>()</code> 可以省略掉</li></ul></li><li>建议将 Lambda 表达式中的捕获的东西明确写出来</li><li>static 和 global 变量是不需要被捕获的</li><li>捕获 <code>this</code> 指针<ul><li><code>this</code> by reference, since only copy pointer</li><li><code>*this</code> really copy all members</li><li>包括私有成员也可以捕获</li></ul></li><li>You may add specifiers after <code>()</code><ul><li><code>mutable</code>: since C++ 17, remove <code>const</code> in <code>operator()</code></li><li><code>static</code>: since C++ 23, same as <code>static operator()</code></li><li><code>constexpr</code>、<code>consteval</code>、<code>noexcept</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> m = [i] {i = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }; <span class="hljs-comment">// 不允许修改 i = 1，因为重载的 operator() 是 const</span><br>    <span class="hljs-keyword">auto</span> m = [i]() <span class="hljs-keyword">mutable</span> {i = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }; <span class="hljs-comment">// 修改的不是外面定义的变量，本质上修改的是 i 的拷贝</span><br>}<br></code></pre></td></tr></table></figure><ul><li>It’s also legal to add attributes between <code>[]</code> and <code>()</code></li><li>函数也可以写成 Lambda 表达式的形式 <code>auto Foo(params) -&gt; ReturnType {function body;}</code></li></ul><p>Code Block With Initializer</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> it = table.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (it == table.<span class="hljs-built_in">end</span>())<br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><ul><li><code>it</code>会泄露出去，下面如果继续判断会再定义迭代器类型的变量</li><li>Since C++ 17, you mey code like</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = table.<span class="hljs-built_in">find</span>(<span class="hljs-number">1</span>); it == table.<span class="hljs-built_in">end</span>())<br>    <span class="hljs-comment">//</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><ul><li>Since C++ 20, range-based for loop can also add an additional initializer, e.g. <code>for (auto vec = GetVec(); auto&amp; m : vec);</code></li><li>Since C++ 23, type alias declaration can also be initializer, e.g. <code>if (using T = xx; ...)</code></li></ul><h3 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h3><ul><li>Since C++ 17, CATD(class template argument deduction) is introduced, meaning that the argument of ctor can deduce the template parameter of class. e.g. <code>std::vector v{1, 2, 3, 4}</code></li><li>Lambda expression can also use template</li></ul><h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><ul><li><code>std::size_t</code>: the type of <code>sizeof()</code> 意味着对象的大小不能超过 <code>std::size_t</code> 所表示的范围<ul><li>也意味着数组的大小不能超过 <code>std::size_t</code> 所表示的范围</li><li>容器的大小也不能超过<code>std::size_t</code></li></ul></li><li><code>std::ptrdiff_t</code>：两个指针相减得到的类型</li></ul><h3 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h3><ul><li>Input/Output iterator<ul><li>For output <code>*it = val</code>, <code>it++</code>, <code>++it</code>, ‘it1 = it2’</li><li>For input <code>==</code>, <code>!=</code>, <code>-&gt;</code></li></ul></li><li>Forward iterator: e.g. linked list</li><li>Bidirectional iterator: <code>--it</code>, <code>it--</code> e.g. double linked list, map</li><li>Random access iterator: <code>+</code>, <code>-</code>, <code>+=</code>, <code>-=</code>, <code>[]</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>!=</code> e.g. deque</li><li>Contiguous iterator (since C++ 17): 保证地址空间是连续的</li><li><strong>IMPORTANT</strong>: Iterator are as unsafe as pointers 线程不安全的</li><li>All containers can get their iterators by:<ul><li><code>.begin()</code>, <code>.end()</code></li><li><code>.cbegin()</code>, <code>cend()</code> read-only access</li></ul></li><li>双向链表等还提供了倒序的遍历迭代器<ul><li><code>.rbegin()</code>, <code>.rend()</code>, <code>.crbegin()</code>, <code>crend()</code></li></ul></li><li>还可以使用全局的方法得到迭代器<ul><li><code>std::begin(vec)</code>, <code>std::end(vec)</code></li><li>C++ 20 建议使用<code>std::ranges::begin</code></li><li>只有类似 <code>int arr[5]</code> 传入到 <code>std::begin()</code> 或<code>std::end()</code>中才有效，指针传入进来是无效的</li></ul></li><li>There are also general methods of iterator operations, defined in <code>&lt;iterator&gt;</code><ul><li><code>std::advance(InputIt&amp; it, n)</code>: <code>it += n</code></li><li><code>std::next(InputIt it, n = 1)</code>: <code>return it + n</code></li><li><code>std::prev(InputIt it, n = 1)</code>: <code>return it - n</code></li><li><code>std::distance(InputIt it1, InputIt it2)</code>: <code>return it2 - it1</code> 不同的容器时间复杂度不一样</li></ul></li></ul><h4 id="Iterator-traits（显著的特点，特征）"><a href="#Iterator-traits（显著的特点，特征）" class="headerlink" title="Iterator traits（显著的特点，特征）"></a>Iterator traits（显著的特点，特征）</h4><ul><li>Iterators provide some types to show their information:<ul><li><code>value_type</code>: The type of elements referred to</li><li><code>difference_type</code>: The type that can be used to represent the distance between elements (usually <code>ptrdiff_t</code>) 迭代器之间的距离所表示的类型，一般就是<code>ptrdiff_t</code></li><li><code>iterator_category</code>: e.g. <code>input_iterator_tag</code>, <code>continuous_iterator_tag</code></li><li><code>pointer</code> &amp; <code>reference</code>: only available in container iterators 只有在容器中才会有的特性<ul><li>可以使用 <code>std::iterator_traits&lt;IteratorType&gt;::xxx</code> 获取</li></ul></li></ul></li></ul><h4 id="Stream-iterator"><a href="#Stream-iterator" class="headerlink" title="Stream iterator"></a>Stream iterator</h4><ul><li><code>std::istream_iterator&lt;T&gt;</code> &amp; <code>std:ostream_iterator&lt;T&gt;</code></li><li>The default constructed <code>istream_iterator</code> is <code>end()</code> 默认的构造函数表示终止的迭代器</li></ul><h4 id="Iterator-adaptor"><a href="#Iterator-adaptor" class="headerlink" title="Iterator adaptor"></a>Iterator adaptor</h4><p>有两种类型的迭代器适配器</p><ul><li>One is created from iterators to preform different utilities:<ul><li>E.g. reversed iterators 反向迭代器，++ 的本质上是 –，所以可以用 <code>begin()</code> 初始化，即<code>std:::reverse_iterator r{p.begin() }</code></li><li>You can get the underlying iterator by <code>.base()</code>, which actually returns the iterator that points to the elements after the referred one 调用 <code>.base()</code> 实际上是指向当前指向位置的下一个元素<ul><li><code>rbegin().base() == end()</code></li></ul></li></ul></li><li>Another is created from containers to work more than “iterate”<ul><li><code>std::back_insert_iterator{container}</code>: <code>*it = val</code> will call <code>push_back(val)</code> to insert</li><li><code>std:front_insert_iterator{container}</code>: call <code>push_front(val)</code> to insert</li><li><code>std::insert_iterator{container, pos}</code>: call <code>insert(pos, val)</code> to insert</li></ul></li><li>Notice that inserting/assigning a range directly is usually better than inserting one by one for <code>vector</code> or <code>deque</code></li></ul><h3 id="Sequential-Container"><a href="#Sequential-Container" class="headerlink" title="Sequential Container"></a>Sequential Container</h3><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><ul><li>E.g. <code>int a[5]</code> will decay to <code>int*</code> when passing to function, and the size information is dropped 以参数的方式传递到函数中会退化成指针，并且大小也被舍弃了</li><li><code>std::array&lt;T, size&gt;</code> the same as <code>T[size]</code>. It always preserves size, can copy from another array, and can do more things like bound check</li><li>It’s allocated on stack<ul><li>But if you <code>new std::array</code>, then it;s still allocated on heap</li></ul></li><li>特殊的构造函数需要额外的 <code>{}</code> e.g. <code>struct S {int i; int j;}</code> 初始化时是<code>std::array&lt;S, 2&gt; arr{{{1, 2}, {3, 4}}}</code><ul><li>第一个 <code>{}</code> 是<code>array</code>本身初始化的<code>{}</code></li><li>第二个 <code>{}</code> 是数组初始化的<code>{}</code></li></ul></li><li>For member accessing 成员访问<ul><li><code>operator[]</code></li><li><code>at()</code> will check the bound</li><li><code>front()</code>, <code>back()</code>: get the first/last element of vector 首先要保证非空</li><li>If you want to get the raw pointer of array content, you can use <code>.data()</code></li></ul></li><li>Additional methods<ul><li><code>.swap()</code></li><li><code>operator=</code>, <code>operator&lt;=&gt;</code> 三路比较运算符</li><li><code>.fill()</code> 将整个数组填充为某个特定值</li><li><code>std::to_array</code>(C-style array)</li></ul></li><li>Size operations<ul><li><code>.size()</code>: return <code>size_t</code></li><li><code>empty()</code></li><li><code>.max_size()</code>: get maximum possible size in this system(usually useless)</li></ul></li></ul><h4 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h4><ul><li>动态数组<ul><li>支持随机访问，占据连续空间</li><li>When inserting and removing elements at the end (i.e. pushing/poping back), the complexity is amortized（均摊） <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>If not at end, it’ll be <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li><li>在 cache 上的效果非常不错，对 cache 利用率非常显著</li><li>实现思路<ul><li>准备一部分空间，这样在 pushing 或者 poping 的时候时间复杂度才是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>当容量不够的时候在重新分配（reallocation），重分配的均摊复杂度也要求是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>The element number is called size; total space is called capacity</li><li>重分配的策略<ul><li>The easiest strategy is increasing space linearly<ul><li>E.g. 0 -&gt; 4 -&gt; 8 -&gt; 12 -&gt; 16 -&gt; …</li><li>Every <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> operations will trigger reallocation an copy <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.54ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 3332.6 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(1933.6,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(2454.6,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> elements<ul><li>So, the amortized complexity is <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="26.843ex" height="3.38ex" role="img" focusable="false" viewbox="0 -1141.1 11864.5 1493.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(1167,0)"><g data-mml-node="mrow" transform="translate(220,582.8) scale(0.707)"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2453.3,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(521,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g><g data-mml-node="mrow" transform="translate(898.9,-345) scale(0.707)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mi" transform="translate(521,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g></g><rect width="2547.1" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(3954.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4620.9,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5676.7,0)"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(6454.7,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(6843.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(7721.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(8388.4,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(9444.2,0)"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(10222.2,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(10611.2,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mi" transform="translate(247.9,-345) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(11475.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>Considering that <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> is an constant, this is still <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul></li><li>So, what about exponentially（指数）?<ul><li>E.g. 1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 16 -&gt; 32 -&gt; …</li><li>Every <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.152ex" height="1.932ex" role="img" focusable="false" viewbox="0 -853.7 951.4 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></g></svg></mjx-container> operations will trigger reallocation an copy <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.527ex" height="2.117ex" role="img" focusable="false" viewbox="0 -853.7 2885 935.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(877.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="msup" transform="translate(1933.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></g></svg></mjx-container> elements<ul><li>So, the amortized complexity is <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.885ex;" xmlns="http://www.w3.org/2000/svg" width="17.432ex" height="3.752ex" role="img" focusable="false" viewbox="0 -1267.1 7705 1658.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(1167,0)"><g data-mml-node="mrow" transform="translate(220,582.8) scale(0.707)"><g data-mml-node="munderover"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="mi" transform="translate(1089,477.1) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(345,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(1123,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2453.3,0)"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g><g data-mml-node="msup" transform="translate(1043.4,-391.4) scale(0.707)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,289) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g><rect width="2519.5" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(3926.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4593.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(5649,0)"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(6427,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(6816,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(7316,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul></li><li>Finally, why is the exponent 2?<ul><li>可以证明任何大于 1 的指数最后的均摊复杂度都是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>This is a trade-off between space and time 空间和时间的权衡</li><li>In MS（微软）, it’s 1.5</li></ul></li></ul></li><li>vector 不会自动的进行缩容（shrink），但是会暴露出接口手动缩容</li><li>Insert 是从后向前的（move backwards）</li><li>Removal is similar, but move forwards from the end of deletion to the deletion point, and finally destruct the last several elements</li><li><code>std::initializer_list</code></li><li>For member accessing (same as array)<ul><li>operator[]<code>,</code>at()<code>: accessing by index;</code>at()<code>will check th bound, i.e. if the index is greater than size,</code>std::out_of_range` will be thrown</li><li><code>front()</code>, <code>back()</code>: get the first/last element of vector</li><li>If you want to get the raw pointer of array content, you can use <code>.data()</code></li></ul></li><li>For capacity operations (i.e. adjust memory)<ul><li><code>.capacity()</code>: get capacity (return <code>size_t</code>)</li><li><code>.reserve(n)</code>: 直接分配 <code>n</code> 大小的内存，如果比当前 capacity 小就什么都不做，size 是不会改变的<ul><li>作用是前提知道需要分配的数量，一次性分配，就不需要有扩容的操作了</li></ul></li><li><code>.shrink_to_fit</code>: request to shrink the capacity so that <code>capacity == size</code></li></ul></li><li>For size operations<ul><li><code>.size()</code></li><li><code>.empty()</code></li><li><code>.resize(n, obj = Object{})</code></li><li><code>.clear()</code>: remove all things; size will be 0 after this</li></ul></li><li><code>.push_back(obj)</code></li><li><code>.emplace_back(params)</code>: insert an element constructed by params at the end 就地根据 <code>params</code> 构造元素<ul><li>Since C++ 17, it returns reference of inserted element (before it’s <code>void</code>)</li></ul></li><li><code>.pop_back()</code></li><li><code>.insert(const_iterator pos, xxx)</code></li><li><code>.erase(const_iterator pos)</code>, <code>.erase(const_iterator first, const_iterator last)</code>: erase a single element/elements from <code>[first, last)</code><ul><li>insert/erase will return next valid iterator of inserted/erase elements</li></ul></li><li>Interact with another vector<ul><li><code>.assign</code></li><li><code>.swap(vec)</code></li></ul></li><li>Since C++ 23, ranges-related methods are added<ul><li><code>.assign_range(Range)</code></li><li><code>insert_range(const_iterator pos, Range)</code></li><li><code>append_range(Range)</code></li></ul></li></ul></li></ul><h4 id="Iterator-Invalidation"><a href="#Iterator-Invalidation" class="headerlink" title="Iterator Invalidation"></a>Iterator Invalidation</h4><ul><li><p>迭代器就是指针的包装，但是指针是不安全的</p></li><li><p>导致不安全的情况</p><ul><li>reallocation 重分配，造成原来保存的指针悬垂</li><li>Insertion &amp; removal 插入和删除</li></ul></li><li><p>For vector</p><ul><li><p>If the capacity changes, all iterators are invalid</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    std::vector{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>};<br>    <span class="hljs-keyword">auto</span> it = v.<span class="hljs-built_in">begin</span>();<br>    v.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10086</span>); <span class="hljs-comment">// 会导致上一行的 `it` 失效</span><br>    it = v.<span class="hljs-built_in">begin</span>(); <span class="hljs-comment">// 必须进行重新获取</span><br>}<br></code></pre></td></tr></table></figure></li><li><p>If the capacity doesn’t change, but some elements are moved, iterators after the changed points are invalid</p></li></ul></li></ul><h4 id="Span"><a href="#Span" class="headerlink" title="Span"></a>Span</h4><ul><li>视图 View means that it doesn’t actually hold the data; it observes the data</li><li>Span is a view for contiguous memory (e.g. vector, array, string, C-style array initializer list, etc.)</li><li>可以像 array 一样操控 span</li><li><code>.first(N)/.last(N)</code></li><li><code>.subspan(beginPos(, size))</code></li><li>span is just a pointer with a size</li></ul><h4 id="Dequeue-Double-Ended-Queue- 双端队列"><a href="#Dequeue-Double-Ended-Queue- 双端队列" class="headerlink" title="Dequeue Double-Ended Queue 双端队列"></a>Dequeue Double-Ended Queue 双端队列</h4><ul><li>最主要的特点就是<ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> on insertion &amp; removal of elements at the front or the back</li><li>Random access</li></ul></li><li>Other properties are just like vector<ul><li><code>push_front</code></li><li><code>emplace_front</code></li><li><code>pop_front</code></li><li><code>prepend_range</code> C++ 23</li></ul></li><li>Circular queue<ul><li>When enqueue, tail moves forward</li><li>When dequeue, head moves forward</li><li>If <code>tail == head</code> i.e. the queue is full, overwrite the element at head, both tail and head move forward</li></ul></li><li>Dequeue 相当于动态的循环队列，当队列满的时候需要进行扩容<ul><li>扩容是做到均摊复杂度是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>可以做到随机访问的原理是 e.g. <code>deque[i]</code> is just <code>vec[(head + i) % size]</code></li></ul></li><li>实现方式<ul><li>降低拷贝的代价</li><li>通常的实现方式是使用动态循环队列（called map），里面的元素是指针<ul><li>指针指向一个 block，block 中存储对象</li><li>block 的大小是固定的</li></ul></li><li>Dequeue 中的数据结构<ul><li>The map and its size</li><li>The block size</li><li>The global offset of the first element <code>off</code><ul><li>We can use <code>off / block_size</code> to know the position of head</li></ul></li><li>Element numbers</li></ul></li><li>重新分配的时候只需要拷贝指针</li><li>Map reallocation in dequeue<ul><li>假设新加的 block 的大小是<code>count</code></li><li>需要使得循环队列仍然是连续的<ul><li>First, copy all elements from <code>vec[head, vecEnd]</code> to <code>newVec[head, currEnd]</code></li><li>Then, if <code>head &lt;= count</code>, copy <code>[0, head)</code> to <code>[currEnd, ...)</code></li><li>Else, copy after <code>currEnd</code> as mush as possible, and the rest is arranged to the <code>newVecBegin</code></li><li>Finally, set all the rest to <code>nullptr</code></li></ul></li></ul></li></ul></li><li>Dequeue iterator invalidation<ul><li>All iterators are seen as invalid after insertion 插入之后所有的迭代器都是失效的，还包括<ul><li><code>resize</code></li><li><code>shrink_to_fit</code></li><li><code>clear</code></li></ul></li></ul></li></ul><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><ul><li>Double linked list</li><li>Properties<ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> insertion and removal</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> splice 融合另一个 list 的一部分元素</li><li>不支持随机访问</li></ul></li><li>每个节点都已一个数据 <code>T data</code>、<code>prev</code>、<code>next</code>，并且第一个节点的<code>prev</code> 指向 <code>nullptr</code>，最后一个节点的<code>next</code> 指向<code>nullptr</code></li><li>微软用循环 list 实现的<ul><li>引入了哨兵节点 sentinel node，是 <code>prev</code> 指针的前一个节点，<code>next</code>指针的后一个节点</li><li>不需要特判 nullptr`</li></ul></li><li>There are two methods to move nodes from another list<ul><li>和 <code>insert(pos, it1, it2)</code> 有区别，<code>insert</code>只是拷贝，没有清除操作</li><li><code>.merge(list2)/.merge(list2, cmp)</code>，通常用在已排序的 list 中</li><li><code>.splice(pos, list2, ...)</code><ul><li><code>()</code>: insert the total <code>list2</code> to pos</li><li><code>(it2)</code>: insert <code>it2</code> to <code>pos</code> (and remove it from <code>list2</code>)</li><li><code>(first, last)</code>: insert <code>[first, last)</code> to <code>pos</code> (abd remove them from <code>list2</code>)</li></ul></li></ul></li></ul><h4 id="Froward-list"><a href="#Froward-list" class="headerlink" title="Froward list"></a>Froward list</h4><ul><li>Single linked list</li><li>Forward list 的目的是为了减少存储空间，所以不提供 <code>.size()</code> 函数</li><li>只存储头部节点</li></ul><h3 id="Container-adaptors"><a href="#Container-adaptors" class="headerlink" title="Container adaptors"></a>Container adaptors</h3><ul><li>容器适配器是对已经存在的容器进行包装，通常情况下不提供迭代器</li></ul><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><ul><li>Stack is a LIFO data structure</li><li>The provide container show have <code>push_back</code>, <code>emplace_back</code>, <code>pop_back</code>, so vector, deque and list are all OK</li><li>APIs<ul><li><code>.pop()</code></li><li><code>.push(val)</code>, <code>.emplace(params)</code></li><li><code>.push_range(params)</code> C++ 23</li><li><code>.top()</code></li><li><code>.empty()</code>, <code>.size()</code></li><li><code>.swap(s2)</code></li><li><code>operator=</code></li><li><code>operator&lt;=&gt;</code></li></ul></li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><ul><li>Queue is a FIFO data structure</li><li><code>.front()</code></li><li><code>.end()</code></li></ul><h4 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority queue"></a>Priority queue</h4><ul><li>It’s defined in <code>&lt;queue&gt;</code></li><li>It’s in fact max heap<ul><li>插入或者弹出元素的时间复杂度是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.167ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3610 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(2621,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3221,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>建堆的时间复杂度是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>Percolation is the core algorithm<ul><li>插入的时候进行上滤 percolate up</li><li>删除的时候进行下滤 percolate down</li></ul></li></ul></li></ul><h4 id="Flat-containers"><a href="#Flat-containers" class="headerlink" title="Flat containers"></a>Flat containers</h4><ul><li>The only defect of map/unordered_map/… is that they’re really cache-unfriendly</li><li>Flat containers 对缓存利用率更高<ul><li>The functionality is same as set/map</li><li>But it’s in fact an ordered “vector”<ul><li>没有冗余的数据，对 cache 更友好</li><li>本质上是两个 “vector”</li></ul></li></ul></li><li>The whole definition is <code>std::flat_map&lt;Key, Value, Compare = std::less&lt;Key&gt;, ContainerForKey = std::vector&lt;Key&gt;, ContainerForValue = std::vector&lt;Value&gt;&gt;</code></li><li>也可以使用 deque 作为容器</li><li>The complexity<ul><li>For lookup, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.819ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3898 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(2621,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(3509,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 二分查找</li><li>For insertion/removal, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>For <code>iterator++</code>, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul><h3 id="Associative-containers"><a href="#Associative-containers" class="headerlink" title="Associative containers"></a>Associative containers</h3><ul><li>They’re called associative because they associate key with value<ul><li>The value can also be omitted</li></ul></li><li>There exist ordered one and unordered one<ul><li>有序的需要比较函数 less than<ul><li>BBST (balanced binary search tree) 查找、插入、删除的时间复杂度都是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.538ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3332 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(2343,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2943,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container><ul><li>RB tree</li><li>AVL</li></ul></li></ul></li><li>无序的需要提供哈希函数和判断是否相等的函数<ul><li>查找、插入、删除的时间复杂度都是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="3.989ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 1763 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(874,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1374,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul></li></ul><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><ul><li>The key is unique; a single key cannot be mapped to multiple values</li><li><code>std::map&lt;Key, Value, CMPForKey = std::less&lt;Key&gt;&gt;</code><ul><li>默认是小于号</li><li><code>CMPForKey</code> should be able to accept <code>const key</code></li></ul></li><li>For member accessing<ul><li><code>operator[]</code>, <code>at()</code></li><li>Bidirectional iterators<ul><li>Notice that the worst complexity of <code>++/--</code> is <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.819ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3898 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(2621,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(3509,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>对 BBST 进行中序遍历就能得到有序的序列<ul><li><code>.begin()</code> is just the leftmost node and <code>.rbegin()</code> is just the rightmost node</li></ul></li></ul></li></ul></li><li>Note<ul><li><code>operator[]</code> will insert a default-constructed value if the key doesn’t exits<ul><li>如果 key 不存在并且默认构造的值也不是真正需要的，用 <code>insert_xxx</code> 效率更高</li><li><code>const map</code>不能用<code>operator[]</code></li><li>如果 value 是不能被默认构造的（例如没有默认构造函数）也是不能用<code>operator[]</code></li></ul></li><li>Key-value pair is stored in RB tree, so iterator also points to the pair</li><li>You can use structured binding to facilitate iteration</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::map&lt;string::string, <span class="hljs-type">int</span>&gt; scoreTable{<br>    {<span class="hljs-string">"Li"</span>, <span class="hljs-number">99</span> },<br>    {<span class="hljs-string">"God Liu"</span>, <span class="hljs-number">99</span> },<br>    {<span class="hljs-string">"Saint Liu"</span>, <span class="hljs-number">99</span> },<br>    {<span class="hljs-string">"Liang"</span>, <span class="hljs-number">99</span> },<br>};<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [name, score] : scoreTable)<br>    std::cout &lt;&lt; name &lt;&lt; <span class="hljs-string">''</span> &lt;&lt; score &lt;&lt; <span class="hljs-string">'\n'</span>;<br></code></pre></td></tr></table></figure><ul><li><p>APIs</p><ul><li><p><code>.lower_bound(key)</code>: find <code>it</code> that <code>prev(it)-&gt;key &lt; key &lt;= it-&gt;key</code></p><ul><li>Use key as a lower bound to make <code>[it, end) &gt;= key</code></li></ul></li><li><p><code>.lower_bound(key)</code>: find <code>it</code> that <code>prev(it)-&gt;key &lt;= key &lt; it-&gt;key</code></p><ul><li>Use key as a lower bound to make <code>[begin, it) &lt;= key</code></li></ul></li><li><p><code>.equal_range(key)</code>: find <code>it</code> pair with the same key as <code>key</code> in range</p></li><li><p>Insertion</p><ul><li><p>因为键是唯一的，插入的时候如果 key 存在会失败；无论失败成功都返回<code>pair&lt;iterator, bool&gt;</code></p><ul><li>If succeed, <code>iterator</code> refers to inserted element and <code>bool</code> is <code>true</code></li><li>If fail, <code>iterator</code> refers to the element with the same key and <code>bool</code> is false`</li></ul></li><li><p>插入失败会有多个处理方式</p><ul><li>Leave it unchanged<ul><li><code>.insert({key, value})</code></li><li><code>.emplace(params)</code></li></ul></li><li>Overwrite it (C++ 17)<ul><li><code>.insert_or_assign(key, value)</code>: return <code>pair&lt;iterator, bool&gt;</code></li></ul></li><li>Leave it unchanged and even not construct the inserted value (C++ 17)<ul><li><code>.try_emplace(key, params)</code>: same as <code>emplace</code>, except that the params are used to construct value, and <code>emplace</code> is not forbidden to construct the pair in failure 构造 value 非常昂贵的时候使用</li></ul></li></ul></li><li><p>You can also provide a hint iterator for insertion</p><ul><li><p>hint iterator 在被插入元素后面的时候会有效率提升，在前面的话会使效率降低</p></li><li><p>Hint is often used in idiom blow</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> pLoc = someMap.<span class="hljs-built_in">lower_bound</span>(someKey);<br><span class="hljs-keyword">if</span> (pLoc != someMap.<span class="hljs-built_in">end</span>() &amp;&amp; !(someMap.<span class="hljs-built_in">Key_comp</span>()(someKey, pLoc-&gt;first)))<br>    <span class="hljs-keyword">return</span> pLoc-&gt;second;<br><span class="hljs-keyword">else</span> {<br>    <span class="hljs-keyword">auto</span> newValue = <span class="hljs-built_in">expensiveCalculation</span>();<br>    someMap.<span class="hljs-built_in">insert</span>(pLoc, <span class="hljs-built_in">make_pair</span>(someKey, <span class="hljs-keyword">new</span> Value));<br>    <span class="hljs-keyword">return</span> newValue;<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Erasure</p><ul><li><code>.erase(...)</code><ul><li><code>(key)</code></li><li><code>(iterator pos)</code></li><li><code>(iterator first, iterator last)</code></li></ul></li></ul></li><li><p><code>.extract(key)</code>, <code>extract(iterator pos)</code>: extract out the node from the map</p></li><li><p><code>.insert(node_type&amp;&amp;)</code>: insert the node to the map</p></li><li><p><code>.merge(another map/multimap)</code></p></li></ul></li></ul><blockquote><p><strong>Structured binding</strong></p><ul><li><p>Structured binding is just <code>auto&amp; [...]{xx}</code></p><ul><li><p><code>{xx}</code> can be <code>(xx)</code> or <code>=xx</code></p></li><li><p><code>auto&amp;</code> can be anything</p></li><li><p><code>xx</code> can be a pair; it can also be</p><ul><li>An object with all public data members, which will be bound on them</li><li>A C-style array or <code>std::array</code>, which will be bound on elements <code>arr[i]</code></li><li>A tuple-like thing, which will be bound on every element</li></ul></li><li><p>Note</p><ul><li><p>pair and <code>std::array</code> is also somewhat tuple-like thing and can use some tuple methods, e.g. <code>std::get</code> pair 和 <code>std::array</code> 也可以像 tuple 一样，访问的时候也可以使用访问 tuple 的方法</p></li><li><p>结构化绑定时一个新的声明，不能绑定已经存在的变量，如果想绑定已存在的变量可以使用<code>std::tie(name, score) = pair</code></p></li><li><p>结构化绑定的本质是匿名结构体，结构体中的变量是别名</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>&gt; a{<span class="hljs-number">1</span>, <span class="hljs-number">1.0f</span> };<br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [b, c] = a;<br><span class="hljs-keyword">decltype</span>(b) m = <span class="hljs-number">0</span>; <span class="hljs-comment">// const int m  = 0;</span><br></code></pre></td></tr></table></figure></li><li><p>Structured binding is usually more efficient than novice/careless programmers 建议使用结构化绑定</p></li></ul></li></ul></li></ul><p><strong>Tuple</strong></p><ul><li><code>std::tuple&lt;int, float, double&gt; t{1, 2.0f, 3.0};</code></li><li>It can only be accessed by an index that can be determined in compile time 下标访问的下标只能在编译时确定<ul><li><code>std::get&lt;0&gt;(tuple)</code> to get the <code>int 1</code></li><li>C++ 14 可以使用类型获取相应的值，前提是类型不能重复 e.g. <code>std::get&lt;int&gt;(tuple)</code></li><li><code>std::tuple_cat</code></li></ul></li></ul></blockquote><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><ul><li>Set is just a map without value</li><li>The only difference with amp is that it doesn’t have <code>operator[]</code> and <code>.at()</code></li><li>The iterator points to only key instead of key-value pair</li></ul><h4 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h4><ul><li>把 key 的唯一性取消了</li><li>不能使用 <code>operator[]</code> 和<code>.at()</code></li><li>相等的值的顺序取决于插入时的顺序</li><li>插入永远都是成功的</li><li>Nodes of multimap and map can be exchanged 两个容器的节点是可以相互替换的</li></ul><h4 id="Multiset"><a href="#Multiset" class="headerlink" title="Multiset"></a>Multiset</h4><ul><li>Except for only key and no value, same as multimap</li><li>You can also exchange nodes of multiset and set</li></ul><h4 id="Unordered-map"><a href="#Unordered-map" class="headerlink" title="Unordered map"></a>Unordered map</h4><ul><li><code>std::unordered_map&lt;Key, Value, Hash = std::hash&lt;key&gt;, Equal = std::equal_to&lt;Key&gt;&gt;</code></li><li>Many types have <code>std::hash&lt;Type&gt;</code>, e.g. <code>std::string</code>, <code>float</code>, etc.</li><li>The hash value of different keys may be same, so we need <code>Equal</code> to judge which key is wanted</li><li>微软的实现在解决冲突的时候用双向链表，并且链接相邻的 Bucket 延申出来的双向链表，并添加一个哨兵节点</li><li>当插入数据太多的时候，每个 bucket 也会链接很多数据<ul><li>这样会增加查找的复杂度</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.798ex;" xmlns="http://www.w3.org/2000/svg" width="9.174ex" height="2.76ex" role="img" focusable="false" viewbox="0 -867.1 4054.7 1219.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mfrac"><g data-mml-node="mtext" transform="translate(1475.8,394) scale(0.707)"><path data-c="73" d="M295 316Q295 356 268 385T190 414Q154 414 128 401Q98 382 98 349Q97 344 98 336T114 312T157 287Q175 282 201 278T245 269T277 256Q294 248 310 236T342 195T359 133Q359 71 321 31T198 -10H190Q138 -10 94 26L86 19L77 10Q71 4 65 -1L54 -11H46H42Q39 -11 33 -5V74V132Q33 153 35 157T45 162H54Q66 162 70 158T75 146T82 119T101 77Q136 26 198 26Q295 26 295 104Q295 133 277 151Q257 175 194 187T111 210Q75 227 54 256T33 318Q33 357 50 384T93 424T143 442T187 447H198Q238 447 268 432L283 424L292 431Q302 440 314 448H322H326Q329 448 335 442V310L329 304H301Q295 310 295 316Z"/><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(394,0)"/><path data-c="7A" d="M42 263Q44 270 48 345T53 423V431H393Q399 425 399 415Q399 403 398 402L381 378Q364 355 331 309T265 220L134 41L182 40H206Q254 40 283 46T331 77Q352 105 359 185L361 201Q361 202 381 202H401V196Q401 195 393 103T384 6V0H209L34 1L31 3Q28 8 28 17Q28 30 29 31T160 210T294 394H236Q169 393 152 388Q127 382 113 367Q89 344 82 264V255H42V263Z" transform="translate(672,0)"/><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(1116,0)"/></g><g data-mml-node="mtext" transform="translate(220,-345) scale(0.707)"><path data-c="62" d="M307 -11Q234 -11 168 55L158 37Q156 34 153 28T147 17T143 10L138 1L118 0H98V298Q98 599 97 603Q94 622 83 628T38 637H20V660Q20 683 22 683L32 684Q42 685 61 686T98 688Q115 689 135 690T165 693T176 694H179V543Q179 391 180 391L183 394Q186 397 192 401T207 411T228 421T254 431T286 439T323 442Q401 442 461 379T522 216Q522 115 458 52T307 -11ZM182 98Q182 97 187 90T196 79T206 67T218 55T233 44T250 35T271 29T295 26Q330 26 363 46T412 113Q424 148 424 212Q424 287 412 323Q385 405 300 405Q270 405 239 390T188 347L182 339V98Z"/><path data-c="75" d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z" transform="translate(556,0)"/><path data-c="63" d="M370 305T349 305T313 320T297 358Q297 381 312 396Q317 401 317 402T307 404Q281 408 258 408Q209 408 178 376Q131 329 131 219Q131 137 162 90Q203 29 272 29Q313 29 338 55T374 117Q376 125 379 127T395 129H409Q415 123 415 120Q415 116 411 104T395 71T366 33T318 2T249 -11Q163 -11 99 53T34 214Q34 318 99 383T250 448T370 421T404 357Q404 334 387 320Z" transform="translate(1112,0)"/><path data-c="6B" d="M36 46H50Q89 46 97 60V68Q97 77 97 91T97 124T98 167T98 217T98 272T98 329Q98 366 98 407T98 482T98 542T97 586T97 603Q94 622 83 628T38 637H20V660Q20 683 22 683L32 684Q42 685 61 686T98 688Q115 689 135 690T165 693T176 694H179V463L180 233L240 287Q300 341 304 347Q310 356 310 364Q310 383 289 385H284V431H293Q308 428 412 428Q475 428 484 431H489V385H476Q407 380 360 341Q286 278 286 274Q286 273 349 181T420 79Q434 60 451 53T500 46H511V0H505Q496 3 418 3Q322 3 307 0H299V46H306Q330 48 330 65Q330 72 326 79Q323 84 276 153T228 222L176 176V120V84Q176 65 178 59T189 49Q210 46 238 46H254V0H246Q231 3 137 3T28 0H20V46H36Z" transform="translate(1556,0)"/><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(2084,0)"/><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(2528,0)"/><path data-c="20" d=""transform="translate(2917,0)"/><path data-c="6E"d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"transform="translate(3167,0)"/><path data-c="75"d="M383 58Q327 -10 256 -10H249Q124 -10 105 89Q104 96 103 226Q102 335 102 348T96 369Q86 385 36 385H25V408Q25 431 27 431L38 432Q48 433 67 434T105 436Q122 437 142 438T172 441T184 442H187V261Q188 77 190 64Q193 49 204 40Q224 26 264 26Q290 26 311 35T343 58T363 90T375 120T379 144Q379 145 379 161T380 201T380 248V315Q380 361 370 372T320 385H302V431Q304 431 378 436T457 442H464V264Q464 84 465 81Q468 61 479 55T524 46H542V0Q540 0 467 -5T390 -11H383V58Z"transform="translate(3723,0)"/><path data-c="6D"d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q351 442 364 440T387 434T406 426T421 417T432 406T441 395T448 384T452 374T455 366L457 361L460 365Q463 369 466 373T475 384T488 397T503 410T523 422T546 432T572 439T603 442Q729 442 740 329Q741 322 741 190V104Q741 66 743 59T754 49Q775 46 803 46H819V0H811L788 1Q764 2 737 2T699 3Q596 3 587 0H579V46H595Q656 46 656 62Q657 64 657 200Q656 335 655 343Q649 371 635 385T611 402T585 404Q540 404 506 370Q479 343 472 315T464 232V168V108Q464 78 465 68T468 55T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z"transform="translate(4279,0)"/></g><rect width="3814.7"height="60"x="120"y="220"/></g></g></g></svg></mjx-container> is called load factor 装载因子</li><li>装载因子过大时，需要对 bucket array 进行扩容</li><li>Rehash 重哈希</li></ul></li><li>APIs<ul><li><code>.bucket_count()</code>: size of bucket array</li><li><code>.load_factor()</code>: <code>size() / bucket_count()</code></li><li><code>.max_load_factor()</code>: when load factor exceeds this limit, refresh will happen</li><li><code>.rehash(n)</code>: make <code>bucket_count() = max(n, ceil(size() / max_load_factor()))</code> and rehash</li><li><code>.reserve(n)</code></li><li><code>.bucket(key)</code>: get the bucket index of the key</li><li><code>.begin(index)</code>, <code>.cbegin(index)</code>, <code>.end(index)</code>, <code>.cend(index)</code>: get the iterator of the bucket at index</li><li><code>.bucket_size(index)</code>: get the size of bucket at index</li></ul></li><li>You can also extract nodes and insert them</li></ul><h2 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h2><ul><li><p>Using ranges is very like functional programming</p></li><li><p>There are three important components in ranges:</p><ul><li>Range: A type provides a begin iterator and end sentinel, so that it can be iterated over</li><li>View: A range that can be moved in <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, copied in <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> (or cannot be copied) and destructed in <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>Range adaptor</li></ul></li><li><p>Note</p><ul><li>Range 可以按照迭代器进行分类</li><li>计算是惰性计算</li></ul></li><li><p>They’re all defined in <code>&lt;range&gt;</code>; all views are defines as <code>std::ranges::xx_view</code>, and all range adaptors are defined as <code>std::views::xx</code></p><ul><li>一般用别名来简化定义 <code>namespace stdr = std::ranges</code> 和<code>namespace stdv = std::views</code></li><li><code>stdr::iota_view{lower, upper = INF}</code>, <code>stdv::iota(lower, upper = INF)</code>: 和 python 中的 <code>range(a, b)</code> 类似</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> oddNum : stdv::<span class="hljs-built_in">iota</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)<br>  | stdv::<span class="hljs-built_in">filter</span>([](<span class="hljs-type">int</span> num) {<span class="hljs-keyword">return</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>; })<br>  | stdv::<span class="hljs-built_in">take</span>(<span class="hljs-number">3</span>))<br>{<br>    std::cout &lt;&lt; oddNum &lt;&lt; <span class="hljs-string">'';</span><br><span class="hljs-string">}</span><br></code></pre></td></tr></table></figure></li><li><p>Writable</p><ul><li><code>stdv::filter(Pred)</code>: drop the element if the predicate function <code>Pred</code> returns <code>false</code></li><li><code>stdv::take(x)</code>: take first <code>x</code> elements (but not exceed <code>end</code>)</li><li><code>stdv::take_while(Pred)</code>: take elements until <code>Pred</code> return <code>false</code> (or <code>end</code>)</li><li><code>stdv::drop(x)</code>: drop first <code>x</code> elements</li><li><code>stdv::drop_while(Pred)</code>: drop elements until <code>Pred</code> returns <code>false</code></li><li><code>stdv::reverse</code></li><li><code>stdv::keys</code>: get the first element from a tuple-like thing</li><li><code>stdv::values</code></li><li><code>stdv::elements&lt;i&gt;</code>: get the <code>i</code>th element from a tuple-like thing</li><li><code>stdv::stride(k)</code>: use <code>k</code> as stride to iterate<ul><li>e.g. <code>stdv::iota(1, 0) | stdv::stride(2)</code> gets <code>{1, 3, 5, 7, 9}</code></li></ul></li><li><code>stdv::join</code>: flattens the ranges to a single range 需要用 <code>|</code> 连接</li><li><code>stdv::join_with(xx)</code>: fill the interval with <code>xx</code> 需要用 <code>|</code> 连接</li><li><code>stdv::zip(r1, r2, ...)</code>: zip values from ranges to a tuple</li><li><code>stdv::cartesian_product(r1, r2, ...)</code>: return a tuple of elements from the cartesian product of these ranges</li><li><code>stdv::enumerate</code>: return <code>std::tuple&lt;Integer, T&amp;&gt;</code>; Integer is index whose tpe is diff type of iterator</li><li><code>stdv::slide(width)</code>: slide the range in a sliding window of <code>width</code><ul><li>e.g. <code>std::vector v{1, 2, 3, 4, 5}; v | stdv::slide(3)</code> gets <code>{{1, 2, 3}, {2, 3, 4}, {3, 4, 5}}</code></li></ul></li><li><code>stdv::adjacent&lt;width&gt;</code>: same as <code>stdv::slide(width)</code></li><li><code>stdv::pairwise</code>: i.e. stdv::adjacent&lt;2&gt;</li><li><code>stdv::chunk(width)</code>: partition the range by <code>width</code></li><li><code>stdv::chunk_by(pred2)</code>: partition the range by <code>pred2</code>, i.e. a view sill stop when <code>pred2(*it, *next(it))</code> return <code>false</code></li><li><code>stdv::split(xx)</code></li><li><code>stdv::lazy_split(xx)</code></li></ul></li><li><p>Read-only</p><ul><li><p>Either make the view const, i.e. <code>std::as_const</code>; this will return <code>const T&amp;</code> or <code>tuple&lt;const T&amp;, ...&gt;</code></p></li><li><p>Or return value, i.e. transform-related, which will return <code>T</code> or <code>tuple&lt;T, ...&gt;</code></p><ul><li><p><code>stdv::zip_transform(TransformN, r1, r2, ...)</code>: return a view of <code>TransformN(ele1, ele2, ...)</code></p></li><li><p><code>stdv::adjacent_transform&lt;N&gt;(TransformN)</code>: return a view of <code>TransformN(...)</code>, where <code>...</code> is the elements of the sliding windows</p></li><li><p><code>stdv::transform(Transform)</code>: transform element to another element</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;<span class="hljs-type">int</span>&gt; v{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> };<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">auto</span> r = v | stdv::<span class="hljs-built_in">transform</span>([&amp;cnt](<span class="hljs-type">const</span> <span class="hljs-type">int</span> ele) {<br>    std::cout &lt;&lt; std::format(<span class="hljs-string">"cnt={}, ele={}\n"</span>, cnt, ele);<br>    cnt++;<br>    <span class="hljs-keyword">return</span> cnt + ele;<br>}) | stdv::<span class="hljs-built_in">take_while</span>([](<span class="hljs-type">const</span> <span class="hljs-type">int</span> ele) {<span class="hljs-keyword">return</span> ele &lt; <span class="hljs-number">10</span>; });<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; i : r);<br><span class="hljs-comment">// output:</span><br><span class="hljs-comment">// cnt=0, ele=1</span><br><span class="hljs-comment">// cnt=1, ele=1</span><br><span class="hljs-comment">// cnt=2, ele=2</span><br><span class="hljs-comment">// cnt=3, ele=2</span><br><span class="hljs-comment">// cnt=4, ele=3</span><br><span class="hljs-comment">// cnt=5, ele=3</span><br><span class="hljs-comment">// cnt=6, ele=4</span><br></code></pre></td></tr></table></figure><ul><li><code>++</code> will trigger transform since <code>take_while</code> needs the transformed value to advance the iterator (i.e. by <code>Pred(*it)</code>)</li><li><code>const auto&amp; ele = *it</code> will trigger it again</li><li>That’s because the result doesn’t reference some existing elements, but generate from temporary; every time you need it, lazy evaluation generate it again 太 lazy 了</li><li>Sometimes, you may want to convert a range to a e.g. container, which needs to eagerly evaluate all<ul><li><code>stdr::to</code>, e.g. <code>stdr::to&lt;std::vector&gt;()</code></li></ul></li></ul></li></ul></li></ul></li><li><p>There are also some naïve range factories</p><ul><li><code>stdv::single(obj)</code>: make a view that copies/moves an object, i.e. the view owns only a single element</li><li><code>stdv::empty&lt;T&gt;</code>: create an empty view</li><li><code>stdv::repeat(r, k = INF)</code>: repeat a range <code>r</code> for <code>k</code> times, i.e. like a range <code>[r, r, r, ...]</code></li><li><code>stdv::istream&lt;xxx&gt;(stream)</code>: similar to <code>istream_iterator</code>; it caches value</li><li><code>stdr::subrange(first, last)</code></li></ul></li></ul><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">end</span>):<br>    begin = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> begin != end:<br>        <span class="hljs-keyword">yield</span> begin<br>        begin += <span class="hljs-number">1</span><br><br>generator = func(<span class="hljs-number">10</span>)<br><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> generator:<br>    <span class="hljs-built_in">print</span>(num)<br></code></pre></td></tr></table></figure><p>When the function reaches <code>yield</code>, it will pause and <code>return</code> the number; when iterator moves forward, the function will resume and continue to execute until the next <code>yield</code> or real <code>return</code></p><ul><li>Since C++ 23, generator is also supported by <strong>coroutine</strong><ul><li>Coroutines <strong>cooperates</strong> with each other and yield their execution flow themselves 协程之间是相互配合的控制流<ul><li>By contrast, for threads, they usually compete with each other and are interrupted by OS to give other threads chances to execute 线程则是抢占式的</li></ul></li></ul></li><li>Generator is just the same; when you need the next value , you just yield your execution flow to the generator function; when the generator function completes its task, it will give back the right of execution</li><li>Generator is also an <code>input_range</code> and view; it provides <code>begin()</code> and <code>end()</code> to iterate, and <code>++</code> the iterator will resume the function<ul><li>NOTICE: Call <code>.begin()</code> will start the coroutine</li></ul></li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::generator&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> end)</span></span><br><span class="hljs-function"></span>{<br>    std::cout &lt;&lt; <span class="hljs-string">"Ahh..."</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> begin = <span class="hljs-number">0</span>; begin &lt; end; begin++)<br>        <span class="hljs-keyword">co_yield</span> begin;<br>    <span class="hljs-keyword">co_return</span>;<br>}<br><span class="hljs-keyword">auto</span> generator = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = generator.<span class="hljs-built_in">begin</span>(); it != generator.<span class="hljs-built_in">end</span>(); it++)<br>    std::cout &lt;&lt; *it;<br><span class="hljs-comment">// or</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; num : generator)<br>    std::cout &lt;&lt; num;<br></code></pre></td></tr></table></figure><ul><li>Some notes<ul><li>One generator can only be used once 只能使用一次</li><li>Generator has <code>operator=</code></li><li><code>co_return</code> can be omitted</li><li>Saving contexts also needs memory, so an allocator can also be provided as the last template parameter</li></ul></li></ul><h2 id="Function- 函数"><a href="#Function- 函数" class="headerlink" title="Function 函数"></a>Function 函数</h2><h3 id="Pointer-to-member-functions"><a href="#Pointer-to-member-functions" class="headerlink" title="Pointer to member functions"></a>Pointer to member functions</h3><ul><li>Member functions can be static or non-static<ul><li>Static ones are just normal functions with some <code>Class::</code>, their pointers are same as normal ones</li><li>Non-static ones are always bound to some specific objects, i.e. there is a <code>this</code> pointer as a parameter</li></ul></li></ul><p>e.g.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>{<br>    <span class="hljs-keyword">public</span>: <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AddAge</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> n)</span> </span>{<br>        age += n;<br>    }<br>}<br><br><span class="hljs-keyword">using</span> FuncPtr = <span class="hljs-built_in">void</span> (Person::*)(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    Person p{<span class="hljs-number">0</span> }, *pointer = &amp;p;<br>    FuncPtr ptr = &amp;Person::AddAge;<br>    (p.*ptr)(<span class="hljs-number">5</span>);<br>    (pointer-&gt;*ptr)(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">// C++ 17</span><br>    std::<span class="hljs-built_in">invoke</span>(ptr, p, <span class="hljs-number">5</span>);<br>    std::<span class="hljs-built_in">invoke</span>(ptr, pointer, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><ul><li>Define a pointer to member function is <code>Ret (Class::*)(params)</code></li><li><code>std::invoke</code> define in <code>&lt;functional&gt;</code> since C++ 17</li><li>Since C++ 23, <code>std::invoke_r&lt;Result&gt;</code> is provided</li></ul><h3 id="Callable-parameter"><a href="#Callable-parameter" class="headerlink" title="Callable parameter"></a>Callable parameter</h3><h4 id="Function-as-parameter"><a href="#Function-as-parameter" class="headerlink" title="Function as parameter"></a>Function as parameter</h4><ul><li>函数指针也可以实现将函数视为参数来传递，但是有两个问题<ul><li>有时候函数指针的参数类型有严格的限制，例如 <code>int</code> can be converted to <code>double</code>, <code>func(double)</code> is also acceptable</li><li>In C++, usually what you need is just “something callable”, i.e. a functor is allowed 有时候只是想传入一个可调用的类型</li></ul></li><li>有两种方式解决<ul><li>Use a template parameter <code>&lt;algorithm&gt;</code>常用的方法采用模板参数接受可调用的参数</li><li>Use a <code>std::function</code> defined in <code>&lt;functional&gt;</code><ul><li><code>std::function&lt;RetType(Args...)&gt;</code> can adopt almost all callable that have the return type <strong>convertible</strong> to <code>RetType</code> and accept <code>Args</code></li><li>The member function even preserves polymorphism</li><li>After getting the <code>std::function</code>, you can just use <code>operator()</code> to call it</li><li>Even more powerful, you can bind some parameters to get new functors<ul><li>E.g. you can use <code>std::bind(any_callable, params)</code> to get a <code>std::function</code> <code>std::bind</code>已经没有用了，完全可以用 Lambda 表达式绑定</li></ul></li><li>There are two defects<ul><li>Performance: It roughly causes 10% - 20% performance loss compared with direct function call<ul><li>有可能会用 <code>new</code>/<code>delete</code> 自定义<code>ctor</code>/<code>dtor</code></li><li>解决方式是使用 SOO(small object optimization)，在栈上准备一块小的 buffer 用于分配函数空间</li><li>如果绑定的 Lambda 表达是太大可以使用 <code>auto lambda = xx;</code>，然后再通过<code>std::ref(lambda)</code> 传给 <code>std::function</code> 的构造函数（但是要注意声明周期），但是不可以使用<code>std::ref(&amp;&amp;xx)(){...}</code>，lambda 表达式会立马失效</li></ul></li><li>The second defect of <code>std::function</code> is that it cannot really accept all functors 并不是支持所有的可调用类型<ul><li>When the functor is not copiable (e.g. move-only, like <code>std::unique_ptr</code>) 仿函数不能拷贝的就不能接受<ul><li>Thus, since C++ 23, <code>std::move_only_function</code> is introduced</li></ul></li></ul></li></ul></li></ul></li><li>Reference wrapper<ul><li><code>std::(c)ref()</code> in fact create <code>std::reference_wrapper&lt;(const) T&gt;</code>, which can be seen as an instantiated reference<ul><li>例如容器中不可能存储引用类型的，如果想储存引用类型可以使用<code>std::vector&lt;std::reference_wrapper&lt;T&gt;&gt;</code></li><li>It’s in fact a wrapper of pointer, but it cannot be null, just like reference</li><li>Different from reference, it can be bound to another object by <code>operator=</code>, just like pointer 引用是不可以换绑的，但是 <code>std::ref()</code> 可以</li></ul></li><li>It’s also used to denote “it should be a reference” explicitly in some methods in standard library, e.g. <code>std::bind_back</code> or <code>std::bind_front</code></li></ul></li></ul></li><li>There are also some predefined template functors in <code>&lt;functional&gt;</code><ul><li>Arithmetic functors: <code>plus</code>, <code>minus</code>, <code>multiplies</code>, <code>divides</code>, <code>modulus</code>, <code>negate</code></li><li>Comparison functors: <code>equal_to</code>, <code>not_equal_to</code>, <code>greater</code>, <code>less</code>, <code>greater_equal</code>, <code>less_equal</code>, <code>compare_three_way</code></li><li>Logical functors: <code>logical_and</code>, <code>logical_or</code>, <code>logical_not</code></li><li>Bitwise functors: <code>bit_and</code>, <code>bit_or</code>, <code>bit_xor</code>, <code>bit_not</code></li><li>These <code>Functor&lt;T&gt;</code> all have <code>auto operator()(const T&amp;, const T&amp;) const</code></li></ul></li></ul><h4 id="Lambda-expression"><a href="#Lambda-expression" class="headerlink" title="Lambda expression"></a>Lambda expression</h4><ul><li>We call lambda expression without capture <em>stateless lambda</em>; otherwise <em>stateful lambda</em></li><li>可以使用 <code>decltype(...)</code> 去推断 lambda 表达式的类型</li><li>理论上可以使用推断出来的仿函数的类型进行声明，但是只有再 C++ 20 之后才是合法的<ul><li>E.g. <code>auto l = [](int a, int b) {return a + b;}; using T = decltype(l); T l2{};</code></li><li>只适用 stateless lambda</li></ul></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><h3 id="Algorithms’-Consist"><a href="#Algorithms’-Consist" class="headerlink" title="Algorithms’ Consist"></a>Algorithms’ Consist</h3><ul><li>Iterator pairs 迭代器对，或者直接传入 ranges</li><li>Predicate function / transform function 判别函数或者变换函数，通常情况下变换都是<code>const&amp;</code>，或者对于比较小的类型传入拷贝</li><li>大部分算法都返回一个范围迭代器</li><li>从来都不会改变序列的大小</li><li>Callables of algorithm are of value type instead of reference type 判别函数或者变换函数都是传递值类型，不是引用类型</li></ul><h3 id="Search"><a href="#Search" class="headerlink" title="Search"></a>Search</h3><ul><li>两种搜索算法<ul><li>Linear search<ul><li>Find single value<ul><li><code>std::find</code></li><li><code>std::find_if</code></li></ul></li><li>Find one of values in a range<ul><li><code>std::find_first_of</code></li></ul></li><li>Find a sub-sequence in a sequence (Pattern matching)<ul><li><code>std::search</code></li><li><code>std::find_end</code></li></ul></li><li>Others<ul><li><code>std::adjacent_find(begin, end[, Pred2])</code>: 相邻元素相等的位置</li><li><code>std::search_n(begin, end, count, value, [, Pred2])</code></li></ul></li></ul></li><li>Binary search, which is applied on sorted sequence<ul><li><code>std::binary_search</code>: return bool, denoting whether <code>value</code> exists in <code>[begin, end)</code></li><li><code>std::lower_bound</code>: return <code>it</code> so that <code>value</code> is the lower bound of <code>[it, end)</code></li><li><code>std::upper_bound</code>: return <code>it</code> so that <code>value</code> is the lower upper of <code>[begin, end)</code></li><li><code>std::equal_range</code>: return an iterator pair <code>(it1, it2)</code> so that <code>value</code> is equal to <code>[it1, it2)</code></li></ul></li></ul></li></ul><h3 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h3><ul><li><code>std::equal(begin1, end1, ..., [, Pred2])</code>: return a bool</li><li><code>std::lexicographical_compare(begin1, end1, begin2, end2[, Pred2])</code>: return bool; Pred2<code>acts as</code>operator&lt;&gt;`<ul><li>Compare until <code>ele1 &lt; ele2 || ele2 &lt; ele1</code></li></ul></li><li><code>std::lexicographical_compare_three_way(begin1, end1, begin2, end2[, Pred2])</code>: return an ordering; <code>Pred2</code> acts as <code>operator&lt;=&gt;</code></li><li><code>std::mismatch(begin1, end1, ...[, Pred2])</code>:  return an iterator pair <code>(it1, it2)</code> denoting the first occurrence of mismatching</li><li>These algorithms are all <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul><h3 id="Counting"><a href="#Counting" class="headerlink" title="Counting"></a>Counting</h3><ul><li><code>std::all_of/any_of/none_of(begin, end, Pred)</code></li><li><code>std::count(begin, end, value)</code></li><li><code>std::count_if(begin, end, Pred)</code></li><li>These algorithms are all <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul><h3 id="Generating-and-Transforming"><a href="#Generating-and-Transforming" class="headerlink" title="Generating and Transforming"></a>Generating and Transforming</h3><ul><li><code>std::fill(begin, end, value)</code></li><li><code>std::fill_n(begin, count, value)</code></li><li><code>std::generate(begin, end, Gen)</code>: for each element in <code>[begin, end)</code>, <code>ele = Gen()</code></li><li><code>std::for_each(begin, end, Transform)</code>: for each element in <code>[begin, end)</code>, call <code>Transform(ele)</code></li><li><code>std::transform</code>: There are unary/binary transforms<ul><li><code>(begin, end, dstBegin, Transform)</code>: unary 一元</li><li><code>(begin, end, begin2, dstBeing, Transform)</code>: binary, the transformation is <code>Transform(*it1, *it2)</code></li></ul></li></ul><h3 id="Modifying"><a href="#Modifying" class="headerlink" title="Modifying"></a>Modifying</h3><ul><li><code>std::remove(begin, end, value)/std::remove_if(begin, end, Pred)</code>: return the iterator so that <code>[begin, it)</code> has no element that is equal to <code>value</code> or make <code>Pred</code> return <code>true</code><ul><li>不会真的擦除迭代器</li><li>Since C++ 20, they’re integrated as methods <code>std::erase/std::erase_if</code></li></ul></li><li><code>std::unique(begin, end[, Pred2])</code>: return the iterator so that <code>[begin, it)</code> has not adjacent equal element; <code>Pred2</code> acts as <code>operator==</code> 使得在 <code>[begin, it)</code> 区间内没有相邻且相等的元素</li><li>These algorithms are all <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, by the technique of dual pointers 算法用双指针实现<ul><li>定义两个指针 <code>before</code> 和<code>after</code></li><li>两个指针一开始都指向<code>begin</code></li><li>先前进<code>after</code></li><li>判断 <code>*before == *after</code>；相等只前进<code>after</code>，不相等则前进<code>before</code>，并将<code>after</code> 指向的值和 <code>before</code> 交换，前进<code>after</code></li><li>直到<code>after == end</code></li><li>需要考虑 <code>begin == end</code> 和整个序列就是 unique 的情况</li></ul></li><li><code>std::replace(begin, end, oldValue, newValue)/std::replace_if(begin, end, Pred, newValue)</code></li><li><code>std::swap(x, y)</code></li><li><code>std::iter_swap(it1, it2)</code></li><li><code>std::swap_range(begin1, end1, begin2)</code></li><li><code>std::reverse(begin, end)</code></li><li><code>std::rotate(begin, mid, end)</code>: left rotate <code>[begin, mid)</code><ul><li>2, 3, 4, 4, 5 -&gt; 4, 5, 2, 3, 4 相当于左移</li><li>Rotate is also <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container><ul><li>brute-force method: swap each element ot its position (just like bubble sort). This will be <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="11.727ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5183.4 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(1673,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2062,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(2884.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(3884.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(4405.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(4794.4,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 一个一个的交换，需要两层循环<ul><li>可以考虑将第一个元素拿出来，再确定序列中哪一个元素会再下一步出现在第一个位置，然后进行替换，以此类推完成旋转</li><li>但是这种方式对 cache 不友好</li></ul></li><li>swap all groups together<ul><li>The complexity is <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container><center>    <img src="/2024/06/03/56ae950785e9/algorithm-modifying-rotate.png" alt></center></li></ul></li><li>reverse<ul><li>In fact, reverse is the basis of many algorithms</li><li><code>[begin, mid - 1]``[mid, end - 1]</code></li><li>Reverse two sub-sequences, get <code>[mid - 1, being]``[end - 1, mid]</code></li><li>Reverse the total sequence, get <code>[mid, end - 1]``[begin, mid - 1]</code></li><li>The complexity is <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="23.931ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 10577.3 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1167,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(1688,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2299.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(3299.4,0)"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(4077.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(4466.4,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(5288.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(6288.9,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(6809.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(7421.1,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(8421.3,0)"><path data-c="398" d="M56 340Q56 423 86 494T164 610T270 680T388 705Q521 705 621 601T722 341Q722 260 693 191T617 75T510 4T388 -22T267 3T160 74T85 189T56 340ZM610 339Q610 428 590 495T535 598T463 651T384 668Q332 668 289 638T221 566Q168 485 168 339Q168 274 176 235Q189 158 228 105T324 28Q356 16 388 16Q415 16 442 24T501 54T555 111T594 205T610 339ZM223 263V422H263V388H514V422H554V263H514V297H263V263H223Z"/></g><g data-mml-node="mo" transform="translate(9199.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(9588.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(10188.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul></li></ul></li><li><code>std::shift_left/right(begin, end, n)</code>: the dropped elements are permanently dropped (invalid)</li></ul><h3 id="Copying"><a href="#Copying" class="headerlink" title="Copying"></a>Copying</h3><ul><li><code>std::copy(begin1, end1, dstBegin)</code></li><li><code>std::copy_if(begin1, end1, dstBegin[, Pred])</code></li><li><code>std::copy_n(begin1, n, dstBegin)</code></li><li><code>std::copy_backward(begin1, end1, dstBegin)</code></li></ul><h3 id="Partition-and-Sort"><a href="#Partition-and-Sort" class="headerlink" title="Partition and Sort"></a>Partition and Sort</h3><h4 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h4><p>Partition denotes that a range is divide into two parts; assuming predicate function <code>Pred</code>, then there exists an iterator <code>it</code> (i.e. partition point 轴点） so that all elements in <code>[begin, it)</code> make <code>Pred</code> return <code>true</code> while <code>[it, end)</code> make <code>Pred</code> return <code>false</code> 左边的都小于轴点（使得 <code>Pred</code> 函数返回 <code>true</code>），右边的都大于轴点（使得<code>Pred</code> 函数返回<code>false</code>）</p><ul><li><code>std::is_partitioned(begin, end, Pred)</code></li><li><code>std::partition(begin, end, Pred)</code></li><li><code>std::stable_partition(begin, end, Pred)</code>: each sub-partition preserves the original order 保证 partition 后的结果和原序列的顺序一致<ul><li>原序列 <code>{0, 1, 9, 4, 5, 2, 7, 8}</code>, <code>Pred</code>为 <code>[](const int ele) {return ele % 2;}</code> 左边是奇数右边是偶数</li><li><code>std::partition</code>: <code>{7, 1, 9, 5, 4, 2, 0, 8}</code></li><li><code>std::stable_partition</code>: <code>{1, 9, 5, 7, 0, 4, 2, 8}</code></li><li>Implementation:<ul><li>When the memory is enough （内存足够）, prepare a buffer; move the <code>false</code> range to the buffer and move the <code>true</code> range to be consecutive (just like preform <code>std::remove_if()</code>, with removed range saved in buffer). Then move the buffer elements back</li><li>When the memory is not enough （内存不够）, divide the sequence into two halves and stable partition each half<ul><li>This will from <code>[true, false], [true, false]</code> sequence 最终都会变成这样的序列</li><li>Rotate the middle <code>[false, true]</code> so that the final result is totally partitioned</li><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="21.777ex" height="2.477ex" role="img" focusable="false" viewbox="0 -750 9625.3 1095"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(704,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1093,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1693,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(2359.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(3415.6,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(3915.6,0)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="mo" transform="translate(4619.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mfrac" transform="translate(5008.6,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(255.4,-345) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><rect width="624.3" height="60" x="120" y="220"/></g><g data-mml-node="mo" transform="translate(5872.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mo" transform="translate(6484,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="mi" transform="translate(7484.3,0)"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(8247.3,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(8636.3,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(9236.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, to it’s overall <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.896ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3932 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(874,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(1474,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(2943,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3543,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li></ul></li></ul></li><li><code>std::partition_point(begin, end, Pred)</code>: assume the range is a partition 前提是序列已经是 partition</li></ul><h4 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h4><ul><li><code>std::is_sorted(begin, end[, Pred2])</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><code>std::is_sorted_until(begin, end[, Pred2])</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><code>std::sort(begin, end[, Pred2])</code> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.828ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4786 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2040,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3509,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(4397,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><code>std::stable_sort(begin, end[, Pred2])</code><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> space complexity, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.828ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4786 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2040,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3509,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(4397,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> time complexity</li><li>If space is insufficient, <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="13.576ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 6000.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2429,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3898,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="msup" transform="translate(4786,0)"><g data-mml-node="mo"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g><g data-mml-node="mn" transform="translate(422,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(5611.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> time complexity</li></ul></li><li>Since <code>std::sort</code> requires the complexity exactly <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.828ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4786 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2040,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3509,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(4397,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>, quick sort is not enough 快排只是平均意义上的<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.828ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4786 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2040,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3509,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(4397,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，最坏的情况是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="6.606ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2919.8 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mn" transform="translate(975.3,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2530.8,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>C++ 标准库广泛使用的排序算法是 Introspective Sort(IntroSort)<ul><li>It integrates insertion sort, heap sort and quick sort 结合了插入排序，堆排序和快排</li><li>When the element number is <strong>low enough</strong>, insertion sort is used</li><li>When the recursion is too deep, heap sort is used<ul><li>避免快排的最坏情况</li><li>堆排序是稳定<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.828ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4786 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2040,0)"><g data-mml-node="mi"><path data-c="1D425" d="M43 686L134 690Q225 694 226 694H232V62H301V0H292Q274 3 170 3Q67 3 49 0H40V62H109V332Q109 387 109 453T110 534Q110 593 108 605T94 620Q80 624 53 624H40V686H43Z"/><path data-c="1D428" d="M287 -5Q228 -5 182 10T109 48T63 102T39 161T32 219Q32 272 50 314T94 382T154 423T214 446T265 452H279Q319 452 326 451Q428 439 485 376T542 221Q542 156 514 108T442 33Q384 -5 287 -5ZM399 230V250Q399 280 398 298T391 338T372 372T338 392T282 401Q241 401 212 380Q190 363 183 334T175 230Q175 202 175 189T177 153T183 118T195 91T215 68T245 56T287 50Q348 50 374 84Q388 101 393 132T399 230Z" transform="translate(319,0)"/><path data-c="1D420" d="M50 300Q50 368 105 409T255 450Q328 450 376 426L388 420Q435 455 489 455Q517 455 533 441T554 414T558 389Q558 367 544 353T508 339Q484 339 471 354T458 387Q458 397 462 400Q464 401 461 400Q459 400 454 399Q429 392 427 390Q454 353 459 328Q461 315 461 300Q461 240 419 202Q364 149 248 149Q185 149 136 172Q129 158 129 148Q129 105 170 93Q176 91 263 91Q273 91 298 91T334 91T366 89T400 85T432 77T466 64Q544 22 544 -69Q544 -114 506 -145Q438 -201 287 -201Q149 -201 90 -161T30 -70Q30 -58 33 -47T42 -27T54 -13T69 -1T82 6T94 12T101 15Q66 57 66 106Q66 151 90 187L97 197L89 204Q50 243 50 300ZM485 403H492Q491 404 488 404L485 403V403ZM255 200Q279 200 295 206T319 219T331 242T335 268T336 300Q336 337 333 352T317 380Q298 399 255 399Q228 399 211 392T187 371T178 345T176 312V300V289Q176 235 194 219Q215 200 255 200ZM287 -150Q357 -150 400 -128T443 -71Q443 -65 442 -61T436 -50T420 -37T389 -27T339 -21L308 -20Q276 -20 253 -20Q190 -20 180 -20T156 -26Q130 -38 130 -69Q130 -105 173 -127T287 -150Z" transform="translate(894,0)"/></g></g><g data-mml-node="mi" transform="translate(3509,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(4397,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li>堆排序速度不是很快，对 cache 也不是很友好</li></ul></li></ul></li><li><code>std::partial_sort(begin, mid, end)</code></li><li><code>std::nth_element(begin, mid, end)</code>: rearrange <code>[begin, end)</code> so that <code>*mid</code> is sorted (i.e. same as the <code>*mid</code> in the full sorted range) and the whole range is partitioned by it 在排好序的中第 n 个位置的元素</li><li><code>std::merge(begin1, end1, begin2, end2, dstBegin[, Pred2])</code></li><li><code>std::inplace_merge(begin, mid, end)</code></li></ul><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><ul><li><code>std::is_heap(_until)(begin, end[, Pred2])</code></li><li><code>std::make_heap(begin, end[, Pred2])</code>: Floyd algorithm <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li><li><code>std::push_heap(begin, end[, Pred2])</code></li><li><code>std::pop_heap(begin, end[, Pred2])</code></li><li><code>std::sort_heap(begin, end[, Pred2])</code></li></ul><h4 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a>Set Operations</h4><p>Set operations are used on <strong>sorted</strong> range, including <code>set</code></p><ul><li><code>std::includes(begin1, end1, begin2, end2[, Pred2])</code>: check whether th second range is subset of the first range<center>    <img src="/2024/06/03/56ae950785e9/set-operations-inclues-1.png" alt>    <img src="/2024/06/03/56ae950785e9/set-operations-inclues-2.png" alt></center></li><li><code>std::set_intersection(begin1, end1, begin2, end2, dstBegin[, Pred2])</code>: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.929ex" height="1.67ex" role="img" focusable="false" viewbox="0 -716 2620.4 738"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2229" d="M88 -21T75 -21T55 -7V200Q55 231 55 280Q56 414 60 428Q61 430 61 431Q77 500 152 549T332 598Q443 598 522 544T610 405Q611 399 611 194V-7Q604 -22 591 -22Q582 -22 572 -9L570 405Q563 433 556 449T529 485Q498 519 445 538T334 558Q251 558 179 518T96 401Q95 396 95 193V-7Q88 -21 75 -21Z"/></g><g data-mml-node="mi" transform="translate(1861.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container></li><li><code>std::set_union(begin1, end1, begin2, end2, dstBegin[, Pred2])</code>: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="5.929ex" height="1.67ex" role="img" focusable="false" viewbox="0 -716 2620.4 738"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="222A" d="M591 598H592Q604 598 611 583V376Q611 345 611 296Q610 162 606 148Q605 146 605 145Q586 68 507 23T333 -22Q268 -22 209 -1T106 66T56 173Q55 180 55 384L56 585Q66 598 75 598Q85 598 95 585V378L96 172L98 162Q112 95 181 57T332 18Q415 18 487 58T570 175Q571 180 571 383V583Q579 598 591 598Z"/></g><g data-mml-node="mi" transform="translate(1861.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container></li><li><code>std::set_symmetric_difference(begin1, end1, begin2, end2, dstBegin[, Pred2])</code>: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="6.18ex" height="1.805ex" role="img" focusable="false" viewbox="0 -716 2731.4 798"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1972.4,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g></g></g></svg></mjx-container></li><li><code>std::set_difference(begin1, end1, begin2, end2, dstBegin[, Pred2])</code>: <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="12.151ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 5370.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(972.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mo" transform="translate(1972.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(2361.4,0)"><path data-c="1D434" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/></g><g data-mml-node="mo" transform="translate(3333.7,0)"><path data-c="2229" d="M88 -21T75 -21T55 -7V200Q55 231 55 280Q56 414 60 428Q61 430 61 431Q77 500 152 549T332 598Q443 598 522 544T610 405Q611 399 611 194V-7Q604 -22 591 -22Q582 -22 572 -9L570 405Q563 433 556 449T529 485Q498 519 445 538T334 558Q251 558 179 518T96 401Q95 396 95 193V-7Q88 -21 75 -21Z"/></g><g data-mml-node="mi" transform="translate(4222.9,0)"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mo" transform="translate(4981.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul><h4 id="MinMax"><a href="#MinMax" class="headerlink" title="MinMax"></a>MinMax</h4><ul><li><code>std::min/max/minmax(a, b[, Pred2])</code>: return (pair of) reference of the smaller/bigger element</li><li><code>std::min_element/max_element/minmax_element(begin, end[, Pred2])</code>: return the iterator of the minimum/maximum value in the range</li><li><code>std::clamp(value, low, high)</code></li></ul><h4 id="Permutation"><a href="#Permutation" class="headerlink" title="Permutation"></a>Permutation</h4><p>Permutation means that two sequence are <strong>unorderly equal</strong></p><ul><li><code>std::is_permutation(begin, end1, begin2[, Pred2])</code><ul><li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewbox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></li></ul></li><li><code>std::prev/next_permutation(begin, end[, Pred2])</code>: return the sequence to the previous/next permutation</li></ul><h4 id="Numeric-Algorithms"><a href="#Numeric-Algorithms" class="headerlink" title="Numeric Algorithms"></a>Numeric Algorithms</h4><p>They are all <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.495ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2429 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2040,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><ul><li>For the most basic ones:<ul><li><code>std::iota(begin, end, beginVal)</code>: fill in <code>[begin, end)</code> with <code>{beginVal, ++beginVal, ...}</code></li><li><code>std::adjacent_difference(begin, end, dstBegin, Op = std::minus)</code>: as its name, output <code>{val[0], val[1] - val[0], val[2] - val[1], ...}</code></li><li><code>std::accumulate(begin, end, initVal, Op = std::plus)</code>: accumulate all values, return <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.975ex;" xmlns="http://www.w3.org/2000/svg" width="19.261ex" height="3.165ex" role="img" focusable="false" viewbox="0 -967.8 8513.5 1398.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mtext"><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z"/><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(278,0)"/><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(834,0)"/><path data-c="74" d="M27 422Q80 426 109 478T141 600V615H181V431H316V385H181V241Q182 116 182 100T189 68Q203 29 238 29Q282 29 292 100Q293 108 293 146V181H333V146V134Q333 57 291 17Q264 -10 221 -10Q187 -10 162 2T124 33T105 68T98 100Q97 107 97 248V385H18V422H27Z" transform="translate(1112,0)"/><path data-c="56" d="M114 620Q113 621 110 624T107 627T103 630T98 632T91 634T80 635T67 636T48 637H19V683H28Q46 680 152 680Q273 680 294 683H305V637H284Q223 634 223 620Q223 618 313 372T404 126L490 358Q575 588 575 597Q575 616 554 626T508 637H503V683H512Q527 680 627 680Q718 680 724 683H730V637H723Q648 637 627 596Q627 595 515 291T401 -14Q396 -22 382 -22H374H367Q353 -22 348 -14Q346 -12 231 303Q114 617 114 620Z" transform="translate(1501,0)"/><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(2251,0)"/><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z" transform="translate(2751,0)"/></g><g data-mml-node="mo" transform="translate(3251.2,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="munderover" transform="translate(4251.4,0)"><g data-mml-node="mo"><path data-c="2211" d="M61 748Q64 750 489 750H913L954 640Q965 609 976 579T993 533T999 516H979L959 517Q936 579 886 621T777 682Q724 700 655 705T436 710H319Q183 710 183 709Q186 706 348 484T511 259Q517 250 513 244L490 216Q466 188 420 134T330 27L149 -187Q149 -188 362 -188Q388 -188 436 -188T506 -189Q679 -189 778 -162T936 -43Q946 -27 959 6H999L913 -249L489 -250Q65 -250 62 -248Q56 -246 56 -239Q56 -234 118 -161Q186 -81 245 -11L428 206Q428 207 242 462L57 717L56 728Q56 744 61 748Z"/></g><g data-mml-node="TeXAtom" transform="translate(1089,477.1) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z"/><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(444,0)"/><path data-c="64" d="M376 495Q376 511 376 535T377 568Q377 613 367 624T316 637H298V660Q298 683 300 683L310 684Q320 685 339 686T376 688Q393 689 413 690T443 693T454 694H457V390Q457 84 458 81Q461 61 472 55T517 46H535V0Q533 0 459 -5T380 -11H373V44L365 37Q307 -11 235 -11Q158 -11 96 50T34 215Q34 315 97 378T244 442Q319 442 376 393V495ZM373 342Q328 405 260 405Q211 405 173 369Q146 341 139 305T131 211Q131 155 138 120T173 59Q203 26 251 26Q322 26 373 103V342Z" transform="translate(1000,0)"/></g></g><g data-mml-node="TeXAtom" transform="translate(1089,-285.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mtext"><path data-c="62" d="M307 -11Q234 -11 168 55L158 37Q156 34 153 28T147 17T143 10L138 1L118 0H98V298Q98 599 97 603Q94 622 83 628T38 637H20V660Q20 683 22 683L32 684Q42 685 61 686T98 688Q115 689 135 690T165 693T176 694H179V543Q179 391 180 391L183 394Q186 397 192 401T207 411T228 421T254 431T286 439T323 442Q401 442 461 379T522 216Q522 115 458 52T307 -11ZM182 98Q182 97 187 90T196 79T206 67T218 55T233 44T250 35T271 29T295 26Q330 26 363 46T412 113Q424 148 424 212Q424 287 412 323Q385 405 300 405Q270 405 239 390T188 347L182 339V98Z"/><path data-c="65" d="M28 218Q28 273 48 318T98 391T163 433T229 448Q282 448 320 430T378 380T406 316T415 245Q415 238 408 231H126V216Q126 68 226 36Q246 30 270 30Q312 30 342 62Q359 79 369 104L379 128Q382 131 395 131H398Q415 131 415 121Q415 117 412 108Q393 53 349 21T250 -11Q155 -11 92 58T28 218ZM333 275Q322 403 238 411H236Q228 411 220 410T195 402T166 381T143 340T127 274V267H333V275Z" transform="translate(556,0)"/><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(1000,0)"/><path data-c="69" d="M69 609Q69 637 87 653T131 669Q154 667 171 652T188 609Q188 579 171 564T129 549Q104 549 87 564T69 609ZM247 0Q232 3 143 3Q132 3 106 3T56 1L34 0H26V46H42Q70 46 91 49Q100 53 102 60T104 102V205V293Q104 345 102 359T88 378Q74 385 41 385H30V408Q30 431 32 431L42 432Q52 433 70 434T106 436Q123 437 142 438T171 441T182 442H185V62Q190 52 197 50T232 46H255V0H247Z" transform="translate(1500,0)"/><path data-c="6E" d="M41 46H55Q94 46 102 60V68Q102 77 102 91T102 122T103 161T103 203Q103 234 103 269T102 328V351Q99 370 88 376T43 385H25V408Q25 431 27 431L37 432Q47 433 65 434T102 436Q119 437 138 438T167 441T178 442H181V402Q181 364 182 364T187 369T199 384T218 402T247 421T285 437Q305 442 336 442Q450 438 463 329Q464 322 464 190V104Q464 66 466 59T477 49Q498 46 526 46H542V0H534L510 1Q487 2 460 2T422 3Q319 3 310 0H302V46H318Q379 46 379 62Q380 64 380 200Q379 335 378 343Q372 371 358 385T334 402T308 404Q263 404 229 370Q202 343 195 315T187 232V168V108Q187 78 188 68T191 55T200 49Q221 46 249 46H265V0H257L234 1Q210 2 183 2T145 3Q42 3 33 0H25V46H41Z" transform="translate(1778,0)"/></g></g></g><g data-mml-node="mtext" transform="translate(7207.5,0)"><path data-c="76" d="M338 431Q344 429 422 429Q479 429 503 431H508V385H497Q439 381 423 345Q421 341 356 172T288 -2Q283 -11 263 -11Q244 -11 239 -2Q99 359 98 364Q93 378 82 381T43 385H19V431H25L33 430Q41 430 53 430T79 430T104 429T122 428Q217 428 232 431H240V385H226Q187 384 184 370Q184 366 235 234L286 102L377 341V349Q377 363 367 372T349 383T335 385H331V431H338Z"/><path data-c="61" d="M137 305T115 305T78 320T63 359Q63 394 97 421T218 448Q291 448 336 416T396 340Q401 326 401 309T402 194V124Q402 76 407 58T428 40Q443 40 448 56T453 109V145H493V106Q492 66 490 59Q481 29 455 12T400 -6T353 12T329 54V58L327 55Q325 52 322 49T314 40T302 29T287 17T269 6T247 -2T221 -8T190 -11Q130 -11 82 20T34 107Q34 128 41 147T68 188T116 225T194 253T304 268H318V290Q318 324 312 340Q290 411 215 411Q197 411 181 410T156 406T148 403Q170 388 170 359Q170 334 154 320ZM126 106Q126 75 150 51T209 26Q247 26 276 49T315 109Q317 116 318 175Q318 233 317 233Q309 233 296 232T251 223T193 203T147 166T126 106Z" transform="translate(528,0)"/><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z" transform="translate(1028,0)"/></g></g></g></svg></mjx-container></li><li><code>std::partial_sum(begin, end, dstBegin, Op = std::plus)</code>: output <code>{val[0], val[0] + val[1], val[0] + val[1] + val[2], ...}</code></li><li><code>std::inner_product(begin1, end1, begin2, initVal, Op1 = std::plus, Op2 = std::multiplies)</code>: finally get <code>initVal + a[0] * b[0] + a[1] * b[1] + ...</code></li><li><code>std::reduce(begin, end, initVal, Op = std::plus)</code>: same as accumulate</li><li><code>std::inclusive_scan(begin, end, dstBegin, Op = std::plus[, initVal])</code>: same as partial sum</li><li><code>std::transform_reduce(begin1, end1, begin2, initVal, ReduceOp = std::plus, BiTransformOp = std::multiplies)</code>: same as inner product</li><li><code>std::exclusive_scan(begin, end, dstBegin, initVal, Op = std::plus)</code>: similar to partial, but exclude the element itself, i.e. the sequence is <code>{initVal, initVal + val[0], ..., initVal + val[0] + ... + val[n - 2]}</code></li><li><code>std::transform_inclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])</code></li><li><code>std::transform_exclusive_scan(begin, end, dstBegin, Op, UnaryTransformOp[, initVal])</code></li></ul></li><li><code>std::gcd(a, b)</code>: 最大公约数</li><li><code>std::lcm(a, b)</code>: 最小公倍数</li><li><code>std::midpoint(a, b)</code>: since C++ 20, return <code>a + (b - a) / 2</code></li></ul><h4 id="Parallel-Algorithm"><a href="#Parallel-Algorithm" class="headerlink" title="Parallel Algorithm"></a>Parallel Algorithm</h4><ul><li>There are two kinds of parallelism<ul><li>SIMD: single instruction multiple data 单指令多数据</li><li>SIMT: single instruction multiple threads</li></ul></li><li>Since C++ 17, parallel-version algorithms are added</li><li>Defined in <code>&lt;execution&gt;</code><ul><li>There are four execution policies defined in <code>std::execution</code><ul><li><code>seq</code>: sequenced policy 完全不并行</li><li><code>par</code>: parallel policy 并行</li><li><code>unseq</code>: unsequenced policy (since C++ 20) 算法可以适应 SIMD</li><li><code>par_unseq</code>: parallel and unsequenced policy</li></ul></li></ul></li><li>There are four kinds of data dependencies<ul><li>RAR: read after read 可以使用<code>par_unseq</code><ul><li>E.g. <code>std::adjacent_find</code></li></ul></li><li>RAW: read after write, e.g. <code>a[j] = a[j - 1] + 1</code></li><li>WAR: write after read, e.g. <code>a[j - 1] = a[j] + 1</code></li><li>WAW: write after write</li></ul></li><li>Parallel algorithms<ul><li><code>std::partition</code>, <code>std::nth_element</code></li><li><code>std::merge</code></li><li><code>std::inplace_merge</code></li></ul></li><li>There are also some algorithms that cannot be parallelized<ul><li>Those who only operate on several values, e.g. <code>std::min/max/minmax/clamp</code>, <code>std::swap/iter_swap</code></li><li>随机算法</li><li><code>std::search</code></li><li><code>std::push/pop/make/sort_heap</code></li><li>排列算法</li><li>二叉搜索算法</li><li>Ordered numeric algorithms, i.e. <code>std::iota/accumulate/inner_product/partial_sum</code></li></ul></li></ul><h4 id="Range-version-Algorithms"><a href="#Range-version-Algorithms" class="headerlink" title="Range-version Algorithms"></a>Range-version Algorithms</h4><p>算法中需要声明迭代器，当操作的是一整个容器时，就需要 <code>begin</code> 和<code>end</code>，所以可以使用<code>ranges</code>。range-version 算法也可以叫做 constrained algorithms，使得算法操作更加灵活</p><ul><li>You can additionally specify <strong>projection</strong> as the last parameter, i.e. transformation of elements before entering the real function 最后一个参数可以指定一个映射，例如使用 transform 在传入函数前进行变换<ul><li>This just changes criteria（标准；条件）, the element itself is unchanged</li><li>Multiple ranges may specify multiple projections</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::vector vec{<span class="hljs-number">-1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">6</span> };<br><span class="hljs-keyword">auto</span> print = [](<span class="hljs-type">int</span> i) {<br>    std::cout &lt;&lt; i &lt;&lt; <span class="hljs-string">","</span>;<br>};<br>std::cout &lt;&lt; <span class="hljs-string">"with abs() projection: \n"</span>;<br>std::ranges::<span class="hljs-built_in">sort</span>(vec, {}, [](<span class="hljs-type">int</span> i) {<span class="hljs-keyword">return</span> std::<span class="hljs-built_in">abs</span>(i); });<br>std::range::for_each(vec, print);<br></code></pre></td></tr></table></figure><ul><li>Range-version algorithms also have these advantages<ul><li>使用了 C++20 中的 concept</li><li>The range doesn’t need to be comma (i.e. <code>begin/end</code> with the same type) <code>begin</code>和 <code>end</code> 不要求类型相同</li><li>更加安全</li><li>有些算法被加强了</li><li>新的方法加入进来</li><li>用模板方法更容易</li></ul></li><li>There are also some defects<ul><li>不能使用并行算法</li><li>一些算法被削弱了</li><li>返回值类型并不和 <code>std::</code> 相同，返回值改变有以下几种形式<ul><li><code>stdr::in_in_result&lt;I1, I2&gt;</code>: 本来返回两个迭代器，现在返回了一个结构体，里面的成员变量是两个迭代器</li><li><code>stdr::in_out_result&lt;I, O&gt;</code></li><li><code>stdr::in_in_out_result&lt;I1, I2, O&gt;</code><ul><li><code>stdr::set_union/intersection/symmetric_difference</code></li><li><code>stdr::merge</code></li><li>binary <code>stdr::transform</code></li></ul></li><li><code>stdr::in_out_out_result&lt;I1, I2, O&gt;</code><ul><li><code>stdr::partition_copy</code></li></ul></li><li><code>stdr::in_found_result&lt;T&gt;</code></li></ul></li></ul></li></ul><h2 id="Lifetime"><a href="#Lifetime" class="headerlink" title="Lifetime"></a>Lifetime</h2><h3 id="Storage-duration- 存储持续性"><a href="#Storage-duration- 存储持续性" class="headerlink" title="Storage duration 存储持续性"></a>Storage duration 存储持续性</h3><p>There are four kinds of storage duration</p><ul><li>Static storage duration: global variables, static variables in a function/class</li><li>Automatic storage duration: variables that belong to a block scope ro function arguments 定义的时候构造，退出的时候析构</li><li>Dynamic storage duration: you can create objects by using or some other allocation functions</li><li>Thread storage duration: 线程创建的时候构造，线程退出的时候析构</li></ul><p>The lifetime of an object begins when storage with proper alignment and size is allocated and the object is initialized 合适的对齐，合适的大小，以及初始化</p><p>The lifetime of an object ends when it’s destroy, or the dtor is called, or its storage is released or reused by non-nested object 析构函数被调用，存储被释放，被重用（<code>float</code>类型的变量通过某些手段被 <code>int</code> 类型变量占用）</p><p>Temporary objects are only alive until the statement ends (i.e. until <code>;</code>) 临时变量的声明周期只到语句结束之前，也就是 <code>;</code> 分号之后才结束</p><ul><li>函数中的参数传递 <code>const&amp;</code> 或<code>std::function_ref</code>是安全的</li><li>返回临时变量可以延长对象的生命周期，例如<code>const&amp;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span>{};<br><span class="hljs-function">A <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> A{};};<br><span class="hljs-type">const</span> A&amp; a = <span class="hljs-built_in">bar</span>();<br></code></pre></td></tr></table></figure></li></ul><p>In modern C++, <strong>pointer is far beyond address</strong>; it has type <code>T*</code>, and you can hardly ever access some address by it when there are no underlying objects of type <code>T</code> alive 指针的功能远远超出寻址的语义，指针是带有类型的概念；如果指针指向的地址不符合指针具有的类型，如果再用指针访问相应的元素就会是无效的</p><h3 id="Placement-new"><a href="#Placement-new" class="headerlink" title="Placement new"></a>Placement new</h3><p>“就地初始化” <code>ConstructOnBuffet</code>, which won’t allocate memory, but only create the object at the place 不在重新分配内存，直接在现有已开辟的内存空间中创建对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">alignas</span>(T) <span class="hljs-type">unsigned</span> chat buf[<span class="hljs-built_in">sizeof</span>(T)];<br>T* tptr = <span class="hljs-built_in">new</span>(buf) T;<br>tptr-&gt;~<span class="hljs-built_in">T</span>();<br></code></pre></td></tr></table></figure><ul><li><code>new(buffet) Type Initializer</code>, where <code>Initializer</code> is optional</li><li>Of course, you need to make sure the alignment satisfies the requirement of the type, so you can use keyword <code>alignas</code>  为了保证类型对齐需要用到在 C++ 11 引入的关键字<code>alignas</code></li></ul><blockquote><ul><li><code>std::byte</code>: defined in <code>&lt;cstddef&gt;</code> since C++ 17; it’s just an enumeration class and explicitly represents a byte (before we may use <code>unsigned char</code>)</li><li>Trivial dtor<ul><li>It’s implicitly declared or declared with <code>=default</code> 隐式生成（编译器）的或者被定义为<code>default</code></li><li>It’s non-virtual and all non-static data members have trivial dtor 所有的非静态成员都有 trivial dtor，并且成员不能是虚的</li><li>For example<ul><li>✅<code>struct A{int a; float b;};</code></li><li>✅<code>class A{int a; public: float b; ~A() = default };</code></li><li>✅<code>class A{int a; public: float b; virtual ~A() = default };</code></li><li>❎<code>class B : public A{};</code></li><li>❎<code>class A{~A() {}};</code></li><li>❎<code>class A{std::unique_ptr&lt;int&gt; ptr;};</code></li></ul></li></ul></li></ul></blockquote><h3 id="Corner-Cases"><a href="#Corner-Cases" class="headerlink" title="Corner Cases"></a>Corner Cases</h3><ul><li>Case1: if you construct an object that has the same type as the original object, and they occupies exactly same storage, then the original name, pointers and references are still valid 就像赋值符号一样</li><li>Case2: it’s best to reuse storage of plain types like <code>int</code> or classes that have trivial dtor 如果要重用内存尽量使用简单的类型，例如 <code>int</code> 或者带有 trivial dtor 的类，对于其他类型编译器会在退出当前 scope 时候会自动调用析构函数</li><li>Case3: it’s illegal to reuse memory of <code>const</code> objects that have determined their value in the compilation time</li><li>Case4: <code>unsigned char/std::byte</code> array is explicitly regulated to be able to provide storage 这两个类型的数组是明确地可以提供 storage 的</li><li>Case5: It’s legal to access the underlying object by pointers without the same type in these cases (type punning/aliasing 类型堆叠 / 类型别名） 在少数情况下可以使用不同类型的指针访问一些对象<ul><li>add/remove cv-qualification <code>int</code>类型的指针可以使用 <code>const int</code> 类型的指针访问</li><li>decayed array 用指针访问数组的元素</li><li>if the underlying type is integer, then using the pointer of its signed/unsigned variant to access it is OK</li><li>convert it to <code>(unsigned) char*/ std::byte*</code> 允许将对象视作字节数组 byte array</li></ul></li><li>Case6:If you have an old pointer where you’ve constructed a new object, but you want to use the old pointer to get the new pointer, you can use <code>std::launder</code>（洗涤；洗钱） defined in <code>&lt;new&gt;</code> since C++ 17<ul><li><code>std::launder(reinterpret_cast&lt;A*&gt;(buffer))</code> to get the actual valid pointer 用旧的指针获得指向新的对象的指针</li></ul></li></ul><h3 id="Strict-Aliasing-Rules"><a href="#Strict-Aliasing-Rules" class="headerlink" title="Strict Aliasing Rules"></a>Strict Aliasing Rules</h3><p>Strict aliasing rules, if pointers are not aliased or not contained as member, then compilers can freely assume that they’re different objects 本质上就是检查两个指针指向的区域有没有可能重叠</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">T</span><br>{<br>    <span class="hljs-type">uint8_t</span>* target;<br>    <span class="hljs-type">char</span>* source;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Unpack</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span></span><br><span class="hljs-function">    </span>{<br>        <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>)<br>        {<br>            <span class="hljs-type">uint64_t</span> t;<br>            std::<span class="hljs-built_in">memcpy</span>(&amp;t, source, <span class="hljs-built_in">sizeof</span>(t));<br>            target[<span class="hljs-number">0</span>] = t &amp; <span class="hljs-number">0x7</span>;<br>            target[<span class="hljs-number">1</span>] = (t &gt;&gt; <span class="hljs-number">3</span>) &amp; <span class="hljs-number">0x7</span>;<br>            target[<span class="hljs-number">2</span>] = (t &gt;&gt; <span class="hljs-number">6</span>) &amp; <span class="hljs-number">0x7</span>;<br>            target[<span class="hljs-number">3</span>] = (t &gt;&gt; <span class="hljs-number">9</span>) &amp; <span class="hljs-number">0x7</span>;<br>            source += <span class="hljs-number">6</span>, size -= <span class="hljs-number">6</span>, target += <span class="hljs-number">16</span>;<br>        }<br>    }<br>};<br></code></pre></td></tr></table></figure><ul><li>Compared with non-member version (i.e. <code>Unpack(uint8_t* target, char* src, int size)</code>), it’s 15% slower</li><li><code>target</code> is an alias of <code>this</code>. It will then always reload <code>target[i]</code> instead of caching a <code>qword</code> to prevent change of <code>target</code> 编译器认为 <code>target</code> 是<code>this</code>的别名</li></ul><h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><ul><li>Attention to lambda lifetime<ul><li>Lambda lifetime should always be shorter than reference captures</li><li>If you capture in the class, then this only captures members by <code>this</code>, which may be invalid after destruction 如果 <code>this</code> 被析构掉，就算是把 <code>this</code> 拷贝出来，还是失效的</li></ul></li><li>Attention to view lifetime<ul><li>Sometimes you mey return a view generated by range adaptor in a function (e.g. <code>v | std::reverse</code>)<ul><li>For lvalue, it’s same as the lvalue itself, i.e. <code>v</code> here</li><li>For rvalue, it’ll same as return a value, so that it’s always safe 临时值</li></ul></li><li>所有的 range adaptors 在调用之前都会调用 <code>stdv::all</code> 尝试将 range 转换成 view；但是对于 view 来说不做任何事情<ul><li>For lvalue range, it’ll create a <code>stdr::ref_view</code></li><li>For rvalue range, it’ll create a <code>stdr::owning_view</code></li></ul></li></ul></li></ul><h2 id="Type-Safety"><a href="#Type-Safety" class="headerlink" title="Type Safety"></a>Type Safety</h2><h3 id="Implicit-Conversion"><a href="#Implicit-Conversion" class="headerlink" title="Implicit Conversion"></a>Implicit Conversion</h3><ul><li>Some implicit conversions are automatic (standard conversions), and others are user-defined 很多隐式的转型都是自动的<ul><li>E.g. <code>operator float()</code>. If you declare it as <code>explicit</code>, then implicit conversion will be disabled</li></ul></li><li>Standard conversions<ul><li>Lvalue-to rvalue conversion, array-to-pointer conversion, function-to-pointer conversion<ul><li>Decay actually means<ul><li>Array/Function -&gt; pointer</li><li>Or for other types, remove remove references first, remove cv-qualifiers(const &amp; volatile) next</li><li>You can use <code>std::decay_t&lt;T&gt;</code> to get the decayed type</li><li><code>auto a = xx;</code> will also decay the deduced type, while <code>auto&amp;</code> will not<ul><li>But structured binding <code>auto [a, b] = xx;</code> “seems” not decay decay 看似没发生，其实是发生在结构化绑定的实现上，相当于 <code>auto anonymous = xx;</code>，<code>a</code> 和<code>b</code>是成员变量的别名，decay 发生在 <code>anonymous</code> 中</li></ul></li></ul></li></ul></li><li>Numeric promotions and conversions<ul><li>Promotion: promotion has higher precedence and will not lose precision<ul><li><code>b + c</code> where <code>b</code> and <code>c</code> are <code>unsigned short</code> will in fact silently promote them to <code>int</code> and then do <code>+</code> 先提升到 <code>int</code> 然后再做加法</li><li>至少提升到<code>int</code></li><li><code>float</code> can be promoted to <code>double</code></li></ul></li><li>Signed value has negative values while unsigned ones don’t, but conversion may happen</li><li><code>float</code> cannot represent all <code>int/...</code> but <code>int</code> can be converted to <code>float</code> implicitly</li><li>Any scalar types can be converted to <code>bool</code></li><li>Pointers can be converted to <code>void*</code> to base class, and <code>nullptr</code> can be converted to pointer directly</li><li>Pointer to member of derived class can also be converted to pointer to member of base class, i.e. <code>Derived::int*</code> -&gt; <code>Base::int*</code></li><li>There are also some numeric conversions that need explicit cast 数值上的转换需要显示的转换<ul><li>Narrow integer conversion will mod <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.279ex" height="1.528ex" role="img" focusable="false" viewbox="0 -675.5 1007.3 675.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 例如 <code>int</code> -&gt; <code>short</code>，<code>long long</code> -&gt; <code>int</code> 会把高位的位数截断</li><li>Narrow floating conversion will be rounded</li><li>Floating to integer will truncate the digits after dot; UB if truncated integer is not representable by converted type</li></ul></li></ul></li><li>(Exception-specified) function pointer conversion<ul><li>可以把 <code>noexcept</code> 的函数指针转换成没有 <code>noexcept</code> 的函数指针</li></ul></li><li>Qualification conversions<ul><li>You can convert a non-const/non-volatile to const/volatile one</li></ul></li></ul></li></ul><h3 id="Static-Cast"><a href="#Static-Cast" class="headerlink" title="Static Cast"></a>Static Cast</h3><p><code>static_cast</code> is the most powerful one, which can process almost all of normal conversion,defined as <code>static_cast&lt;TargetType&gt;(Exp)</code></p><blockquote><p><strong>Standard-layout</strong></p><ul><li>所有的成员都有相同的访问属性</li><li>没有虚函数</li><li>The base class is not the type of the first member data 基类对象不能是子类第一个成员变量</li><li>整个继承结构，只能有其中一个类是有非静态的变量</li></ul></blockquote><ul><li>All implicit conversions can be explicitly denoted by <code>static_cast</code> 可以做任何一种隐式的转换，也会允许逆操作 e.g. <code>int</code> -&gt; <code>short</code>, <code>double</code> -&gt; <code>float</code></li><li>Scoped enumeration can be converted to/from integer or floating point, which is same as the underlying integer type</li><li>Inheritance-related conversions<ul><li>upcast 向基类转换；更安全的</li><li>downcast 向派生类转换；有点危险</li></ul></li><li>For <code>static_cast</code>, besides inheritance-related pointer conversion, it also processes <code>void*</code><ul><li>You can convert any object pointer to <code>void*</code> (this is also implicit conversion)</li><li>You can also convert explicitly <code>void*</code> to any object pointer 前提是对象潜在的类型 <code>U</code> 和指针的类型 <code>T</code> 有某种特殊的关系——pointer-interconvertible<ul><li><code>T == U</code></li><li><code>U</code> is a union type, while <code>T</code> is type of its member</li><li><code>U</code> is standard-layout, while <code>T</code> is type of its first member or its base class</li><li>Or all vice versa/transitivity</li></ul></li></ul></li><li>并不保证地址是相同的</li><li>Convert to <code>void</code>: just discard value, nothing happens</li><li>Construct new object: if the object ctor can accept a single parameter, which is convertible from the expression, then it in fact constructs a new object. E.g. <code>static_cast&lt;A&gt;(a)</code> for <code>A(int)</code></li><li>Transform value category</li><li><code>static_cast</code> can be used to specify which overload of functions is used by function-to-pointer conversion</li></ul><h3 id="Dynamic-Cast-and-RTTI"><a href="#Dynamic-Cast-and-RTTI" class="headerlink" title="Dynamic Cast and RTTI"></a>Dynamic Cast and RTTI</h3><h4 id="Dynamic-Cast"><a href="#Dynamic-Cast" class="headerlink" title="Dynamic Cast"></a>Dynamic Cast</h4><p><code>static_cast</code>在继承链中检查是非常弱的（可以说是不做检查），即便转换的对象不是派生类的类型仍然会做转换，只是会带来 undefined behavior。<code>dynamic_cast</code>尝试解决这个问题，如果转换不合适会失败</p><ul><li>引用上转换失败会抛出异常<code>throw std::bad_cast</code></li><li>指针上转换失败会返回<code>nullptr</code></li><li>比 UB 更强，更容易定位 bug</li></ul><p>为了做了运行时检查，C++ 编译器会在文件中保留运行时的类型识别（RTTI, Run-Time Type Information/Identification），<code>dynamic_cast</code>只能用在多态的类型转换中，因为 RTTI 依赖于虚指针等特性。但是 <code>dynamic_cast</code> 性能上要比 <code>static_cast</code> 慢 10 倍甚至百倍</p><ul><li>You can do downcast in polymorphic types<ul><li>被转换的对象，潜在的对象类型必须和基类的类型相同，否则不能转换成功</li><li><code>dynamic_cast</code>不能用在当前类构造函数和析构函数中，因为当前类的虚指针不是完整的</li></ul></li><li>You can also do sidecast in polymorphic types with multiple inheritance</li></ul><h4 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h4><p>C++ 提供了一种方式可以直接得到类型的信息，定义在 <code>&lt;typeinfo&gt;</code>，同样要限制使用，会造成性能上的问题。可以使用<code>typeid(xxx)</code> 得到 <code>const std::type_info</code>，类似于<code>sizeof</code> 操作符。<code>type_info</code>是只读的，不能通过拷贝或者构造，只能通过 <code>typeid</code> 获得或者引用。可以使用 <code>.name()</code> 进行 debug</p><ul><li><code>.name()</code></li><li><code>.hash_code()</code></li><li><code>.before()</code></li></ul><p>RTTI is unfriendly to shared library 对动态链接库不是友好的</p><ul><li>Since GCC 3.0, symbols are compared equality by address instead fo names. So to preserve only one symbol across many <code>.obj</code> file, it  merges them when linking (like in static library) 符号使用地址比较相等性，而不是通过名字比较相等性；即使两个符号的名字是相等的，地址不相等，当出现在不同的 <code>.obj</code> 文件中的时候，会将名字相等的符号进行地址合并</li><li>So to load shared library quickly, many procedures are omitted, which includes resolving different RTTI symbols 为了快速链接动态链接库，很多步骤都要被省略，其中也包括 RTTI 符号的合并</li></ul><h4 id="Const-Cast"><a href="#Const-Cast" class="headerlink" title="Const Cast"></a>Const Cast</h4><ul><li>It tries to drop the cv-qualifiers<ul><li>明确的知道了原来的对象就是非 read-only，然后接收到的对象是 <code>const</code> 类型的</li><li>The author forgets the <code>const</code> in parameter, but it in fact doesn’t write it</li></ul></li><li><code>volatile</code> is similar 把 <code>volatile</code> 去掉会有 cache 的风险，<code>volatile</code>要求每次使用都要到内存中重新去读</li><li>一般情况下用不到</li></ul><h4 id="Reinterpret-Cast"><a href="#Reinterpret-Cast" class="headerlink" title="Reinterpret Cast"></a>Reinterpret Cast</h4><p><code>reinterpret_cast</code> is used to process pointers of different types, which is dangerous because of life time</p><ul><li>Converting from an object pointer to another type, i.e. <code>reinterpret_cast&lt;T*&gt;(xxx)</code><ul><li>This is same as <code>static_cast&lt;T*&gt;)(static_cast&lt;(cv) void*&gt;(xxx))</code></li><li><code>std::launder</code></li></ul></li><li>Converting from a pointer to function to another type of pointer to function; or pointer to member to another one</li><li>Converting pointer to integer or vice versa （反之亦然）<ul><li>A pointer can be converted to integer by <code>reinterpret_cast</code> if the integer is large enough (<code>std::uintptr_t</code>)</li><li>This integer can be converted back to get the original pointer</li><li><code>reinterpret_cast</code> from <code>0/NULL</code> is UB</li><li>Reference is also convertible 引用和指针一样</li></ul></li></ul><h4 id="Type-safe-union-and-void"><a href="#Type-safe-union-and-void" class="headerlink" title="Type-safe union and void*"></a>Type-safe <code>union</code> and <code>void*</code></h4><ul><li><p>Since C++ 17, <code>&lt;variant&gt;</code> and <code>&lt;any&gt;</code> are introduced to guarantee the safety</p><ul><li><p><code>std::variant</code> can be seen as a <code>union</code> with a <code>size_t</code> index, which will inspect whether the member is  in its lifetime when getting</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::variant&lt;<span class="hljs-type">int</span>, <span class="hljs-type">float</span>, <span class="hljs-type">int</span>, std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; v{<span class="hljs-number">1.0f</span> };<br><span class="hljs-comment">// 类似于</span><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">Union</span> {<br>    <span class="hljs-type">int</span> _1;<br>    <span class="hljs-type">float</span> _2;<br>    <span class="hljs-type">int</span> _3;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; _4;<br>};<br></code></pre></td></tr></table></figure><ul><li>For construction<ul><li>By default, the first alternative is value-initialized 默认第一个位置被初始化</li><li>You can also assign a value with the same type of some alternative, then this’s the active alternative</li><li>You can also construct the member in place,i.e. by <code>(std::in_place_type&lt;T&gt;, args...)</code></li><li>You can construct by index, i.e. <code>(std::in_place_index&lt;Index&gt;, args...)</code></li></ul></li><li>To access or check the existence of alternative<ul><li><code>.index()</code>: return the index of active alternative</li><li>These methods need the examined type <strong>unique</strong> in type params<ul><li><code>std::hold_alternative&lt;T&gt;(v)</code>: return Boolean that denotes whether the active alternative is of type <code>T</code></li><li><code>std::get&lt;T&gt;(v)</code>: return the active alternative of type <code>T</code> 传入引用</li><li><code>std::get_if&lt;T&gt;(v)</code>: return the pointer to the active alternative of type <code>T</code> 传入指针</li></ul></li><li>If not unique, you can also use index-based access: <code>std::get&lt;I&gt;(v)</code>, <code>std::get_if&lt;I&gt;(v)</code></li></ul></li><li>Besides type safety, the most important extension of <code>std::variant</code> than <code>union</code> is that it implements <strong>visitor pattern</strong></li></ul></li><li><p><code>std::any</code> can be seen as a <code>void*</code> with the original type “stored” magically, so that you’ll fail to grasp（理解；领会） the inner object with the wrong type 可以加载任意的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::any a{<span class="hljs-number">1</span> };<br>a = <span class="hljs-number">2.0f</span>;<br>a = <span class="hljs-string">"test"</span>;<br></code></pre></td></tr></table></figure><ul><li>承载的对象必须有构造函数，类型会 decay</li><li>You can also default-construct it or call <code>.reset()</code>, then it holds nothing</li><li><code>.has_value()</code></li><li><code>(std::in_place_t&lt;T&gt;, args...)</code></li><li>When you need to get the underlying object, you need to use <code>std::any_cast&lt;T&gt;(a)</code> or <code>(&amp;a)</code></li><li><code>std::any</code> can have SBO (small buffer optimization) like <code>std::function</code> 标准库会给 <code>std::any</code> 在栈上分配比较小的 buffer，存储一些非常小的对象，而不是在堆上分配内存</li><li><code>.swap/std::swap/.emplace</code></li><li><code>.type()</code></li><li><code>std::make_any</code>, same as constructing <code>std::any</code></li></ul></li></ul></li></ul><h2 id="Programming-in-Multiple-Files"><a href="#Programming-in-Multiple-Files" class="headerlink" title="Programming in Multiple Files"></a>Programming in Multiple Files</h2><p>Remember the compilation procedures of C</p><ul><li>Preprocess, where comments are stripped and <strong>macros are processed</strong> (so that your <code>#include</code> can get the file correctly)</li><li>Compile, where each source file is compiled independently 编译</li><li>Assemble; this is not something we care since it just translate assembly to object file 汇编</li><li>Link, to locate symbols that are referred in other TUs(Translation unit) 链接</li></ul><h3 id="Preprocessor- 预处理器"><a href="#Preprocessor- 预处理器" class="headerlink" title="Preprocessor 预处理器"></a>Preprocessor 预处理器</h3><p>To be specific, preprocessing can be divided into 6 phases</p><ul><li>Read files and map them to translation character set, which guarantees UTF-7 to be supported 读文件 映射</li><li>Backslashes as the end of line are processed to concatenate two physical lines into a single logical line 处理反斜杠<code>\</code></li><li>Comments and macros are extracted, and the whole file is parsed</li><li>Preprocessor runs to process all macros</li><li>String literals are encoded as specified by the prefix 处理字符串常量，按照指定的前缀进行编码</li><li>Adjacent string literals are concatenated ；邻近的字符串拼接</li></ul><p>A preprocessing directive begins with <code>#</code>. There are four kinds of directives</p><ul><li><p><code>#include ...</code>, which copies all file content into the current file</p><ul><li><code>#include &lt;...&gt;</code></li><li><code>#include "..."</code></li></ul></li><li><p><code>#define</code> i.e. macros, which does pure text replacement</p><ul><li><p><code>#define FUNC(a, b) a + b</code></p></li><li><p>Parameters of macros can be blank</p></li><li><p>Parameters of macros are directly parsed by commas when no paratheses surrounded, e.g. <code>FUNC(SomeFunc&lt;int, double&gt;())</code> -&gt; <code>SomeFunc&lt;int + double&gt;()</code> 用 <code>,</code> 直接进行分词，遇到 <code>,</code> 就会替换</p><ul><li><p>You need to add an additional pair of paratheses to help parse, e.g. <code>FUNC((SomeFunc&lt;int, double&gt;()), 3)</code></p></li><li><p>You can use <code>...</code> for parameters of any number, and reference them by <code>__VA_ARGS__</code> 变长参数的替换</p></li><li><p>Since C++ 20, you can use <code>__VA_OPT__(content)</code>, which will be enabled only when <code>__VA_ARGS__</code> is not empty</p></li><li><p><code>#</code> can be used to turn parameters to strings, and  <code>##</code> can be used to concatenate parameters to make them a whole token</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NameToStr(a, b) #a #b</span><br><span class="hljs-keyword">auto</span> str = <span class="hljs-built_in">NameToStr</span>(<span class="hljs-number">1</span>, aa)<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ConcatName(a, id) a ## id</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">ConcatName</span>(a, <span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>std::cout &lt;&lt; a1;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>You need <code>#undef</code> to drop the definition of the macro 取消宏定义</p></li></ul></li><li><p>Conditional choice of code</p><ul><li><code>#ifdef</code>, (<code>#elifdef</code> since C++ 23), <code>#else</code></li><li><code>#ifndef</code>, (<code>#elifndef</code> since C++ 23), <code>#else</code></li><li><code>#if defined xx</code> is equivalent to <code>#ifdef xx</code></li><li><code>#endif</code></li><li><code>#if</code>, <code>#elif</code>, <code>#else</code></li></ul></li><li><p><code>#pragma</code> is in fact a macro for implementation-defined usage 需要查看编译器文档或者其他相关文档才能知道具体的用途</p><ul><li><code>#pragma once</code>, <code>#pragma pack</code></li></ul></li><li><p><code>#line</code>: specify the line number manually</p></li></ul><h3 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h3><h4 id="Declaration-amp-Definition"><a href="#Declaration-amp-Definition" class="headerlink" title="Declaration & Definition"></a>Declaration &amp; Definition</h4><ul><li>Translation unit (TU)<ul><li>每一个源文件都是单独进行编译，最后通过连接器去链接未知的符号，每个源文件通过预处理将其他符号加到当前文件中，这一整个处理结果就是 TU</li><li>C++ 要求先声明再使用，所以每个 TU 首先要看到所使用的声明</li><li>C/C++ has One-Definition Rule (ODR), meaning that each entity should have only one definition in a TU or even in a program 一个实体只能定义一次</li></ul></li><li>典型的声明和定义<ul><li>Function prototype &amp; one with function body 函数签名和具有函数体的函数，也包括类的成员函数</li><li><code>class A;</code>, <code>class A{...}</code>, <code>struct</code> 类的声明和定义</li><li><code>enum class A (: Type)</code></li></ul></li><li>类的声明是一个比较特殊的实体，对于函数来说只需要暴露函数的签名就可以使用，但是对于类来说声明是远远不能够使用类</li><li>It only requires the class to be defined only once in a TU</li><li>Besides, class definition requires to fully see all definitions of its members &amp; base classes 类的定义必须要求有完整的定义，包括类的成员和基类<ul><li>You cannot <code>class Vector3; class A {Vector3 v;};</code></li><li>This is because compilers need to determine the layout of the class; if definition of some members are unknown, its <code>sizeof</code> is unclear 编译器必须知道类的大小</li></ul></li><li>We can use mere class declarations in these cases 只需要使用类的声明的情况<ul><li>As an argument of prototype; its members and layout are not used 做为函数的参数</li><li>When you only needs a pointer or reference as members 用指针或者引用指向类</li></ul></li><li>Notes<ul><li>It’s allowed to put definition of methods into class definition</li><li>Return types and parameter types of declarations and definitions of methods should be the same</li><li><code>friend</code> will implicitly declares the class or function</li><li>Class members in class definition is in fact definition instead of just simple declaration, so we don’t need to define it again in .cpp</li><li>Default parameters of functions should be put into declaration, and shouldn’t be put into definition</li><li>Type alias (like <code>using</code>) and <code>static_assert</code> are also declarations</li><li><strong>header guard</strong> 解决定义出现两次的问题 <code>#pragma once</code></li></ul></li><li>Template 的声明和定义<ul><li>Template will not preserve its information to object file</li><li>在头文件中写声明和定义</li><li>Function template in class should also be put into header</li></ul></li></ul><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><ul><li><p>When code base is large, name conflicts usually happen 解决命名冲突，C 语言中解决方式是加大量的前缀</p></li><li><p><code>using namespace xx</code> is like <code>from xx import *</code></p></li><li><p><code>using yy::xx</code> is like <code>from yy import xx</code></p></li><li><p>You should <strong>never</strong> put <code>using namespace xxx</code> or <code>using xx</code> into header files</p></li><li><p>Inline namespace has nothing to do with <code>inline</code>. It’ll expose contents into the parent namespace, as if there is a <code>using namespace xx</code> 和关键字 <code>inline</code> 毫无关系，目的是把所包含的内容暴露到上层命名空间中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> Test6<br>{<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">namespace</span> Implv1<br>    {<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span></span>;<br>    }<br>}<br><span class="hljs-keyword">namespace</span> Test6::Implv1<br>{<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        std::cout &lt;&lt; <span class="hljs-string">"This is v1.\n"</span>;<br>    }<br>}<br><span class="hljs-comment">// 调用的时候完全可以将 `Implv1` 忽略掉</span><br>Test6::<span class="hljs-built_in">Func</span>();<br></code></pre></td></tr></table></figure><blockquote><p>老代码需要兼容，新代码可以平滑过渡</p></blockquote></li></ul><h4 id="Inline"><a href="#Inline" class="headerlink" title="Inline"></a>Inline</h4><ul><li>Recall procedures of function calls<ul><li>Caller saves registers on the stack</li><li>Jump to the calling position 跳转到函数所在的地址</li><li>Callee saves registers, execute code, and restores registers 对于函数本身来说也会保存寄存器，并执行代码，在把寄存器中的内存恢复</li><li>Jumping back by popping up the return address</li><li>Caller restores registers on the stack</li></ul></li><li>If we can fuse function body into the caller and optimize together, then register saving / restoring and jumping will be almost eliminated 直接将内联函数插入到调用的地方，寄存器的保存和恢复，以及跳转的开销会被消除以达到优化的目的</li><li>Inline function should be put into header files 因为每个源文件都需要知道内联的函数体</li><li><code>inline</code>也会造成其他问题<ul><li>The code size may bloat（膨胀）, since the function body is inserted everywhere</li><li>Utility of instruction cache may be lower, since the same function has different addresses 对 i-cache 的利用率降低，相同的代码具有完全不一样的地址</li><li>Inline function won’t create their function address, so you cannot “jump to the next” when debugging 进行 debug 时把整个函数跳过去了</li></ul></li><li><code>inline</code> is just an suggestion to compiler, and compiler may choose to not inline the body<ul><li>递归调用</li><li>函数本身逻辑比较复杂</li><li>不知道什么时候使用 <code>inline</code> 合适</li></ul></li><li>Since C++ 17, inline variables are introduced 内联变量，可以直接把内联变量放到头文件中<ul><li>This mainly facilitates header-only libraries, since they hope to use some global variables without source files</li><li>Inline variables can also be in class definitions, so that <code>static</code> variable can be unnecessary to split definition and declaration 静态变量就不需要分开声明和定义了</li></ul></li><li>Inline functions/variables may cause double symbols in shared libraries 内联函数 / 变量会在动态链接是造成双定义<ul><li>静态链接库是需要完全的符号合并</li><li>但是动态链接库的符号是未必进行合并的 RTTI</li><li>在链接库的内外会存在两个版本的变量</li></ul></li></ul><h3 id="Linkage"><a href="#Linkage" class="headerlink" title="Linkage"></a>Linkage</h3><p>External linkage: Linker can always find the symbol in other TUs 链接器在大多数情况下都能在其他的 TU 中找到相关符号，这种的叫做外部链接，几乎所有的实体在不加关键字的情况下，都是 external linkage</p><ul><li>Class members</li><li>Functions</li><li>Functions declared by <code>friend</code></li><li>Enumerations</li><li>Templates</li><li>Non-const variables, volatile variables and inline variables</li></ul><p>Internal linkage: 但是有的时候不想暴露实体，使用外部链接会让其他 TU 窃取实现的私密性</p><ul><li><code>static</code> in introduced to force internal linkage 用 <code>static</code> 关键字声明内部链接性实体<ul><li>Unlike static member functions, <code>static</code> that denotes linkage is necessary in definition 在函数定义时需要带上<code>static</code>，成员函数则不需要</li><li>外部链接性和模板实例化不会冲突，完全是两个不相干的概念</li></ul></li><li>Another way is to define things in an anonymous namespace 需要定义大量的内部链接性实体时候可以使用</li><li>There are some special cases where entities are born with internal linkage<ul><li><code>const</code> global variables</li><li>Anonymous unions</li></ul></li></ul><h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><ul><li>Reason<ul><li>The sequence of initializing global variables across TU isn’t determined 全局变量初始化的顺序在同一个 TU 中可以保证，但是在不同的 TU 中不能保证</li><li>Side effects caused by global variables may not be executed</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// singleton.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">static</span> Singleton&amp; <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Singleton</span>() = <span class="hljs-keyword">default</span>;<br>}<br><span class="hljs-comment">// singleton.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"singleton.h"</span></span><br><br><span class="hljs-function">Singleton&amp; <span class="hljs-title">Singleton::GetInstance</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">static</span> Singleton* instance = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Singleton</span>();<br>    <span class="hljs-keyword">return</span> *instance;<br>}<br></code></pre></td></tr></table></figure><ul><li>No linkage 无链性<ul><li>This happens for static local variables (i.e. <code>static</code> variables in functions) and normal local variables</li><li>You can even define a class inside the block scope, which also has no linkage</li></ul></li></ul><h2 id="XMake"><a href="#XMake" class="headerlink" title="XMake"></a>XMake</h2><p>XMake acts as both a build tool and a package manager</p><ul><li><p>(Optional) Project name, project version and required xmake version</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">set_project(<span class="hljs-string">"Programming in Multiple Files"</span>)<br>set_xmakever(<span class="hljs-string">"2.8.1"</span>)<br>set_version(<span class="hljs-string">"0.0.0"</span><br></code></pre></td></tr></table></figure></li><li><p>Modes and language version</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">add_rules(<span class="hljs-string">"mode.debug"</span>, <span class="hljs-string">"mode.release"</span>)<br>set_languages(<span class="hljs-string">"cxx20"</span>)<br></code></pre></td></tr></table></figure></li><li><p>Some other options</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua">set_policy(<span class="hljs-string">"build.warning"</span>, <span class="hljs-literal">true</span>)<br>set_warning(<span class="hljs-string">"all"</span>)<br></code></pre></td></tr></table></figure><ul><li><code>set_policy("build.warning", true)</code> means that report warning even if compile success</li></ul></li><li><p>Add required packages <code>add_requires("ctre 3.8.1", "catch2")</code></p></li><li><p>Specify the building target</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lua">target(<span class="hljs-string">"example"</span>)<br>    set_kind(<span class="hljs-string">"binary"</span>)<br>    add_headerfiles(<span class="hljs-string">"example1/*.h"</span>)<br>    add_files(<span class="hljs-string">"example1/*.cpp"</span>)<br></code></pre></td></tr></table></figure><ul><li><code>target(name)</code></li><li><code>set_kind(...)</code><ul><li><code>binary</code> will compile the executable</li><li><code>static</code> static library</li><li><code>shared</code> stared library/dynamic-linked library</li><li><code>phony</code> empty, just used to combine targets like libraries</li><li><code>header_only</code> for projects that only have header files</li></ul></li><li><code>add_files(...)</code></li><li><code>add_headerfiles(...)</code></li></ul></li><li><p><code>xmake</code> to compile all targets</p><ul><li><code>xmake -b xx</code> to compile specific targets</li><li><code>xmake run xx</code> to run specific executable</li></ul></li></ul><h2 id="Modules"><a href="#Modules" class="headerlink" title="Modules"></a>Modules</h2><ul><li><p>There are several problems in headers</p><ul><li>Non-inline functions cannot be defined to keep ODR</li><li><code>#include</code> always requires the preprocessor to copy all contents, which makes the real file huge and drags the compilation stage</li><li>If marcos aren’t undef, they will be leaked</li></ul></li><li><p>Every module has only one primary interface unit</p><ul><li><p>Begin with <code>export module Name</code> 在文件开始时声明</p></li><li><p>It regulates that entities are visible to other modules by <code>export</code> 文件中的其他实体都可以加 <code>export</code> 关键字</p></li><li><p>Module interface files have no determined suffix</p><ul><li>msvc - ixx</li><li>clang - cppm</li><li>gcc - don’t care</li><li>It can also be mmp, mmx</li></ul></li><li><p><code>export import</code> 字面意义</p></li><li><p>Modules 也允许声明和定义分离，原理是 module implementation unit</p><ul><li>It begins with <code>module Name;</code> and shouldn’t have any <code>export</code></li><li>A module can have multiple implementation files, as long as they all begin with <code>module Name;</code> 一个模块可以有多个源文件去实现</li><li>You can directly <code>import "xxx.h"</code>; they’re called <strong>header unit</strong></li><li>C++ uses <strong>global module fragment</strong><ul><li>It begins before <code>export module Name;</code> or <code>module Name;</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">module</span>; <span class="hljs-comment">// global module fragment</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEED_PARAM</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Old.h"</span></span><br><br><span class="hljs-keyword">module</span> Person; <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>You can partition either interface or implementation 如果模块太大也可以进行拆分</p><ul><li>Interface partition unit: begin with <code>export module Name:SubName;</code></li><li>Implementation partition unit: begin with <code>module Name:SubName2;</code></li><li>分区时模块内部的概念，对其他模块是透明的<ul><li>Inside the module, it can use <code>import :SubName</code> to import the partition</li><li>But in other modules, they cannot use <code>import Name:SubName</code></li></ul></li><li>Unlike module implementation, implementation partition is not implementation of interface partition 模块的实现分区和模块的接口分区并不是实现的对应关系，不能在出现同名的分区了<ul><li>If there exists <code>module A:B</code>; there shouldn’t exist <code>export module A:B</code></li></ul></li><li>Partitions cannot have partitions (depth == 1) 分区不能再进行分区</li></ul></li></ul><h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><h3 id="Error-code-extension"><a href="#Error-code-extension" class="headerlink" title="Error code extension"></a>Error code extension</h3><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><ul><li><p>It uses an additional <code>bool</code> to denote “exist or not” 用 <code>bool</code> 值来表示是否存在</p><ul><li><p>Empty value then introduced as <code>std::nullopt</code>, which essentially makes the underlying <code>bool</code> to be the <code>false</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> Key, <span class="hljs-keyword">typename</span> Val&gt;</span><br><span class="hljs-function">std::optional&lt;Val&gt; <span class="hljs-title">Get</span><span class="hljs-params">(<span class="hljs-type">const</span> std::map&lt;Key, Val&gt;&amp; map, <span class="hljs-type">const</span> Key&amp; key)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> it = map.<span class="hljs-built_in">find</span>(key); it != map.<span class="hljs-built_in">end</span>()<br>        <span class="hljs-keyword">return</span> it-&gt;second;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-literal">nullopt</span>;<br>}<br></code></pre></td></tr></table></figure></li></ul></li><li><p>Ctor, <code>operator=</code>, <code>swap</code>, <code>emplace</code>, <code>std::swap</code>, <code>std::make_optional</code></p><ul><li>Ctor can also accept <code>(std::in_place, Args to construct T)</code></li></ul></li><li><p><code>operator&lt;=&gt;</code></p></li><li><p><code>std::hash</code>; unlike <code>std::variant</code>, it’s guaranteed for <code>std::optional</code> to have the same hash as <code>std::hash&lt;T&gt;</code> if it’s not <code>std::nullopt</code></p></li><li><p>You can just use <code>std::optional</code> as a nullable pointer</p><ul><li><code>operator-&gt;/operator*/operator bool</code>, as if a T*<ul><li>The behavior is undefined for <code>-&gt;/*</code> if it’s in fact <code>std::nullopt</code></li></ul></li><li><code>.has_value()</code>, <code>.value()</code> (which will throw <code>std::bad_optional_access</code> instead of <code>std::nullopt</code>)</li><li><code>.value_or(xx)</code> can provide a default value</li></ul></li><li><p>Note</p><ul><li>Most of types in Java and C# are nullable, which makes them “optional” automatically 像是 Java 和 C# 语言大部分的变量类型都是自动的”optional”，但是也会有效率上的问题</li><li><code>std::optional</code>, <code>std::expected</code>, <code>std::any</code> and <code>std::variant</code> are sometimes called “vocabulary type” 它们都不能用作引用类型去实例化模板 <code>std::optional&lt;int&amp;&gt;</code></li><li>Though <code>std::optional</code> only store an additional <code>bool</code>, this alignment and padding will make it in fact larger</li></ul></li></ul><h4 id="Expected"><a href="#Expected" class="headerlink" title="Expected"></a>Expected</h4><ul><li>It uses an Error type (i.e. <code>std::expected&lt;T, E&gt;</code>) instead of <code>null</code> to denote absent value 用第二个模板参数来表达错误类型，更被建议用作错误处理</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::expected&lt;<span class="hljs-type">double</span>, std::errc&gt; <span class="hljs-title">parse_number</span><span class="hljs-params">(std::string_view&amp; str)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-type">double</span> result;<br>    <span class="hljs-keyword">auto</span> begin = str.<span class="hljs-built_in">data</span>();<br>    <span class="hljs-keyword">auto</span> [end, ec] = std::<span class="hljs-built_in">from_chars</span>(begin, begin + str.<span class="hljs-built_in">size</span>(), result);<br><br>    <span class="hljs-keyword">if</span> (ec != std::errc{})<br>        <span class="hljs-keyword">return</span> std::unexpected{ec};<br>    <span class="hljs-keyword">if</span> (std::<span class="hljs-built_in">isinf</span>(result))<br>        <span class="hljs-keyword">return</span> std::unexpected{std::errc::result_out_of_range};<br>    str.<span class="hljs-built_in">remove_prefix</span>(end - begin);<br>    <span class="hljs-keyword">return</span> result;<br>}<br></code></pre></td></tr></table></figure><h4 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h4><ul><li><code>&lt;T1, E1&gt;.and_then(T1)</code> needs to return <code>&lt;T2, E1&gt;</code><ul><li>For <code>std::optional</code>, it’s obligated to return <code>std::optional&lt;T2&gt;</code></li></ul></li><li><code>&lt;T1, E1&gt;.transform(T1)</code> needs to return <code>T2</code>, which will construct <code>&lt;T2, E1&gt;</code> automatically<ul><li>For <code>std::optional</code>, it’s obligated return <code>T2</code>, which will construct <code>&lt;T2&gt;</code></li></ul></li><li><code>&lt;T1, E1&gt;.or_else(T1)</code> needs to return <code>&lt;T1, E2&gt;</code><ul><li>For <code>std::optional</code>, it’s obligated return <code>std::optional&lt;T1&gt;</code></li></ul></li><li><code>&lt;T1, E1&gt;.transform_error(E1)</code> needs to return <code>E2</code>, which will construct <code>&lt;T1, E2&gt;</code> automatically</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> process = [](std::string_view str)<br>{<br>    std::<span class="hljs-built_in">print</span>(<span class="hljs-string">"str: {:?},"</span>, str);<br>    <span class="hljs-built_in">parse_number</span>(str).<span class="hljs-built_in">transform</span>([](<span class="hljs-type">double</span> val)<br>    {<br>        std::<span class="hljs-built_in">println</span>(<span class="hljs-string">"value: {}"</span>, val);<br>        <span class="hljs-keyword">return</span> val;<br>    }).<span class="hljs-built_in">transform_error</span>([](std::errc err)<br>    {<br>        <span class="hljs-keyword">if</span> (err == std::errc::invalid_argument)<br>            std::<span class="hljs-built_in">println</span>(<span class="hljs-string">"error: invalid input"</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (err == std::errc::result_out_of_range)<br>            std::<span class="hljs-built_in">println</span>(<span class="hljs-string">"error: overflow"</span>);<br>        <span class="hljs-keyword">return</span> err;<br>    });<br>}<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> src : {<span class="hljs-string">"42"</span>, <span class="hljs-string">"32abc"</span>, <span class="hljs-string">"meow"</span>, <span class="hljs-string">"inf"</span> })<br>    <span class="hljs-built_in">process</span>(src);<br></code></pre></td></tr></table></figure><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><ul><li>Exception is a technique that will automatically propagate to the caller if it’s omitted 异常可以将调用者忽略的错误自动地传递给更上层的调用者<ul><li>For example, function chain A -&gt; B -&gt; C -&gt; D, if D throws an exception, and D doesn’t catch it, then C needs to do so; if C doesn’t, B needs to do so; etc.</li></ul></li><li><code>try - catch</code> block to catch an exception</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span><br>{<br>    <span class="hljs-built_in">Test</span>();<br>}<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::out_of_range&amp; error)<br>{<br>    std::cout &lt;&lt; <span class="hljs-string">"Encountering error:"</span>;<br>    std::cout &lt;&lt; error.<span class="hljs-built_in">what</span>() &lt;&lt; <span class="hljs-string">"\n"</span>;<br>}<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; error)<br>{<br>    <span class="hljs-comment">// ...</span><br>}<br><span class="hljs-built_in">catch</span> (...) {<span class="hljs-comment">/* ... */</span>}<br></code></pre></td></tr></table></figure><blockquote><p><code>.what()</code> is a virtual method of <code>std::exception</code></p></blockquote><ul><li>Note<ul><li>You only need to catch exception when this method can handle it</li><li>Though you can throw any type, it’s recommended to throw a type inherited from <code>std::exception</code><ul><li>Reason: base class can also match derived class exception to catch it, so you can always <code>catch(const std::exception&amp;)</code> and print <code>.what()</code> to know information</li></ul></li><li>Catch block is matched one by one catch 块是线性的进行的</li><li>Though it’s allowed to catch with or without <code>const/&amp;</code>, exception should definitely be caught by <code>const Type&amp;</code></li><li>If you’re in a <code>catch</code> block and find that the caught exception still cannot be handled, you can use a single <code>throw;</code> to throw this exception again 不能处理异常可以继续往上抛出，最好不抛出异常对象</li><li>If another exception is thrown during internal exception handling (e.g. dtor throw an exception during stack unwinding), <code>std::terminate</code> will also be called 在处理异常的时候由出现了异常会直接终结，不可能在异常中再重新抛出异常了</li></ul></li></ul><h3 id="Exception-Safety"><a href="#Exception-Safety" class="headerlink" title="Exception Safety"></a>Exception Safety</h3><ul><li><p>Exception safety means that when an exception is thrown and caught, program is still in a valid state and can correctly run 当异常被抛出并且被捕获后，程序依然处于有效状态并且正确运行</p><ul><li><p>No guarantee 没有异常安全性</p><ul><li>资源或内存泄漏</li><li>不变量被破坏</li><li>内存发生了损毁，一片内存写了一部分就发生了损坏并退出了程序</li></ul></li><li><p>Basic guarantee: at least program can run normally, no resources leak, invariants are maintained, etc</p><ul><li><p>RAII is a really important technique for basic guarantee</p></li><li><p>解决方案是使用析构函数 use destructor</p></li><li><p>RAII (Resource acquirement is initialization): acquire resources in ctor and release them in dtor 在构造函数里申请资源，在析构函数里释放资源，这就是 RAII</p><ul><li><code>std::unique_ptr</code> to manage heap memory instead of <code>new/delete</code></li><li><code>std::lock_guard</code> to manage mutex instead of <code>lock/unlock</code></li><li><code>std::fstream</code> to manage file instead of <code>FILE* fopen/fclose</code></li><li>自己编写的类也要符合 RAII 的原则</li></ul></li><li><p>To sum up, all members that have been fully constructed will be destruct, but dtor of itself won’t be called 只有在构造函数中完全初始化（没有异常）析构函数才会执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">MyData</span>(<span class="hljs-type">int</span> id) : ptr1{<span class="hljs-literal">nullptr</span> }, someData{<span class="hljs-literal">nullptr</span> } {<br>    <span class="hljs-keyword">auto</span> init_ptr1 = std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {id} };<br>    <span class="hljs-keyword">auto</span> init_someData = std::unique_ptr&lt;<span class="hljs-type">int</span>&gt;{<span class="hljs-keyword">new</span> <span class="hljs-type">int</span> {id} };<br>    <span class="hljs-comment">// will never throw below</span><br>    ptr1 = init_ptr1.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// release ownership, so dtor of</span><br>    someData = init_someData.<span class="hljs-built_in">release</span>(); <span class="hljs-comment">// unique_ptr does nothing</span><br>}<br><br>~<span class="hljs-built_in">MyData</span>() { <span class="hljs-keyword">delete</span> ptr1; <span class="hljs-keyword">delete</span> someData; }<br></code></pre></td></tr></table></figure><ul><li>指针抛出的异常是<code>std::bad_alloc</code></li><li><code>new(std::nothrow)</code> will return <code>nullptr</code> instead of throwing exception. e.g. <code>new(std::throw) int{id}</code> 但是仍然需要判断<code>nullptr</code></li></ul></li></ul></li><li><p>Strong exception guarantee 强异常保证，当函数抛出异常后，程序能够回滚到原来的状态</p><ul><li><p>Most of methods in STL obey strong exception guarantee</p><ul><li><code>std::vector::push_back()</code>, <code>std::vector</code> has same elements as before even if exception is thrown 当插入元素失败的时候，原来 <code>vector</code> 中的元素还存在</li></ul></li><li><p>A technique to maintain strong exception guarantee in assignment operator is copy-and-swap idiom 拷贝交换惯用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Vector</span>(std::<span class="hljs-type">size_t</span> num, <span class="hljs-type">const</span> T&amp; val)<br>    {<br>        std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[num] };<br>        std::ranges::<span class="hljs-built_in">fill</span>(arr.<span class="hljs-built_in">get</span>(), arr.<span class="hljs-built_in">get</span>() + num, val);<br>        first_ = arr.<span class="hljs-built_in">release</span>();<br>        last_ = end_ = first_ + num;<br>    }<br><br>    <span class="hljs-function">std::<span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> </span>{<span class="hljs-keyword">return</span> last_ - first_; }<br>    <span class="hljs-keyword">auto</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) <span class="hljs-keyword">noexcept</span> {<span class="hljs-keyword">return</span> first_[idx]; }<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; <span class="hljs-keyword">operator</span>[](std::<span class="hljs-type">size_t</span> idx) <span class="hljs-type">const</span> <span class="hljs-keyword">noexcept</span> {<span class="hljs-keyword">return</span> first_[idx]; }<br><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">const</span> Vector&amp; another)<br>    {<br>        <span class="hljs-keyword">auto</span> size = another.<span class="hljs-built_in">size</span>();<br>        std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[size] };<br>        std::ranges::<span class="hljs-built_in">copy</span>(another.first_, another.last_, arr.<span class="hljs-built_in">get</span>());<br>        first_ = arr.<span class="hljs-built_in">release</span>();<br>        last_ = end_ = first_ + size;<br>    }<br><span class="hljs-keyword">private</span>:<br>    T* first_, *last_, *end_;<br>};<br></code></pre></td></tr></table></figure><p>如何实现<code>operator=</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; another)<br>{<br>    <span class="hljs-keyword">delete</span>[] first_; <span class="hljs-comment">// 只是放指针所指向的内存</span><br>    <span class="hljs-keyword">auto</span> size = another.<span class="hljs-built_in">size</span>();<br>    std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[size] };<br>    first_ = arr.<span class="hljs-built_in">release</span>();<br>    std::ranges::<span class="hljs-built_in">copy</span>(another.first_, another.last_, first_);<br>    last_ = end_ = first_ + size;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><p>如果 <code>new</code> 抛出异常，尽管内存已经释放掉了，但是 <code>first_</code> 和<code>end_</code>仍然不变，所以 <code>.size()</code> 依然不变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; another)<br>{<br>    <span class="hljs-keyword">delete</span>[] first_;<br>    first_ = last_ = end_ = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将指针也释放掉</span><br>    <span class="hljs-keyword">auto</span> size = another.<span class="hljs-built_in">size</span>();<br>    std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[size] };<br>    first_ = arr.<span class="hljs-built_in">release</span>();<br>    std::ranges::<span class="hljs-built_in">copy</span>(another.first_, another.last_, first_);<br>    last_ = end_ = first_ + size;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><p>如果 <code>std::ranges::copy</code> 出现了异常，那么 <code>first_ ，</code>last_<code>，</code>end_<code> 状态又是不一致的，</code>first_` 被先赋值的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; another)<br>{<br>    <span class="hljs-keyword">delete</span>[] first_;<br>    first_ = last_ = end_ = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将指针也释放掉</span><br>    <span class="hljs-keyword">auto</span> size = another.<span class="hljs-built_in">size</span>();<br>    std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[size] };<br>    std::ranges::<span class="hljs-built_in">copy</span>(another.first_, another.last_, first_);<br>    <span class="hljs-comment">// only release when all exceptions are possibly thrown!</span><br>    first_ = arr.<span class="hljs-built_in">release</span>();<br>    last_ = end_ = first_ + size;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><p>满足了基本异常安全的保证，但是不满足强异常安全性的保证，必须保证释放资源是在所有可能抛出异常语句的后面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; another)<br>{<br>    <span class="hljs-keyword">auto</span> size = another.<span class="hljs-built_in">size</span>();<br>    std::unique_ptr&lt;T[]&gt; arr{ <span class="hljs-keyword">new</span> T[size] };<br>    std::ranges::<span class="hljs-built_in">copy</span>(another.first_, another.last_, first_);<br>    <span class="hljs-keyword">delete</span>[] first_;<br>    first_ = arr.<span class="hljs-built_in">release</span>();<br>    last_ = end_ = first_ + size;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><p>除了 <code>delete[]</code> 其他的和构造函数几乎一样，可以换一种方式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Vector&amp; vec1, Vector&amp; vec2)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>{<br>    std::range::<span class="hljs-built_in">swap</span>(vec1.first_, vec2.first_);<br>    std::range::<span class="hljs-built_in">swap</span>(vec1.last_, vec2.last_);<br>    std::range::<span class="hljs-built_in">swap</span>(vec1.end_, vec2.end_);<br>}<br>Vector&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Vector&amp; another)<br>{<br>    Vector vec{another};<br>    <span class="hljs-built_in">swap</span>(vec, *<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><ul><li>Allocating memory before releasing, which increases peak memory</li><li>Swap cost it slightly higher than direct assignment</li><li>May be not optimal for performance</li></ul></li><li><p>Exception safety of containers</p><ul><li>All read-only &amp; <code>.swap()</code> don’t throw at all 所有只读方法和 <code>.swap()</code> 都不抛出异常，除了故意抛出异常的函数</li><li>For <code>std::vector</code>, <code>.push_back()</code>, <code>emplace_back()</code>, or <code>.insert/emplace/insert_range/append_range()</code> only one element at back provide strong exception guarantee</li><li>For <code>std::list/forward_list</code>, all strong exception guarantee 因为内存不是连续的，所有的方法都会保证强异常安全性</li><li>For <code>std::deque</code>, it’s similar to <code>std::vector</code>, adding push at front</li><li>For associative containers, <code>.insert/...</code> a node only a single element has strong exception guarantee</li></ul></li></ul></li><li><p>Strongest exception safety 最强异常安全性：一个方法永远都不会抛出异常可以加上 <code>noexcept</code> 标识符</p><ul><li>If your function is labeled as <code>noexcept</code> but it throws exception, then <code>std::terminate</code> will be called</li><li><code>noexcept</code> is also an operator 也是一个运算符，用 evaluate 函数是否标记了 <code>noexcept</code> 标识符</li><li><strong>IMPORT</strong>: destructor &amp; deallocation is always assumed to be <code>noexcept</code> by standard library 标准库永远假设析构函数和释放行为不会抛出异常<ul><li>Dtor is the only function by default <code>noexcept</code> without any explicit specifier if all dtors of members are <code>noexcept</code></li><li>编译器自动生成的构造函数或赋值函数也是<code>noexcept</code></li></ul></li><li>Since C++ 17, noexcept function pointer is also supported C++ 17 支持了函数指针用 <code>noexcept</code> 标识 e.g. <code>using Ptr = void(*)(int) noexcept; Ptr ptr = square;</code> 不能指向可以抛出异常的函数</li><li>General rule: for normal methods, only when the operation obviously doesn’t throw should you add <code>noexcept</code><ul><li>Merely read-only methods in containers (like <code>.size()</code>) are marked as <code>noexcept</code></li></ul></li></ul></li></ul></li></ul><h3 id="When-to-use-exception"><a href="#When-to-use-exception" class="headerlink" title="When to use exception"></a>When to use exception</h3><ul><li>Exception is relatively costly compared with other error handling mechanisms, like it relies on heap allocation 相对于其他错误处理机制代价更高，需要保证抛出异常发生情况是极少数的情况；只有在抛出和捕获的时候才有开销</li><li>Besides, in current typical implementations, stack unwinding of exception needs a global lock, which is really unfriendly to multi-threading programs 对多线程不友好</li><li>Also, exception is highly dependent on platform (just like RTTI)</li></ul><h3 id="Assertion"><a href="#Assertion" class="headerlink" title="Assertion"></a>Assertion</h3><p>Assertion is a technique to <strong>check expected behaviors</strong> of functions or code segments <strong>when debugging</strong></p><ul><li>When the parameter is evaluated to <code>false</code>, program will be aborted<ul><li><code>std::abort()</code> is the default behavior of <code>std::terminate()</code>, but latter can change its behavior by <code>std::set_terminate_handler(...)</code></li><li>It’s a macro defined in <code>&lt;cassert&gt;</code></li></ul></li><li><code>assert</code>用作没有副作用行为的条件检查</li><li><code>assert</code> is done in runtime; if you want to determine in compile time, you can use keyword <code>static_asset(xx, msg)</code>, <code>msg</code> can be omitted since C++ 17</li><li>通常用于内部的方法，检查已应过滤掉，但是仍然会出现的非法的情况，用于在 <strong>debug</strong> 中定位问题</li><li>Assertion 在安全检查方面是非常有限的</li><li><code>Contract</code> C++ 26 is likely to add <code>contract</code>, which will enrich it a lot</li></ul><h3 id="Debug-Helpers"><a href="#Debug-Helpers" class="headerlink" title="Debug Helpers"></a>Debug Helpers</h3><ul><li><p>Source Location</p><ul><li><p>Before C++ 20, we may use maros <code>__FILE__</code> and <code>__LINE__</code>, which will be substituted to source file name and line number</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">CheckError</span><span class="hljs-params">(cudaError_t error, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file, <span class="hljs-type">int</span> line)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-keyword">if</span> (error == cudaSuccess)<br>        <span class="hljs-keyword">return</span>;<br>    std::cerr &lt;&lt; <span class="hljs-string">"Cuda Error at file"</span> &lt;&lt; file &lt;&lt; <span class="hljs-string">"line :"</span> line &lt;&lt; <span class="hljs-string">":"</span> &lt;&lt; <span class="hljs-built_in">cudaGetErrorString</span>(error);<br>    <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>}<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHECK_ERROR(<span class="hljs-keyword">error</span>) (CheckError((<span class="hljs-keyword">error</span>), __FILE__, __LINE__))</span><br></code></pre></td></tr></table></figure><p><code>__FILE__</code>和 <code>__LINE__</code> 是不能用在 <code>CheckError</code> 的默认参数中的，因为这两个宏是在预处理的时候确定的，而不是在调用的时候确定的</p></li><li><p>Since C++ 20, <code>&lt;source_location&gt;</code> is added to solve it</p><ul><li><code>void logError(std::string_view errorInfo, std::ostream&amp; logFile = std::cerr, const std::source_location&amp; location =  std::source_location::current());</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">logError</span><span class="hljs-params">(std::string_view errorInfo, std::ostream &amp;logFile = std::cerr, <span class="hljs-type">const</span> std::source_location &amp;location = std::source_location::current())</span></span><br><span class="hljs-function"></span>{<br>    logFile &lt;&lt; std::format(<span class="hljs-string">"In file {} function {} - line {}, Error :\n{}\n"</span>,<br>        location.<span class="hljs-built_in">file_name</span>(), location.<span class="hljs-built_in">function_name</span>(), location.<span class="hljs-built_in">line</span>(), errorInfo);<br>    <span class="hljs-keyword">return</span>;<br>}<br></code></pre></td></tr></table></figure></li></ul></li><li><p>stacktrace</p><ul><li>Since C++ 23, in <code>&lt;stacktrace&gt;</code></li><li>Similar to <code>source_location</code>, you need <code>std::stacktrace::current</code> to get it; but you may print it directly</li></ul></li><li><p>debugging, Since C++ 26, in <code>&lt;debugging&gt;</code></p></li></ul><h3 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h3><h4 id="Catch2"><a href="#Catch2" class="headerlink" title="Catch2"></a>Catch2</h4><p>A C++ unit test framework - <font color="#3FC1C9"><strong>Catch2</strong></font></p><ul><li>Catch2 uses macro, so still remember to add paratheses for comma</li><li>Catch2 overloads <code>operator&amp;&amp;</code> and <code>operator||</code>, so using them <strong>won’t be short-circuit</strong><ul><li>Thus, you may need to split it to multiple <code>REQUIRE</code></li></ul></li><li><code>SECTION</code> can be generated dynamically; you just need to ensure they have different names</li></ul><h2 id="String-and-String-View"><a href="#String-and-String-View" class="headerlink" title="String and String View"></a>String and String View</h2><ul><li>常量字符串类型 <code>const char[]</code> 赋值给 <code>auto</code> 类型会退化为 <code>const char*</code>，C++ 中不能将<code>const char[]</code> 赋值给<code>char*</code>，除非使用<code>const_cast</code></li><li>可以使用空格或换行来连接两个字符串常量 e.g. <code>"123" "456"</code>和 <code>"123456"</code> 一样，编译器编译的时候会进行拼接</li><li>Raw strings: 任意字符都不会被转义 escaped<ul><li><code>\\\n\"</code>在普通字符串解释为 <code>\\n"</code>，但是用裸字符串表示<code>R"(\\\n\")"</code> 就是 6 个字符</li><li>例如 Windows 系统中的文件路径</li><li>裸字符解析主要是通过匹配 <code>"(</code> 和<code>')"'</code>，但是可以在 <code>"</code> 和<code>(</code>或 <code>)</code> 之间加入任意其他通配符配合将中间的字符部分解析为裸字符串 e.g. <code>R"+(I want a)"!)+"</code></li></ul></li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><code>std::string</code>是 <code>std::vector&lt;char&gt;</code> 的加强版</li><li>很多方法和 <code>std::vector</code> 一模一样</li><li>提供了 <code>.length()</code> 函数，和 <code>.size()</code> 一样，只是 length 是更常见命名习惯</li><li><code>.append</code>, <code>.append_range</code>和 <code>insert(str.end(), ...)</code> 一样，但是不能插入一个字符串，返回值是对 string 的引用</li><li><code>.assign</code>, <code>.insert</code>, <code>.erase</code>, <code>.append</code>都提供了下标的版本</li><li><code>.starts_with</code>, <code>ends_with</code> (C++ 20); <code>contains</code> (C++ 23)</li><li><code>.substr(index(, count))</code>: 从 <code>index</code> 开始到 <code>count</code> 结束，<code>count</code>默认是<code>std::string::npos</code>，会创建新的对象</li><li><code>.replace</code>: replace part of the string with a new string same as sub-string</li><li><code>.data()</code>, <code>.c_str()</code>: get the underlying pointer<ul><li>C++ 17 之后 <code>.data()</code> 返回的是<code>char*</code>，而不是<code>const char*</code></li><li><code>.c_str()</code>返回的是<code>const char *</code></li></ul></li><li>Search<ul><li>如果找不到则返回 <code>std::string::npos</code>，也就是<code>static_cast&lt;size_t&gt;(-1)</code> 一个很大的数</li><li><code>.find()</code>,<code>rfind()</code>: 正向查找或逆向查找</li><li><code>find_first_of()</code>, <code>find_first_not_of()</code>, <code>find_last_of()</code>, <code>find_last_not_of()</code></li></ul></li><li>Notes<ul><li><code>find()</code>时，使用不等号来判断是否找到，而不是用<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code></li><li><code>std::string</code> guarantees the underlying string is null-terminated<ul><li><code>std::string</code>可以存储<code>'\0'</code></li></ul></li><li><code>std::string</code> has <strong>SSO</strong> (small string optimization) 段字符串优化<ul><li>当 string 非常小的时候可以放到栈上而不是放到堆上，降低内存分配</li><li>具体 string 在栈上可以容纳多少字符是由标准库实现的；在 x64 libstdc++/VC 上是 15，在 libc++ 上是 22</li></ul></li><li>C++ 23 introduces another optimization for resizing<ul><li>Resize 通常需要用固定的字符（例如 <code>'\0'</code>）去填充，通常需要<code>reserve</code> 和<code>insert</code>两个步骤，性能上会有损耗</li><li><code>.resize_and_overwrite(newSize, Op)</code>意义更明确，并且是覆盖</li></ul></li><li>和数字进行相互转换<ul><li><code>std::stoi/sto(u)l/sto(u)ll(string, std::size_t* end = nullptr, int base = 10)</code><ul><li>It will stop at the end of the first parsed number, and try to write the stop index to <code>*end</code> 在结束之前解析好，解析失败会抛出异常<code>std::invalid_argument</code></li></ul></li><li>Base（进制） can be 2 - 36 按照字母表的顺序添加；<code>base=0</code>时会根据字符串前缀自动解析进制大小<ul><li>前缀时 <code>0</code> 是八进制</li><li>前缀是 <code>0x</code> 是十六进制</li></ul></li><li><code>std::stof/stod/stold(string, std::size_t* end = nullptr)</code></li><li><code>std::to_string()</code></li></ul></li></ul></li></ul><h3 id="String-View"><a href="#String-View" class="headerlink" title="String View"></a>String View</h3><p>如果在函数中仅仅是读取一个 string，就会用 <code>const std::string&amp;</code> 作为参数，如果传入的是 C-string 类型，就会构造一个临时的 string 对象，这种情况可以使用<code>std::string_view</code>（C++ 17）。可以理解为本身就存储了一个<code>const char*</code></p><ul><li><code>.substr</code>返回的仍然是 <code>std::string_view</code> 而不是<code>std::string</code></li><li>不支持<code>operator+</code></li><li><code>std::string_view</code> is not required to be null-terminated 都是通过 length 识别长度的</li><li>The pointer it contains can be <code>nullptr</code><ul><li>C++ 23 开始不能使用 <code>nullptr</code> 进行构造</li></ul></li><li>当 <code>std::string_view</code> 做为返回值时，注意指针悬垂的问题<ul><li>返回 <code>std::string</code> 是安全的</li></ul></li><li>作为模板参数时也要注意声明周期</li></ul><h3 id="User-defined-literals- 用户定义自变量"><a href="#User-defined-literals- 用户定义自变量" class="headerlink" title="User-defined literals 用户定义自变量"></a>User-defined literals 用户定义自变量</h3><ul><li>类似数值类型 <code>1ull</code> 表示数字 <code>1</code> 是<code>unsigned long long</code> 类型的，字符串对象也可以使用用户自定义变量</li><li><code>std::string</code>: <code>"PKU"s</code></li><li><code>std::string_view</code>: <code>"PKU"sv</code></li><li><code>1s</code> for seconds, <code>1.1ms</code> for milliseconds, <code>1d</code> for a day</li><li><code>1i</code> for pure imaginary number 复数，<code>1.2if</code>, <code>2.5id</code></li><li>Remember <code>using namespace std::literals;</code> in your local scope</li><li>也可以自己定义用户定义自变量<ul><li><code>constexpr unsigned int operator"" _KB(unsigned long long m) {return static_cast&lt;unsigned int&gt;(m) * 1024; }</code></li><li>The parameter type is limited 参数类型的限制<ul><li>对整数来说只支持<code>unsigned long long</code>，最大的整数类型</li><li>对浮点数只支持<code>long double</code></li><li>对字符<code>char</code></li><li>对 C-strings<code>const CHAR*, std::size_t</code></li><li>最后兜底（fallback）类型是<code>const char*</code></li></ul></li></ul></li></ul><h3 id="charconv"><a href="#charconv" class="headerlink" title="charconv"></a>charconv</h3><ul><li><p><code>stoi/to_string</code> will create new <code>std::string</code>; we may want to provide storage ourselves</p><ul><li>E.g. <code>stoi(std::string{view})</code> is costly, since we only read the string 耗费资源</li><li>Also, they may throw exceptions, which are expensive sometimes 抛出异常也很耗费资源</li></ul></li><li><p>You can use <code>std::from_chars</code> and <code>std::to_chars</code> in <code>&lt;charconv&gt;</code></p><ul><li><code>std::from_chars(const char* begin, const char* end, val)</code> will try to save the result into <code>val</code> (an integer or a floating point)</li><li>It returns <code>std::from_chars_result</code>, which includes <code>.ptr</code> as stopping point and <code>.ec</code> as error code</li><li>When <code>ec == std::errc{}</code>, success; it’s also possible that <code>ec == std::errc::invalid_argument</code>, or <code>std::errc::result_out_of_range</code></li><li>You can use structured binding, e.g. <code>if(auto [ptr, ec] = xx; ec != std::errc{})</code>.</li></ul></li><li><p><code>std::from_chars(const char* begin, const char* end, val)</code> will try to save the result into <code>val</code> 必须以数字开头</p><ul><li><code>base/std::chars_format</code> 进制或格式</li></ul></li><li><p><code>std::to_chars(const char* begin, const char* end, val)</code> will try to write <code>val</code> (an integer or a floating point) into <code>[begin, end)</code></p><ul><li><code>base/std::chars_format</code></li></ul></li></ul><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><ul><li>UTF-32: make each character occupy 32 bits; it’s direct but useful, since at most 4 billion characters can be used<ul><li>But it may occupy too much space, e.g. <code>abc</code> needs only 4 bytes before, but currently 16 bytes!</li><li>It also needs BOM</li></ul></li><li>UTF-8: to solve space waste, UTF-8 uses code with varying length<ul><li>Different character length has different coding prefix (like Huffman tree that we’ve learnt) to ensure no ambiguity</li><li>This makes it waste some code space, so some characters may need more than 4 bytes</li><li>For example, ASCII characters, including null-termination ‘\0’, still occupy 1 byte in UTF-8 (the coding is same too) 兼容之前的 ASCII 字符的</li><li>UTF-8 is the most commonly used character set in modern systems</li></ul></li></ul><div class="note note-warning">            <p>Notice that UTF8 doesn’t need BOM, but Windows identifies Unicode by BOM long long before (UCS-2 needs that), and it has been part of Windows and hard to change, so Windows may require you to give UTF8 a BOM<br>UTF-8 是单字节并不需要 BOM，但是 Windows 需要 BOM 去识别是不是 Unicode</p>          </div><ul><li>Unicode has these basic elements:<ul><li>Byte, i.e. computer representation</li><li>Code unit, i.e. (byte count ÷ minimal bytes) used to represent a character (1 for UTF-8, 2 for UTF-16, 4 for UTF-32) 一个 code unit 并不一定是合法的字符</li><li>Code point, i.e. each Unicode character</li><li>Text element, i.e. what humans really see on the screen</li></ul></li></ul><h3 id="Unicode-Support-in-C"><a href="#Unicode-Support-in-C" class="headerlink" title="Unicode Support in C++"></a>Unicode Support in C++</h3><ul><li>There are <code>char8_t/char16_t/char32_t</code> for UTF-8/16/32, but it’s used as one code unit, instead of one code point<ul><li>They’re at least 8/16/32 bits to hold one code unit 表示 code unit 比较合适</li><li>You can use <code>u8/u/U</code> as prefix separately</li></ul></li></ul><div class="note note-info">            <p>But one code point may (and usually) have more than one code unit, so some weird things may happen</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char8_t</span> ch1 = <span class="hljs-string">u8'A'</span>; <span class="hljs-comment">// correct</span><br><span class="hljs-type">char8_t</span> ch2 = <span class="hljs-string">u8'刘'</span>; <span class="hljs-comment">// cannot be represented in 1 byte, compile error</span><br><span class="hljs-type">const</span> <span class="hljs-type">char8_t</span> str1 = <span class="hljs-string">u8"刘"</span>; <span class="hljs-comment">// correct, but sizeof(str1) = 3, 2 for 刘 and 1 for null-termination</span><br></code></pre></td></tr></table></figure><p>There are also types like <code>std::u8string</code>, but they are all in code units</p><ul><li>This makes traversal really hard, e.g. <code>for(auto ch : std::u8string{u8"刘"})</code> will not get <code>刘</code>, but several code units 遍历实际上得到的也是 code unit</li><li><code>.size()</code>, <code>.find_first_of()</code> … are also for code unit</li></ul>          </div><ul><li>So in fact, e.g. <code>std::string</code>, <code>std::string_view</code> are just instantiation of template <code>std::string</code>和 <code>std::string_view</code> 实际上是模板的实例化<ul><li>More specifically, i.e. <code>std::basic_string&lt;char&gt;</code> and <code>std::basic_string_view&lt;char&gt;</code></li><li>So, e.g. <code>std::u8string</code>, <code>std::u8string_view</code> are just <code>std::basic_string&lt;char8_t&gt;</code> and <code>std::basic_string_view&lt;char8_t&gt;</code></li><li>Since <code>char8_t</code> itself is code unit, the string represents vector of code units too</li><li>It also accepts <code>Traits = std::char_traits&lt;charT&gt;</code> as the second template parameter, which regulates operations used by basic_string like comparison of characters. So theoretically (but usually not used) you can define you own character type as long as it’s standard-layout and trivial, then give a <code>YourString</code> with the <code>NewTraits&lt;NewCharType&gt;</code></li><li>You can also provide an allocator, just like STL</li></ul></li><li>Weak Unicode support is mostly due to its complexity C++ 本身提供 Unicode 的支持不是很好，所以需要 Unicode 官方的标准库，或者使用其他的标准库<ul><li>C++ core guideline recommends you to use ICU (International Components for Unicode), Boost.Locale, etc. for complete Unicode support</li><li>You may also use utf8cpp, which operates UTF-8 by code point, since ICU is too large for small project</li></ul></li><li>Besides, input/output Unicode is troublesome in C++ 在 C++ 中 Unicode 的输入输出比较麻烦</li><li>There is also a wide character <code>wchar_t</code> in C/C++ 宽字符类型（C++ 11 之前）<ul><li>It’s platform dependent, only regulated that “it has the same property with one of integer types” 内部的表示由平台决定，用正数类型表示其大小</li><li>It’s UTF-16 on Windows, while UTF-32 on Linux</li><li>Prefix for wide character/string literals is <code>L</code>, e.g. <code>L"爱情可以慷慨又自私"</code></li><li>And, you can also use <code>std::wcout/wcin/wstring(_view)</code></li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DecomposeToByte</span><span class="hljs-params">(<span class="hljs-type">const</span> T&amp; str)</span> </span>{<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++) {<br>        <span class="hljs-keyword">auto</span> ch = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(str[i]);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> mask = (<span class="hljs-number">1</span> &lt;&lt; CHAR_BIT) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">sizeof</span>(str[<span class="hljs-number">0</span>]); j++) {<br>            std::cout &lt;&lt; std::format(<span class="hljs-string">"{:02x}"</span>, (mask &amp; ch));<br>            ch &gt;&gt; <span class="hljs-number">8</span>;<br>        }<br>        std::cout &lt;&lt; <span class="hljs-string">"=&gt;"</span>;<br>    }<br>    std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;<br>    <span class="hljs-keyword">return</span>;<br>}<br><br>std::wstring s1 = <span class="hljs-string">L"\U0001F449"</span>;<br>std::u8string s2 = <span class="hljs-string">u8"\U0001F449"</span>;<br>std::u16string s3 = <span class="hljs-string">u"\U0001F449"</span>;<br>std::u32string s4 = <span class="hljs-string">U"\U0001F449"</span>;<br></code></pre></td></tr></table></figure><div class="note note-warning">            <p>In fact, C-string or <code>std::string</code> is more like <strong>a byte array</strong> instead of an ASCII string 事实上 C-string 或者 <code>std::string</code> 本质上是字节数组而不是 ASCII</p>          </div><h3 id="Locale"><a href="#Locale" class="headerlink" title="Locale"></a>Locale</h3><ul><li>Locale is used for localization<ul><li>Each <code>std::locale</code> contains information for a set of <span class="hint--info hint--rounded hint--top" data-hint="culture 是什么？可以理解为不同国家的本地化表达方式" ontouchstart>culture</span>-dependent features by <code>std::facet</code> objects</li><li>Standard facets are divided into six categories:<ul><li>Collate: i.e. how characters are compared, transformed or hashed 字符如何进行比较，变换或哈希</li><li>Numeric: <code>num_get</code>, <code>num_put</code>, <code>numpunct</code><ul><li><code>num_get</code> will affect how <code>std::cin</code> works, <code>num_put</code> -&gt; <code>std::cout</code>, <code>numpunct</code> only affect punctuation 标点符号</li><li>For example, in German, <code>1.234,56</code> means <code>1234.56</code>; if you use Germany locale, then inputting <code>1.234,56</code> will correctly get it instead of <code>1.234</code></li></ul></li><li>Time: <code>time_get/time_put</code></li><li>Monetary: <code>money_get/money_put/moneypunct</code> 财政的；货币的</li><li>Message: transform some error message to another language</li><li>Ctype: <code>ctype/codecvt</code>, how characters are classified and converted, e.g. is upper 字符如何进行分类，其他字符集如何向其进行转化</li></ul></li><li>Locale 会影响输入输出流、字符识别和匹配</li></ul></li></ul><center>    <img src="/2024/06/03/56ae950785e9/locale-imp.gif" alt></center><div class="note note-success">            <ul><li>每个 locale 创建出来都会指向一个实现 </li><li> 复制的时候只是复制指针 </li><li> 每个实现的数据结构都是 <code>vector&lt;facet*&gt;</code></li><li><code>facet</code> 可以复用</li></ul>          </div><ul><li><p>Locale is cheap to copy; it uses reference count when copied and points to same set of facets 拷贝的代价很小</p></li><li><p>Facets use the address of a static member <code>id</code> to group; e.g. if you want a new facet, you need to inherit from <code>std::locale::facet</code> and have static <code>std::locale::id id</code> 不同的类的实现会</p></li><li><p>Facet will be deleted when it’s never referenced, so <code>new</code> is correct. It also uses reference count <code>facet</code>不需要担心内存泄漏的问题，通过引用计数来管理的</p></li><li><p>Create a new group of facet 如何创建新的 facet</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Umlaut</span> : <span class="hljs-keyword">public</span> std::locale::facet {<span class="hljs-comment">//1</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> std::locale::id id;                               <span class="hljs-comment">//2</span><br>    <span class="hljs-built_in">Umlaut</span>(std::<span class="hljs-type">size_t</span> refs=<span class="hljs-number">0</span>): std::locale::<span class="hljs-built_in">facet</span>(refs) {}  <span class="hljs-comment">//3</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_umlaut</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> <span class="hljs-type">const</span> </span>{<span class="hljs-keyword">return</span> <span class="hljs-built_in">do_isumlaut</span>(c);}    <span class="hljs-comment">//4</span><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">do_isumlaut</span><span class="hljs-params">(<span class="hljs-type">char</span>)</span> <span class="hljs-type">const</span></span>;                    <span class="hljs-comment">//5</span><br>};<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
    <category term="现代 C++" scheme="https://silhouettesforyou.github.io/tags/%E7%8E%B0%E4%BB%A3-C/"/>
    
  </entry>
  
  <entry>
    <title>DIY 摆放</title>
    <link href="https://silhouettesforyou.github.io/2024/05/31/ee6e87e384c9/"/>
    <id>https://silhouettesforyou.github.io/2024/05/31/ee6e87e384c9/</id>
    <published>2024-05-31T06:45:00.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="分析"><a href="# 分析" class="headerlink" title="分析"></a>分析</h2><center>    <img src="/2024/05/31/ee6e87e384c9/mind-map.png" alt></center><h2 id="相关细节"><a href="# 相关细节" class="headerlink" title="相关细节"></a>相关细节 </h2><h3 id="自定义网格"><a href="# 自定义网格" class="headerlink" title="自定义网格"></a> 自定义网格 </h3><p> 基础网格</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Grid</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">public</span> T[,] grids;<br>    <span class="hljs-keyword">public</span> Vector3 rotation; <span class="hljs-comment">// 为 0 时表示地面，63（arctan2）时表示墙面</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> width;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> height;<br>    <span class="hljs-keyword">private</span> Vector3 cellSize; <span class="hljs-comment">// 网格大小，类似 unity 中 tilemap，layout 设置为 `isometric` 类型，(2, 1, 1) 表示每个 cell 的 width:height 为 2:1</span><br>    <span class="hljs-keyword">private</span> Vector3 origin;<br>&#125;<br></code></pre></td></tr></table></figure><p>网格物件</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">GridObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> x, y;<br>    <span class="hljs-keyword">private</span> Grid&lt;GridObject&gt; grid;<br>    <span class="hljs-keyword">public</span> PlaceableObject PlaceableObject;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> CanBuild;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GridObject</span>(<span class="hljs-params">Grid&lt;GridObject&gt; grid, <span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.grid = grid;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center>    <img src="/2024/05/31/ee6e87e384c9/grid-ground.jpg" alt>    <img src="/2024/05/31/ee6e87e384c9/grid-wall.png" alt></center><h3 id="可放置物件"><a href="# 可放置物件" class="headerlink" title="可放置物件"></a>可放置物件</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PlaceableObject</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> depth; <span class="hljs-comment">// 记录物件的深度，每有一个物件被放置深度加一</span><br>    <span class="hljs-keyword">public</span> Vector2Int offset; <span class="hljs-comment">// 相对于网格原点的偏移</span><br>    <span class="hljs-keyword">public</span> Transform placedObjectTransform; <span class="hljs-comment">// 贴图 transform</span><br>    <span class="hljs-keyword">public</span> List&lt;Vector2Int&gt; GridPositions; <span class="hljs-comment">// 占据的网格大小</span><br>    <span class="hljs-keyword">private</span> List&lt;Grid&lt;GridObject&gt;&gt; grids; <span class="hljs-comment">// 物件也有网格，用于堆叠</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="遮挡和排序"><a href="# 遮挡和排序" class="headerlink" title="遮挡和排序"></a>遮挡和排序</h3><ul><li>深度值越大的（即被放置到其他物件之上），越靠前</li><li>网格索引 (x, 0, z) 越小排序越靠前</li><li>地面的可以遮挡墙面的</li></ul><h3 id="工具"><a href="# 工具" class="headerlink" title="工具"></a>工具</h3><ul><li>定义可编辑场景，导入相关资源</li><li>编辑模式<ul><li>编辑物件的 Placeable 部分</li><li>编辑物件的 Grid 部分</li><li>删除区域</li></ul></li><li>响应利用射线检测鼠标位置，在不同编辑模式下，将屏幕坐标转成世界坐标，再转换到网格坐标</li><li>存储编辑结果<ul><li>利用<code>ScriptableObject</code>、<code>Json</code>、二进制等存储方式进行保存</li><li>加载</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Unity" scheme="https://silhouettesforyou.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>面经</title>
    <link href="https://silhouettesforyou.github.io/2024/05/13/cf86467b04aa/"/>
    <id>https://silhouettesforyou.github.io/2024/05/13/cf86467b04aa/</id>
    <published>2024-05-13T14:12:47.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="波克城市"><a href="# 波克城市" class="headerlink" title="波克城市"></a>波克城市 </h2><h3 id="协程是否共享堆栈"><a href="# 协程是否共享堆栈" class="headerlink" title="协程是否共享堆栈"></a> 协程是否共享堆栈</h3><ul><li>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度</li><li>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度（标准线程是的）</li><li><strong>协程和线程 </strong> 一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度</li></ul><h3 id="透明物体位于 -Unity- 哪个渲染阶段"><a href="# 透明物体位于 -Unity- 哪个渲染阶段" class="headerlink" title="透明物体位于 Unity 哪个渲染阶段"></a>透明物体位于 Unity 哪个渲染阶段 </h3><h3 id="已知法向纹理，如何还原法线向量"><a href="# 已知法向纹理，如何还原法线向量" class="headerlink" title="已知法向纹理，如何还原法线向量"></a> 已知法向纹理，如何还原法线向量 </h3><h3 id="如何计算 -MipMap- 个数"><a href="# 如何计算 -MipMap- 个数" class="headerlink" title="如何计算 MipMap 个数"></a> 如何计算 MipMap 个数 </h3><h3 id="描述 -Blooming- 方法"><a href="# 描述 -Blooming- 方法" class="headerlink" title="描述 Blooming 方法"></a> 描述 Blooming 方法 </h3><h3 id="如何解决 -AssetBundle- 依赖"><a href="# 如何解决 -AssetBundle- 依赖" class="headerlink" title="如何解决 AssetBundle 依赖"></a> 如何解决 AssetBundle 依赖 </h3><h2 id="B- 站"><a href="#B- 站" class="headerlink" title="B 站"></a>B 站</h2><h3 id="图集是怎样生成的"><a href="# 图集是怎样生成的" class="headerlink" title="图集是怎样生成的"></a> 图集是怎样生成的 </h3><h3 id="资源加载"><a href="# 资源加载" class="headerlink" title="资源加载"></a> 资源加载 </h3><h4 id="Unity-AssetDatabase 和 Resources 资源管理"><a href="#Unity-AssetDatabase 和 Resources 资源管理" class="headerlink" title="Unity AssetDatabase 和 Resources 资源管理"></a>Unity <code>AssetDatabase</code> 和<code>Resources</code>资源管理</h4><p>Unity 常用的资源大概有以下几类：</p><ul><li>纯资源（material，texture，shader，audio，…）这些资源不能直接拖到场景里使用</li><li>预置（prefab），这种资源需要实例化之后才能使用</li><li>scene 也是一种资源</li><li>脚本对象，文本文件，unity 自己内置的资源（像新建粒子时的默认材质之类的）</li></ul><p>Unity 管理这些资源分为两种：</p><ul><li>在编辑器内管理，使用 <code>AssetDatabase</code> 加载卸载资源<ul><li>在编辑器内加载卸载资源，并不能在游戏发布时使用，它只能在编辑器内使用。但是，它加载速度快，效率高，适合在测试时使用</li></ul></li><li>运行时管理，简单化使用<code>Resources</code>，复杂化使用 AssetBundle<ul><li>在运行时管理资源，简单的方法就是使用 <code>Resources</code> 接口。这种方式控制资源的管理效率高，资源需要放在 Resources 文件夹下。这就说明 Unity 在打包时只会打包 Resources 文件夹下的资源到终端上。 加载这个文件夹下的资源不需要扩展名。最好不要建立多个 Resources 文件夹，否则 Unity 可能会不知道要加载哪一个</li></ul></li></ul><h2 id="叠纸一面"><a href="# 叠纸一面" class="headerlink" title="叠纸一面"></a>叠纸一面 </h2><h3 id="C- 调用 -Lua-GC- 是如何产生的，如何避免 -GC"><a href="#C- 调用 -Lua-GC- 是如何产生的，如何避免 -GC" class="headerlink" title="C# 调用 Lua GC 是如何产生的，如何避免 GC"></a>C# 调用 Lua GC 是如何产生的，如何避免 GC</h3><h3 id="UGUI- 自适应大小"><a href="#UGUI- 自适应大小" class="headerlink" title="UGUI 自适应大小"></a>UGUI 自适应大小</h3><h3 id="如何避免装箱拆箱"><a href="# 如何避免装箱拆箱" class="headerlink" title="如何避免装箱拆箱"></a> 如何避免装箱拆箱 </h3><h3 id="Lua- 元表是什么"><a href="#Lua- 元表是什么" class="headerlink" title="Lua 元表是什么"></a>Lua 元表是什么</h3><p> 原表是 Lua 中元表（Metatable）的一种特殊类型。元表是一种可选的附加到表上的表，用于控制表的行为。当我们进行特定的操作时，例如访问表中不存在的键、进行算术运算或比较等，Lua 会在元表中查找相应的元方法并执行相关的操作。</p><p>元表通过定义元方法来定义特定操作的行为。元方法是一组预定义的函数，以特定的键存储在元表中。当执行相关操作时，Lua 会检查元表中是否存在对应的元方法，并根据元方法的定义来处理操作。</p><p>以下是一些常见的元方法及其对应的操作：</p><ul><li><code>__index</code>：该元方法用于处理当访问表中不存在的键时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__index 元方法。如果存在，Lua 会调用该元方法，并将表和被访问的键作为参数传递给它。该元方法可以返回一个值来作为访问的结果，或者可以是一个函数，以便进行进一步的操作。</li><li><code>__newindex</code>：该元方法用于处理当对表中不存在的键进行赋值时的行为。当 Lua 无法在表中找到对应的键时，它会查找元表中的__newindex 元方法。如果存在，Lua 会调用该元方法，并将表、被赋值的键和赋予的值作为参数传递给它。我们可以在该元方法中自定义处理逻辑，例如捕获赋值操作并执行自定义的操作或者抛出错误。</li><li><code>__add</code>、<code>__sub</code>、<code>__mul</code>、<code>__div</code>等：这些元方法用于重载表的算术运算符。当进行相应的算术运算时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的操作。我们可以在这些元方法中实现自定义的算术运算逻辑。</li><li><code>__eq</code>、<code>__lt</code>、<code>__le</code>：这些元方法用于重载表的比较运算符。当进行相应的比较操作时，Lua 会查找元表中对应的元方法，并根据元方法的定义来执行自定义的比较逻辑。我们可以在这些元方法中实现自定义的比较逻辑。<br>要将元表关联到表上，我们使用 setmetatable 函数。通过将表作为第一个参数，元表作为第二个参数传递给 setmetatable 函数，即可将元表关联到表上。</li></ul><p>原表的应用非常广泛，可以用于实现面向对象的特性，例如继承、多态等。我们可以通过定义元方法来自定义对象的行为，同时还可以通过原表来实现一些高级功能，如代理（Proxy）、属性访问、事件触发等。通过定义适当的元方法，我们可以拦截和重定义对表的操作，从而实现各种定制化的行为。</p><p>以下是一个更具专业性的示例，演示了如何使用原表来实现代理模式：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 原始对象</span><br><span class="hljs-keyword">local</span> realObject = {<br>  value = <span class="hljs-number">42</span>,<br>  getName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Real Object"</span><br>  <span class="hljs-keyword">end</span><br>}<br><br><span class="hljs-comment">-- 代理对象</span><br><span class="hljs-keyword">local</span> proxyObject = {<br>  value = <span class="hljs-number">0</span>,<br>  getName = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">"Proxy Object"</span><br>  <span class="hljs-keyword">end</span><br>}<br><br><span class="hljs-comment">-- 定义代理的元表</span><br><span class="hljs-keyword">local</span> proxyMetatable = {<br>  <span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key)</span></span><br>    <span class="hljs-comment">-- 当访问值时，代理返回代理对象的值</span><br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">"value"</span> <span class="hljs-keyword">then</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">table</span>.value<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">-- 当调用方法时，代理返回原始对象的方法</span><br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">"getName"</span> <span class="hljs-keyword">then</span><br>      <span class="hljs-keyword">return</span> realObject.getName<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span>,<br>  <span class="hljs-built_in">__newindex</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(table, key, value)</span></span><br>    <span class="hljs-comment">-- 代理只允许修改代理对象的值，而不影响原始对象</span><br>    <span class="hljs-keyword">if</span> key == <span class="hljs-string">"value"</span> <span class="hljs-keyword">then</span><br>      <span class="hljs-built_in">table</span>.value = value<br>    <span class="hljs-keyword">end</span><br>  <span class="hljs-keyword">end</span><br>}<br></code></pre></td></tr></table></figure><h3 id="TimeLine- 和 -Animator"><a href="#TimeLine- 和 -Animator" class="headerlink" title="TimeLine 和 Animator"></a>TimeLine 和 Animator</h3><p>Animator 是组件，而 Timeline 是资产</p><p>Animator 这个组件，是用来实现“使用某种动画数据来驱动所在 GameObject 及其子物体的各种参数随时间推移而发生变化”这一功能的。比如：Animator 告诉 Transform 组件将 position 和 rotation 设置到某一个数值，而这个数值的来源就是我们的动画片段（Animation clip，也就是。anim 文件资产）</p><p>但 Animator 这个组件并不直接读取。anim 资产的数据，而是通过 Animator Controller 资产来间接获取。Animator Controller 是一个状态机，可以设置一系列参数来控制多个多个动画片段之间的融合过渡。有了 Animator Controller 的参与，Animator 组件就不需要直接控制很多很多的动画片段了（特别特别麻烦），只需要控制相应的“参数”就可以达到控制很多动画片段之间的融合过渡的目的</p><p>Animator Controller 是用来整合。anim 数据的资产，Timeline 一定程度上也是。Timeline 的 Animation Track 做到事情，就是将多个动画片段按时间顺序连接起来（你可以把 Timeline 理解成一个非线性动画编辑器），这样我们就不需要手动控制这些动画片段的播放时间，只需要在需要的时候播放 Timeline 即可。当然，使用 Animator Controller 也能达到类似的目的，比如将多个片段“串起来”，但 Timeline 的整合显然更直观更好用</p><h3 id="Animator- 如何解决帧数冲突"><a href="#Animator- 如何解决帧数冲突" class="headerlink" title="Animator 如何解决帧数冲突"></a>Animator 如何解决帧数冲突 </h3><h3 id="Lua- 插入哈希表还是数组"><a href="#Lua- 插入哈希表还是数组" class="headerlink" title="Lua 插入哈希表还是数组"></a>Lua 插入哈希表还是数组</h3><h3 id="readonly 和 const 区别"><a href="#readonly 和 const 区别" class="headerlink" title="readonly 和 const 区别"></a><code>readonly</code> 和<code>const</code>区别</h3><ul><li><code>const</code>修饰符<ul><li>初始化时机：编译时，即编译程序时将值已经嵌入代码中；</li><li>值状态：不允许动态修改</li><li>修饰范围：字段、局部变量</li><li>主要应用场景：主要应用于程序运行中不需要改变的变量的值，比如数学符号 PI；</li></ul></li><li><code>static</code>修饰符<ul><li>初始化时机：运行时，可以声明时赋值，也可以在构造函数，或使用时赋值</li><li>值状态：允许修改</li><li>修饰范围：类、字段、属性、方法、运算符、事件、构造函数（不能用于索引器、析构函数或类以外的类型）</li><li>主要应用场景：主要作用于类的公共属性</li></ul></li><li><code>readonly</code>修饰符<ul><li>初始化时机：运行时，可以声明时赋值或在类中的构造函数中赋值</li><li>值状态：允许修改，但只能在构造函数中修改</li><li>修饰范围：字段</li><li>主要应用场景：主要作用于实例化的对象的只读属性</li></ul></li><li><code>static readonly</code>修饰符<ul><li>初始化时机：运行时，是两个关键字的组合</li><li>值状态：允许修改，声明时赋值或者静态构造函数中赋值</li><li>修饰范围：字段</li><li>主要应用场景：<ul><li>和 <code>const</code> 相比，它主要应用于引用性变量；而 <code>const</code>，只能用于<code>string</code> 类型的引用性变量；</li><li>类的只读公共属性 <br> 总结：</li></ul></li></ul></li><li><code>const</code>是静态的、编译期变量，只能在声明变量的时候赋值。</li><li><code>readonly</code>是运行时变量，可以在声明的时候或在构造函数内赋值。</li><li><code>static readonly</code>变量就变成了静态的、编译期变量。只能静态构造函数中进行初始化。</li><li>同时 <code>static readonly</code> 可以理解为是最简单的一种单例模式实现方式。</li><li><code>const</code>是静态常量，<code>readonly</code>是动态常量。<code>const</code>高效，<code>readonly</code>灵活！但实际开发中我们经常用 <code>static readonly</code> 来代替 <code>const</code>, 以平衡<code>const</code> 在灵活性上的不足</li></ul><h2 id="叠纸二面"><a href="# 叠纸二面" class="headerlink" title="叠纸二面"></a>叠纸二面 </h2><h3 id="Used-Total- 和 -Reserved-Total"><a href="#Used-Total- 和 -Reserved-Total" class="headerlink" title="Used Total 和 Reserved Total"></a>Used Total 和 Reserved Total</h3><p> 在 Profiler 工具中提供了两种模式供我们监测内存的使用情况，即简易模式和详细模式。在简易模式中，我们可以看到总的内存（total）列出了两列，即 Used Total（使用总内存）和 Reserved Total（预定总内存）。Used Total 和 Reserved 均是物理内存，其中 Reserved 是 unity 向系统申请的总内存，Unity 底层为了不经常向系统申请开辟内存，开启了较大一块内存作为缓存，即所谓的 Reserved 内存，而运行时，unity 所使用的内存首先是向 Reserved 中来申请内存，当不使用时也是先向 Reserved 中释放内存，从而来保证游戏运行的流畅性。一般来说，Used Total 越大，则 Reserved Total 越大，而当 Used Total 降下去后，Reserved Total 也是会随之下降的（但并不一定与 Used Total 同步）</p><h3 id="如何实现历史记录"><a href="# 如何实现历史记录" class="headerlink" title="如何实现历史记录"></a>如何实现历史记录 </h3><h3 id="EditorWindow 生命周期"><a href="#EditorWindow 生命周期" class="headerlink" title="EditorWindow 生命周期"></a><code>EditorWindow</code> 生命周期</h3><center>    <img src="/2024/05/13/cf86467b04aa/editor-window-life.png" alt></center><h3 id="Animation-Clip 数据结构"><a href="#Animation-Clip 数据结构" class="headerlink" title="Animation Clip 数据结构"></a><code>Animation Clip</code>数据结构 </h3><h3 id="协程的原理"><a href="# 协程的原理" class="headerlink" title="协程的原理"></a> 协程的原理 </h3><h4 id="yield 和 IEnumerator 什么关系"><a href="#yield 和 IEnumerator 什么关系" class="headerlink" title="yield 和 IEnumerator 什么关系"></a><code>yield</code> 和<code>IEnumerator</code>什么关系 </h4><p><code>yield</code> 是 C# 的关键字，其实就是快速定义迭代器的语法糖。只要是 <code>yield</code> 出现在其中的方法就会被编译器自动编译成一个迭代器，对于这样的函数可以称之为迭代器函数。迭代器函数的返回值就是自动生成的迭代器类的一个对象</p><p>试试想象如果没有 <code>yield</code> 关键字，我们每定义一个迭代器，就要创建一个类，实现 <code>IEnumerator</code> 接口，接口包含的属性与方法都要正确的实现，是不是很麻烦？而利用 <code>yield</code> 关键字，只需要下面简单的几行代码，就可以快速定义一个迭代器。诸如迭代器类的创建，<code>IEnumerator</code>接口的实现工作编译器通通帮你做了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">// 由迭代器函数定义的迭代器</span><br><span class="hljs-function">IEnumerator <span class="hljs-title">Test</span>()</span><br>{<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    Debug.Log(<span class="hljs-string">"Surprise"</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>}<br><br></code></pre></td></tr></table></figure><h4 id="Unity- 协程机制的实现原理"><a href="#Unity- 协程机制的实现原理" class="headerlink" title="Unity 协程机制的实现原理"></a>Unity 协程机制的实现原理 </h4><p> 协程是一种比线程更轻量级的存在，协程可完全由用户程序控制调度。协程可以通过 <code>yield</code> 方式进行调度转移执行权，调度时要能够保存上下文，在调度回来的时候要能够恢复。这是不是和上面“停住”代码然后又原位恢复的执行效果很像？没错，Unity 实现协程的原理，就是通过 <code>yield return</code> 生成的 <code>IEnumerator</code> 再配合控制何时触发 <code>MoveNext</code> 来实现了执行权的调度</p><p>具体而言，Unity 每通过 <code>MonoBehaviour.StartCoroutine</code> 启动一个协程，就会获得一个 <code>IEnumerator</code>（<code>StartCoroutine</code> 的参数就是 <code>IEnumerator</code>，参数是方法名的重载版本也会通过反射拿到该方法对应的<code>IEnumerator</code>）。并在它的游戏循环中，根据条件判断是否要执行<code>MoveNext</code> 方法。而这个条件就是根据 <code>IEnumerator</code> 的<code>Current</code>属性获得的，即 <code>yield return</code> 返回的值。</p><p>在启动一个协程时，Unity 会先调用得到的 <code>IEnumerator</code> 的<code>MoveNext</code>一次，以拿到 <code>IEnumerator</code> 的<code>Current</code>值。所以每启动一个协程，协程函数会立即执行到第一个 yield return 处然后“停住”。</p><p>对于不同的 <code>Current</code> 类型（一般是 <code>YieldInstruction</code> 的子类），Unity 已做好了一些默认处理，比如：</p><ul><li>如果 <code>Current</code> 是<code>null</code>，就相当于什么也不做。在下一次游戏循环中，就会调用 <code>MoveNext</code>。所以<code>yield return null</code> 就起到了等待一帧的作用</li><li>如果 <code>Current</code> 是<code>WaitForSeconds</code>类型，Unity 会获取它的等待时间，每次游戏循环中都会判断时间是否到了，只有时间到了才会调用 <code>MoveNext</code>。所以<code>yield return WaitForSeconds</code> 就起到了等待指定时间的作用</li><li>如果 <code>Current</code> 是<code>UnityWebRequestAsyncOperation</code>类型，它是 <code>AsyncOperation</code> 的子类，而 <code>AsyncOperation</code> 有<code>isDone</code>属性，表示操作是否完成，只有 <code>isDone</code> 为<code>true</code>时，Unity 才会调用 M<code>oveNext</code>。对于 <code>UnityWebRequestAsyncOperation</code> 而言，只有请求完成了，才会将 <code>isDone</code> 属性设置为<code>true</code>。</li></ul><p>也因此我们才可以使用下面的同步代码，完成本来是异步的网络请求操作。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span>(UnityWebRequest webRequest = UnityWebRequest.Get(<span class="hljs-string">"https://www.cnblogs.com/iwiniwin/p/13705456.html"</span>))<br>{<br>    <span class="hljs-keyword">yield</span> <span class="hljs-keyword">return</span> webRequest.SendWebRequest();<br>    <span class="hljs-keyword">if</span>(webRequest.isNetworkError)<br>    {<br>        Debug.Log(<span class="hljs-string">"Error"</span> + webRequest.error);<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        Debug.Log(<span class="hljs-string">"Received"</span> + webRequest.downloadHandler.text);<br>    }<br>}<br></code></pre></td></tr></table></figure><h4 id="Lua- 协程"><a href="#Lua- 协程" class="headerlink" title="Lua 协程"></a>Lua 协程 </h4><p>Lua 协程的相关函数封装在 coroutine 中，对应的 C API 为<code>lua_newthread</code>，<code>lua_resume</code> 等。Lua 文档中的 thread 和 coroutine 是一个概念，但与操作系统的线程是两个东西。C API 通过 <code>lua_State</code> 维护一个协程的状态（以及 Lua 虚拟机状态的引用），协程的状态主要指协程上下文（如交互栈），Lua 虚拟机状态是全局的，可被多个协程共享</p><p>当调用 <code>lua_newstate</code> 时，实际上分为两步</p><ul><li>创建并初始化一个 Lua 虚拟机<code>global_State</code></li><li>创建一个主协程运行于虚拟机中，并返回主协程的执行上下文 LuaState</li></ul><p>调用 <code>lua_newthread</code> 时，将在已有 Lua 虚拟机上，创建另一个协程执行环境，该协程与已有协程共享虚拟机状态（同一个 Lua 虚拟机中的不同协程共享<code>global_State</code>)，并返回新的执行上下文。因此将 LuaState 理解为协程执行上下文可能更合适，LuaState 本身也是一个类型为 thread 的 GCObject，无需手动释放</p><h2 id="游卡"><a href="# 游卡" class="headerlink" title="游卡"></a>游卡 </h2><h3 id="LoopScrollView"><a href="#LoopScrollView" class="headerlink" title="LoopScrollView"></a>LoopScrollView</h3><h3 id="UI- 框架"><a href="#UI- 框架" class="headerlink" title="UI 框架"></a>UI 框架</h3><h3 id="表格加载"><a href="# 表格加载" class="headerlink" title="表格加载"></a> 表格加载 </h3><h2 id="莉莉丝"><a href="# 莉莉丝" class="headerlink" title="莉莉丝"></a> 莉莉丝</h2><h3 id="C- 字符串优化"><a href="#C- 字符串优化" class="headerlink" title="C# 字符串优化"></a>C# 字符串优化</h3><ul><li><p>使用 <code>string.Empty</code> 给一个空字符串变量赋初始值，<code>String.Empty</code>是一个指代，而 <code>""</code> 是具体的实现</p></li><li><p>使用 <code>str.Length == 0</code> 做空串比较</p></li><li><p>避免不必要的字符串 <code>ToUpper</code>、<code>ToLower</code> 类操作</p><ul><li><code>ToUpper</code>、<code>ToLower</code>这类方法均会重新生成字符串对</li><li><code>String.Compare</code>可实现忽略字符串大小写</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 不推荐的写法</span><br><span class="hljs-keyword">if</span>(s1.ToUpper() == s2.ToUpper())<br><span class="hljs-comment">// 推荐的写法</span><br><span class="hljs-keyword">if</span>(String.Compare(s1, s2, <span class="hljs-literal">true</span>) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li><li><p>用 <code>StringBuilder</code> 进行字符串拼接操作</p></li><li><p>创建 <code>StringBuilder</code> 应指定初始大小</p></li><li><p>避免滥用<code>StringBuilder</code></p><ul><li>类似 <code>str1 + str2 + str3 + str4</code> 的字符串拼接操作会被编译为 <code>String.Concat(str1, str2, str3, str4)</code>，效率反而高于<code>StringBuilder</code>。<code>String.Concat</code> 会一次性确定字符串长度，<code>StringBuilder</code>需要做 <code>Resize</code>，适用于多次生成<code>string</code> 对象的情况</li></ul></li><li><p>通过直接设置 <code>.Length = 0</code> 来初始化<code>StringBuilder</code></p></li><li><p>不要使用 <code>.Length = 0</code> 来释放 <code>StringBuilder</code> 占用的内存</p></li></ul><h3 id="图片压缩"><a href="# 图片压缩" class="headerlink" title="图片压缩"></a>图片压缩 </h3><h4 id="术语"><a href="# 术语" class="headerlink" title="术语"></a> 术语</h4><ul><li><strong>内存 </strong>：例如<code>A8R8G8B8</code> 格式中一个像素占 4 字节，如果是 512x512 分辨率内存就占用<code>512 * 512 * 4B = 1048576B = 1MB</code>，这种内存消耗在低端设备上根本无法接受</li><li><strong>带宽</strong>：在渲染 3D 场景时，会有大量的贴图被传输到 GPU，若不限制，总线带宽很快就会成为瓶颈</li><li><strong>有损</strong>：表示对于渲染来说，有损压缩是可以接受的，一般选择压缩格式时需要在纹理质量和文件大小上寻求一个平衡</li><li><strong>固定速率压缩</strong>：因为 GPU 需要能够高效的随机访问一个像素，这意味着对任意像素，解码速度不该有太大的变化。因此，见的贴图压缩算法都是固定速率压缩。相反的例如 zip 则是一种可变速率压缩</li><li><strong>向量量化（Vector Quantization，VQ）</strong>：此技术原用于资料压缩，透过分割大数量的资料点（函数），让每个小群集都有相同的资料点，而这些小群集的所有资料就由其正中央的点作为代表</li><li><strong>编码和解码速度</strong>：一般来说编码速度慢没关系，因为通常纹理压缩只需要在游戏打包时进行一次，对于用户运行时体验完全没有影响。但解码速度必须足够快，而且基本上不能影响到渲染性能</li><li><strong>压缩比</strong>：通常以比特率或每像素的平均比特数（bits per pixel，bpp）表示，常见的为 2~8bpp。一般 RGB 原生纹理的像素指 24 位，4bpp 表示每像素占 4 位，所以也可以认为 4bpp 表示压缩比为 6:1</li></ul><h4 id="ETC"><a href="#ETC" class="headerlink" title="ETC"></a>ETC</h4><h5 id="基本思想"><a href="# 基本思想" class="headerlink" title="基本思想"></a>基本思想 </h5><p> 将图片分成 4x4 的若干个像素块，每个像素块按照一定规则编码成为一个 64 位 (8 字节）的数据，大概的想法是计算像素块的平均颜色，然后记录这个平均颜色和每个像素相对平均颜色的差值，平均颜色只耗费了一个像素的数据，而差值也并不记录完全真实的差值，而是从一个固定的静态数据中找到最接近的差值（RGB 三个通道差值一样），每个像素只需要记录其差值在静态数据中的索引即可</p><ul><li>压缩比：对于 RGB24 图片，每个块的数据由 4x4x3 = 48 字节，压缩为 8 字节，压缩比为 6:1，针对 Alpha 图片，由 4x4x1 = 16 字节 压缩为 8 字节，所以，对于普通的 RGBA 分离为 RGB24 和 Alpha 之后分别进行 ETC1 压缩的图片，整体压缩比为 (48 + 16) : (8 + 8) = 4:1</li><li>文件头数据：除了编码后的数据块之外，还会存储一部分文件头数据，用来表示文件的特征码、宽高等</li></ul><h5 id="像素块编码思想"><a href="# 像素块编码思想" class="headerlink" title="像素块编码思想"></a>像素块编码思想</h5><ul><li>将 4x4 的像素块分为两个 4x2 的子块，有水平和竖直两种分法。使用 1 位数据 flipbit 来表示是哪一种分法，还剩下 63 位数据</li></ul><center>    <img src="/2024/05/13/cf86467b04aa/pixel-split.webp" alt></center><ul><li>分别计算两个分块中 8 个像素颜色的平均值，根据两个块颜色平均值的差值，确定使用 individual 模式还是 differential 模式。使用 1 位数据 diffbit 来表示是哪种模式，还剩下 62 位数据</li><li>存放两个子块的平均颜色信息，individual 模式用 R4G4B4 的格式分别表示两个子块的平均颜色，differential 模式使用 R5G5B5 格式表示第一个子块的平均颜色，R3G3B3 格式表示第二个子块与第一个子块平均颜色的差值。这里使用了 8 * 3 = 24 位数据，还剩下 62 - 24 = 38 位数据</li><li>所有的图片共享一个全局的映射表数据，这个数据是固定的全局静态数据，并不会进入到编码数据中，这个表是一个 8 x 4 的二维数组，使用 3 位数表示第一个子块在映射表中查询的第一维索引，需要 3 位来表示 0 - 7 的下标，第二个子块同样需要 3 位数来表示，还剩下 38 - 3 * 2 = 32 位数据</li><li>4 x 4 像素块中的每个像素，使用 2 位数来表示该像素在映射表中查询的第二维索引，需要 2 位数来表示 0 - 3 的下标，所以消耗了 4 x 4 x 2 = 32 位数据</li></ul><h5 id="内存布局和解码过程"><a href="# 内存布局和解码过程" class="headerlink" title="内存布局和解码过程"></a>内存布局和解码过程 </h5><p> 以 RGB555 基本色和 RGB3333 颜色差表示的编码为例，每个 4x4 像素块经过 ETC1 编码后的 64 位数据的内存布局大概是这样</p><center>    <img src="/2024/05/13/cf86467b04aa/etc-memory-layout.webp" alt></center><p>假如编码前像素块表示为下图，需要得到图中编号 2 对应像素的颜色，需要进行如下的解码步骤：</p><center>    <img src="/2024/05/13/cf86467b04aa/etc-decode.webp" alt></center><ul><li>获取目标所在的子块：根据第 32 位 flipbit 标志位，知道这个像素块采用的是横版划分子块，2 号像素处在子块 2 中</li><li>获取子块 1 基本颜色：首先根据第 33 位 diffbit 标志位得知，这里采用的是 R5G5B5 基本色 + R3G3B3 差值的方式。分别从 59-63 位 (11100)、51-55 位 (00100) 和 43-47 位 (00011) 读取子块 1 基本色 RGB1=(11100, 00100, 00011) = (28, 4, 3)</li><li>获取子块 2 的颜色差值：这里是 differential 模式，所以需要读取子块 2 的颜色差值，从 56-58 位 (100)、48-50 位 (010) 和 40-42 位 (000) 获得颜色差值 RGB_offset=(100, 010, 000) = (-4, 2, 0)，注意这里的 3 位数据中最高位是符号位，所以差值部分的取值范围是 [-4, 3]</li><li>计算子块 2 的基本色：将子块 1 基本色和子块 2 差值相加，得到子块 2 的基本色，RGB2=RGB1 + RGB_offset = (28 - 4, 4+2, 3+0) = (24, 6, 3)，转为 5 位二进制表示为 RGB2=(11000, 00110, 00011)</li><li>扩展子块 2 基本色分量为 8 位：对 5 位标识的基本色补位为 8 位表示，得到 RGB1 = (11000110, 00110110, 00011011) = (198, 54, 27)，这就是子块 2 的基本色<blockquote><p>补位规则：</p><ul><li>individual 模式，直接将 4 位数复制到尾部，得到 8 位</li><li>differential 模式，将 5 位中的高 3 位复制到尾部，得到 8 位</li><li>differential 模式，一定是将子块 1 基本色和子块 2 偏移值相加后再进行补位</li></ul></blockquote></li><li>获得目标像素的颜色偏移值：目标像素下标为 2，在编码数据的第 2 位得到映射表的下标的低位 (lsb) 为 1，第 18 位得到映射表的下标高位 (msb) 为 1，假如使用如下的映射表，则可以得到映射表下标为<code>(lsb, msb) = (1, 1)</code>，对应下标为<code>-b</code></li></ul><center>    <img src="/2024/05/13/cf86467b04aa/etc-mapped.webp" alt></center><p>  上面知道目标像素位于子块 2，这里还需要从编码数据的 34-36 获得子块 2 的修正表索引，得到索引为 <code>(1, 1, 0) = 6</code>，根据上面的映射表，根据下标<code>(6, -b)</code> 可以索引到像素的颜色差值为 -106</p><ul><li>计算目标像素的最终颜色值：这里 RGB 三个分量的差值相同，目标像素最终的颜色值为子块 2 的基本颜色 + 目标像素的颜色偏移值：<br><code>RGB_target = RGB2 + (-106, -106, -106) = (198 - 106, 54 - 106, 27 - 106)</code>，修正后得到目标颜色值<code>RGB_target = (92, 204, 177)</code></li></ul><h5 id="编码过程"><a href="# 编码过程" class="headerlink" title="编码过程"></a>编码过程</h5><ul><li>将图划分为 4x4 的像素块，如果不够 4x4，则将这些像素填充在 4x4 块的左上角</li><li>针对每个 4x4 的像素块尝试以下编码，取解码后和原像素差值最小的那种编码作为结果<ol><li>确定 <code>flipbit</code>，并计算两个子块的平均颜色值，这里我猜测是先将 8 个像素的<code>R8G8B8</code> 取均值得到像素的平均值，然后将每个分量的后三位直接抛弃，得到<code>R5G5B5</code></li><li>根据两个子块颜色值的差值，确定 <code>diffbit</code>，根据上面得到的两个子块的<code>R5G5B5</code>，计算差值，如果差值在<code>[-4, 3]</code> 之间，说明差值可以用 3 位带符号的二进制数表示，可以用 <code>differential</code> 模式，否则用 <code>individual</code> 模式</li><li>枚举不同的子块索引，确定每个子块使用映射表中的哪一组偏移值</li><li>枚举每个像素的映射下标，确定像素使用映射表中的哪一个偏移值</li><li>针对第 3 步和第 4 步的枚举，可以得到很多组不同的编码，将编码结果解压后和原始像素数据对比，取相差最小的一组编码作为最终结果</li></ol></li><li>将图片中各个像素块编码合并</li></ul><h5 id="Unity- 的几种 -ETC- 纹理压缩格式"><a href="#Unity- 的几种 -ETC- 纹理压缩格式" class="headerlink" title="Unity 的几种 ETC 纹理压缩格式"></a>Unity 的几种 ETC 纹理压缩格式</h5><ul><li>RGB ETC1 4 bit：4 bits/pixel，对 RGB 压缩比 6:1，不支持 Alpha，绝大部分安卓设备都支持</li><li>RGB ETC2 4 bit：4 bits/pixel，对 RGB 压缩比 6:1。不支持 Alpha，ETC2 兼容 ETC1，压缩质量可能更高，但对于色度变化大的块误差也更大，需要在 OpenGL ES 3.0 和 OpenGL 4.3 以上版本</li><li>RGBA ETC2 8bit：8 bits/pixel，对 RGBA 压缩比 4:1。支持完全的透明通道，版本要求同上</li><li>RGB +1bit Alpha ETC2 4bit：4 bits/pixel。支持 1bit 的 Alpha 通道，也就是只支持镂空图，图片只有透明和不透明部分，没有中间的透明度</li></ul><h4 id="DXT"><a href="#DXT" class="headerlink" title="DXT"></a>DXT</h4><p>DXT 是一种有损纹理压缩算法，微软的 Direct 中支持，DXT 的格式包括 DXT1~DXT5，其中 DXT1 和 DXT5 较为多见</p><center>    <img src="/2024/05/13/cf86467b04aa/dxt.webp" alt></center><p>DXT 算法非常容易理解，而且整体看上去效果不错，但如果对局部特写，会发现在细节上会有很多丢失，这也是算法本身导致的，毕竟每个块只有两个颜色，而其他颜色都是在这两个颜色区间的差值，如果当前区域内还有其他显著颜色则必然会有丢失</p><p>这种信息的丢失主要集中在比较细的边界中，但 DXT1 在压缩率上是 RGB 的 6 倍，这种问题可以通过提高纹理分辨率的方式来解决，高宽放大 41%(<code>1.41 * 1.41 = 1.9881</code>)，这样整个纹理是以前的 2 倍，但压缩率还能保持为 3 倍，也是可以接受的。在 DXT 中还有一个主要的损失，就是 RGB 的 24 位转为了 16 位颜色，16 位中 R&amp;B 各占 5 位，但是 G 占了 6 位，这是因为人眼对绿色最为敏感</p><center>    <img src="/2024/05/13/cf86467b04aa/dxt-16bits.webp" alt></center><p>另外一个问题就是 DXT3 和 DXT5 之间的对比，相比 DXT1 不支持透明度（但支持是否透明），DXT5 要大一倍（多了 64bit），和之前颜色保存方案一样对透明度也保存了两个 16 位的颜色和对应的调色板，对 RGBA 的效果也得到了保证，但 DXT3 思路不一样，它是对每一个像素保存了 4bit 的透明度，同样也是多了 64bit，但此时毕竟只有 16 个透明度选项，相比 DXT5，在压缩率上相当，但对透明色的处理不够细腻，因此在实用性上并不推荐 DXT3</p><h4 id="PVRTC"><a href="#PVRTC" class="headerlink" title="PVRTC"></a>PVRTC</h4><p>PVRTC 不同于 DXT 和 ETC 这类基于块的算法，而将整张纹理分为了高频信号和低频信号，低频信号由两张低分辨率的图像 A 和 B 表示，这两张图在两个维度上都缩小了 4 倍，高频信号则是全分辨率但低精度的调制图像 M，M 记录了每个像素混合的权重。要解码时，A 和 B 图像经过双线性插值（Bilinearly）宽高放大 4 倍，然后与 M 图上的权重进行混合</p><center>    <img src="/2024/05/13/cf86467b04aa/pvrtc.webp" alt></center><p>PVRTC 4-bpp 模式下，每 4x4 像素占一个 64 位数据块，2-bpp 模式下每 8x4 像素会有一个 64 位数据块。4-bpp 模式下，A 图和 B 图缩小后都只保存一个颜色值，如下图所示，Color A 比 Color B 少 1 位，但两张图都可以选择以 RGB 或 ARGB 的方式存储（最高位决定为哪种），Color A 可以用 RGB554 或 ARGB3443 格式编码，Color B 可以用 RGB555 或 ARGB3444 格式编码</p><center>    <img src="/2024/05/13/cf86467b04aa/pvrtc-block.webp" alt></center><p>在解码时，为了解码任意像素，必须读取 4 个相邻的 PVRTC 块，使用这 4 个块来解码一个 5x5 块</p><center>    <img src="/2024/05/13/cf86467b04aa/pvrtc-decode.webp" alt></center><p>使用双线性过滤来对 A 和 B 图进行扩大，然后 A 和 B 图根据 M 图与 <code>Mode</code> 位进行混合，这里的 <code>Mode</code> 位为 1 时，M 图中 10 值像素被看作是开启了 punch-through alpha，Alpha 通道会被强制清零，是为了兼容旧应用程序</p><center>    <img src="/2024/05/13/cf86467b04aa/pvrtc-bilinear-filter.webp" alt></center><h4 id="ASTC"><a href="#ASTC" class="headerlink" title="ASTC"></a>ASTC</h4><p>以下每个用例都对压缩方案有自己的要求：</p><ul><li>支持从 1 到 4 个分量的纹理。虽然单通道纹理也可以使用 BC7、PVRTC2 或 ETC2 来存储，但空通道上大量 bit 被浪费掉了。</li><li>在通道之间数据无相关性的情况下，拥有可以接受的质量。这对于法线图和 RGBA 图像来说非常重要。</li><li>支持 LDR 和 HDR。BC6H 可用于 HDR 纹理压缩，但它不支持 alpha 通道。</li><li>跨平台。特别是：PVRTC 只在 iOS 平台上可用，BC6H/BC7 在移动设备中缺失，ETC 不被桌面级 GPU 所支持。对于跨平台应用程序的开发者来说，有诸多不便。<br>比特率 / 质量比的灵活性。根据纹理类型，不同程度的压缩伪影是可以接受的，因为不同图像的可压缩性是不同的。前文中提到的格式里，能提供的比特率 / 质量选项的不超过两个 (BC1/BC7 或 PVRTC 4bpp/2bpp) 。如果不能使用 5bpp 的压缩级别 （如果 4bpp 的质量略显不足） ，就必须使用 8bpp 的选项。带宽增加了一倍，但质量却没有明显改善。</li><li>支持 2D 和 3D 纹理。</li></ul><p>概念上讲，ASTC 类似于 S3TC/BC7：一个压缩块中最多存储四个端点对和插值权重，只支持预定义的分区，特定的分区由分区 ID 指定，也存储在一个块中。在弱相关的情况下，该通道会存储一个独立的索引表。每个独立的编码被称为一个平面。或许 ASTC 最主要、最有趣的创新是用小数位编码整数值的技术，称为 BISE。同时，BISE 可以在硬件中有效实现</p><h5 id="有界整数序列编码 -Bounded-Integer-Sequence-Encoding-BISE"><a href="# 有界整数序列编码 -Bounded-Integer-Sequence-Encoding-BISE" class="headerlink" title="有界整数序列编码 (Bounded Integer Sequence Encoding, BISE)"></a>有界整数序列编码 (Bounded Integer Sequence Encoding, BISE)</h5><p>有界整数序列编码，或称 BISE，解决了如下抽象问题：从大小为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.009ex" height="1.545ex" role="img" focusable="false" viewbox="0 -683 888 683"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g></g></g></svg></mjx-container> 的字母表中给定等概率的符号序列， 找到一种编码，使得能够在常数时间复杂度内使用最少的硬件消耗提取第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.781ex" height="1.52ex" role="img" focusable="false" viewbox="0 -661 345 672"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个符号，并允许相同硬件设计能够用于多种不同大小的字母表，同时具备存储效率</p><p>例如，考虑一个由 5 个整数组成的序列，其中每个整数可以是 0，1 或 2（译者注：5 位的 3 进制数）。使用标准二进制编码时，需要为每个值分配 2 位，总共 10 位。但不同序列的数量是<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.53ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3770.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z" transform="translate(500,0)"/><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container>，小于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.53ex" height="2.072ex" role="img" focusable="false" viewbox="0 -833.9 3770.1 915.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(500,0)"/><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container>。因此，可以用 8 比特对整个序列进行编码，每个值的比特率为 1.6。换句话说，可以用 8 比特来表示 5 位的 3 进制数</p><p>现在，考虑任意长度的序列，其中每个值都属于范围 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.301ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 4111.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"/></g><g data-mml-node="mi" transform="translate(1222.7,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(2332.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3333.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(3833.1,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></svg></mjx-container>，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.202ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4951.3 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(2943.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msup" transform="translate(3944,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>。每个值都可以用一个三进制位和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewbox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></svg></mjx-container> 个比特来表示。假设 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="7.289ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 3221.6 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/></g></g></g></svg></mjx-container>，那么满足该条件的任何值都可以用以下形式表示：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="21.566ex" height="2.261ex" role="img" focusable="false" viewbox="0 -833.9 9532.2 999.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"/></g><g data-mml-node="mo" transform="translate(1129.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mi" transform="translate(2185.6,0)"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="msup" transform="translate(2546.6,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="mo" transform="translate(3705.3,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(4705.6,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(5571.1,0)"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g><g data-mml-node="mo" transform="translate(6729.9,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"/></g><g data-mml-node="msub" transform="translate(7730.1,0)"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8595.7,0)"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></g></svg></mjx-container>，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="0.817ex" height="1.441ex" role="img" focusable="false" viewbox="0 -626 361 637"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g></g></g></svg></mjx-container> 是一个三进制位，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.91ex" role="img" focusable="false" viewbox="0 -694 865.6 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container>和 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 865.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container> 是比特位。整个序列可以被划分为五组值，最后一组会在必要时填充 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewbox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container>。二进制形式下，一个特定的组可以表示为一个比特串<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="22.546ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 9965.5 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="msub" transform="translate(797.6,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="msub" transform="translate(1993.1,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="msub" transform="translate(2790.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="msub" transform="translate(3986.2,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msub" transform="translate(4783.8,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msub" transform="translate(5979.3,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(6776.9,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(7972.4,0)"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g><g data-mml-node="msub" transform="translate(8770,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>，其中<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="1.556ex" height="1.773ex" role="img" focusable="false" viewbox="0 -626 688 783.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mi" transform="translate(394,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 是一个三进制位的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container> 比特表示，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.357ex;" xmlns="http://www.w3.org/2000/svg" width="2.457ex" height="1.902ex" role="img" focusable="false" viewbox="0 -683 1086 840.8"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mi" transform="translate(792,-150) scale(0.707)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container>是一个值的剩余比特位（译注：即上文中的 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.91ex" role="img" focusable="false" viewbox="0 -694 865.6 844"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="1.958ex" height="1.945ex" role="img" focusable="false" viewbox="0 -694 865.6 859.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D44F" d="M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z"/></g><g data-mml-node="mn" transform="translate(462,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container>)。只要三进制位与比特信息保持这种相关性，就可以用比特串 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="33.25ex" height="2.345ex" role="img" focusable="false" viewbox="0 -683 14696.7 1036.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(1413.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="msub" transform="translate(2609.3,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(4573.1,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="msub" transform="translate(5768.6,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(7182.4,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g><g data-mml-node="msub" transform="translate(8377.9,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(10341.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g><g data-mml-node="msub" transform="translate(11537.3,0)"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(13501.1,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></g></svg></mjx-container> 保存这五组值。其中 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="4.054ex" height="2.331ex" role="img" focusable="false" viewbox="0 -677 1792 1030.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mi" transform="translate(278,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(623,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mi" transform="translate(901,0)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"/></g><g data-mml-node="mo" transform="translate(1313,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g></g></g></svg></mjx-container> 为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.593ex" height="1.532ex" role="img" focusable="false" viewbox="0 -677 704 677"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g></g></g></svg></mjx-container>的各个比特，这段数据要比原先短 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.507ex" role="img" focusable="false" viewbox="0 -666 500 666"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></svg></mjx-container> 比特</p><p>事实证明，这种编码能够保留尾部的零。例如，如果我们序列中的最后一组被填充了两个零 （所以 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="4.509ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1993.1 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g><g data-mml-node="msub" transform="translate(797.6,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.375ex;" xmlns="http://www.w3.org/2000/svg" width="4.509ex" height="1.92ex" role="img" focusable="false" viewbox="0 -683 1993.1 848.6"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D461" d="M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z"/></g><g data-mml-node="mn" transform="translate(394,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="msub" transform="translate(797.6,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container>是零） ，那么 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="5.903ex" height="2.345ex" role="img" focusable="false" viewbox="0 -683 2609.3 1036.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(1413.7,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="34" d="M462 0Q444 3 333 3Q217 3 199 0H190V46H221Q241 46 248 46T265 48T279 53T286 61Q287 63 287 115V165H28V211L179 442Q332 674 334 675Q336 677 355 677H373L379 671V211H471V165H379V114Q379 73 379 66T385 54Q393 47 442 46H471V0H462ZM293 211V545L74 212L183 211H293Z"/></g></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.8ex;" xmlns="http://www.w3.org/2000/svg" width="7.148ex" height="2.345ex" role="img" focusable="false" viewbox="0 -683 3159.4 1036.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"/></g><g data-mml-node="TeXAtom" transform="translate(617,-176.7) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="5B" d="M118 -250V750H255V710H158V-210H255V-250H118Z"/></g><g data-mml-node="mn" transform="translate(278,0)"><path data-c="36" d="M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z"/></g><g data-mml-node="mo" transform="translate(778,0)"><path data-c="3A" d="M78 370Q78 394 95 412T138 430Q162 430 180 414T199 371Q199 346 182 328T139 310T96 327T78 370ZM78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"/></g><g data-mml-node="mn" transform="translate(1056,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mo" transform="translate(1556,0)"><path data-c="5D" d="M22 710V750H159V-250H22V-210H119V710H22Z"/></g></g></g><g data-mml-node="msub" transform="translate(1963.8,0)"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></g></svg></mjx-container>是零，它们不需要被存储。因此，任何长度的序列，假如其数值范围从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewbox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container> 到<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="10.073ex" height="1.714ex" role="img" focusable="false" viewbox="0 -675.5 4452.2 757.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msup" transform="translate(1722.4,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g><g data-mml-node="mo" transform="translate(2951.9,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(3952.2,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container>，都可以用接近于理论上的最小的比特率进行编码。同时，其中的任意值能以最小的硬件消耗容易的提取出来</p><p>同样的推理也可以应用于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="11.202ex" height="1.731ex" role="img" focusable="false" viewbox="0 -683 4951.3 765"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"/></g><g data-mml-node="mo" transform="translate(1165.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2221.6,0)"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mo" transform="translate(2943.8,0)"><path data-c="D7" d="M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z"/></g><g data-mml-node="msup" transform="translate(3944,0)"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g></g></g></g></svg></mjx-container> 的序列。这里，<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.554ex" role="img" focusable="false" viewbox="0 -665 500 687"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g></g></svg></mjx-container>个五进制数 （基数为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewbox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g></g></g></svg></mjx-container> 的数字） 可以用 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.579ex" role="img" focusable="false" viewbox="0 -676 500 698"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g></g></svg></mjx-container> 位来编码，因为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.53ex" height="2.071ex" role="img" focusable="false" viewbox="0 -833.2 3770.1 915.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="35" d="M164 157Q164 133 148 117T109 101H102Q148 22 224 22Q294 22 326 82Q345 115 345 210Q345 313 318 349Q292 382 260 382H254Q176 382 136 314Q132 307 129 306T114 304Q97 304 95 310Q93 314 93 485V614Q93 664 98 664Q100 666 102 666Q103 666 123 658T178 642T253 634Q324 634 389 662Q397 666 402 666Q410 666 410 648V635Q328 538 205 538Q174 538 149 544L139 546V374Q158 388 169 396T205 412T256 420Q337 420 393 355T449 201Q449 109 385 44T229 -22Q148 -22 99 32T50 154Q50 178 61 192T84 210T107 214Q132 214 148 197T164 157Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container> 小于<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="8.53ex" height="2.088ex" role="img" focusable="false" viewbox="0 -841 3770.1 923"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g><g data-mml-node="mn" transform="translate(533,363) scale(0.707)"><path data-c="37" d="M55 458Q56 460 72 567L88 674Q88 676 108 676H128V672Q128 662 143 655T195 646T364 644H485V605L417 512Q408 500 387 472T360 435T339 403T319 367T305 330T292 284T284 230T278 162T275 80Q275 66 275 52T274 28V19Q270 2 255 -10T221 -22Q210 -22 200 -19T179 0T168 40Q168 198 265 368Q285 400 349 489L395 552H302Q128 552 119 546Q113 543 108 522T98 479L95 458V455H55V458Z"/></g></g><g data-mml-node="mo" transform="translate(1214.3,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></g><g data-mml-node="mn" transform="translate(2270.1,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z" transform="translate(500,0)"/><path data-c="38" d="M70 417T70 494T124 618T248 666Q319 666 374 624T429 515Q429 485 418 459T392 417T361 389T335 371T324 363L338 354Q352 344 366 334T382 323Q457 264 457 174Q457 95 399 37T249 -22Q159 -22 101 29T43 155Q43 263 172 335L154 348Q133 361 127 368Q70 417 70 494ZM286 386L292 390Q298 394 301 396T311 403T323 413T334 425T345 438T355 454T364 471T369 491T371 513Q371 556 342 586T275 624Q268 625 242 625Q201 625 165 599T128 534Q128 511 141 492T167 463T217 431Q224 426 228 424L286 386ZM250 21Q308 21 350 55T392 137Q392 154 387 169T375 194T353 216T330 234T301 253T274 270Q260 279 244 289T218 306L210 311Q204 311 181 294T133 239T107 157Q107 98 150 60T250 21Z" transform="translate(1000,0)"/></g></g></g></svg></mjx-container>。因此，使用三进制数和五进制数的 BISE 技术在存储方面都是是有效率的</p><center>    <img src="/2024/05/13/cf86467b04aa/astc-BISE.jpg" alt></center><h5 id="其他改进"><a href="# 其他改进" class="headerlink" title="其他改进"></a>其他改进</h5><p>ASTC 还改进了分区模式。BC6H 和 BC7 压缩方案也使用了预定义的分区集表，但这种方法不适合 ASTC，因为它支持大量的瓦片尺寸，支持更多的区域，还增加了分区 ID 字段的大小 (10 位，而 BC7 是 6 位） 。ASTC 的分区模式是用一个特殊的哈希函数生成的，它为每个纹素分配一个分区索引。这个函数将纹素在瓦片中的位置、分区 ID、瓦片大小和分区数量作为输入，并输出一个分区索引。该函数很简单，可以用硬件实现。该函数也用于 3D 纹理。图中描述了 8x8 瓦片的所有分区模式</p><center>    <img src="/2024/05/13/cf86467b04aa/astc-8x8.jpg" alt></center><p>ASTC 的一个更显著的特点是内插权重的编码方式。S3TC 系列方案使用每个顶点的索引来设置插值权重。根据块的类型，索引的大小可以是 2、3 或 4 比特。然而，对于 12x12 瓦片来说，即使每个像素使用 1bit 的索引，也无法存储在一个 128 位块。因此，ASTC 为权重和纹素提供独立的网格大小。例如，对于 12x12 的瓦片，只能存储 4x6 的权重网格。在解码阶段，权重网格被双线性地放大到瓦片大小。不过虽然看起来像，但是它和简单的瓦片缩放并不一样。例如，平滑的梯度通常可以用一个小的权重网格来表示，如 2x2。因此有更多的比特可用于端点。同时尖锐的边缘和颜色过渡可以用适合的分区模式进行编码。权重网格的大小是根据每个块来选择的。因此某些具有强烈垂直特征的瓦片，可以用 4x2 或 8x4 的权重网格进行编码</p><p>所有这些配置数据 （网格大小、分区数量、端点格式） 都必须存储在一个压缩块中。虽然不得不牺牲一些颜色数据位，因而可能降低图像质量，但这种方法带来了很好的灵活性，并且大大增强了压缩质量。ASTC 允许在每个块中进行不同的比特权衡，任意瓦片都可以在分区、端点和权重之间的分布选用最合适的比特分布进行编码。事实证明，即使在较低的比特率下，ASTC 也能够提供比 PVRTC、BC1-BC5 和 ETC 更好的质量。PSNR （译注：峰值信噪比） 增益平均为 1.5dB 至 2dB，大多数观察者 （译注：推测此处数值为 ASTC 对比其他压缩格式获得的增益 ) 大约能察觉 0.25dB 的增益。BC6H 的质量与之相当，而 BC7 平均比 ASTC 多出 0.5dB。不过在 8bpp 时，ASTC 和 BC7 压缩图像的 PSNR 质量都在 45dB 左右，这种差异很难从视觉上发现</p><p>此外，ASTC 是第一个支持 3D 纹理的标准压缩方案，它利用了所有三个维度的颜色相关性。nVidia 的 OpenGL(26) 的 VTC 扩展也是针对 3D 纹理的，但它只是把一个 3D 瓦片分成 2D 片，使用 BC1 方案进行压缩。ASTC 则使用 3D 权重网格和分区，利用分区模式生成器来压缩整个 3D 瓦片。不过权重网格是用单线法而非三线插值法进行放大的 (67) 。整个 3D 瓦片的压缩比分片压缩的 PSNR 高出 2dB</p><p>另外，ASTC 的所有特征都是 “正交 “的，即任何特征都可以独立使用，例如可以用两个弱相关的 HDR 通道来压缩一个三维纹理</p><h3 id="ASTC- 块"><a href="#ASTC- 块" class="headerlink" title="ASTC 块"></a>ASTC 块 </h3><p> 首先是一些全局解码参数，这些参数对任何特定的纹理都是一样的。因此，没有必要在压缩块中存储这些</p><ul><li>动态范围 (LDR/HDR)</li><li>纹理尺寸 (2D/3D)</li><li>瓦片尺寸</li><li>输出色彩空间 (sRGB/RGB)</li></ul><p>而每块指定的数据如下</p><ul><li>权重网格大小</li><li>权重范围 （用于 BISE 解码）</li><li>权重值</li><li>分区的数量</li><li>分区模式 ID</li><li>颜色端点模式</li><li>颜色端点数据</li><li>平面的数量 (1 或 2)</li><li>平面到通道的分配</li></ul><p>纹理可以被编码为单通道、双通道、三通道或四通道图像。但解码后的值总是以 RGBA 格式输出。在 LDR sRGB 模式下，颜色值以 8 位整数返回，否则以 16 位浮点数返回。图 40 展示了 ASTC 块的布局</p><center>    <img src="/2024/05/13/cf86467b04aa/astc-block.png" alt></center><p>除了 BlockMode 和 Part 字段，所有字段的长度都是可变的。</p><p>Part 字段指定了分区的数量 （减一） 。在双平面模式下，分区的数量必须是 1、2 或 3。BlockMode 字段指定了平面数、权重范围和权重网格的大小。ConfigData 和 MoreConfigData 字段指定每个端点对的端点模式。</p><p>如果是 2D 瓦片，BlockMode 由 5 个字段组成。A、B、R、D、H。 特殊的 void-exten 模式有一个单独的编码，用于单色瓦片。void-exten 块还允许识别附近的单色区域。可以缩短获取相同的块的过程，并进一步减少内存带宽占用</p><center>    <img src="/2024/05/13/cf86467b04aa/astc-block-mode.jpg" alt></center><p>A、B 字段分别指定权重网格的宽度 (N) 和高度 (M) 。D 位 （双倍） 被设置为表示双平面模式。R 字段 （范围） 和 H 位 （高精度） 指定重量范围 （见表 14) 。注意，由于 R 字段的编码，为了避免产生歧义，位 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.705ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1195.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></g></svg></mjx-container> 和<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.339ex;" xmlns="http://www.w3.org/2000/svg" width="2.705ex" height="1.885ex" role="img" focusable="false" viewbox="0 -683 1195.6 833"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"/></g><g data-mml-node="mn" transform="translate(792,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"/></g></g></g></g></svg></mjx-container>不能同时为零</p><center>    <img src="/2024/05/13/cf86467b04aa/weight-encode.png" alt></center><p>ConfigData 和 MoreConfigData 指定了端点对的编码，每个端点对都可以有独立的编码模式。共有 16 种编码模式：10 种 LDR 格式和 6 种 HDR 格式。然而，HDR 纹理可以使用其中任何一种。所有这些端点格式都是基于以下基本方法之一：</p><ul><li>独立性。两个 k 位的值直接存储。</li><li><code>base + offset</code>（类似于 ETC 的差分编码） 。第一个值为 base, 用 (k+1) 位存储。第二个值为 offset, 用 (k-1) 位存储。</li><li><code>base + scale</code>。两个 RGB 值由四个数值 <code>(R、G、B、s)</code> 表示。颜色一等于<code>(R，G，B)</code>，颜色二等于<code>(sR，sG，sB)</code></li></ul><p>从概念上讲，ASTC 块的解码是这样进行的。BlockMode 字段用于确定权重范围和权重网格的大小。权重数据从压缩块的尾部读取，并使用 BISE 进行解包。之后，权重被反量化为 [0, 64] 范围。如果权重网格的尺寸小于瓦片的尺寸，则使用双线性插值进行升格。</p><p>之后，Part 字段用于指定分区的数值。分区模式 ID 从块中读出，然后针对每个纹素生成哈希作为分区索引。给定分区数量，还可以利用 ConfigData 和 MoreConfigData 字段计算标量的总值，该值会被用于端点编码 （端点可以有不同数量的通道，不同的端点存储模式下会使用不同数量的值） 。然而，这些标量值的范围在 BISE 解码时必须是已知的，因为该范围并没有被明确指出。在权重和分区数据解码阶段之后，就可以知道可用于彩色端点数据的比特数。颜色端点的值会使用适用于上述比特数的最大范围的值来存储。端点被解压缩和反量化。端点对会根据分区索引来选择。端点的颜色则使用插值权重来混合</p><h2 id="叠纸三面"><a href="# 叠纸三面" class="headerlink" title="叠纸三面"></a>叠纸三面</h2><h3 id="C- 内存分配"><a href="#C- 内存分配" class="headerlink" title="C#内存分配"></a>C#内存分配</h3><p>C# 开发三个重要的内存区域：托管堆内存、非托管堆内存和栈内存</p><center>    <img src="/2024/05/13/cf86467b04aa/csharp-memory-layout.png" alt></center><h4 id="托管堆内存（Managed-Heap-Memory）"><a href="# 托管堆内存（Managed-Heap-Memory）" class="headerlink" title="托管堆内存（Managed Heap Memory）"></a>托管堆内存（Managed Heap Memory）</h4><center>    <img src="/2024/05/13/cf86467b04aa/managed-heap-memory.png" alt></center><p>托管堆内存是由 .NET 运行时（CLR）自动管理的内存区域，用于存储对象实例和数组等引用类型数据。在堆上分配的内存会通过垃圾回收器（Garbage Collector）进行自动回收，对象的创建和销毁都是由垃圾回收器负责管理</p><h4 id="非托管堆内存（Unmanaged-Heap-Memory）"><a href="# 非托管堆内存（Unmanaged-Heap-Memory）" class="headerlink" title="非托管堆内存（Unmanaged Heap Memory）"></a>非托管堆内存（Unmanaged Heap Memory）</h4><center>    <img src="/2024/05/13/cf86467b04aa/unmanaged-heap-memory.png" alt></center><p>非托管堆内存是由本机代码或外部资源分配的内存区域，通常用于与非托管代码进行交互、进行底层的系统编程或使用特定的外部库。需要手动分配和释放内存，没有自动垃圾回收的机制，可以使用 <code>Marshal</code> 类或<code>unsafe</code> 上下文来进行非托管内存的操作</p><h4 id="栈内存（Stack-Memory）"><a href="# 栈内存（Stack-Memory）" class="headerlink" title="栈内存（Stack Memory）"></a>栈内存（Stack Memory）</h4><center>    <img src="/2024/05/13/cf86467b04aa/stack-memory.jpg" alt></center><p>栈内存用于存储局部变量、方法调用和执行上下文等信息，存储的是值类型数据和引用类型数据的引用。栈内存的分配和释放是由编译器自动完成的，具有较高的效率，栈内存的作用域仅限于所属的代码块或方法</p><h4 id="优化技巧"><a href="# 优化技巧" class="headerlink" title="优化技巧"></a>优化技巧 </h4><h5 id="托管堆内存优化"><a href="# 托管堆内存优化" class="headerlink" title="托管堆内存优化"></a> 托管堆内存优化</h5><ul><li>使用对象池：避免频繁地创建和销毁对象，可以使用对象池来重复利用对象实例</li><li>减少装箱和拆箱：尽量使用泛型集合（如<code>List</code>）来避免值类型的装箱和拆箱操作</li><li>及时释放资源：手动释放不再使用的托管内存，如调用对象的 <code>Dispose()</code> 方法或使用 <code>using</code> 语句来确保及时释放资源</li></ul><h5 id="非托管堆内存优化"><a href="# 非托管堆内存优化" class="headerlink" title="非托管堆内存优化"></a>非托管堆内存优化</h5><ul><li>尽量避免直接使用非托管内存：推荐优先使用托管内存，仅在必要时与非托管代码交互，并使用 <code>Marshal</code> 类的相关方法来管理非托管内存的分配和释放</li><li>避免内存泄漏：确保将非托管内存正确释放，避免内存泄漏问题</li></ul><h5 id="栈内存优化"><a href="# 栈内存优化" class="headerlink" title="栈内存优化"></a>栈内存优化</h5><ul><li>尽量使用局部变量：将数据存储在栈上的局部变量中，而不是使用类的实例变量。这样可以减少托管堆内存的压力，同时也提高访问速度</li><li>使用值类型：对于小型数据，考虑使用值类型而不是引用类型来减少内存开销和垃圾回收的成本</li></ul><h5 id="其他优化技巧"><a href="# 其他优化技巧" class="headerlink" title="其他优化技巧"></a>其他优化技巧</h5><ul><li>避免使用过多的字符串拼接操作：频繁的字符串拼接可能会导致内存碎片和性能下降，尽量使用 <code>StringBuilder</code> 类来处理大量字符串拼接</li><li>缓存重复计算结果：如果有一些计算结果会被重复使用，可以将结果缓存起来，避免重复计算和内存消耗</li><li>使用合适的数据结构：选择适当的数据结构和算法来优化内存和性能，如使用哈希表、集合等数据结构</li><li>使用性能分析工具：使用性能分析工具（如。NET Memory Profiler）来检测内存泄漏、高内存使用和潜在性能问题</li></ul><h3 id="堆和栈的访问速度"><a href="# 堆和栈的访问速度" class="headerlink" title="堆和栈的访问速度"></a>堆和栈的访问速度 </h3><p> 栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是 C/C++ 函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构 / 操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多</p><h3 id="红点系统"><a href="# 红点系统" class="headerlink" title="红点系统"></a>红点系统 </h3><h2 id="米哈游一面"><a href="# 米哈游一面" class="headerlink" title="米哈游一面"></a> 米哈游一面 </h2><h3 id="Top-K- 问题"><a href="#Top-K- 问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h3><h4 id="小顶堆"><a href="# 小顶堆" class="headerlink" title="小顶堆"></a> 小顶堆 </h4><p> 可以通过构造一个前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个最大元素小顶堆来解决，小顶堆上的任意节点值都必须小于等于其左右子节点值，即堆顶是最小值。具体步骤如下：</p><ul><li>从数组中取前 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个数（<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.05ex;" xmlns="http://www.w3.org/2000/svg" width="1.131ex" height="1.557ex" role="img" focusable="false" viewbox="0 -666 500 688"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"/></g></g></g></svg></mjx-container>到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.076ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2243.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g><g data-mml-node="mo" transform="translate(743.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mn" transform="translate(1743.4,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g></g></g></svg></mjx-container> 位），构造一个小顶堆</li><li>从 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。</li><li>遍历完成后，堆顶的数据就是第 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 大的数据</li></ul><h5 id="代码实现"><a href="# 代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">findKthLargest</span> = <span class="hljs-title function_ invoke__">function</span>(nums, k) {<br>    <span class="hljs-comment">// 从 nums 中取出前 k 个数，构建一个小顶堆</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">heap</span> = [,], i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span>(i &lt; k) {<br>       heap.<span class="hljs-title function_ invoke__">push</span>(nums[i++]) <br>    }<br>    <span class="hljs-title function_ invoke__">buildHeap</span>(heap, k)<br>    <br>    <span class="hljs-comment">// 从 k 位开始遍历数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = k; i &lt; nums.length; i++) {<br>        <span class="hljs-keyword">if</span>(heap[<span class="hljs-number">1</span>] &lt; nums[i]) {<br>            <span class="hljs-comment">// 替换并堆化</span><br>            heap[<span class="hljs-number">1</span>] = nums[i]<br>            <span class="hljs-title function_ invoke__">heapify</span>(heap, k, <span class="hljs-number">1</span>)<br>        }<br>    }<br>    <br>    <span class="hljs-comment">// 返回堆顶元素</span><br>    <span class="hljs-keyword">return</span> heap[<span class="hljs-number">1</span>]<br>};<br><br><span class="hljs-comment">// 原地建堆，从后往前，自上而下式建小顶堆</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">buildHeap</span> = (arr, k) =&gt; {<br>    <span class="hljs-keyword">if</span>(k === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>    <span class="hljs-comment">// 从最后一个非叶子节点开始，自上而下式堆化</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = Math.<span class="hljs-title function_ invoke__">floor</span>(k/<span class="hljs-number">2</span>); i&gt;=<span class="hljs-number">1</span> ; i--) {<br>        <span class="hljs-title function_ invoke__">heapify</span>(arr, k, i)<br>    }<br>}<br><br><span class="hljs-comment">// 堆化</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">heapify</span> = (arr, k, i) =&gt; {<br>    <span class="hljs-comment">// 自上而下式堆化</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">minIndex</span> = i<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i &lt;= k &amp;&amp; arr[<span class="hljs-number">2</span>*i] &lt; arr[i]) {<br>            minIndex = <span class="hljs-number">2</span>*i<br>        }<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span> &lt;= k &amp;&amp; arr[<span class="hljs-number">2</span>*i+<span class="hljs-number">1</span>] &lt; arr[minIndex]) {<br>            minIndex = <span class="hljs-number">2</span>*i+<span class="hljs-number">1</span><br>        }<br>        <span class="hljs-keyword">if</span>(minIndex !== i) {<br>            <span class="hljs-title function_ invoke__">swap</span>(arr, i, minIndex)<br>            i = minIndex<br>        } <span class="hljs-keyword">else</span> {<br>            <span class="hljs-keyword">break</span><br>        }<br>    }<br>}<br><br><span class="hljs-comment">// 交换</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">swap</span> = (arr, i , j) =&gt; {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = arr[i]<br>    arr[i] = arr[j]<br>    arr[j] = temp<br>}<br></code></pre></td></tr></table></figure><h4 id="快速选择（Quick-Select）算法"><a href="# 快速选择（Quick-Select）算法" class="headerlink" title="快速选择（Quick Select）算法"></a>快速选择（Quick Select）算法 </h4><h5 id="快排"><a href="# 快排" class="headerlink" title="快排"></a> 快排 </h5><p> 快排使用了分治策略的思想，所谓分治，顾名思义，就是分而治之，将一个复杂的问题，分成两个或多个相似的子问题，在把子问题分成更小的子问题，直到更小的子问题可以简单求解，求解子问题，则原问题的解则为子问题解的合并。</p><p>快排的过程简单的说只有三步：</p><ul><li>首先从序列中选取一个数作为基准数</li><li>将比这个数大的数全部放到它的右边，把小于或者等于它的数全部放到它的左边 （一次快排<code>partition</code>）</li><li>然后分别对基准的左右两边重复以上的操作，直到数组完全排序</li></ul><p>具体按以下步骤实现：</p><ol><li>创建两个指针分别指向数组的最左端以及最右端</li><li>在数组中任意取出一个元素作为基准</li><li>左指针开始向右移动，遇到比基准大的停止</li><li>右指针开始向左移动，遇到比基准小的元素停止，交换左右指针所指向的元素</li><li>重复 3，4，直到左指针超过右指针，此时，比基准小的值就都会放在基准的左边，比基准大的值会出现在基准的右边</li><li>然后分别对基准的左右两边重复以上的操作，直到数组完全排序</li></ol><h6 id="代码实现 -1"><a href="# 代码实现 -1" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">quickSort</span> = (arr) =&gt; {<br>  <span class="hljs-title function_ invoke__">quick</span>(arr, <span class="hljs-number">0</span> , arr.length - <span class="hljs-number">1</span>)<br>}<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">quick</span> = (arr, left, right) =&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span><br>  <span class="hljs-keyword">if</span>(left &lt; right) {<br>    <span class="hljs-comment">// 划分数组</span><br>    index = <span class="hljs-title function_ invoke__">partition</span>(arr, left, right)<br>    <span class="hljs-keyword">if</span>(left &lt; index - <span class="hljs-number">1</span>) {<br>      <span class="hljs-title function_ invoke__">quick</span>(arr, left, index - <span class="hljs-number">1</span>)<br>    }<br>    <span class="hljs-keyword">if</span>(index &lt; right) {<br>      <span class="hljs-title function_ invoke__">quick</span>(arr, index, right)<br>    }<br>  }<br>}<br><br><span class="hljs-comment">// 一次快排</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">partition</span> = (arr, left, right) =&gt; {<br>  <span class="hljs-comment">// 取中间项为基准</span><br>  var datum = arr[Math.<span class="hljs-title function_ invoke__">floor</span>(Math.<span class="hljs-title function_ invoke__">random</span>() * (right - left + <span class="hljs-number">1</span>)) + left],<br>      i = left,<br>      j = right<br>  <span class="hljs-comment">// 开始调整</span><br>  <span class="hljs-keyword">while</span>(i &lt;= j) {<br>    <br>    <span class="hljs-comment">// 左指针右移</span><br>    <span class="hljs-keyword">while</span>(arr[i] &lt; datum) {<br>      i++<br>    }<br>    <br>    <span class="hljs-comment">// 右指针左移</span><br>    <span class="hljs-keyword">while</span>(arr[j] &gt; datum) {<br>      j--<br>    }<br>    <br>    <span class="hljs-comment">// 交换</span><br>    <span class="hljs-keyword">if</span>(i &lt;= j) {<br>      <span class="hljs-title function_ invoke__">swap</span>(arr, i, j)<br>      i += <span class="hljs-number">1</span><br>      j -= <span class="hljs-number">1</span><br>    }<br>  }<br>  <span class="hljs-keyword">return</span> i<br>}<br><br><span class="hljs-comment">// 交换</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">swap</span> = (arr, i , j) =&gt; {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = arr[i]<br>    arr[i] = arr[j]<br>    arr[j] = temp<br>}<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">arr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>]<br><span class="hljs-title function_ invoke__">quickSort</span>(arr)<br>console.<span class="hljs-title function_ invoke__">log</span>(arr) <span class="hljs-comment">// [1, 2, 3, 4, 5]</span><br><span class="hljs-comment">// 第 2 个最大值</span><br>console.<span class="hljs-title function_ invoke__">log</span>(arr[arr.length - <span class="hljs-number">2</span>])  <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h5 id="快速选择"><a href="# 快速选择" class="headerlink" title="快速选择"></a>快速选择 </h5><p> 仅仅需要在每执行一次快排的时候，比较基准值位置是否在 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.302ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2343.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 位置上</p><ul><li>如果小于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.302ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2343.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>，则第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个最大值在基准值的右边，我们只需递归快排基准值右边的子序列即可；</li><li>如果大于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.302ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2343.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>，则第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个最大值在基准值的做边，我们只需递归快排基准值左边的子序列即可；</li><li>如果等于 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="5.302ex" height="1.756ex" role="img" focusable="false" viewbox="0 -694 2343.4 776"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(822.2,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"/></g><g data-mml-node="mi" transform="translate(1822.4,0)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container>，则第<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.179ex" height="1.595ex" role="img" focusable="false" viewbox="0 -694 521 705"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"/></g></g></g></svg></mjx-container> 个最大值就是基准值</li></ul><h6 id="代码实现 -2"><a href="# 代码实现 -2" class="headerlink" title="代码实现"></a>代码实现</h6><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-variable">findKthLargest</span> = <span class="hljs-title function_ invoke__">function</span>(nums, k) {<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">quickSelect</span>(nums, nums.length - k)<br>};<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">quickSelect</span> = (arr, k) =&gt; {<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">quick</span>(arr, <span class="hljs-number">0</span> , arr.length - <span class="hljs-number">1</span>, k)<br>}<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">quick</span> = (arr, left, right, k) =&gt; {<br>  <span class="hljs-keyword">let</span> <span class="hljs-variable">index</span><br>  <span class="hljs-keyword">if</span>(left &lt; right) {<br>    <span class="hljs-comment">// 划分数组</span><br>    index = <span class="hljs-title function_ invoke__">partition</span>(arr, left, right)<br>    <span class="hljs-comment">// Top k</span><br>    <span class="hljs-keyword">if</span>(k === index) {<br>        <span class="hljs-keyword">return</span> arr[index]<br>    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(k &lt; index) {<br>        <span class="hljs-comment">// Top k 在左边</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">quick</span>(arr, left, index-<span class="hljs-number">1</span>, k)<br>    } <span class="hljs-keyword">else</span> {<br>        <span class="hljs-comment">// Top k 在右边</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_ invoke__">quick</span>(arr, index+<span class="hljs-number">1</span>, right, k)<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> arr[left]<br>}<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">partition</span> = (arr, left, right) =&gt; {<br>  <span class="hljs-comment">// 取中间项为基准</span><br>  var datum = arr[Math.<span class="hljs-title function_ invoke__">floor</span>(Math.<span class="hljs-title function_ invoke__">random</span>() * (right - left + <span class="hljs-number">1</span>)) + left],<br>      i = left,<br>      j = right<br>  <span class="hljs-comment">// 开始调整</span><br>  <span class="hljs-keyword">while</span>(i &lt; j) {<br>    <br>    <span class="hljs-comment">// 左指针右移</span><br>    <span class="hljs-keyword">while</span>(arr[i] &lt; datum) {<br>      i++<br>    }<br>    <br>    <span class="hljs-comment">// 右指针左移</span><br>    <span class="hljs-keyword">while</span>(arr[j] &gt; datum) {<br>      j--<br>    }<br>    <br>    <span class="hljs-comment">// 交换</span><br>    <span class="hljs-keyword">if</span>(i &lt; j) <span class="hljs-title function_ invoke__">swap</span>(arr, i, j)<br><br>    <span class="hljs-comment">// 当数组中存在重复数据时，即都为 datum，但位置不同</span><br>    <span class="hljs-comment">// 继续递增 i，防止死循环</span><br>    <span class="hljs-keyword">if</span>(arr[i] === arr[j] &amp;&amp; i !== j) {<br>        i++<br>    }<br>  }<br>  <span class="hljs-keyword">return</span> i<br>}<br><br><span class="hljs-comment">// 交换</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">swap</span> = (arr, i , j) =&gt; {<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">temp</span> = arr[i]<br>    arr[i] = arr[j]<br>    arr[j] = temp<br>}<br></code></pre></td></tr></table></figure><h3 id="Rebatch- 和 -Rebuild- 的作用"><a href="#Rebatch- 和 -Rebuild- 的作用" class="headerlink" title="Rebatch 和 Rebuild 的作用"></a>Rebatch 和 Rebuild 的作用 </h3><h4 id="术语 -1"><a href="# 术语 -1" class="headerlink" title="术语"></a> 术语</h4><ul><li><p><strong>Canvas</strong> 是 Unity 渲染系统给层状几何体 (layered geometry) 提供的可以被画入、被放在上面或者放在世界空间的底层 Unity 组件。Canvas 负责将它包含的几何体组合成 batch，生成合适的渲染命令发送给 Unity 图形系统。这个过程在底层的 C++ 代码中完成，这个过程被称为一次 rebatch 或者一次 batch build。当一个 Canvas 被标记为包含需要 rebatch 的几何体时，这个 Canvas 被认为是 dirty 的。<br>layered geometry , 由 Canvas Renderer 组件提供给 Canvas。Canvas 负责进行渲染，Canvas Renderer 负责采集 / 接收</p></li><li><p><strong>动静隔离</strong> 一个子 Canvas 仅仅是一个嵌套在父 Canvas 中的组件，子 Canvas 将它的子物体和它的父 Canvas 隔离，一个子 Canvas 下 dirty 的子物体不会触发父 Canvas 的 rebuild，反之亦然（这些在某些特殊情况下是不确定的，比如说改变父 Canvas 的大小导致子 Canvas 的大小改变）</p></li><li><p><strong>Graphic</strong> 是 UGUI 的 C# 库提供的一个基类。它是 UGUI 所有类的基类，给所有的 UGUI 类提供可以画在 Canvas 系统上的几何图形。大多数 Unity 内置的继承 Graphic 的类都是通过继承一个叫 MaskableGraphic 的子类来实现，这使得他们可以通过 IMaskable 接口来被隐藏。Drawable 类的子类主要是 image 和 text，已经提供了同名的组件</p></li><li><p><strong>Layout</strong> 组件控制着 RectTransform 的大小和位置，经常被用于要生成具有相似的大小和位置关系内容的复杂布局。它只依靠 RectTransform，只影响与其相关的 RectTransform 的属性。这些 layout 组件不依赖于 Graphic 类，可以独立于 UGUI 的 Graphic 组件之外使用</p></li><li><p><strong><code>CanvasUpdateRegistry</code></strong> Graphic 和 Layout 组件都依赖于 CanvasUpdateRegistry 类，它不会在 Unity 编辑器的界面中显示。这个类追踪那些 Graphic 和 Layout 组件必须被更新的时候，还有与其对应的 Canvas 触发了 willRenderCanvases 事件的时候。更新 Graphic 类和 Layout 类叫做<strong>Rebuild</strong></p></li></ul><blockquote><p>在使用 UGUI 制作 UI 时，请牢记 Canvas 中所有几何体的绘制都在一个透明队列中，这就意味着由 UGUI 制作的几何体将从始至终伴随着 alpha 混合，所以从多边形栅格化的每个像素都将被采样，即使它被完全不透明的物体所覆盖。在手机设备上，这种高等级的过度绘制将迅速超过 GPU 填充频率的承受能力</p></blockquote><h4 id="Batch- 构建过程（Canvas）"><a href="#Batch- 构建过程（Canvas）" class="headerlink" title="Batch 构建过程（Canvas）"></a>Batch 构建过程（Canvas）</h4><ul><li>Batch 构建过程是指 Canvas 通过结合网格绘制它所承载的 UI 元素，生成适当的渲染命令发送给 Unity 图形流水线。Batch 的结果被缓存复用，直到这个 Canvas 被标为 dirty，当 Canvas 中某一个构成的网格改变的时候就会标记为 dirty</li><li>Canvas 的网格从那些 Canvas 下的 CnavasRenderer 组件中获取，但不包含任何子 Canvas</li><li>计算 Batch 要求按照深度排序网格，测试它们是否有重叠，共享材质等等。这个过程是多线程的，在不同的 CPU 架构下性能表现非常不同，特别是在手机芯片（通常 CPU 核心很少）和现代桌面 CPU（通常拥有四核心或者更多）之间非常不同</li></ul><h4 id="Rebuild- 过程（Graphics）"><a href="#Rebuild- 过程（Graphics）" class="headerlink" title="Rebuild 过程（Graphics）"></a>Rebuild 过程（Graphics）</h4><p>Rebuild 过程是指 Layout 和 UGUI 的 C# 的 Graphic 组件的网格被重新计算，这是在 CanvasUpdateRegistry 类中执行的。这是一个 C＃类，它的源码可以在 Unity 的 Bitbucket 上找到。CanvasUpdateRegistry 类中，PerformUpdate 方法，当一个 Canvas 组件触发它的 WillRenderCanvases 事件时，这个方法就会被执行。这个事件每帧调用一次。PerformUpdate 函数运行的三个步骤：</p><ol><li>通过 ICanvasElement.Rebuild 函数，请求 rebuild 被 Dirty 的 Layout 组件</li><li>所有被注册的裁剪组件（例如 Mask），对需要被裁剪的组件进行剔除。这在 ClippingRegistry.Cull 中执行</li><li>dirty 的 Graphic 组件被要求 rebuild 其图形元素</li></ol><h5 id="Layout- 和 -Graphic- 的 -Rebuild"><a href="#Layout- 和 -Graphic- 的 -Rebuild" class="headerlink" title="Layout 和 Graphic 的 Rebuild"></a>Layout 和 Graphic 的 Rebuild</h5><ul><li>Layout Rebuild 要重新计算一个或者多个 Layout 组件所包含的 UI 组件的适当位置（以及可能的大小），有必要对 Layout 应用层次的排序。在 GameObject 的 hierarchy 中靠近 root 的 Layout 可能会影响改变嵌套在它里面的其他 Layout 的位置和大小，所以必须首先计算。 为此，UGUI 根据层次结构中的深度对 dirty 的 Layout 组件列表进行排序。层次结构中较高的 Layout（即拥有较少的父 transform）将被移到列表的前面。然后，排序好的 Layout 组件的列表将被 rebuild，在这个步骤 Layout 组件控制的 UI 元素的位置和大小将被实际改变</li><li>Graphic Rebuild 当 Graphic 组件被 rebuild 的时候，UGUI 将控制传递给 ICanvasElement 接口的 Rebuild 方法。Graphic 执行了这一步，并在 rebuild 过程中的 PreRender 阶段运行了两个不同的 rebuild 步骤：<ul><li>如果顶点数据已经被标为 Dirty（例如组件的 RectTransform 已经改变大小），则重建网格</li><li>如果材质数据已经被标为 Dirty（例如组件的 material 或者 texture 已经被改变），则关联的 Canvas Renderer 的材质将被更新。Graphic 的 Rebuild 不会按照 Graphic 组件的特殊顺序进行，也不会进行任何的排序操作</li></ul></li></ul><h3 id="前向渲染和延迟渲染"><a href="# 前向渲染和延迟渲染" class="headerlink" title="前向渲染和延迟渲染"></a>前向渲染和延迟渲染 </h3><h4 id="正向渲染"><a href="# 正向渲染" class="headerlink" title="正向渲染"></a> 正向渲染 </h4><p> 正向渲染 (Forward Rendering) 或者正向着色法 (Forward Shading)，它是我们渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。它非常容易理解，也很容易实现，但是同时它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个需要渲染的片段进行迭代，这是非常多的！因为大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度（多个物体重合在一个像素上）浪费大量的片段着色器运行时间。延迟着色法 (Deferred Shading)，或者说是延迟渲染 (Deferred Rendering)，为了解决上述问题而诞生了，它大幅度地改变了我们渲染物体的方式</p><p>延迟着色法基于我们延迟 (Defer) 或推迟 (Postpone) 大部分计算量非常大的渲染（像是光照）到后期进行处理的想法。它包含两个处理阶段 (Pass)：</p><ul><li>在第一个几何处理阶段 (Geometry Pass) 中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做 G 缓冲 (G-buffer) 的纹理中；位置向量 (Position Vector)、颜色向量 (Color Vector)、法向量 (Normal Vector) 和 / 或镜面值 (Specular Value)。场景中这些储存在 G 缓冲中的几何信息将会在之后用来做（更复杂的）光照计算。下面是一帧中 G 缓冲的内容</li></ul><center>    <img src="/2024/05/13/cf86467b04aa/deferred_g_buffer.png" alt></center><ul><li>第二个光照处理阶段 (Lighting Pass) 中使用 G 缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用 G 缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对 G 缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和我们以前一样，但是现在我们需要从对应的 G 缓冲而不是顶点着色器（和一些 uniform 变量）那里获取输入变量了</li></ul><center>    <img src="/2024/05/13/cf86467b04aa/deferred_overview.png" alt></center><p>这种渲染方法一个很大的好处就是能保证在 G 缓冲中的片段和在屏幕上呈现的像素所包含的片段信息是一样的，因为深度测试已经最终将这里的片段信息作为最顶层的片段。这样保证了对于在光照处理阶段中处理的每一个像素都只处理一次</p><p>当然这种方法也带来几个缺陷， 由于 G 缓冲要求我们在纹理颜色缓冲中存储相对比较大的场景数据，这会消耗比较多的显存，尤其是类似位置向量之类的需要高精度的场景数据。 另外一个缺点就是他不支持混色（因为我们只有最前面的片段信息）， 因此也不能使用 MSAA 了</p><h4 id="G- 缓冲"><a href="#G- 缓冲" class="headerlink" title="G 缓冲"></a>G 缓冲</h4><p>G 缓冲 (G-buffer) 是对所有用来储存光照相关的数据，并在最后的光照处理阶段中使用的所有纹理的总称。在正向渲染中照亮一个片段所需要的所有数据：</p><ul><li>一个 3D 位置向量来计算（插值）片段位置变量供 <code>lightDir</code> 和<code>viewDir</code>使用</li><li>一个 RGB 漫反射颜色向量，也就是反照率 (Albedo)</li><li>一个 3D 法向量来判断平面的斜率</li><li>一个镜面强度 (Specular Intensity) 浮点值</li><li>所有光源的位置和颜色向量</li><li>玩家或者观察者的位置向量</li></ul><p>光源的位置，颜色，和玩家的观察位置可以通过 uniform 变量来设置，但是其它变量对于每个对象的片段都是不同的。如果我们能以某种方式传输完全相同的数据到最终的延迟光照处理阶段中，我们就能计算与之前相同的光照效果了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span>(...) <span class="hljs-comment">// 游戏循环</span><br>{<br>    <span class="hljs-comment">// 1. 几何处理阶段：渲染所有的几何 / 颜色数据到 G 缓冲 </span><br>    <span class="hljs-built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, gBuffer);<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br>    gBufferShader.<span class="hljs-built_in">Use</span>();<br>    <span class="hljs-keyword">for</span>(Object obj : Objects)<br>    {<br>        <span class="hljs-built_in">ConfigureShaderTransformsAndUniforms</span>();<br>        obj.<span class="hljs-built_in">Draw</span>();<br>    }  <br>    <span class="hljs-comment">// 2. 光照处理阶段：使用 G 缓冲计算场景的光照</span><br>    <span class="hljs-built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">glClear</span>(GL_COLOR_BUFFER_BIT);<br>    lightingPassShader.<span class="hljs-built_in">Use</span>();<br>    <span class="hljs-built_in">BindAllGBufferTextures</span>();<br>    <span class="hljs-built_in">SetLightingUniforms</span>();<br>    <span class="hljs-built_in">RenderQuad</span>();<br>}<br></code></pre></td></tr></table></figure><h4 id="延迟光照处理阶段"><a href="# 延迟光照处理阶段" class="headerlink" title="延迟光照处理阶段"></a>延迟光照处理阶段 </h4><p> 现在我们已经有了一大堆的片段数据储存在 G 缓冲中供我们处置，我们可以选择通过一个像素一个像素地遍历各个 G 缓冲纹理，并将储存在它们里面的内容作为光照算法的输入，来完全计算场景最终的光照颜色。由于所有的 G 缓冲纹理都代表的是最终变换的片段值，我们只需要对每一个像素执行一次昂贵的光照运算就行了。这使得延迟光照非常高效，特别是在需要调用大量重型片段着色器的复杂场景中</p><h2 id="网易"><a href="# 网易" class="headerlink" title="网易"></a>网易 </h2><h3 id="C- 构造函数可以是虚函数吗"><a href="#C- 构造函数可以是虚函数吗" class="headerlink" title="C++ 构造函数可以是虚函数吗"></a>C++ 构造函数可以是虚函数吗</h3><h4 id="为什么构造函数不可以是虚函数"><a href="# 为什么构造函数不可以是虚函数" class="headerlink" title="为什么构造函数不可以是虚函数"></a> 为什么构造函数不可以是虚函数 </h4><h5 id="从内存的角度看"><a href="# 从内存的角度看" class="headerlink" title="从内存的角度看"></a> 从内存的角度看 </h5><p> 虚函数对应一个虚函数表，虚函数表是存储在对象的内存空间中的。而调用虚函数使用过调用虚函数表来实现的。如果构造函数是虚函数，那么就需要通过虚函数表来调用，但是对象是通过构造函数实例化的，<strong>在调用构造函数之前，虚函数表内存空间还没有被创建，无法找到虚表</strong>。所以构造函数不能是虚函数</p><h5 id="从使用的角度看"><a href="# 从使用的角度看" class="headerlink" title="从使用的角度看"></a>从使用的角度看 </h5><p> 虚函数是通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。但是构造函数是通过创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以规定构造函数不能是虚函数</p><h4 id="为什么析构函数可以是虚函数"><a href="# 为什么析构函数可以是虚函数" class="headerlink" title="为什么析构函数可以是虚函数"></a>为什么析构函数可以是虚函数 </h4><p> 一个派生类的指针可以安全地转化为一个基类的指针。这样删除一个基类的指针的时候，C++ 不管这个指针指向一个基类对象还是一个派生类的对象，调用的都是基类的析构函数而不是派生类的。如果你依赖于基类的析构函数的代码来释放资源，而没有重载析构函数，那么会有资源泄漏。<br>C++ 不把虚析构函数直接作为默认值的原因是虚函数表的开销以及和 C 语言的类型的兼容性。有虚函数的对象总是在开始的位置包含一个隐含的虚函数表指针成员</p><h3 id="渲染流程，CPU- 阶段的剔除操作有哪些"><a href="# 渲染流程，CPU- 阶段的剔除操作有哪些" class="headerlink" title="渲染流程，CPU 阶段的剔除操作有哪些"></a>渲染流程，CPU 阶段的剔除操作有哪些 </h3><p> 剔除有视锥体剔除（Frustum Culling）、层级剔除（Layer Culling Mask）、遮挡剔除（Occlusion Culling）等步骤，目的是将不想被摄像机看到的物体剔除掉，减少不必要的性能开销，提高渲染效率</p><h4 id="视锥体剔除"><a href="# 视锥体剔除" class="headerlink" title="视锥体剔除"></a>视锥体剔除 </h4><p> 在 Unity 中，摄像机的可视区域是一个横放的金字塔形称为视锥体，由近裁面、远裁面、视场角三个参数控制，通过计算这个视锥体与场景中的模型是否相交，没有相交就说明位于可视区域外，这样的模型就应该进行剔除</p><center>    <img src="/2024/05/13/cf86467b04aa/frustum-culling.jpg" alt></center><p>由于模型一般面数较多，因此会采用给模型创建包围体再计算包围体与可视区域是否相交的方式简化计算。包围体有多种计算方法，常用的有 OBB（Oriented Bounding Box，有向包围盒）、AABB（Axis-Aligned Bounding Box，轴对齐包围盒）、球形包围体（外接球）等，其中 AABB 因为计算方便而更为常用</p><center>    <img src="/2024/05/13/cf86467b04aa/obb.png" alt></center><h4 id="层级剔除"><a href="# 层级剔除" class="headerlink" title="层级剔除"></a>层级剔除</h4><p>Unity 中的模型可以设置自身所处的层级（Layer），而摄像机则可以设置需要剔除掉的层级，从而跳过特定物体的渲染</p><center>    <img src="/2024/05/13/cf86467b04aa/layer-maks-culling.jpg" alt></center><h4 id="遮挡剔除"><a href="# 遮挡剔除" class="headerlink" title="遮挡剔除"></a>遮挡剔除 </h4><p> 在渲染时，如果物体有前后顺序并且后方的物体完全被前方物体遮挡住，此时后方物体在摄像机中完全看不见，也就没有必要进行计算，可以进行剔除</p><center>    <img src="/2024/05/13/cf86467b04aa/occlusion-culling.png" alt></center><h3 id="LRU- 算法"><a href="#LRU- 算法" class="headerlink" title="LRU 算法"></a>LRU 算法</h3><p>LRU（Least recently used，最近最少使用）是缓存置换策略中的一种常用的算法。其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。当缓存队列已满时，新的元素加入队列时，需要从现有队列中移除一个元素，LRU 策略就是将最近最少被访问的元素移除，从而腾出空间给新的元素。</p><p>当对 key 进行访问时（一般有查询，更新，增加，在 <code>get()</code> 和<code>set()</code>两个方法中实现即可）时，将该 key 放到队列的最前端（或最后端）就行了，这样就实现了对 key 按其最后一次访问的时间降序（或升序）排列，当向空间中增加新对象时，如果空间满了，删除队尾（或队首）的对象。</p><h4 id="普通实现"><a href="# 普通实现" class="headerlink" title="普通实现"></a>普通实现 </h4><p> 借助于普通 dict 和 list 来实现，dict 保存键值对，list 保证插入的有序（借助列表来记录插入的顺序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 基于普通 dict 和 list 实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, size=<span class="hljs-number">5</span></span>):<br>        self.size = size<br>        self.cache = <span class="hljs-built_in">dict</span>()<br>        self.key_list = []<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:<br>            self.key_list.remove(key)<br>            self.key_list.insert(<span class="hljs-number">0</span>, key)<br>            <span class="hljs-keyword">return</span> self.cache[key]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:  <span class="hljs-comment"># 更新</span><br>            self.key_list.remove(key)  <br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(self.cache) == self.size:  <span class="hljs-comment"># 删除插入</span><br>            old_key = self.key_list.pop()<br>            self.cache.pop(old_key)<br>        self.cache[key] = value       <span class="hljs-comment"># 一般插入</span><br>        self.key_list.insert(<span class="hljs-number">0</span>, key)<br></code></pre></td></tr></table></figure><p>使用 hash 表来定位结点位置，<code>get()</code>和 <code>set()</code> 的时间复杂度均为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>，空间复杂度为<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container></p><h4 id="借助 OrderedDict"><a href="# 借助 OrderedDict" class="headerlink" title="借助 OrderedDict"></a>借助<code>OrderedDict</code></h4><p>python 中有一个标准库的类的<code>OrderedDict</code>（有序字典），该类有以下两个方法用来实现 LRU 算法就十分简单：</p><ul><li><code>popitem(last=True)</code>：有序字典的 <code>popitem()</code> 方法移除并返回一个 (key, value) 键值对。 如果 last 值为真，则按 LIFO 后进先出的顺序返回键值对，否则就按 FIFO 先进先出的顺序返回键值对</li><li><code>move_to_end(key, last=True)</code>：将现有 key 移动到有序字典的任一端。 如果 last 为真值（默认）则将元素移至末尾；如果 last 为假值则将元素移至开头。如果 key 不存在则会触发 KeyError`</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> OrderedDict, defaultdict<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LRU</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, capacity=<span class="hljs-number">128</span></span>):<br>        self.capacity = capacity    <span class="hljs-comment"># 缓存容量</span><br>        self.cache = OrderedDict()  <span class="hljs-comment"># 有序字典缓存</span><br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">self, key, value</span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:<br>            <span class="hljs-comment"># 若数据已存在，表示命中一次，需要把数据移到缓存队列末端</span><br>            self.cache.move_to_end(key)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.cache) &gt;= self.capacity:<br>            <span class="hljs-comment"># 若缓存已满，则需要淘汰最早没有使用的数据</span><br>            self.cache.popitem(last=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 录入缓存</span><br>        self.cache[key]=value<br> <br>    <span class="hljs-comment"># 遍历 key</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">travel</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> self.cache.keys():<br>            <span class="hljs-built_in">print</span>(key)<br> <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">self, key</span>):<br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> self.cache:<br>            val = self.cache.pop(key)<br>            self.cache[key] = val<br>        <span class="hljs-keyword">else</span>:<br>            val = <span class="hljs-literal">None</span><br> <br>        <span class="hljs-keyword">return</span> val<br></code></pre></td></tr></table></figure><h3 id="缓存算法"><a href="# 缓存算法" class="headerlink" title="缓存算法"></a>缓存算法 </h3><h4 id="FIFO- 算法"><a href="#FIFO- 算法" class="headerlink" title="FIFO 算法"></a>FIFO 算法</h4><p> 如果一个数据最先进入缓存，则应该最早淘汰掉</p><ul><li><code>get(key)</code>：如果 Cache 中存在该 key，则返回对应的 value 值，否则，返回 -1</li><li><code>set(key,value)</code>：如果 Cache 中存在该 key，则重置 value 值；如果不存在该 key，则将该 key 插入 Cache，若 Cache 已满，则淘汰最早进入 Cache 的数据</li></ul><h4 id="LRU：Least-Recently-used"><a href="#LRU：Least-Recently-used" class="headerlink" title="LRU：Least Recently used"></a>LRU：Least Recently used</h4><p>如果数据最近被访问过，那么将来被访问的几率也更高</p><h4 id="LFU：Least-Frequency-Used"><a href="#LFU：Least-Frequency-Used" class="headerlink" title="LFU：Least Frequency Used"></a>LFU：Least Frequency Used</h4><p>如果数据过去被访问多次，那么将来被访问的频率也更高。注意 LFU 和 LRU 的区别，LRU 的淘汰规则是基于访问时间，而 LFU 是基于访问次数</p><p>为了能够淘汰最少使用的数据，LFU 算法最简单的一种设计思路就是：利用一个数组存储数据项，用 hashmap 存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来，在插入数据和访问数据的时候都能达到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"/></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container>。<br> 另外还有一种实现思路就是利用小顶堆 +hashmap，小顶堆插入、删除操作都能达到 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.695ex" height="2.262ex" role="img" focusable="false" viewbox="0 -750 3401 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"/></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"/></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"/></g><g data-mml-node="mi" transform="translate(1935,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"/></g><g data-mml-node="mi" transform="translate(2412,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/></g><g data-mml-node="mo" transform="translate(3012,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/></g></g></g></svg></mjx-container> 时间复杂度，因此效率相比第一种实现方法更加高效</p><h2 id="骏梦"><a href="# 骏梦" class="headerlink" title="骏梦"></a>骏梦 </h2><h3 id="Unity- 资源管理"><a href="#Unity- 资源管理" class="headerlink" title="Unity 资源管理"></a>Unity 资源管理</h3><p> 在 Unity 中，一般来说，资源加载方式主要分为 <code>Resources</code> 加载和 <code>AssetBundle</code> 加载。Unity 有个特殊文件夹 Resources，放在这个文件夹下的资源可以通过 <code>Resources.Load()</code> 来直接加载。即 <code>Resources</code> 加载资源方式。当获得 <code>AssetBundle</code> 之后，也可以调用 <code>AssetBundle 对应</code> 的 API 来加载资源</p><p>AB 包全名 AssetBundle（资源包）。是一种 Unity 提供的用于存放资源的包。通过将资源分布在不同的 AB 包中可以最大程度地减少运行时的内存压力，并且可以有选择地加载内容</p><h4 id="为什么要用 -AB- 包"><a href="# 为什么要用 -AB- 包" class="headerlink" title="为什么要用 AB 包"></a>为什么要用 AB 包</h4><ol><li>热更新（要热更新需要确保 AB 包打出来的资源具有唯一性，且相同资源的 AB 包检验码相同）</li><li>Resources 加载虽然简单方便，但是也有很多问题<ol><li>对内存管理造成一定的负担</li><li>在打开应用时加载时间很长</li><li>Resources 文件夹下的所有资源统一合并到一个序列化文件中（可以看成统一打一个大包，巨型 AB 包有什么问题它就有什么问题），对资源优化有一定的限制</li><li>不建议大量使用 Resources</li></ol></li></ol><h4 id="获取 -AB- 包方法"><a href="# 获取 -AB- 包方法" class="headerlink" title="获取 AB 包方法"></a>获取 AB 包方法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">AssetBundle.LoadFromFile(<span class="hljs-built_in">string</span> path)<br>AssetBundle.LoadFromFileAsync(<span class="hljs-built_in">string</span> path)<br>AssetBundle.LoadFromMemory(<span class="hljs-built_in">byte</span>[] binary)<br>AssetBundle.LoadFromMemoryAsync(<span class="hljs-built_in">byte</span>[] binary)<br>AssetBundle.LoadFromStream(Stream stream)<br>AssetBundle.LoadFromStreamAsync(Stream stream)<br>WWW.AssetBundle<br></code></pre></td></tr></table></figure><ul><li><code>LoadFromFile</code>是从文件中加载 AB 包，它从一个给定的路径来加载 AB 包。如果 AB 包是 LZ4 加载方式，它只会加载 AB 包的 Header，之后需要什么资源再加载那部分的 AB 包 chunk。极大的减少了内存占用。<ul><li><code>LoadFromFileAsync</code>是它的异步版本</li></ul></li><li><code>LoadFromMemory</code>是从内存中加载 AB 包，它从内存中的 <code>byte[]</code> 中加载 AB 包。它会完整的把 AB 包加载出来<ul><li><code>LoadFromMemoryAsync</code>是它的异步版本</li></ul></li><li><code>LoadFromStream</code>是从流中加载 AB 包，它从一个 Stream 中加载 AB 包。跟 <code>LoadFromFile</code> 一样，如果 AB 包是 LZ4 加载方式，它也是只会加载 AB 包的 Header。<ul><li><code>LoadFromStreamAsync</code>是它的异步版本</li></ul></li><li>WWW 是 Unity 中的跟网络相关的类，可以通过该类从网络中下载资源，之后加载成 AB 包</li></ul><h4 id="加载资源方法"><a href="# 加载资源方法" class="headerlink" title="加载资源方法"></a>加载资源方法</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#">AssetBundle.LoadAsset(<span class="hljs-built_in">string</span> assetName, Type resType)<br>AssetBundle.LoadAssetAsync(<span class="hljs-built_in">string</span> assetName, Type resType)<br></code></pre></td></tr></table></figure><h4 id="LZMA- 和 -LZ4"><a href="#LZMA- 和 -LZ4" class="headerlink" title="LZMA 和 LZ4"></a>LZMA 和 LZ4</h4><p>LZMA 是流压缩方式（stream-based）。流压缩再处理整个数据块时使用同一个字典，它提供了最大可能的压缩率，但是只支持顺序读取。所以加载 AB 包时，需要将整个包解压，会造成卡顿和额外内存占用。</p><p>LZ4 是块压缩方式（chunk-based）。块压缩的数据被分为大小相同的块，并被分别压缩。如果需要实时解压随机读取，块压缩是比较好的选择。<code>LoadFromFile()</code>和 <code>LoadFromStream()</code> 都只会加载 AB 包的 Header，相对 <code>LoadFromMemory()</code> 来说大大节省了内存</p><h4 id="内存占用"><a href="# 内存占用" class="headerlink" title="内存占用"></a>内存占用 </h4><p>AB 包内的资源需要通过<code>AssetBundle.Load()</code> 来加载到内存中</p><ul><li>对于 GameObject 来说，通常情况下需要对其进行改动，所以它是完全复制一份该资源来进行的实例化。也就是说，当 AB 包中的 GameObject 从内存中卸载后，实例化的 GameObject 不会因此丢失。并且对实例化对象的修改不会影响到 GameObject 资源</li><li>对于 Shader 和 Texture 来说，通常情况下不需要对其进行改动，所以它是通过引用来进行的实例化。也就是说，当 AB 包中的 Shader 和 Texture 资源从内存中卸载后，实例化的 Shader 和 Texture 会出现资源丢失的情况。并且对实例化对象的修改会影响到 Shader 和 Texture 资源</li><li>对于 Material 和 Mesh 来说，有时候可能需要对其进行改动，所以它是通过引用 + 复制来进行的实例化。也就是说，当 AB 包中的 Material 和 Mesh 资源从内存中卸载后，实例化的 Material 和 Mesh 会出现资源丢失的情况。并且对实例化对象的修改不会影响到 Material 和 Mesh 资源</li></ul><blockquote><p>AB 包先要从硬盘或者网络中加载到内存中，然后将 AB 包内的每一份资源加载到内存中，再之后在内存中实例化这些资源。每种资源有其自己不同的实例化方式，卸载资源的时候需要注意</p></blockquote><h4 id="AB- 包内部结构"><a href="#AB- 包内部结构" class="headerlink" title="AB 包内部结构"></a>AB 包内部结构</h4><ul><li><code>AssetBundleFileHeader</code>：记录了版本号、压缩等主要描述信息</li><li><code>AssetFileHeader</code>：包含一个文件列表，记录了每个资源的 name、offset、length 等信息</li><li>Asset1：<ul><li><code>AssetHeader</code>：记录了 <code>TypeTree</code> 大小、文件大小、format 等信息</li><li><code>TypeTree</code>（可选）：记录了 <code>Asset</code> 对象的 class ID。Unity 可以用 class ID 来序列化和反序列化一个类（每个 class 对应了一个 ID，如 0 是 <code>Object</code> 类，1 是 <code>GameObject</code> 类等，具体可在 Unity 官网上查询）</li><li><code>ObjectPath</code>：记录了 path ID（资源唯一索引 ID）等</li><li><code>AssetRef</code>：记录了 AB 包对外部资源对引用情况</li></ul></li><li>Asset2</li><li>…</li></ul><h4 id="依赖问题"><a href="# 依赖问题" class="headerlink" title="依赖问题"></a>依赖问题 </h4><p> 依赖问题，通俗的话来说就是 A 包中某资源用了 B 包中的某资源。然而如果 A 包加载了，B 包没有加载，这就会导致 A 包中的资源出现丢资源的现象。在 Unity5.0 后，<code>BuildAssetBundleOptions.CollectDependencies</code>永久开启，即 Unity 会自动检测物体引用的资源并且一并打包，防止资源丢失遗漏的问题出现。因为这个特性，有些情况下，如果没指定某公共资源的存放在哪个 AB 包中，这个公共资源就会被自动打进引用它的 AB 包中，所以出现多个不同的 AB 包中有重复的资源存在的现象。这就是资源冗余。</p><p>要防止资源冗余，就需要明确指出资源存放在哪个 AB 包中，形成依赖关系。所以对于一些公共资源，建议单独存放在一个 AB 包中。在加载的时候，如果 AB 包之间相互依赖，那么加载一个 AB 包中的资源时，先需要加载出另一个 AB 包的资源。这样就会导致不必要的消耗。所以说尽可能地减少 AB 包之间的依赖，并且公共资源尽量提前加载完成</p><h4 id="细粒度问题"><a href="# 细粒度问题" class="headerlink" title="细粒度问题"></a>细粒度问题 </h4><p> 细粒度问题即每个 AB 包分别放入多少资源的问题，一个好的策略至关重要。加载资源时，先要加载 AB 包，再加载资源。如果 AB 包使用了 LZMA 或 LZ4 压缩算法，还需要先给 AB 包解压。</p><ul><li>AB 包数量较多，包内资源较少；AB 包数量较少，包内资源较多</li><li>加载一个 AB 包到内存的时间短，玩家不会有卡顿感，但每个资源实际上加载时间变长；加载一个 AB 包到内存的时间较长，玩家会有卡顿感，但之后包内的每个资源加载很快</li><li>热更新灵活，要更新下载的包体较小；热更新不灵活，要更新下载的包体较大</li><li>IO 次数过多，增大了硬件设备耗能和发热压力；IO 次数不多，硬件压力小</li></ul><p>简单策略：</p><ul><li>经常更新和不经常更新的对象拆分到不同的 AB 包中</li><li>同时加载的对象放在一个 AB 包中</li><li>不可能同时加载的对象拆分到不同的 AB 包中</li><li>根据项目逻辑功能来分组打 AB 包</li><li>根据同一类型对象来分组打 AB 包</li><li>公共资源和非公共资源拆分到不同的 AB 包中</li></ul><h4 id="卸载问题"><a href="# 卸载问题" class="headerlink" title="卸载问题"></a>卸载问题</h4><ul><li>当调用 <code>Resources.UnloadAsset()</code> 时，虽 <code>Object</code> 被销毁，但 Instance ID 被保留且包含有效的 GUID 和 Local ID 引用</li><li>当调用 <code>AssetBundle.Unload(true)</code> 时，不仅 <code>Object</code> 被销毁，而且 Instance ID 的 GUID 和 Local ID 引用变无效</li><li>当调用 <code>AssetBundle.Unload(false)</code> 时，虽 <code>Object</code> 不被销毁，但 Instance ID 的 GUID 和 Local ID 引用变无效。场景中的物体会与该 AB 包分离链接。即该物体的 Instance ID 引用的 GUID 和 Local ID 会断开引用，无法再通过该 Instance ID 找到 GUID 和 Local ID</li><li>如果再次加载该 AB 包时，分离了链接的物体不会受该新加载的 AB 包管理。因此如果不注意的话可能会导致一些不可控的问题。Unity 中有 <code>Resources.UnloadUnusedAssets()</code> 方法可以很好地解决这个问题</li></ul><h4 id="各种 -ID"><a href="# 各种 -ID" class="headerlink" title="各种 ID"></a>各种 ID</h4><ul><li>序列化后，资源用 GUID 和 Local ID 管理</li><li>GUID 对应 Asset，GUID 存在。meta 文件中，提供了文件特定位置的抽象，是一种映射，无需关心资源在磁盘上的存放位置</li><li>Local ID 对应 Asset 内的每一个 Object</li><li>虽然 GUID 和 Local ID 比较好用，但是毕竟因为存在磁盘上，读取比较耗时。因此 Unity 缓存一个 Instance ID 对应 Object，通过 Instance ID 快速找到 Object。Instance ID 是一种快速获取对象实例的 ID，包含着对 GUID 和 Local ID 的引用。解析 Instance ID 可以快速返回 Instance 表示的已加载对象，如果为加载目标对象，则可以将文件 GUID 和 Local ID 解析为对象源数据，从而允许 Unity 即时加载对象。每次 AB 包重新加载时，都会为每个对象创建新的 Instance ID</li></ul><h3 id="Lua- 弱表"><a href="#Lua- 弱表" class="headerlink" title="Lua 弱表"></a>Lua 弱表 </h3><p> 弱表是用来告诉 Lua 虚拟机，被弱表引用的对象，不应该阻止他们被 gc 回收。与弱表相对的是强表。对于强表来说，所有被强表引用到的 gc 对象，都会被标记，从而不会被 gc 机制回收，哪怕这些变量再也没被使用到。因此，对于强表来说，如果你希望被它引用的对象能够被 gc 回收，那么你需要将它的值设置为 nil。对于弱表来说，但凡被设置为弱引用的对象，均不会被 gc 标记，当再也没有其他地方引用该对象时，它们会从弱表中被清除</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = {}<br><br><span class="hljs-comment">-- 使用一个 table 作为 t 的 key 值</span><br>key1 = {name = <span class="hljs-string">"key1"</span>}<br>t[key1] = <span class="hljs-number">1</span><br>key1 = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">-- 又使用一个 table 作为 t 的 key 值</span><br>key2 = {name = <span class="hljs-string">"key2"</span>}<br>t[key2] = <span class="hljs-number">1</span><br>key2 = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(key.name .. <span class="hljs-string">":"</span> .. value)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 强制进行一次垃圾收集</span><br><span class="hljs-comment">-- 此时 key1 和 key2 表都被置 nil，但是并没有被强制回收，换句话说，虽然 key1 本身为 nil，但是他先前指向的内容并没有被删除，因为这个内容被保存在了 t 中</span><br><span class="hljs-built_in">collectgarbage</span>()<br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(key.name .. <span class="hljs-string">":"</span> .. value)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs lua">t = {}<br><span class="hljs-comment">-- 给 t 设置一个元表，增加__mode 元方法，赋值为 "k"</span><br><span class="hljs-built_in">setmetatable</span>(t, {<span class="hljs-built_in">__mode</span> = <span class="hljs-string">"k"</span>});<br><br><span class="hljs-comment">-- 使用一个 table 作为 t 的 key 值</span><br>key1 = {name = <span class="hljs-string">"key1"</span>}<br>t[key1] = <span class="hljs-number">1</span><br>key1 = <span class="hljs-literal">nil</span><br><br><span class="hljs-comment">-- 又使用一个 table 作为 t 的 key 值</span><br>key2 = {name = <span class="hljs-string">"key2"</span>}<br>t[key2] = <span class="hljs-number">1</span><br>key2 = <span class="hljs-literal">nil</span><br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(key.name .. <span class="hljs-string">":"</span> .. value)<br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 强制进行一次垃圾收集</span><br><span class="hljs-built_in">collectgarbage</span>()<br><br><span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(t) <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">print</span>(key.name .. <span class="hljs-string">":"</span> .. value)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>以上代码在创建了表 <code>t</code> 后，立即将 t 设置为元表，元表里面有一个 <code>__mode</code> 字段，值为 <code>k</code>，在执行<code>collectgarbage()</code> 之前，能够输出 <code>t</code> 中的元素，但是执行垃圾回收之后，就不能再次输出 <code>t</code> 中的元素的，这是因为将表设置为元表后，通过 <code>__mode = "k"</code> 将其指定为对键的弱引用，也就是说，一旦表中的某个键被垃圾回收，<code>t</code>中会删除这个键对应的元素</p><h4 id="弱表的用途"><a href="# 弱表的用途" class="headerlink" title="弱表的用途"></a>弱表的用途</h4><ul><li>缓存机制添加自动回收功能 <br> 当外部通过 <code>getFromCache</code> 获取到 <code>tbl[key]</code> 的值之后，如果一直持有，那么这个值就会一直在 <code>tbl</code> 缓存中，如果外部不再引用 <code>tbl[key]</code> 值时，那么它会在下一轮 gc 的时候从 <code>tbl</code> 被清理。这样，我们就不用去实现相对复杂的 LRU 机制，来对 <code>tbl</code> 的内存进行限制和处理了</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> mt = {<span class="hljs-built_in">__mode</span>=<span class="hljs-string">"v"</span>}<br><span class="hljs-keyword">local</span> tbl = setmetable({}, mt)<br><br><span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getFromCache</span><span class="hljs-params">(key)</span></span><br>    <span class="hljs-keyword">if</span> tbl[key] <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">return</span> tbl[key]<br>    <span class="hljs-keyword">end</span><br><br>    tbl[key] = loadFromDB(key)<br>    <span class="hljs-keyword">return</span> tbl[key]<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><ul><li>弱表实现默认值</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> defaults = {}<br><span class="hljs-built_in">setmetatable</span>(defaults, {<span class="hljs-built_in">__mode</span> = <span class="hljs-string">"k"</span>})<br><span class="hljs-keyword">local</span> mt = {<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(t)</span></span> <span class="hljs-keyword">return</span> defaults[t]  <span class="hljs-keyword">end</span>}<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefault</span><span class="hljs-params">(t, d)</span></span><br>    defaults[t] = d<br>    <span class="hljs-built_in">setmetatable</span>(t, mt)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> metas = {}<br><span class="hljs-built_in">setmetatable</span>(metas, {<span class="hljs-built_in">__mode</span> = <span class="hljs-string">"v"</span>})<br> <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDefault</span><span class="hljs-params">(t, d)</span></span><br>    <span class="hljs-keyword">local</span> mt = metas[d]<br>    <span class="hljs-keyword">if</span> mt == <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>        mt = {<span class="hljs-built_in">__index</span> = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> d  <span class="hljs-keyword">end</span>}<br>        metas[d] = mt<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-built_in">setmetatable</span>(t, mt)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="C- 委托和 event 区别"><a href="#C- 委托和 event 区别" class="headerlink" title="C#委托和 event 区别"></a>C# 委托和 <code>event</code> 区别 </h3><p> 委托 <code>delegate</code> 其实就是函数的模版，这个模版可以用来放入各种格式和他相同的函数，也就是这些真实函数的引用 <br> 当声明委托时，在编译阶段会自动生成一个类，并且继承自 <code>MulticastDelegate</code>，<code>MulticastDelegate</code> 继承自 <code>Delegate</code>。当对委托<code>+=</code> 操作时候其实是调用了 <code>Delegate.Combine()</code> 函数，当对委托 <code>-=</code> 操作时候其实是调用了 <code>Delegate.Remove()</code> 函数，一旦执行<code>Invoke</code>，便调用所有的回调函数</p><p>事件就是委托的一种特殊封装，事件本身其实就是一种特殊的委托。如果加了 <code>event</code> 的情况下，在其他类中使用带 <code>event</code> 字段的委托是不能直接使用 <code>=</code> 赋值符号的，只能使用 <code>+=</code>，注意这里说的是其他类中，如果直接在声明<code>event</code> 的类中还是可以直接使用 <code>=</code> 赋值的，当在委托声明的时候加了 <code>event</code> 字段之后，直接赋值的操作会变成 <code>private</code> 权限，那么自然在其他类中就无法直接赋值了，<code>+=</code>和 <code>-=</code> 重写变成了 <code>add</code> 和<code>remove</code>的方法，是 <code>public</code> 的，所以可以在外部调用</p><h3 id="Lambda- 表达式的捕获变量"><a href="#Lambda- 表达式的捕获变量" class="headerlink" title="Lambda 表达式的捕获变量"></a>Lambda 表达式的捕获变量 </h3><p>Lambda 表达式可以捕获其所在作用域中的变量。这些变量将作为 Lambda 表达式的外部变量，在 Lambda 表达式内部被引用。但是，Lambda 表达式只能捕获引用类型的变量，而不能捕获值类型的变量（除非阀门是局部变量并且被标记为<code>readonly</code> 或在 Lamda 表达式之前赋值）</p><h3 id="Lua- 空表大小"><a href="#Lua- 空表大小" class="headerlink" title="Lua 空表大小"></a>Lua 空表大小</h3><blockquote><p><code>debug.tablemem(t)</code>函数用于获取 <code>table</code> 自身占用内存空间的大小，该函数返回四个字段：<code>table</code>占用内存大小、数组部分长度、以 2 为底哈希表部分长度的对数、哈希表部分是否为假节点。<a href="https://github.com/zhyingkun/lua-5.3.5/blob/master/liblua/libraries/ldblib.c"><code>debug.tablemem</code></a></p></blockquote><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> tbl = {}<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">debug</span>.tablemem(tbl)) <span class="hljs-comment">--&gt; 56   0   0   true</span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// luaobject.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">lua_Value</span> {</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GCObject</span>* <span class="hljs-title">gc</span>;</span><br>    <span class="hljs-type">void</span>* p;<br>    <span class="hljs-type">int</span> b;<br>    lua_Interger i;<br>    lua_Number n;<br>    lua_CFunction f;<br>} Value;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lua_TValue</span> {</span><br>    Value value_;<br>    <span class="hljs-type">int</span> tt_;<br>} TValue;<br><br><span class="hljs-comment">// lua Table</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">TKey</span> {</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> {</span><br>        Value value_;<br>        <span class="hljs-type">int</span> tt; <span class="hljs-comment">// 用来标记 value_是什么类型</span><br>        <span class="hljs-type">int</span> next;<br>    } nk;<br>    TValue tvk;<br>} TKey;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br>    TKey key;<br>    TValue value;<br>} Node;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Table</span> {</span><br>    CommonHeader;               <span class="hljs-comment">// GC 部分</span><br>    TValue* <span class="hljs-built_in">array</span>;              <span class="hljs-comment">// 数组部分</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraysize;     <span class="hljs-comment">// 数组大小</span><br>    Node* node;                 <span class="hljs-comment">// hash 部分</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lsizenode;     <span class="hljs-comment">// hash 大小，实际大小为 2&lt;sup&gt;lsizenode</span><br>    Node* lastfree;             <span class="hljs-comment">// 空闲指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GCObject</span>* <span class="hljs-title">gclist</span>;</span>    <span class="hljs-comment">// GC 部分</span><br>}<br></code></pre></td></tr></table></figure><h3 id="C- 字典原理"><a href="#C- 字典原理" class="headerlink" title="C# 字典原理"></a>C# 字典原理</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] buckets;  <span class="hljs-comment">// Hash 桶</span><br><span class="hljs-keyword">private</span> Entry[] entries; <span class="hljs-comment">// Entry 数组，存放元素</span><br></code></pre></td></tr></table></figure><p>字典内部有两个主要的数组</p><ul><li><code>Entry</code>结构体数组：其中存储 hash 值、键值对、发生冲突指向的上一个 <code>Entry</code> 位置</li><li><code>buckets</code>数组：存放对应 <code>Entry</code> 下标</li></ul><h3 id="C- 变量赋值"><a href="#C- 变量赋值" class="headerlink" title="C# 变量赋值"></a>C# 变量赋值</h3><ul><li>值类型变量的赋值： 值类型变量中保存的是实际数据，在赋值的时候只是把数据复制一份，然后赋给另一个变量</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span> var1 = <span class="hljs-number">2</span>;<br><span class="hljs-built_in">int</span> var2 = var1; <span class="hljs-comment">// 编译器会先复制 var1 的值，然后把它赋给 var2. 很明显 var2 的值也为 2</span><br></code></pre></td></tr></table></figure><ul><li>引用类型变量的赋值： 引用类型变量中保存的是“指向实际数据的引用指针”。在进行赋值操作的时候，它和值类型一样，也是先有一个复制的操作，不过它复制的不是实际的数据，而是引用（真实数据的内存地址）所以引用类型的变量在赋值的时候，赋给另一变量的实际上是内存地址</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>}<br><span class="hljs-keyword">struct</span> MyStruct <br>{<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> val;<br>}<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span> {<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    {<br>        MyClass objectA = <span class="hljs-keyword">new</span> MyClass();<br>        MyClass objectB = objectA; <span class="hljs-comment">// 引用变量的赋值 赋值操作完成后，两个变量都指向同一内存地址 </span><br>        objectA.val = <span class="hljs-number">10</span>; <span class="hljs-comment">// 给 objectA.val 赋值 =10 由于 objectB 和 objectA 指向同一内存地址，所以 ojbectB.val 的值也为 10</span><br>        objectB.val = <span class="hljs-number">20</span>; <span class="hljs-comment">// 给 objectB.val 赋值 =20 由于 objectB 和 objectA 指向同一内存地址，所以 objectA.val 的值也为 20</span><br>        MyStruct structA = <span class="hljs-keyword">new</span> MyStruct();<br>        MyStruct structB = structA; <span class="hljs-comment">// 结构是值类型 赋值操作完成后，两个结构中的结构信息一致。注意是“结构中的信息”一致。</span><br>        structA.val = <span class="hljs-number">30</span>;<br>        structB.val = <span class="hljs-number">40</span>;<br>        Console.WriteLine(<span class="hljs-string">"objectA.val={0}"</span>, objectA.val); <span class="hljs-comment">// 输出结果是 20</span><br>        Console.WriteLine(<span class="hljs-string">"objectB.val={0}"</span>, objectB.val); <span class="hljs-comment">// 输出结果是 20</span><br>        Console.WriteLine(<span class="hljs-string">"structA.val={0}"</span>, structA.val); <span class="hljs-comment">// 输出结果是 30</span><br>        Console.WriteLine(<span class="hljs-string">"structB.val={0}"</span>, structB.val); <span class="hljs-comment">// 输出结果是 40</span><br>    }<br>}<br></code></pre></td></tr></table></figure><h2 id="腾讯"><a href="# 腾讯" class="headerlink" title="腾讯"></a>腾讯</h2><h3 id="Unity- 中影响渲染顺序的因素"><a href="#Unity- 中影响渲染顺序的因素" class="headerlink" title="Unity 中影响渲染顺序的因素"></a>Unity 中影响渲染顺序的因素</h3><center>    <img src="/2024/05/13/cf86467b04aa/unity-render-order.png" alt></center><ul><li>Canvas<ul><li>不同 Canvas 之间可以用以下两个属性控制渲染层级<ul><li>Sorting Layer</li><li>Order in Layer</li></ul></li></ul></li><li>Hierarchy 中顺序<ul><li>在同一个 Canvas 中，Hierarchy 的顺序决定了控件的层级关系</li></ul></li></ul><h4 id="模型深度的控制"><a href="# 模型深度的控制" class="headerlink" title="模型深度的控制"></a>模型深度的控制</h4><ul><li>空间深度：对于 3D 物体的显示先后就是完全按空间的先后来的，当然可以在 fragment shader 中关闭深度测试，或进行其他影响帧缓冲区的操作</li><li>RenderQueue：RenderQueue 是对 unity 中所有可以渲染的物体都适用</li></ul><h4 id="粒子特效渲染层级的控制"><a href="# 粒子特效渲染层级的控制" class="headerlink" title="粒子特效渲染层级的控制"></a>粒子特效渲染层级的控制</h4><ul><li>空间深度：和 3D 模型一致</li><li>RenderQueue：和 3D 模型一致</li><li>Sorting Order：粒子系统本身是一个 Renderer 组件，它渲染的是一个一个精灵，是一个一个片，该属性有效</li></ul><h3 id="C- 垃圾回收"><a href="#C- 垃圾回收" class="headerlink" title="C# 垃圾回收"></a>C# 垃圾回收 </h3><h4 id="检查回收对象"><a href="# 检查回收对象" class="headerlink" title="检查回收对象"></a> 检查回收对象</h4><p>GC 能够了解某个实体目前是否依旧被应用程序的某些活动对象所引用；对于那些没有被任何活动对象直接或间接引用的对象，GC 会将其判断为垃圾。GC 在其专门的线程中运行，默默地为程序清除不再使用的内存。压缩托管堆（将当前仍旧使用的对象放在连续的内存中，可以利用局部性原理提高性能），因此空余的空间也会是一块连续的内存</p><p>垃圾回收器采用的是 mark-and-compact 算法（标记和更改对象的同步块索引中的一个位 bit），在执行垃圾回收的时候，GC 不是枚举所有访问不到的对象；相反，它是通过压缩所有相邻的可达对象来执行垃圾回收。这样，由不可访问的对象占用的内存就会被覆盖</p><h4 id="代"><a href="# 代" class="headerlink" title="代"></a>代 </h4><p> 自上一次垃圾收集以来，新创建的对象属于第 0 代对象，而若是某个对象在经过过一次垃圾收集之后仍旧存活，那么它将成为第 1 代对象。两次及两次以上垃圾收集后仍旧没有被销毁的对象就变成了第 2 代对象。（第 0 代对象大多属于局部变量，而成员变量和全局变量（CLR 允许全局变量的定义，即便 C# 中不支持）则会很快成为第 1 代对象，直至第 2 代）</p><p>每一代都会有一个预算容量（以 KB 为单位），如果分配一个新对象造成超出预算，就会启动一次垃圾回收。CLR 垃圾回收器是自调节的，所以会根据回收垃圾对象的数量动态设置预算容量的大小。 一般来说，大概 10 个周期的 GC 中，会有一次同时检查第 0 代和第 1 代对象，大概 100 个周期的 GC 中，会有一次同时检查所有对象</p><h4 id="非托管资源"><a href="# 非托管资源" class="headerlink" title="非托管资源"></a>非托管资源 </h4><p>.Net 提供了两种控制非托管资源生命周期的机制：终结器（finalizer）和 <code>IDisposable</code> 接口</p><h5 id="终结器"><a href="# 终结器" class="headerlink" title="终结器"></a>终结器</h5><ul><li>终结器将由 GC 调用，调用将发生在对象成为垃圾之后的某个时间（无法确定其发生的具体时间），因此 .Net 并不能保证析构操作的确切时间</li><li>依赖终结器还会带来性能上的问题。当 GC 发现某个对象属于垃圾，但该对象需要执行终结操作时（定义了析构函数），就不能将其直接从内存中移除。首先，GC 将调用其终结器，而终结器并不在执行垃圾收集的线程上执行。GC 将把所有需要执行终结的对象放在专门的队列中，然后让另一个线程来执行这些对象的终结器。这样，GC 可以继续执行其当前的工作，在内存中移除垃圾对象。而在下一次的 GC 调用时，才会从内存中移除这些已被终结的对象。因此需要调用终结器的对象将在内存中多停留一次 GC 周期的时间，如果终结对象进入第 1 代或第 2 代，那么将停留更长的 GC 周期</li></ul><p>因此，尽量不要使用终结器来释放非托管资源</p><h5 id="IDisposable 接口"><a href="#IDisposable 接口" class="headerlink" title="IDisposable 接口"></a><code>IDisposable</code>接口 </h5><p><code>IDisposable.Dispose()</code> 方法的实现中需要完成如下 4 个任务</p><ul><li>释放所有非托管资源</li><li>释放所有托管资源，包括释放事件监听程序</li><li>设置一个状态标志，表示该对象已经被销毁，若是在销毁之后再次调用对象的公有方法，那么应该抛出 <code>ObjectDisposed</code>异常。</li><li>跳过终结操作，调用 <code>GC.SuppressFinalize(this)</code> 即可</li></ul><p>由于很多非托管资源都非常宝贵（如数据库和文件句柄），所以它们应尽可能快地被清除，而不能依靠垃圾回收的发生。.Net 中使用了一种标准的模式能够在使用者正常调用是通过 <code>IDisposable</code> 接口释放掉非托管资源，也会在使用者忘记的情况下使用终结器释放。这个模式和 GC 配合，可以保证仅在最糟糕的情况下才调用终结器，尽可能降低其带来的性能影响</p><h3 id="如何进行内存优化"><a href="# 如何进行内存优化" class="headerlink" title="如何进行内存优化"></a>如何进行内存优化</h3><ul><li><p>类中存在空的 <code>Update</code>、<code>LateUpdate</code> 和<code>FixedUpdate</code>方法</p><p>Unity 中的脚本其实默认都是继承自这个 <code>Monobehavior</code>。<code>Update</code>、<code>LateUpdate</code> 和<code>FixedUpdate</code>属于 <code>Monobehaviour</code> 类的“Messages”，虽然不由 <code>Monobehavior</code> 类继承而来，但是在 <code>Monobehaviour</code> 类的脚本中会生效——如果脚本中写上了这些方法，相应的脚本放到场景中，并且 <code>enable</code> 为<code>true</code>，那么游戏运行过程中每帧都会对其进行调用。即使这些方法为空，在运行时，它们依然会因为被调用而造成 CPU 时间的开销，其原因主要有两点</p><ul><li>这些方法是 Native 层对托管层的调用，C++ 与 C# 之间的通信本身存在一定的开销</li><li>当调用这些方法时，Unity 会进行一系列安全检测（比如确保 <code>GameObject</code> 没有被销毁等）导致 CPU 时间的消耗</li></ul></li><li><p>对纹理 <code>SetPixels</code> 的调用</p><p><code>SetPixels</code>可用于对纹理特定的 mipmap 层的像素进行修改，它会将一组数组的像素值赋值到贴图的指定 mipmap 层，调用 <code>Apply()</code> 后会将像素传至显卡。需注意的是，由于 <code>Color32</code> 比<code>Color</code>类型所占的空间更小，使用 <code>SetPixels32</code> 比<code>SetPixels</code>造成的 CPU 耗时也更小。所以在效果允许的情况下，我们推荐使用 <code>SetPixels32()</code> 方法来取代<code>SetPixels()</code></p><ul><li>从内存分配上讲，该函数会在托管堆中分配内存，用以存储纹理数据的像素信息，但引擎不会对其进行缓存。所以如果在频繁调用的函数中使用，就会造成持续性的堆内存分配</li><li>从耗时上讲，擅长执行大规模并行运算的 GPU 来处理图片信息是非常容易的，但 CPU 在进行逐个像素信息的获取时，就显得有些吃力了。并且 <code>GetPixels()</code> 在实现上是由 CPU 同步执行的，所以耗时会较高，同时会阻塞调用的线程，从而可能会造成卡顿。因此在非必要的情况下，并不建议使用<code>GetPixels()</code></li></ul></li><li><p><code>GetComponentsInChildren</code>和 <code>GetComponentsInParent</code> 的调用</p><p><code>GetComponentsInChildren</code>用于获得 <strong> 当前 </strong><code>GameObject</code> 及其 <strong> 子节点 </strong> 的所有给定类型的组件，返回的是一个包含所有符合条件的对象的数组；而 <code>GetComponentsInParent</code> 则是用于获得 <strong> 当前 </strong> 对象及其 <strong> 父节点 </strong> 上的所有给定类型的组件</p><p>这两者的使用都会涉及到较大范围内的搜索遍历，会挤占 CPU 较大的计算资源，所以应当尽量减少相关的调用，可以尝试缓存调用的结果，避免使其出现在 <code>Update</code> 这样的频繁调用的函数当中。此外，对于这两个函数，建议使用接受 <code>List</code> 类型的引用作为参数的版本，这样就可以避免每次调用都造成堆内存的分配</p></li><li><p><code>Linq</code>相关函数的调用</p><p><code>Linq</code>相关的函数一般都用于对数据的查询和处理。功能上简单来讲，就是对一堆数据进行各种 <code>if</code> 判断和 <code>for</code> 循环处理。使用 <code>Linq</code> 提供的 API，可以写出 SQL 语句风格的代码来进行集合数据的处理，这能够明显提升代码的简明性、可读性，维护上也更方便，从而提升编写效率，但是这些优点是以性能的开销为代价的</p><p><code>Linq</code>在执行过程中会产生一些临时变量，而且会用到委托（<code>lambda</code>表达式）。如果使用委托作为条件的判定方法，时间开销就会很高，并且会造成一定的堆内存分配。所以在一般的 Unity 游戏项目开发中，不推荐使用 <code>Linq</code> 相关的函数。在编辑器功能开发中，才常常把 <code>Linq</code> 和<code>Reflection</code>进行配合使用</p></li><li><p>对 <code>Renderer</code> 进行 <code>Material</code>/<code>Materials</code> 的获取</p><p>在 Unity 中，如果对 <code>Renderer</code> 类型调用 <code>.material</code> 和<code>.materials</code>，那么 Unity 就会生成新的材质球实例。其主要影响如下：</p><ul><li>通过<code>.material</code>，创建材质实例，并修改属性的方式实现多样的渲染效果，时间开销会较高</li><li>使用相同 Shader，但因为 <code>Material</code> 实例不同的<code>GameObject</code>，所以无法进行合批，导致 Draw Call 增加，变相造成了 CPU 耗时的增加</li><li>每次对新的 <code>GameObject</code> 的<code>Renderer</code>调用 <code>.material</code>，都会生成一个新的<code>Material</code> 实例，且 <code>GameObject</code> 销毁后，<code>Material</code>实例无法自动销毁，这会对资源管理造成一定的成本，想要处理的话就需要手动调用 <code>UnloadUnusedAssets</code> 来卸载，但这样就造成了性能开销；管理不好可能会造成材质球大量冗余甚至泄露，极端情况下甚至会导致过高的内存</li></ul></li></ul><h3 id="UI- 如何降低 -Draw-Call"><a href="#UI- 如何降低 -Draw-Call" class="headerlink" title="UI 如何降低 Draw Call"></a>UI 如何降低 Draw Call</h3><ul><li>每个单独的材质 / 纹理的渲染一定是会产生 DrawCall 的，将多张小图打包成一个图集，在渲染 UI 时就可使用同一个材质 / 纹理，即可有效降低 Draw Call 的产生<ul><li>从功能角度划分图集，例如将公共 UI 打包成一个图集，将每个系统的 UI 分别打成单独的图集，主要原则是将显示上密切相关的图片打包到一起</li><li>避免将无关联的东西打包在一个图集里，特别是那些不可能同时出现的元素，这样不但无法减少 DrawCall，还会增加内存消耗</li><li>控制图集大小，不要让图集太大</li></ul></li><li>合并 UI 元素<ul><li>UGUI 的渲染过程是通过 Canvas 组件实现的。每个 Canvas 都有一个 Sorting Layer 和一个 Order in Layer 属性，用于控制 UI 元素的渲染顺序。如果 UI 元素在同一个 Sorting Layer 和 Order in Layer 下，它们就会被合并成一个 DrawCall。可以将相同的 UI 元素放在同一个 Sorting Layer 和 Order in Layer 下，以减少 DrawCall 的数量</li></ul></li></ul><h4 id="合批的规则"><a href="# 合批的规则" class="headerlink" title="合批的规则"></a>合批的规则</h4><p>UGUI 在合批之前，会根据节点的 Depth、Material InstanceID 、Texture InstanceID、RendererOrder 进行排序，之后对相邻的节点进行检测，判断 Material InstanceID 和 Texture InstanceID 是否相同，如果相同则可以进行合批处理，如果这两个 UI 的 Material InstanceID 和 Texture InstanceID 都相同，但是不连续，中间有其他不同 Material InstanceID 或 Texture InstanceID 的 UI 则会打断合批</p><p>Depth 排序</p><ul><li>筛选掉 Depth 为 -1 的值，这部分默认不渲染</li><li>判断是否该元素底部是否有物体，如果没有则赋值 Depth 为 0，如果盖住物体（这块是通过 Mesh 进行判断，判断 Mesh 是否相交）则等于底部盖住的 UI 元素中 Depth 最大的值 +1</li><li>如果两个相邻元素通过了合批测试，则这两个相邻元素的深度值相等</li></ul><p>深度排序之后，就会根据 Texture InstanceID 进行排序，如果材质相同则对 Texture InstanceID 进行排序，如果也相同，那会根据 Inspection 面板上的 RendererOrder，最后真正进行 UI 的合批</p><h4 id="Mask- 影响合批"><a href="#Mask- 影响合批" class="headerlink" title="Mask 影响合批"></a>Mask 影响合批</h4><ul><li>在 <code>StencilMaterial.Add</code> 的时候为这个节点增加了一个新的材质，导致了 Mask 内的物体无法和外部同样材质的物体合批</li><li>Mask 会进行两次 Pass，第一步是对在模板缓冲中的值进行赋值，将要显示的部分缓存值设置为 1，不显示的部分设置为 0，在第二个 Pass 绘制时对模板缓冲值为 0 的部分进行剔除，所以这两个 Pass 也会带来两个 Draw Call 的生成</li></ul><p>所以添加一个 Mask 最起码会增加 3 个 Draw Call</p><blockquote><p>不同的 Mask 之间是可以合批的，虽然 Mask 会对原来的材质进行替换，添加一个新的材质，但是两个 Mask 添加的材质是相同的就支持合批（前提是两个 Mask 不重叠，当他们重叠时，因为被剔除的部分参与了运算，发现 Depth 不同并且 Material InstanceID 也不同，就无法进行合批）</p></blockquote><h4 id="RectMask2D- 与 -Mask- 的区别"><a href="#RectMask2D- 与 -Mask- 的区别" class="headerlink" title="RectMask2D 与 Mask 的区别"></a>RectMask2D 与 Mask 的区别 </h4><p> 和 Mask 不同的是，RectMask2D 并不会产生两额外的 Pass 增加两个 Draw Call 的消耗。RectMask2D 是通过 canvasRender 里面进行了 ClipRect 的剔除，这样相比于 Mask 会带来以下不同</p><ul><li>RectMask2D 之间无法进行合批</li><li>被 RectMask2D 隐藏的物体不会参与合批计算</li><li>RectMask2D 组件上挂载的 Image 可以参与外部的合批</li></ul><h3 id="Lua- 中的 pcall 和 xpcall"><a href="#Lua- 中的 pcall 和 xpcall" class="headerlink" title="Lua 中的 pcall 和 xpcall"></a>Lua 中的 <code>pcall</code> 和<code>xpcall</code></h3><ul><li><code>pcall(f, arg1, ···)</code>：在保护模式下，用给定的参数调用函数 <code>f</code>，这意味着<code>f</code> 内部的任何错误，都会被 <code>pcall</code> 捕获，而不会传播出去。<code>pcall</code>的第一个返回值是 <code>boolean</code> 类型的状态码。如果 <code>f</code> 内部没有发生错误，那么 <code>pcall</code> 返回 <code>true</code> 加调用 <code>f(arg, ...)</code> 返回的所有值，否则返回 <code>nil</code> 加错误信息</li><li><code>xpcall (f, err, ...)</code>：与 <code>pcall</code> 类似，但是可以设置一个错误处理函数。<code>xpcall</code>在保护模式下，用给定的参数调用函数 <code>f</code>，使用<code>err</code> 作为错误处理函数。在 <code>f</code> 内部发生的任何错误，都会被 <code>xpcall</code> 捕获，而不会传播出去。当函数 <code>f</code> 内部发生错误时，会使用原始的错误信息调用 <code>err</code> 函数，<code>xpcall</code>返回 <code>false</code> 加<code>err</code>函数的第一个返回值；否则，返回 <code>true</code> 加调用 <code>f(...)</code> 返回的所有值</li></ul><h2 id="雷火"><a href="# 雷火" class="headerlink" title="雷火"></a>雷火 </h2><h3 id="动画资源是如何加载的"><a href="# 动画资源是如何加载的" class="headerlink" title="动画资源是如何加载的"></a> 动画资源是如何加载的 </h3><h3 id="Animator- 和 -Animation- 区别"><a href="#Animator- 和 -Animation- 区别" class="headerlink" title="Animator 和 Animation 区别"></a>Animator 和 Animation 区别</h3><h3 id="GPU-Instance"><a href="#GPU-Instance" class="headerlink" title="GPU Instance"></a>GPU Instance</h3><h3 id="材质相同，材质的参数不同可以进行动态合批吗"><a href="# 材质相同，材质的参数不同可以进行动态合批吗" class="headerlink" title="材质相同，材质的参数不同可以进行动态合批吗"></a> 材质相同，材质的参数不同可以进行动态合批吗 </h3><h3 id="状态机和行为树的区别"><a href="# 状态机和行为树的区别" class="headerlink" title="状态机和行为树的区别"></a> 状态机和行为树的区别 </h3><h3 id="Playable- 的使用"><a href="#Playable- 的使用" class="headerlink" title="Playable 的使用"></a>Playable 的使用</h3><h3 id="顶点动画"><a href="# 顶点动画" class="headerlink" title="顶点动画"></a> 顶点动画 </h3><h3 id="多个实体如何处理动画"><a href="# 多个实体如何处理动画" class="headerlink" title="多个实体如何处理动画"></a> 多个实体如何处理动画 </h3><h2 id="快手"><a href="# 快手" class="headerlink" title="快手"></a> 快手 </h2><h3 id="Unity- 中 -C- 与 -Lua- 的交互"><a href="#Unity- 中 -C- 与 -Lua- 的交互" class="headerlink" title="Unity 中 C# 与 Lua 的交互"></a>Unity 中 C# 与 Lua 的交互</h3><p>Lua 与宿主语言是通过栈进行交互的。在 c 中通常以<code>lua_State* L</code> 的形式表示指向栈的一个指针，在 C# 中以 <code>System.IntPtr L</code> 的形式存在。栈的元素用过 <code>index</code> 进行索引。以负数表示从顶向底索引，以正数表示由底向顶索引</p><h4 id="Lua- 是获取一个 -C- 对象"><a href="#Lua- 是获取一个 -C- 对象" class="headerlink" title="Lua 是获取一个 C# 对象"></a>Lua 是获取一个 C# 对象 </h4><p> 主要是通过 <code>PushUserObject</code> 来获取</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PushUserObject</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">object</span> o</span>)</span><br>{<br>    Type type = o.GetType();<br>    <span class="hljs-built_in">int</span> reference = LuaStatic.GetMetaReference(L, type);<br><br>    <span class="hljs-keyword">if</span> (reference &lt;= <span class="hljs-number">0</span>)<br>    {<br>        reference = LoadPreType(L, type);<br>    }<br>                <br>    PushUserData(L, o, reference);<br>}<br></code></pre></td></tr></table></figure><p>通过一个 <code>GetMetaReference</code> 方法获取了一个 <code>reference</code> 值，这个是 C# 类导出 Wrap 文件时创建的 Wrap 类对应的元表引用（因为元表是 Lua 的东西，C# 里不能直接获取元表，所以这里只能拿到元表在内存中的引用 Id)</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PushUserData</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">object</span> o, <span class="hljs-built_in">int</span> reference</span>)</span><br>{<br>    <span class="hljs-built_in">int</span> index;<br>    ObjectTranslator translator = ObjectTranslator.Get(L);<br><br>    <span class="hljs-keyword">if</span> (translator.Getudata(o, <span class="hljs-keyword">out</span> index))<br>    {<br>        <span class="hljs-keyword">if</span> (LuaDLL.tolua_pushudata(L, index))<br>        {<br>            <span class="hljs-keyword">return</span>;<br>        }<br><br>        translator.Destroyudata(index);<br>    }<br><br>    index = translator.AddObject(o);<br>    LuaDLL.tolua_pushnewudata(L, reference, index);<br>}<br></code></pre></td></tr></table></figure><p>Lua 从 C# 获取对象的时候，实际上获取的是一个 userdata，这个 userdata 以 C# 导出的 Wrap 类为元表，以实现 Lua 对 C# 方法的调用。Lua 从 C# 这边获取的对象，都将被缓存到 <code>ObjectTranlator</code> 中的 <code>LuaObjectPool</code> 中</p><p>当 Lua 调用 C# 方法的时候，C# 需要获得对象的实例。通过调用 C API <code>tolua_rawnetobj</code>，从 Lua 调用栈中拿到 userdata 的值，也就是前面说的 <code>LuaObjectPool</code> 中缓存的索引值，根据这个索引值从 <code>ObjectTranslator</code> 中拿回缓存的 C# 对象</p><h4 id="C- 执行 -Lua- 代码"><a href="#C- 执行 -Lua- 代码" class="headerlink" title="C# 执行 Lua 代码"></a>C# 执行 Lua 代码 </h4><p>C# 从 Lua 获取的对象主要是 Lua 方法和<code>table</code>。获取 Lua 方法一般都是 Lua 这边绑定一个方法到 C# 的委托。通过<code>CheckDelegate</code> 方法获取到 Lua 方法对象。调用 <code>ToLuaFunction</code> 从 Lua 栈中获取到方法引用并创建一个对应 C# 的<code>LuaFunction</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LuaFunction <span class="hljs-title">ToLuaFunction</span>(<span class="hljs-params">IntPtr L, <span class="hljs-built_in">int</span> stackPos</span>)</span><br>{<br>    LuaTypes type = LuaDLL.lua_type(L, stackPos);<br>    <span class="hljs-keyword">if</span> (type == LuaTypes.LUA_TNIL)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    }<br>    stackPos = LuaDLL.abs_index(L, stackPos);<br>    LuaDLL.lua_pushvalue(L, stackPos);<br>    <span class="hljs-built_in">int</span> reference = LuaDLL.toluaL_ref(L);<br>    <span class="hljs-keyword">return</span> LuaStatic.GetFunction(L, reference);<br>}<br></code></pre></td></tr></table></figure><p><code>ToLuaFunction</code>会创建一个当前栈顶的对象的引用并返回 <code>reference</code>，<code>lua_pushvalue</code> 接口调过之后，将 Lua 方法的栈索引重新压栈，也就是说创建的当前栈顶的引用，这个 <code>reference</code> 现在是指向的是 Lua 方法的栈索引。之后再以这个 <code>reference</code> 调用 <code>GetFunction</code> 方法，获取<code>LuaFunction</code></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">public</span> LuaFunction <span class="hljs-title">GetFunction</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> reference</span>)</span><br>{<br>    LuaFunction func = TryGetLuaRef(reference) <span class="hljs-keyword">as</span> LuaFunction;<br>    <span class="hljs-keyword">if</span> (func == <span class="hljs-literal">null</span>)<br>    {<br>        func = <span class="hljs-keyword">new</span> LuaFunction(reference, <span class="hljs-keyword">this</span>);<br>        funcRefMap.Add(reference, <span class="hljs-keyword">new</span> WeakReference(func));<br>        <span class="hljs-keyword">if</span> (LogGC)<br>            Debugger.Log(<span class="hljs-string">"Alloc LuaFunction name , id {0}"</span>, reference);      <br>    }<br>    RemoveFromGCList(reference);<br>    <span class="hljs-keyword">return</span> func;<br>}<br></code></pre></td></tr></table></figure><p>若当前 Lua 方法没有缓存，这里就会以这个 Lua 方法的栈索引引用创建一个 <code>LuaFunction</code> 对象。并缓存到 <code>funcRefMap</code> 中。注意这里缓存的是 <code>LuaFunction</code> 的弱引用对象，这样 <code>LuaFunction</code> 对象就不会因为被 <code>funcRefMap</code> 持有引用而导致无法被 C# GC 回收，也就是说这个 <code>funcRefMap</code> 纯粹是用来做一个缓存，避免同一个 <code>LuaFunction</code> 的反复创建用，不会干扰 <code>LuaFunction</code> 的内存释放。</p><h4 id="GC- 的处理"><a href="#GC- 的处理" class="headerlink" title="GC 的处理"></a>GC 的处理 </h4><p> 当 Lua 从 C# 获取一个对象的时候，C# 会把这个对象缓存到 <code>ObjectTranslator</code> 中的 <code>LuaObjectPool</code> 中，从而实现 C# 端可以根据 Lua 传递的 Wrap 对应的 userdata 拿回对应的 C# 对象。并且也保证了当 Lua 端持有 userdata 引用的时候 C# 对象不会因为在 C# 端无其它引用而被 C# GC 回收掉。缓存在 ObjectPool 中的引用将会在 lua 端 GC 清理了 userdata 之后，由 userdata 的元方法 <code>__gc</code> 触发移除缓存，从而释放 C# 对象的内存</p><p>当 C# 获取一个 Lua 对象的时候， 将会在 C# 端建立一个 <code>LuaBaseRef</code> 对象，并调用 C API 在 Lua 端创建一个对象引用，并持有在 C 环境，从而保证了在 C# 端持有 Lua 对象的时候，Lua 对象不会因为在 Lua 端无其它引用而被 Lua GC 回收掉。 C API 创建的引用将在 C# 端 GC 清理了 <code>LuaBaseRef</code> 引用或手动调用 <code>Dispose()</code> 方法之后解除，从而释放 Lua 对象的内存</p><h2 id="泊松"><a href="# 泊松" class="headerlink" title="泊松"></a>泊松 </h2><h3 id="笔试"><a href="# 笔试" class="headerlink" title="笔试"></a> 笔试 </h3><h4 id="include-lt-xxx-h-gt- 和 -include-quot-xxx-h-quot- 有什么差别"><a href="#include-lt-xxx-h-gt- 和 -include-quot-xxx-h-quot- 有什么差别" class="headerlink" title="#include <xxx.h> 和 #include &quot;xxx.h&quot; 有什么差别"></a><code>#include &lt;xxx.h&gt;</code>和 <code>#include "xxx.h"</code> 有什么差别</h4><ul><li>用引号，代表编译程序会优先在程序的本地目录搜索这个文件，找不到再搜索系统目录</li><li>用尖括号，代表编译程序只会在系统目录（系统环境变量和编译本身设置的默认搜索目录）搜索这个文件</li></ul><h4 id="被 static 修饰的变量 - 函数有什么作用"><a href="# 被 static 修饰的变量 - 函数有什么作用" class="headerlink" title="被 static 修饰的变量 / 函数有什么作用"></a>被 <code>static</code> 修饰的变量 / 函数有什么作用</h4><ul><li>修饰变量<ul><li>局部变量<ul><li>静态局部变量保存在全局数据区（静态存储区），而不是保存在栈中，每次的值保持到下一次调用，直到下一次赋新值</li><li>静态局部变量值初始化一次；若不赋初值，在初始化的时候会自动赋值为 0；只对定义自己的函数体始终可见；把局部变量改变为静态变量是改变了他的存储方式即改变了他的生存周期</li></ul></li><li>全局变量<ul><li>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同</li><li>两者的区别在于非静态全局变量的作用域是整个源程序， 当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的</li><li>静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效， 在同一源程序的其它源文件中不能使用它</li></ul></li></ul></li><li>修饰函数<ul><li>如果这个静态函数出现在类里，那么它是一个静态成员函数，调用这个函数不会访问或者修改任何对象（非<code>static</code>）数据成员</li><li>如果它不是出现在类中，那么它是一个普通的全局的静态函数。用 static 修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是 <code>extern</code> 的，也就是说它可以被其它代码文件调用</li></ul></li></ul><h4 id="在 -C- 工程里面引入 -C- 语言库的时候为什么要用”extern-C”"><a href="# 在 -C- 工程里面引入 -C- 语言库的时候为什么要用”extern-C”" class="headerlink" title="在 C++ 工程里面引入 C 语言库的时候为什么要用”extern C”"></a>在 C++ 工程里面引入 C 语言库的时候为什么要用”extern C”</h4><p>由于 C 和 C++ 编译器对函数的编译处理是不完全相同的，尤其对于 C++ 来说，支持函数的重载，编译后的函数一般是以函数名和形参类型来命名的</p><p>例如函数 <code>void fun(int, int)</code> 编译后的可能是 <code>_fun_int_int</code> 不同编译器可能不同，但都采用了相似机制，用函数名和参数类型来命名编译后的函数名；而 C 语言没有类似的重载机制，一般是利用函数名来指明编译后的函数名的，对应上面的函数可能会是 <code>_fun</code> 这样的名字</p><h4 id="说出 const 的作用"><a href="# 说出 const 的作用" class="headerlink" title="说出 const 的作用"></a>说出 <code>const</code> 的作用</h4><ul><li>修饰变量<ul><li>当 <code>const</code> 修饰变量时，该变量将被视为只读变量，即不能被修改</li></ul></li><li>修饰函数参数，表示函数不会修改参数</li><li>修饰函数返回值<ul><li><code>const</code>修饰函数返回值时，表示函数的返回值为只读，不能被修改。这样做可以使函数返回的值更加安全，避免被误修改</li></ul></li><li>修饰指针或引用<ul><li>指向只读变量的指针</li><li>只读指针</li><li>只读指针指向只读变量</li><li>常量引用</li></ul></li><li>修饰成员函数<ul><li>当 <code>const</code> 修饰成员函数时，表示该函数不会修改对象的状态（就是不会修改成员变量）</li></ul></li></ul><h4 id="字符串拷贝函数的形式是 char-strcpy-char-dst-const-char-src- 请编写逻辑实现，并说明为什么要返回 char- 类型"><a href="# 字符串拷贝函数的形式是 char-strcpy-char-dst-const-char-src- 请编写逻辑实现，并说明为什么要返回 char- 类型" class="headerlink" title="字符串拷贝函数的形式是 char* strcpy(char* dst, const char* src)请编写逻辑实现，并说明为什么要返回 char* 类型"></a>字符串拷贝函数的形式是 <code>char* strcpy(char* dst, const char* src)</code> 请编写逻辑实现，并说明为什么要返回 <code>char*</code> 类型</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">strcpy</span><span class="hljs-params">(<span class="hljs-type">char</span>* dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-built_in">assert</span>((dst != <span class="hljs-literal">nullptr</span>) &amp;&amp; src != <span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">char</span>* res = dst;<br>    <span class="hljs-keyword">while</span> ((&amp;dst++ = *src++ != <span class="hljs-string">'\0'</span>))<br>    {<br><br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></td></tr></table></figure><p>为了实现链式表达式<code>int length = strlen(strcpy(dst, "xxxxx"));</code></p><h4 id="c- 工程使用动态链接库，最后一步连接的时候提示找不到符号"><a href="#c- 工程使用动态链接库，最后一步连接的时候提示找不到符号" class="headerlink" title="c++ 工程使用动态链接库，最后一步连接的时候提示找不到符号"></a>c++ 工程使用动态链接库，最后一步连接的时候提示找不到符号</h4><ul><li>链接时缺失了相关目标文件（.o）</li><li>链接时缺少相关的库文件（.a/.so）</li><li>链接的库文件中又使用了另一个库文件</li><li>多个库文件链接顺序问题</li><li>定义与实现不一致</li><li>在 c++ 代码中链接 c 语言的库</li><li>C++ 中类中静态变量没有在类外初始化</li><li><code>inline</code>函数</li><li>GCC 的 visibility 属性隐藏</li></ul><h4 id="异常会跨线程吗"><a href="# 异常会跨线程吗" class="headerlink" title="异常会跨线程吗"></a>异常会跨线程吗</h4><p>C++ 主线程无法捕获子线程异常</p><ul><li>在主线程中声明一个变量，将该变量传递到子线程中</li><li>在子线程抛出异常的时候，修改变量的值为异常值</li><li>然后在主线程中捕获异常</li></ul><p>在主线程中声明了一个 <code>std::promiss&lt;void&gt;</code> 类型的变量，并传递到子线程中，然后在子线程中使用 <code>try catch</code> 语句捕获异常然后设置给 <code>std::promise&lt;void&gt;</code> 变量；而在主线程中我们使用 <code>std::future</code> 获取到 <code>std::promise</code> 的<code>future</code>，然后使用 <code>try catch</code> 成功捕捉到设置到 <code>std::promise&lt;void&gt;</code> 变量中的异常</p><h4 id="以下代码有什么问题"><a href="# 以下代码有什么问题" class="headerlink" title="以下代码有什么问题"></a>以下代码有什么问题</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getMemory</span><span class="hljs-params">(<span class="hljs-type">char</span>** p, <span class="hljs-type">int</span> num)</span> </span>{<br>    *p = (<span class="hljs-type">char</span>*)<span class="hljs-built_in">malloc</span>(num);<br>}<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testMethod</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">char</span>* src=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">getMemory</span>(&amp;src, <span class="hljs-number">100</span>);<br>    <span class="hljs-built_in">strcpy</span>(src, <span class="hljs-string">"hello"</span>);<br>    <span class="hljs-built_in">print</span>(src);<br>}<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>{<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = {<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>};<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = arr.<span class="hljs-built_in">begin</span>(); it!=arr.<span class="hljs-built_in">end</span>(); ++it) {<br>        <span class="hljs-keyword">if</span> (*it &gt; <span class="hljs-number">2</span>) {<br>            arr.<span class="hljs-built_in">erase</span>(it);<br>        }<br>    }<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = arr.<span class="hljs-built_in">begin</span>(); it!=arr.<span class="hljs-built_in">end</span>(); ++it) {<br>        std::cout &lt;&lt;*it &lt;&lt;std::endl;<br>    }<br>}<br></code></pre></td></tr></table></figure><ul><li>以上代码有什么问题？</li><li>应该怎么修改？</li><li>还有其他类型数据结构会出此类问题吗？</li><li>出现上述问题的本质是什么？</li></ul><h4 id="vector- 迭代器失效"><a href="#vector- 迭代器失效" class="headerlink" title="vector 迭代器失效"></a>vector 迭代器失效</h4><ul><li>当容器调用 <code>erase()</code> 方法后，当前位置到容器末尾元素的所有迭代器全部失效。</li><li>当容器调用 <code>insert()</code> 方法后，当前位置到容器末尾元素的所有迭代器全部失效。</li><li>如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了。</li></ul><h3 id="编译"><a href="# 编译" class="headerlink" title="编译"></a>编译 </h3><h4 id="编译流程"><a href="# 编译流程" class="headerlink" title="编译流程"></a> 编译流程 </h4><h5 id="预处理 -Preprocessing"><a href="# 预处理 -Preprocessing" class="headerlink" title="预处理 Preprocessing"></a> 预处理 Preprocessing</h5><p>在编译器开始编译之前，会先进行预处理。预处理器会处理代码中的所有预处理指令，例如 #include 和 #define 等。它会将这些指令替换成对应的代码，生成一个新的文本文件。这个新的文本文件就是编译器的输入。在预处理的过程中，还会进行条件编译，即根据条件来选择是否编译某些代码块。预处理完成后，会生成一个没有宏定义和条件编译的中间文件</p><p>预处理器的主要作用是解决代码中的宏定义，它会将宏定义展开成对应的代码。此外，预处理器还会处理 #include 指令，将指定的头文件插入到源文件中，以便让编译器能够对头文件中的函数和变量进行编译</p><blockquote><p>预处理器还会在代码中插入记号，使编译器能分辨出每一行来自哪个文件，以便在调试过程中能生成对应的错误信息</p></blockquote><h5 id="编译 -Compilation"><a href="# 编译 -Compilation" class="headerlink" title="编译 Compilation"></a>编译 Compilation</h5><p>编译器将预处理后的文件作为输入，对其进行词法分析、语法分析和语义分析等处理。这些处理会将代码转化成中间代码，中间代码是一种类似于 <strong> 汇编语言 </strong> 的低级代码。编译器将代码分成多个模块，每个模块编译成一个对象文件。在编译的过程中，编译器会对代码进行优化，以提高程序的运行效率和节省内存空间</p><h5 id="汇编 -Assembly"><a href="# 汇编 -Assembly" class="headerlink" title="汇编 Assembly"></a>汇编 Assembly</h5><p>中间代码会被汇编器转化成机器语言指令，这些指令可以被计算机直接执行。汇编的过程将每个对象文件转换成机器语言的目标文件。每个目标文件包含机器指令和数据，以及其他的控制信息。目标文件可以被链接器用于构建可执行文件</p><h5 id="链接 -Linking"><a href="# 链接 -Linking" class="headerlink" title="链接 Linking"></a>链接 Linking</h5><p>在编译过程中，可能会用到其他的库文件和对象文件。链接器会将这些文件与生成的可执行文件进行链接，生成最终的可执行文件。链接器的主要任务是解决符号引用问题，即通过在不同的目标文件中查找符号的定义，使得所有的符号都能够正确地被解析和链接。链接器还会对代码进行优化和压缩，以减小可执行文件的体积，并提高程序的运行效率</p><h4 id="静态链接和动态链接"><a href="# 静态链接和动态链接" class="headerlink" title="静态链接和动态链接"></a>静态链接和动态链接 </h4><p> 链接过程主要包含了三个步骤</p><ul><li>地址与空间分配 Address and Storage Allocation</li><li>符号解析 Symbol Resolution</li><li>重定位 Relocation</li></ul><p>两步链接（Two-pass Linking）的方法</p><ul><li>地址与空间分配<ul><li>扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系</li></ul></li><li>符号解析与重定位<ul><li>使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。事实上，第二步是链接过程的核心，尤其是重定位</li></ul></li></ul><center>    <img src="/2024/05/13/cf86467b04aa/two-step-linking.png" alt></center><h5 id="地址与空间分配"><a href="# 地址与空间分配" class="headerlink" title="地址与空间分配"></a>地址与空间分配 </h5><p> 可执行文件中的 segment 是由目标文件中的 section 合并而来的，对于多个输入目标文件，链接器如何将它们的各个 section 合并到输出文件呢？或者说，输出文件中的空间如何分配给输入文件</p><h6 id="按序叠加"><a href="# 按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h6><center>    <img src="/2024/05/13/cf86467b04aa/elf-simple-merge.png" alt></center><blockquote><p>然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86 硬件的对齐要求是 4KB。如果一个节的大小只有 1 个字节，它也要在内存在重用 4KB。这样会造成大量内部碎片。所以不是一个好的方案</p></blockquote><h6 id="合并相似节"><a href="# 合并相似节" class="headerlink" title="合并相似节"></a>合并相似节 </h6><p> 一个更加实际的方法便是合并相同性质的 section，比如：将所有输入文件的<code>.text</code> section 合并到输出文件的 <code>text</code> segment</p><center>    <img src="/2024/05/13/cf86467b04aa/elf-similar-merge.png" alt></center><p>其中 <code>.bss</code> 节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义：</p><ul><li>在输出的可执行文件中的空间</li><li>在装载后的虚拟地址中的空间</li></ul><p>对于有实际数据的节，如 <code>.text</code> 和<code>.data</code>，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于 <code>.bss</code> 来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。这里的空间分配只关注于虚拟地址空间的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大</p><p>在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了程序头表（Program Header Table）结构</p><center>    <img src="/2024/05/13/cf86467b04aa/different-elf-type.png" alt></center><p>链接前目标文件中所有节的 VMA（Virtual Memory Address）都是 0，因为虚拟空间还没有分配。链接后，可执行文件中各个 section 被分配到了相应的虚拟地址。在 Linux x86-64 系统中，代码段总是从 <code>0x0000000000400000</code> 开始的，另外 <code>.text</code> section 之前还有<code>ELF Header</code>、<code>Program Header Table</code>、<code>.init</code> 等占用了一定的空间，所以代码段的地址不是从 <code>0x0000000000400000</code> 开始的</p><h5 id="符号解析"><a href="# 符号解析" class="headerlink" title="符号解析"></a>符号解析 </h5><p> 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字</p><p>然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止</p><p>另一方面，对全局符号的解析，经常会面临多个目标文件可能会定义相同名字的全局符号。这种情况下，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义</p><h6 id="多重定义的全局符号解析"><a href="# 多重定义的全局符号解析" class="headerlink" title="多重定义的全局符号解析"></a>多重定义的全局符号解析 </h6><p> 链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部符号（只对定义该符号的模块可见），有些是全局符号（对其他模块也可见）。如果多个模块定义同名的全局符号，该如何进行取舍？</p><p>Linux 编译系统采用如下的方法解决多重定义的全局符号解析：</p><p>在编译时，编译器想汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表中。</p><p>根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：</p><ul><li>规则 1：不允许有多个同名的强符号</li><li>规则 2：如果有一个强符号和多个弱符号同名，则选择强符号</li><li>规则 3：如果有多个弱符号同名，则从这些弱符号中任意选择一个</li></ul><p>另一方面，由于允许一个符号定义在多个文件中，所以可能会导致一个问题：如果一个弱符号定义在多个目标文件中，而它们的类型不同，怎么办？这种情况主要有三种：</p><ul><li>情况 1：两个或两个以上的强符号类型不一致</li><li>情况 2：有一个强符号，其他都是弱符号，出现类型不一致</li><li>情况 3：两个或两个以上弱符号类型不一致</li></ul><p>其中，情况 1 由于多个强符号定义本身就是非法的，所以链接器就会报错。对于后两种情况，编译器和链接器采用一种叫 COMMON 块（Common Block）的机制来处理。其过程如下：</p><p>首先，编译器将未初始化的全局变量定义为弱符号处理。对于情况 3，最终链接时选择最大的类型。对于情况 2，最终输出结果中的符号所占空间与强符号相同，如果链接过程中有弱符号大于强符号，链接器会发出警告</p><h5 id="重定位"><a href="# 重定位" class="headerlink" title="重定位"></a>重定位 </h5><p> 事实上，重定位过程也伴随着符号的解析过程。链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。链接器通过重定位表（Relocation Table）用来处理重定位相关的信息</p><p>对于可重定位的 ELF 文件来说，它必须包含重定位表，用来描述如何修改相应的 section 的内容。对于每个要被重定位的 ELF section 都有一个对应的重定位表。如果 <code>.text</code> section 需要被重定位，则会有一个相对应叫<code>.rel.text</code> 的 section 保存了代码 section 的重定位表；如果 <code>.data</code> section 需要被重定位，则会有一个相对应的<code>.rel.tdata</code> 的 section 保存了数据 section 的重定位表</p><h5 id="静态链接"><a href="# 静态链接" class="headerlink" title="静态链接"></a>静态链接 </h5><p> 静态链接就是在程序运行前，链接器通过对象文件中包含的重定位表，完成所有重定位操作，并最终形成一个在运行时不需要再次进行依赖库的加载和重定位操作（因为所有的依赖库在运行前都被链接到程序中了）</p><h5 id="动态链接"><a href="# 动态链接" class="headerlink" title="动态链接"></a>动态链接 </h5><p> 静态链接使得进行模块化开发，大大提供了程序的开发效率。随着，程序规模的扩大，静态链接的诸多缺点也逐渐暴露出来，如：浪费内存和磁盘空间、模块更新困难等；关于模块更新，静态链接的程序有任何更新，都必须重新编译链接，用户则需要重新下载安装该程序</p><p>动态链接指的是主程序对动态共享库或对象中符号的引用，是等到程序运行后再加载并进行重定位操作。程序的主体部分也称为主程序还是静态链接的，这部分链接是不会将依赖的动态共享库或对象链接进主程序的</p><h6 id="动态链接的基本实现"><a href="# 动态链接的基本实现" class="headerlink" title="动态链接的基本实现"></a>动态链接的基本实现 </h6><p> 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化</p><p>目前，主流操作系统都支持动态链接。在 Linux 中，ELF 动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以 <code>.so</code> 为后缀；在 Windows 中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以 <code>.dll</code> 为后缀</p><h6 id="动态链接程序运行时地址空间分布"><a href="# 动态链接程序运行时地址空间分布" class="headerlink" title="动态链接程序运行时地址空间分布"></a>动态链接程序运行时地址空间分布 </h6><p> 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。</p><p>关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是：</p><ul><li>静态共享库 Static Shared Library<ul><li>地址固定</li><li>静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间</li><li>因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态</li></ul></li><li>动态共享库 Dynamic Shared Libary<ul><li><p>地址不固定</p></li><li><p>采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）</p><ul><li>在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成</li><li>一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位</li></ul></li><li><p>但是这种方式也存在一些问题</p><ul><li>态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的</li></ul></li><li><p>地址无关代码</p><ul><li><p>把指令中那些需要被修改的部分分离出来，跟数据部分放在一起，这样指令部分就可以保持不变，而数据部分可以在每个进程中拥有一个副本</p></li><li><p>共享对象模块中的地址引用按照是否为跨模块分为两类：模块内部引用、模块外部引用。按照不用的引用方式又可分为：指令引用、数据引用</p><ul><li>类型 1：模块内部的函数调用<ul><li>由于被调用的函数与调用者都处于同一模块，它们之间的相对位置是固定的。对于现代的系统来说，模块内部的调用都可以是相对地址调用，或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的</li></ul></li><li>类型 2：模块内部的数据访问，如模块中定义的全局变量、静态变量<ul><li>一个模块前面一般是若干个页的代码，后面紧跟着若干个页的数据，这些页之间的相对位置是固定的，即任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，所以只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了</li></ul></li><li>类型 3：模块外部的函数调用<ul><li>模块间的数据访问比模块内部稍微麻烦一些，因为模块间的数据访问目标地址要等到装载时才决定。此时，动态链接需要使用代码无关地址技术，其基本思想是把地址相关的部分放到数据段。ELF 的实现方法是：在数据段中建立一个指向这些变量的指针数组，也称为全局偏移表（Global Offset Table，GOT），当代码需要引用该全局变量时，可以通过 GOT 中相对应的项间接引用</li></ul></li><li>类型 4：模块外部的数据访问，如其他模块中定义的全局变量<ul><li>对于模块间函数调用，同样可以采用类型 3 的方法来解决。与上面的类型有所不同的是，GOT 中响应的项保存的是目标函数的地址，当模块需要调用目标函数时，可以通过 GOT 中的项进行间接跳转</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">static</span> <span class="hljs-type">int</span> a;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> b;<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">ext</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> </span>{<br>    a = <span class="hljs-number">1</span>;      <span class="hljs-comment">// 类型 2：模块内部数据访问</span><br>    b = <span class="hljs-number">2</span>;      <span class="hljs-comment">// 类型 4：模块外部数据访问</span><br>}<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">bar</span>();      <span class="hljs-comment">// 类型 1：模块内部函数调用</span><br>    <span class="hljs-built_in">ext</span>();      <span class="hljs-comment">// 类型 4：模块外部函数调用</span><br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h4 id="静态链接是否将所有函数都链接到可执行文件中"><a href="# 静态链接是否将所有函数都链接到可执行文件中" class="headerlink" title="静态链接是否将所有函数都链接到可执行文件中"></a>静态链接是否将所有函数都链接到可执行文件中</h4><ul><li>动态链接是指在生成可执行文件时不将所有程序用到的函数链接到一个文件，因为有许多函数在操作系统的 dll 文件中，当程序运行时直接从操作系统中找</li><li>静态链接就是把所有用到的函数全部链接到 exe 文件中</li><li>动态链接是只建立一个引用的接口，而真正的代码和数据存放在另外的可执行模块中，在运行时再装入</li><li>而静态链接是把所有的代码和数据都复制到本模块中，运行时就不再需要库了</li></ul><h4 id="动态库抛出异常可以捕获到吗"><a href="# 动态库抛出异常可以捕获到吗" class="headerlink" title="动态库抛出异常可以捕获到吗"></a>动态库抛出异常可以捕获到吗 </h4><p> 同一个编译器编译出来的 dll 和 exe 是可以的</p><h3 id="关键字和操作符"><a href="# 关键字和操作符" class="headerlink" title="关键字和操作符"></a>关键字和操作符 </h3><h4 id="extern 关键字含义"><a href="#extern 关键字含义" class="headerlink" title="extern 关键字含义"></a><code>extern</code> 关键字含义</h4><ul><li>当它与 <code>"C"</code> 一起连用时，如<code>extern "C" void fun(int a, int b);</code>，则编译器在编译 fun 这个函数名时按 C 的规则去翻译相应的函数名而不是 C++ 的</li><li>当它不与 <code>"C"</code> 在一起修饰变量或函数时，如在头文件中，<code>extern int a;</code>，它的作用就是声明函数或变量的作用范围的关键字，其声明的函数和变量可以在本编译单元或其他编译单元中使用</li></ul><h5 id="静态全局变量"><a href="# 静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h5><blockquote><p>注意使用 <code>static</code> 修饰变量，就不能使用 <code>extern</code> 来修饰，即 <code>static</code> 和<code>extern</code>不可同时出现</p></blockquote><p><code>static</code>修饰的全局变量的声明与定义同时进行，即当在头文件中使用 <code>static</code> 声明了全局变量，同时它也被定义了。<code>static</code>修饰的全局变量的作用域只能是本身的编译单元。在其他编译单元使用它时，只是简单的把其值复制给了其他编译单元，其他编译单元会另外开个内存保存它，在其他编译单元对它的修改并不影响本身在定义时的值</p><p>多个地方引用静态全局变量所在的头文件，不会出现重定义错误，因为在每个编译单元都对它开辟了额外的空间进行存储</p><blockquote><p>一般定义 static 全局变量时，都把它放在。cpp 文件中而不是。h 文件中，这样就不会给其他编译单元造成不必要的信息污染</p></blockquote><h4 id="如何使用全局变量"><a href="# 如何使用全局变量" class="headerlink" title="如何使用全局变量"></a>如何使用全局变量</h4><ul><li>在同一文件中定义了全局变量，需要在前面使用，这时在定义之前用 <code>extern</code> 关键字对其进行声明</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SetA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    a = <span class="hljs-number">100</span>;<br>}<br><br><span class="hljs-type">int</span> a;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ...<br>}<br></code></pre></td></tr></table></figure><ul><li>在一个源文件文件中定义了全局变量，需要在其他文件中使用，这时需要在其他文件中需要使用的地方之前用 <code>extern</code> 声明下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// a.cpp 文件，a 的定义文件</span><br><span class="hljs-type">int</span> a;  <span class="hljs-comment">// 全局变量 a 的定义</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    ...<br>}<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// b.cpp 文件</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> a;  <span class="hljs-comment">// 声明</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setA</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    a = <span class="hljs-number">100</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="如何更改变量的 const 属性"><a href="# 如何更改变量的 const 属性" class="headerlink" title="如何更改变量的 const 属性"></a>如何更改变量的 <code>const</code> 属性</h4><ul><li>强制类型转换</li></ul><p>C++ 中的强制类型转换可以将 <code>const</code> 类型转换为非 <code>const</code> 类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> &amp;b = <span class="hljs-built_in">const_cast</span>&lt;<span class="hljs-type">int</span> &amp;&gt;(a);<br>    b = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// output: 20</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><p><code>const_cast</code>只能在类型上进行强制转换，但不能去掉变量的实际限定符。因此，如果要去掉指向 <code>const</code> 对象的指针或引用的 <code>const</code> 限定符，必须先解除指针或引用的 <code>const</code> 属性，然后再进行强制类型转换</p><ul><li>使用 <code>mutable</code> 关键字</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bar</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>{<br>        count++;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    Foo foo;<br>    foo.<span class="hljs-built_in">bar</span>(); <span class="hljs-comment">// count = 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="如何初始化 const 成员变量"><a href="# 如何初始化 const 成员变量" class="headerlink" title="如何初始化 const 成员变量"></a>如何初始化 <code>const</code> 成员变量</h4><ul><li><code>const</code>成员变量初始化在构造函数的初始化列表里进行，不可以通过赋值来初始化</li><li>若有多个构造函数，则必须每个构造函数都必须要为 <code>const</code> 成员变量赋初值</li></ul><h4 id="new 和 delete 运算符"><a href="#new 和 delete 运算符" class="headerlink" title="new 和 delete 运算符"></a><code>new</code>和 <code>delete</code> 运算符</h4><ul><li><code>new</code><ul><li>调用 <code>operator new</code> 函数申请空间</li><li>在申请的空间上执行构造函数，完成对象的构造</li></ul></li><li><code>delete</code><ul><li>在空间上执行析构函数，完成对象中资源的清理工作</li><li>调用 <code>operator delete</code> 函数释放对象的空间</li></ul></li></ul><h5 id="Placement- 技术"><a href="#Placement- 技术" class="headerlink" title="Placement 技术"></a>Placement 技术 </h5><p> 系统默认的 <code>new</code> 关键字除了分配堆内存外还进行构造函数的调用。而实际中可能有一些已经预先分配好的内存区域，想在这些已经分配好的内存中来构建一个对象。还有一种情况是不希望进行频繁的堆内存分配和释放而只是对同一块内存进行重复的对象构建和销毁</p><h3 id="面向对象"><a href="# 面向对象" class="headerlink" title="面向对象"></a>面向对象 </h3><h4 id="多继承情况下成员变量和函数的内存分布"><a href="# 多继承情况下成员变量和函数的内存分布" class="headerlink" title="多继承情况下成员变量和函数的内存分布"></a> 多继承情况下成员变量和函数的内存分布 </h4><h5 id="单继承"><a href="# 单继承" class="headerlink" title="单继承"></a> 单继承</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span>: <span class="hljs-keyword">public</span> Base {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>;<br>};<br></code></pre></td></tr></table></figure><p>在 msvc 环境下，首先编译源文件 <code>cl /EHsc main.cpp</code>，生成<code>.obj</code> 文件</p><h6 id="基类的内存分布"><a href="# 基类的内存分布" class="headerlink" title="基类的内存分布"></a>基类的内存分布</h6><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cl /d1 reportSingleClassLayoutBase main.cpp<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class _s__RTTIBaseClassDescriptor       size(28):<br>        +---<br> 0      | pTypeDescriptor<br> 4      | numContainedBases<br> 8      | _PMD where<br>20      | attributes<br>24      | pClassDescriptor<br>        +---<br><br>class _s__RTTIBaseClassArray    size(1):<br>        +---<br> 0      | arrayOfBaseClassDescriptors<br>        +---<br><br>class Base      size(12):<br>        +---<br> 0      | {vfptr} // 存在虚函数，需要分配虚表指针的内存大小是 4 个字节<br> 4      | a<br> 8      | b<br>        +---<br><br>Base::$vftable@:<br>        | &amp;Base_meta<br>        |  0<br> 0      | &amp;Base::func1<br><br>Base::func1 this adjustor: 0<br></code></pre></td></tr></table></figure><center>    <img src="/2024/05/13/cf86467b04aa/memory-layout-single-inherit-base.png" alt></center><h6 id="派生类的内存分布"><a href="# 派生类的内存分布" class="headerlink" title="派生类的内存分布"></a>派生类的内存分布</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Derive    size(16):<br>        +---<br> 0      | +--- (base class Base)<br> 0      | | {vfptr}<br> 4      | | a<br> 8      | | b<br>        | +---<br>12      | c<br>        +---<br><br>Derive::$vftable@:<br>        | &amp;Derive_meta<br>        |  0 // 地址偏移量<br> 0      | &amp;Base::func1<br> 1      | &amp;Derive::func3<br><br>Derive::func3 this adjustor: 0<br></code></pre></td></tr></table></figure><center>    <img src="/2024/05/13/cf86467b04aa/memory-layout-single-inherit.png" alt></center><h5 id="多继承"><a href="# 多继承" class="headerlink" title="多继承"></a>多继承</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span>: <span class="hljs-keyword">public</span> Base1, Base2 {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>;<br>};<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Derive    size(24):<br>        +---<br> 0      | +--- (base class Base1)<br> 0      | | {vfptr}<br> 4      | | a<br> 8      | | b<br>        | +---<br>12      | +--- (base class Base2)<br>12      | | {vfptr}<br>16      | | c<br>        | +---<br>20      | d<br>        +---<br><br>Derive::$vftable@Base1@:<br>        | &amp;Derive_meta<br>        |  0<br> 0      | &amp;Base1::func1<br> 1      | &amp;Derive::func3<br><br>Derive::$vftable@Base2@:<br>        | -12 // 地址偏移量，有的是 -8，有的是 -12；当继承第三个类的时候是 -24<br> 0      | &amp;Base2::func2<br><br>Derive::func3 this adjustor: 0<br></code></pre></td></tr></table></figure><blockquote><ul><li>独有的虚函数放到第一个虚函数表中</li><li>只有第一个虚函数表包含元数据行</li><li>继承后派生类自己没有虚函数指针</li></ul></blockquote><h5 id="虚继承"><a href="# 虚继承" class="headerlink" title="虚继承"></a>虚继承</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derive</span>: <span class="hljs-keyword">virtual</span> Base {<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> c;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>};<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">class Derive    size(24):<br>        +---<br> 0      | {vfptr}<br> 4      | {vbptr}<br> 8      | c<br>        +---<br>        +--- (virtual base Base)<br>12      | {vfptr}<br>16      | a<br>20      | b<br>        +---<br><br>Derive::$vftable@Derive@:<br>        | &amp;Derive_meta<br>        |  0<br> 0      | &amp;Derive::func2<br><br>Derive::$vbtable@:<br> 0      | -4<br> 1      | 8 (Derived(Derive+4)Base)<br><br>Derive::$vftable@Base@:<br>        | -12<br> 0      | &amp;Base::func1<br><br>Derive::func2 this adjustor: 0<br>vbi:       class  offset o.vbptr  o.vbte fVtorDisp<br>            Base      12       4       4 0<br></code></pre></td></tr></table></figure><center>    <img src="/2024/05/13/cf86467b04aa/memory-layout-virtual-inherit.png" alt></center><p>虚基类表指针（vbptr），该指针指向了一个虚基类表，虚表中记录了虚基类与本类的偏移地址。通过偏移地址，这样就可以找到虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，从而节省了存储空间</p><h4 id="基类和派生类指针相互赋值"><a href="# 基类和派生类指针相互赋值" class="headerlink" title="基类和派生类指针相互赋值"></a>基类和派生类指针相互赋值</h4><ul><li>在公有派生的情况下，派生类的指针可以直接赋值给基类指针<ul><li>即便基类指针指向的是一个派生类的对象，也不能通过基类指针访问基类没有而派生类中有的成员</li></ul></li><li>基类的指针不能赋值给派生类的指针<ul><li>但是通过强制类型转换，也可以将基类指针强制转换成派生类指针后再赋值给派生类指针</li><li>只是在这种情况下，需要保证被转换的基类指针本来就指向一个派生类的对象，这样才是安全的，否则很容易出错</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CBase</span><br>{<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> n;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">CBase</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">n</span>(i) {}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span> </span>{cout &lt;&lt; <span class="hljs-string">"CBase:n="</span> &lt;&lt; n &lt;&lt; endl; }<br>};<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CDerived</span> :<span class="hljs-keyword">public</span> CBase<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-built_in">CDerived</span>(<span class="hljs-type">int</span> i) :<span class="hljs-built_in">CBase</span>(i), <span class="hljs-built_in">v</span>(<span class="hljs-number">2</span> * i) {}<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Func</span><span class="hljs-params">()</span> </span>{};<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Print</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>{<br>        cout &lt;&lt; <span class="hljs-string">"CDerived:n="</span> &lt;&lt; n &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">"CDerived:v="</span> &lt;&lt; v &lt;&lt; endl;<br>    }<br>};<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>{<br>    <span class="hljs-function">CDerived <span class="hljs-title">objDerived</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    <span class="hljs-function">CBase <span class="hljs-title">objBase</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-comment">// 使得基类指针指向派生类对象</span><br>    <span class="hljs-comment">// pBase-&gt;Func(); // 错，CBase 类没有 Func() 成员函数</span><br>    <span class="hljs-comment">// pBase-&gt;v = 5;  // 错 CBase 类没有 v 成员变量</span><br>    CBase * pBase = &amp;objDerived; <br>    pBase-&gt;<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">"1)------------"</span> &lt;&lt; endl;<br>    <span class="hljs-comment">//CDerived * pDerived = &amp; objBase; // 错，不能将基类指针赋值给派生类指针</span><br>    CDerived * pDerived = (CDerived *)(&amp;objBase);<br>    pDerived-&gt;<span class="hljs-built_in">Print</span>();  <span class="hljs-comment">// 慎用，可能出现不可预期的错误</span><br>    cout &lt;&lt; <span class="hljs-string">"2)------------"</span> &lt;&lt; endl;<br>    objDerived.<span class="hljs-built_in">Print</span>();<br>    cout &lt;&lt; <span class="hljs-string">"3)------------"</span> &lt;&lt; endl;<br>    pDerived-&gt;v = <span class="hljs-number">128</span>;  <span class="hljs-comment">// 往别人的空间里写入数据，会有问题</span><br>    objDerived.<span class="hljs-built_in">Print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="在函数参数中使用未定义的类"><a href="# 在函数参数中使用未定义的类" class="headerlink" title="在函数参数中使用未定义的类"></a>在函数参数中使用未定义的类</h4><ul><li>前向声明：可以声明一个类而不定义它，这个声明被称为前向声明 (forward declaration)</li><li>声明后的类是一个不完全类型（incompete type），不完全类型只能以有限方式使用<ul><li>不能定义该类型的对象</li><li>只能用于定义指向该类型的指针及引用</li><li>用于声明（而不是定义）使用该类型作为形参类型或返回类型的函数</li></ul></li><li>类的前向声明只适用于指针和引用的定义，如果是普通类的类型就得使用<code>include</code></li></ul><h4 id="如何实现接口"><a href="# 如何实现接口" class="headerlink" title="如何实现接口"></a>如何实现接口 </h4><p> 首先给接口类下了定义</p><ul><li>接口类应该是只提供方法声明，而自身不提供方法定义的抽象类</li><li>接口类自身不能实例化，接口类的方法定义 / 实现只能由接口类的子类来完成</li></ul><p>而对于 C++，其接口类一般具有以下特征：</p><ul><li>最好不要有成员变量，但可以有静态常量 <code>static const</code>或<code>enum</code></li><li>要有纯虚接口方法</li><li>要有虚析构函数，并提供默认实现</li><li>不要声明构造函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span><br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> START = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> STOP = <span class="hljs-number">2</span>;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br> <br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">InterfaceTest</span>() = <span class="hljs-keyword">default</span>;<br>}<br></code></pre></td></tr></table></figure><h4 id="struct 可以定义虚函数吗"><a href="#struct 可以定义虚函数吗" class="headerlink" title="struct 可以定义虚函数吗"></a><code>struct</code>可以定义虚函数吗 </h4><p> 就编译器而言，除了默认的可访问性外，<code>struct</code>和 <code>class</code> 之间没有区别。它们只是定义同一事物的两个不同关键字。所以，结构可以有构造函数、析构函数、基类、虚函数等等</p><p>使用 <code>struct</code> 来处理没有这些东西的类（特别是 POD ) 是一个常见的约定，或者更进一步使用 <code>struct</code> 仅适用于根本没有用户定义的成员函数，只有 <code>public</code> 数据成员的类</p><blockquote><p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p></blockquote><h3 id="生命周期"><a href="# 生命周期" class="headerlink" title="生命周期"></a>生命周期 </h3><h4 id="声明变量会分配内存吗"><a href="# 声明变量会分配内存吗" class="headerlink" title="声明变量会分配内存吗"></a> 声明变量会分配内存吗</h4><ul><li>函数或变量在声明时，并没有给它实际的物理内存空间</li><li>函数或变量在定义时，它就在内存中有了实际的物理空间</li><li>函数或变量可以声明多次，但定义只能有一次</li></ul><h4 id="函数栈中包含的内容"><a href="# 函数栈中包含的内容" class="headerlink" title="函数栈中包含的内容"></a>函数栈中包含的内容 </h4><h5 id="函数栈"><a href="# 函数栈" class="headerlink" title="函数栈"></a> 函数栈 </h5><p> 当进程被加载到内存时，会被分成很多段</p><ul><li>代码段：保存程序文本，指令指针 <code>EIP</code> 就是指向代码段，可读可执行不可写，如果发生写操作则会提示 segmentation fault</li><li>数据段：保存初始化的全局变量和静态变量，可读可写不可执行</li><li>BSS：未初始化的全局变量和静态变量</li><li>堆 (Heap)：动态分配内存，向地址增大的方向增长，可读可写可执行</li><li>栈 (Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，可读可写可执行</li><li>环境 / 参数段（environment/argumentssection）：用来存储系统环境变量的一份复制文件，进程在运行时可能需要。例如，运行中的进程，可以通过环境变量来访问路径、shell 名称、主机名等信息。该节是可写的，因此在缓冲区溢出（buffer overflow）攻击中都可以使用该段</li></ul><h6 id="寄存器"><a href="# 寄存器" class="headerlink" title="寄存器"></a>寄存器</h6><ul><li><code>EAX</code>：累加（Accumulator）寄存器，常用于函数返回值</li><li><code>EBX</code>：基址（Base）寄存器，以它为基址访问内存</li><li><code>ECX</code>：计数器（Counter）寄存器，常用作字符串和循环操作中的计数器</li><li><code>EDX</code>：数据（Data）寄存器，常用于乘除法和 I/O 指针</li><li><code>ESI</code>：源变址寄存器</li><li><code>DSI</code>：目的变址寄存器</li><li><code>ESP</code>：堆栈（Stack）指针寄存器，指向堆栈顶部</li><li><code>EBP</code>：基址指针寄存器，指向当前堆栈底部</li><li><code>EIP</code>：指令寄存器，指向下一条指令的地址</li></ul><h5 id="栈帧 -Stack-Frame"><a href="# 栈帧 -Stack-Frame" class="headerlink" title="栈帧 Stack Frame"></a>栈帧 Stack Frame</h5><p>其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息（参数，返回地址，局部变量等）。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP（栈指针）就是一直指向栈顶的。用 <code>%ebp</code> 指向栈底，也就是基址指针；用 <code>%esp</code> 指向栈顶，也就是栈指针</p><center>    <img src="/2024/05/13/cf86467b04aa/stack-frame.webp" alt></center><p>一般来说，将 <code>%ebp</code> 到<code>%esp</code>之间区域当做栈帧（也有人认为该从函数参数开始，不过这不影响分析）。并不是整个栈空间只有一个栈帧，<strong>每调用一个函数，就会生成一个新的栈帧 </strong>。在函数调用过程中，将调用函数的函数称为<em> 调用者（caller）</em>，将被调用的函数称为 <em> 被调用者（callee）</em>。</p><ul><li><em>调用者 </em> 需要知道在哪里获取 <em> 被调用者 </em> 返回的值</li><li><em>被调用者 </em> 需要知道传入的参数在哪里，返回的地址在哪里</li><li>需要保证在 <em> 被调用者 </em> 返回后，<code>%ebp</code>、<code>%esp</code>等寄存器的值应该和调用前一致，需要使用栈来保存这些数据</li></ul><h4 id="线程个数由什么决定"><a href="# 线程个数由什么决定" class="headerlink" title="线程个数由什么决定"></a>线程个数由什么决定 </h4><p> 线程数和 CPU 核心数可以没有任何关联，但当需要利用线程充分发挥多核威力时，通常情况下创建的线程数与核数要保持一种线性关系，最佳系数通常需要测试才能得到</p><h4 id="RAII- 的用途"><a href="#RAII- 的用途" class="headerlink" title="RAII 的用途"></a>RAII 的用途</h4><h5 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h5><p>RAII 是 Resource Acquisition Is Initialization 的缩写，即“资源获取即初始化”。它是 C++ 语言的一种管理资源、避免资源泄漏的惯用法，利用栈对象自动销毁的特点来实现，可以通过构造函数获取资源，通过析构函数释放资源</p><ul><li>将每一种资源封装在一个 RAII 类中<ul><li>所有资源在构造函数中获取，例如：分配内存、打开文件、建立数据库连接等；如果无法完成则在构造函数中抛出异常</li><li>所有资源在析构函数中释放，例如：释放内存、关闭文件、销毁数据库连接等；不应该抛出任何异常</li></ul></li><li>通过 RAII 类实例获取资源<ul><li>具有自动生命管理周期或临时对象生命周期</li><li>其生命周期与第一种绑定</li></ul></li></ul><h5 id="为什么要使用 -RAII"><a href="# 为什么要使用 -RAII" class="headerlink" title="为什么要使用 RAII"></a>为什么要使用 RAII</h5><p>在 C++ 中，通过 new 运算符动态申请内存，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foo* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">delete</span> ptr;<br></code></pre></td></tr></table></figure><p>在这段代码中，<code>new</code>运算符在计算机内存的堆上申请了一块 <code>Foo</code> 类型的内存，然后将其地址赋值给存储在栈上的指针 <code>ptr</code>。为了能够释放内存资源，需要使用完<code>new</code> 运算符申请的内存后，手动调用 <code>delete</code> 运算符释放内存。但是，情况并不总是如此简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foo* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-built_in">f</span>(ptr);  <span class="hljs-comment">// --&gt;① may throw exception</span><br><span class="hljs-keyword">if</span>(ptr-&gt;<span class="hljs-built_in">g</span>()) {<br>    <span class="hljs-comment">// ... --&gt; ② may forget to delete ptr</span><br>    <span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">delete</span> ptr;<br></code></pre></td></tr></table></figure><ul><li>忘记 <code>delete</code> 释放内存。比如释放原指针指向的内存前就改变了指针的指向</li><li>程序抛出异常后导致无法 <code>delete</code>。比如上面的①处，如果<code>f</code> 函数抛出异常，没有机会运行<code>delete</code>，从而导致内存泄漏</li><li>需求变更后，修改了函数，新增了分支，提前返回，②处却没有<code>delete</code></li><li>现实情况代码复杂的话可能没有这么显而易见</li><li>而通过 RAII 这样一种机制，可以使其自动释放内存</li></ul><h5 id="C-STL- 中 -RAII- 的应用"><a href="#C-STL- 中 -RAII- 的应用" class="headerlink" title="C++ STL 中 RAII 的应用"></a>C++ STL 中 RAII 的应用 </h5><h6 id="智能指针"><a href="# 智能指针" class="headerlink" title="智能指针"></a> 智能指针 </h6><p> 智能指针是 RAII 的一种实现，它是一种模板类，用于管理动态分配的对象。智能指针的主要作用是自动释放内存，从而避免内存泄漏。C++ 11 中提供了三种智能指针：<code>unique_ptr</code>、<code>shared_ptr</code>和 <code>weak_ptr</code>。以<code>unique_ptr</code> 为例，它的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">Deleter</span> = std::default_delete&lt;T&gt; &gt; <span class="hljs-keyword">class</span> unique_ptr;<br></code></pre></td></tr></table></figure><p><code>unique_ptr</code>的析构函数会自动释放内存，因此，可以通过 <code>unique_ptr</code> 来管理动态分配的内存，从而避免内存泄漏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// release memory when ptr is out of scope</span><br>std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; ptr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><h6 id="互斥锁"><a href="# 互斥锁" class="headerlink" title="互斥锁"></a>互斥锁 </h6><p> 在多线程编程中，<code>std::lock_guard</code>, <code>std::unique_lock</code>, <code>std::shared_lock</code>等也利用了 RAII 的原理，用于管理互斥锁。当这些类的等对象创建时，会自动获取互斥锁；当对象销毁时，会自动释放互斥锁</p><p><code>std::lock_guard</code>的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutex</span> &gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">lock_guard</span>;<br></code></pre></td></tr></table></figure><p><code>std::lock_guard</code>的析构函数会自动释放互斥锁，因此，可以通过 <code>std::lock_guard</code> 来管理互斥锁，从而避免忘记释放互斥锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br>std::mutex mtx;<br><span class="hljs-function">std::lock_guard&lt;std::mutex&gt; <span class="hljs-title">lock</span><span class="hljs-params">(mtx)</span></span>; <span class="hljs-comment">// unlock when lock is out of scope</span><br></code></pre></td></tr></table></figure><p>不使用 RAII 的情况下，需要手动释放互斥锁，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::mutex mtx;<br>mtx.<span class="hljs-built_in">lock</span>();<br><span class="hljs-comment">// ...</span><br>mtx.<span class="hljs-built_in">unlock</span>();<br></code></pre></td></tr></table></figure><h6 id="文件操作"><a href="# 文件操作" class="headerlink" title="文件操作"></a>文件操作 </h6><p><code>std::ifstream</code>, <code>std::ofstream</code> 等 C++ 标准库的 IO 操作都是 RAII 的实现</p><h6 id="事务处理"><a href="# 事务处理" class="headerlink" title="事务处理"></a>事务处理 </h6><p> 数据库事务处理中，如果在事务结束时没有提交或回滚，就会导致数据库连接一直被占用，从而导致数据库连接池耗尽。因此，需要在事务结束时自动提交或回滚，从而释放数据库连接。这一过程也可以通过 RAII 来实现</p><h3 id="C- 新特性"><a href="#C- 新特性" class="headerlink" title="C++ 新特性"></a>C++ 新特性 </h3><h4 id="智能指针 -1"><a href="# 智能指针 -1" class="headerlink" title="智能指针"></a> 智能指针 </h4><h3 id="模板"><a href="# 模板" class="headerlink" title="模板"></a> 模板 </h3><h4 id="typename 和 class 的区别"><a href="#typename 和 class 的区别" class="headerlink" title="typename 和 class 的区别"></a><code>typename</code> 和<code>class</code>的区别 </h4><h5 id="typename 独有的功能"><a href="#typename 独有的功能" class="headerlink" title="typename 独有的功能"></a><code>typename</code> 独有的功能 </h5><p> 由于 C++ 允许在类内定义类型别名，且其使用方法与通过类型名访问类成员的方法相同。故而，在类定义不可知的时候，编译器无法知晓类似 <code>Type::foo</code> 的写法具体指的是一个类型还是类内成员</p><p>例如在以下代码中，类模板 <code>Bar</code> 的原意是使用类 <code>Foo</code> 实例化，而后引用其中的 <code>bar_type</code> 定义名为 <code>bar</code> 的类内成员。然而，就 <code>T::bar_type</code> 而言，编译器在编译期无法确定它究竟是不是一个类型。此时就需要 <code>typename</code> 关键字来辅助编译器的判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> <br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> bar_type;<br>};<br><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span><br>{<br>    <span class="hljs-comment">/* typename */</span><br>    T::bar_type bar;<br>};<br></code></pre></td></tr></table></figure><h5 id="class 独有的功能"><a href="#class 独有的功能" class="headerlink" title="class 独有的功能"></a><code>class</code>独有的功能 </h5><p>C++ 的标准模板库中有名为<code>std::stack</code> 的容器适配器，它能适配许多容器作为底层，实现栈的功能。其声明为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> Containter = std::deque&lt;T&gt; &gt;<br><span class="hljs-keyword">class</span> stack;<br></code></pre></td></tr></table></figure><p>因此，在使用中，可以使用 <code>std::stack&lt;int&gt;</code> 来声明一个以 <code>std::deque&lt;int&gt;</code> 保存整型变量的栈；也可以使用 <code>std::stack&lt;int, std::vector&lt;int&gt; &gt;</code>来声明一个以 <code>std::vector&lt;int&gt;</code> 保存整型变量的栈。是否有可能以类似 <code>Stack&lt;int, std::vector&gt;</code>的形式，来达到同样的目的？需要有类似这样的声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T,<br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> E, <span class="hljs-keyword">typename</span> = std::allocater&lt;E&gt; &gt; <span class="hljs-keyword">class</span> Container = std::deque&gt;<br><span class="hljs-keyword">class</span> Stack;<br></code></pre></td></tr></table></figure><p>由于 <code>Container</code> 必须是一个容器类模板，所以，如果不适用具体的模板参数实例化，就必须将其声明为一个类模板。故此，<code>Container</code>之前需要保留标准库中容器类模板的模板参数。注意此处使用了标准库提供的内存分配器</p><p>此处 <code>class</code> 特有的功能，体现在 <code>class Container</code> 之处。此处虽然是在声明 <code>Stack</code> 这个类模板，但是此处的 <code>class</code> 不能替换为<code>typename</code>，否则编译器会报错</p><blockquote><p>指定 <strong> 模板模板 </strong> 时，必须使用 <code>class</code> 关键字，在这种情况下，它不能与 <code>typename</code> 互换</p></blockquote><h4 id="模板泛化、特化、偏特化"><a href="# 模板泛化、特化、偏特化" class="headerlink" title="模板泛化、特化、偏特化"></a>模板泛化、特化、偏特化</h4><ul><li>模板特化按对象类型可分为类模板特化和全局模板函数函数特化</li><li>按特化类型可分为全特化和偏特化<ul><li>偏特化包括范围偏特化和参数数量偏特化</li><li>全局模板函数不支持偏特化，因为函数有重载，所以函数偏特化都是重载</li></ul></li><li>特化的优先级高于泛化<ul><li>编译器会先去匹配特化和偏特化，后去匹配泛化</li></ul></li></ul><h5 id="类模板特化"><a href="# 类模板特化" class="headerlink" title="类模板特化"></a>类模板特化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFun</span> <br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testFun</span>(T1 t1, T2 t2) : <span class="hljs-built_in">a</span>(t1), <span class="hljs-built_in">b</span>(t2) <br>    {<br>        cout &lt;&lt; <span class="hljs-string">"类模板"</span> &lt;&lt; endl;<br>    }<br><span class="hljs-keyword">private</span>:<br>    T1 a;<br>    T2 b;<br>};<br><span class="hljs-comment">// 全特化</span><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFun</span>&lt;<span class="hljs-type">int</span>, string&gt;<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testFun</span>(<span class="hljs-type">int</span> t1, string t2) : <span class="hljs-built_in">a</span>(t1), <span class="hljs-built_in">b</span>(t2)<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"全特化"</span> &lt;&lt; endl;<br>    }<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    string b;<br>};<br><span class="hljs-comment">// 参数数量偏特化</span><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFun</span>&lt;<span class="hljs-type">int</span>, T2&gt;<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testFun</span>(<span class="hljs-type">int</span> t1, T2 t2) : <span class="hljs-built_in">a</span>(t1), <span class="hljs-built_in">b</span>(t2)<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"参数数量偏特化"</span> &lt;&lt; endl;<br>    }<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    T2 b;<br>};<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFun</span>&lt;T1*, T2*&gt;<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testFun</span>(T1* t1, T2* t2) : <span class="hljs-built_in">a</span>(t1), <span class="hljs-built_in">b</span>(t2)<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"范围偏特化，指针偏特化"</span> &lt;&lt; endl;<br>    }<br><span class="hljs-keyword">private</span>:<br>    T1* a;<br>    T2* b;<br>};<br> <br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">testFun</span>&lt;T1 <span class="hljs-type">const</span>, T2 <span class="hljs-type">const</span>&gt;<br>{<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">testFun</span>(T1 t1, T2 t2) : <span class="hljs-built_in">a</span>(t1), <span class="hljs-built_in">b</span>(t2)<br>    {<br>        cout &lt;&lt; <span class="hljs-string">"范围偏特化，const 偏特化"</span> &lt;&lt; endl;<br>    }<br><span class="hljs-keyword">private</span>:<br>    T1 a;<br>    T2 b;<br>};<br></code></pre></td></tr></table></figure><h5 id="函数模板特化"><a href="# 函数模板特化" class="headerlink" title="函数模板特化"></a>函数模板特化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 函数模板</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfun</span><span class="hljs-params">(T1 ta, T2 t2)</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"模板函数"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">// 全特化 1，会被重载，退化为偏特化</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfun</span><span class="hljs-params">(<span class="hljs-type">char</span> ta, string t2)</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"全特化"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">// 全特化 2，不会被重载</span><br><span class="hljs-keyword">template</span>&lt;&gt;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfun</span><span class="hljs-params">(<span class="hljs-type">int</span> ta, string t2)</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"全特化"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">// 偏特化（重载）</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfun</span><span class="hljs-params">(<span class="hljs-type">int</span> t1, T2 t2)</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"偏特化"</span> &lt;&lt; endl;<br>}<br><span class="hljs-comment">/* 不支持 const 范围偏特化</span><br><span class="hljs-comment">template&lt;typename T1, typename T2&gt;</span><br><span class="hljs-comment">void testfun(T1 const t1, T2 const t2) {</span><br><span class="hljs-comment">    cout &lt;&lt; "const 偏特化" &lt;&lt; endl;</span><br><span class="hljs-comment">}*/</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">testfun</span><span class="hljs-params">(T1* t1, T2* t2)</span> </span>{<br>    cout &lt;&lt; <span class="hljs-string">"指针偏特化"</span> &lt;&lt; endl;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="面试" scheme="https://silhouettesforyou.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Unity" scheme="https://silhouettesforyou.github.io/tags/Unity/"/>
    
    <category term="C#" scheme="https://silhouettesforyou.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>RO 项目相关</title>
    <link href="https://silhouettesforyou.github.io/2024/05/09/8015191e61fc/"/>
    <id>https://silhouettesforyou.github.io/2024/05/09/8015191e61fc/</id>
    <published>2024-05-09T10:43:00.000Z</published>
    <updated>2024-07-29T14:23:06.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="客户端自动战斗 -AI"><a href="# 客户端自动战斗 -AI" class="headerlink" title="客户端自动战斗 AI"></a>客户端自动战斗 AI</h2><h3 id="Behaviour-Designer- 行为树插件"><a href="#Behaviour-Designer- 行为树插件" class="headerlink" title="Behaviour Designer 行为树插件"></a>Behaviour Designer 行为树插件</h3><h4 id="AI- 的解决方案"><a href="#AI- 的解决方案" class="headerlink" title="AI 的解决方案"></a>AI 的解决方案</h4><ul><li>编码：反应型 AI<ul><li>状态机</li><li>行为树</li><li>基于规则的系统</li></ul></li><li>求解：协商行 AI<ul><li>A*</li><li>目标导向型行动计划（GOAP）</li><li>层次人物网规划（HTN）</li><li>规划器</li></ul></li><li>学习：机器学习<ul><li>模仿学习</li><li>强化学习</li></ul></li></ul><p>游戏中常见的 AI 解决方案都是反应型 AI，RO 中大量用到反应型 AI 的行为树作为解决方案，这个行为树插件就是 Behaviour Designer</p><h3 id="Behaviour-Designer- 中的 -Task"><a href="#Behaviour-Designer- 中的 -Task" class="headerlink" title="Behaviour Designer 中的 Task"></a>Behaviour Designer 中的 Task</h3><p>简单行为树实际上就是 Task 的集合，Task 有四种不同的类型：</p><ul><li>Action 动作——代表了某种状态，最基本的任务</li><li>Conditional 条件——用来检测是否达到某种条件</li><li>Composite 复合——包含了一系列子任务列表的父任务</li><li>Decorator 修饰符——也是一个父任务，并且只能包含一个子任务，是用来修改子任务的行为。例如将一个子任务运行 10 次（Repeater），或者对子任务的结果取反（Inverter）</li></ul><h4 id="Action- 和 -Conditional- 自定义 -Task"><a href="#Action- 和 -Conditional- 自定义 -Task" class="headerlink" title="Action 和 Conditional 自定义 Task"></a>Action 和 Conditional 自定义 Task</h4><p>一般情况下只会在 Behaviour Designer 中定义 Action 和 Conditional，Composite 和 Decorator 使用提供的就可以，下面的 Action 代码由工具自动生成</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c#">[<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TaskDescriptionAttribute(<span class="hljs-string">"血量属性比较"</span>)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MAISelfCompareByHP</span> : <span class="hljs-title">BehaviorDesigner.Runtime.Tasks.Action</span><br>{<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"是否自己"</span>)</span>]<br>    <span class="hljs-keyword">public</span> BehaviorDesigner.Runtime.SharedBool is_self;<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"目标"</span>)</span>]<br>    <span class="hljs-keyword">public</span> BehaviorDesigner.Runtime.SharedTransform target;<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"值类型 (hp 血量 、hp 百分比）"</span>)</span>]<br>    <span class="hljs-keyword">public</span> MoonClient.MAISelfCompareByHP.MHPValueType hp_value_type;<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"比较类型"</span>)</span>]<br>    <span class="hljs-keyword">public</span> MoonClient.MNumberComparisonType hp_cmp_type;<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"右值"</span>)</span>]<br>    <span class="hljs-keyword">public</span> BehaviorDesigner.Runtime.SharedFloat right_value;<br>    [<span class="hljs-meta">BehaviorDesigner.Runtime.Tasks.TooltipAttribute(<span class="hljs-string">"保存左值结果"</span>)</span>]<br>    <span class="hljs-keyword">public</span> BehaviorDesigner.Runtime.SharedFloat store_left_value;<br>    <span class="hljs-keyword">private</span> MoonClient.MAISelfCompareByHP node;<br>    <span class="hljs-keyword">private</span> MEntity entity;<br>    <span class="hljs-keyword">private</span> MoonClient.MAISelfCompareByHP.MNodeArgs args;<br>   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnAwake</span>()</span><br>    {<br>     entity = MEntityMgr.singleton.GetEntity(<span class="hljs-built_in">ulong</span>.Parse(Owner.gameObject.name));<br>     <span class="hljs-keyword">if</span>(entity == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>     node = <span class="hljs-keyword">new</span> MoonClient.MAISelfCompareByHP();<br>     args = <span class="hljs-keyword">new</span> MoonClient.MAISelfCompareByHP.MNodeArgs();<br>      args.is_self = is_self.swigValue;<br>      args.hp_value_type = hp_value_type;<br>      args.hp_cmp_type = hp_cmp_type;<br>      args.right_value = right_value.swigValue;<br>      args.store_left_value = store_left_value.swigValue;<br>     node.SetNodeArgs(args);<br>    }<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TaskStatus <span class="hljs-title">OnUpdate</span>()</span><br>    {<br>     <span class="hljs-keyword">if</span>(entity == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> TaskStatus.Failure;<br>     <span class="hljs-keyword">return</span> node.Update(entity) ? TaskStatus.Success : TaskStatus.Failure;<br>    }<br>}<br></code></pre></td></tr></table></figure><h4 id="常用的 -Parent-Tasks"><a href="# 常用的 -Parent-Tasks" class="headerlink" title="常用的 Parent Tasks"></a>常用的 Parent Tasks</h4><ul><li><p>Composite 复合类型</p><ul><li>Sequence 将其所有子节点依次执行，也就是说当前一个返回“完成”状态后，再运行先一个子节点 <br>[Image]<br>The sequence task is similar to an “and” operation. It will return failure as soon as one of its child tasks return failure. If a child task returns success then it will sequentially run the next task. If all child tasks return success then it will return success.<br> 和“and”操作符逻辑类似，下面的子任务按照从左到右的顺序执行，如果有一个子任务返回 false，后续子任务都不执行，并且该任务直接返回 false</li><li>Selector 选择其子节点的某一个执行 <br>[Image]<br>The selector task is similar to an “or” operation. It will return success as soon as one of its child tasks return success. If a child task returns failure then it will sequentially run the next task. If no child task returns success then it will return failure.<br> 和“or”操作符逻辑类似，让子任务从左到右依次执行，如果有一个人物返回 true，后续所有人物就不执行，该任务直接返回 true</li><li>Parallel 将其所有子节点都运行一遍</li></ul></li><li><p>Decorator 装饰器类型</p><ul><li>Inverter</li><li>Repeater</li><li>Return Failure 和 Return Success</li></ul><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// ReturnFailure.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TaskStatus <span class="hljs-title">Decorate</span>(<span class="hljs-params">TaskStatus status</span>)</span><br>{<br>    <span class="hljs-comment">// Return failure even if the child task returned success.</span><br>    <span class="hljs-keyword">if</span> (status == TaskStatus.Success) {<br>        <span class="hljs-keyword">return</span> TaskStatus.Failure;<br>    }<br>    <span class="hljs-keyword">return</span> status;<br>}<br><br><span class="hljs-comment">// ReturnSuccess.cs</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TaskStatus <span class="hljs-title">Decorate</span>(<span class="hljs-params">TaskStatus status</span>)</span><br>{<br>    <span class="hljs-comment">// Return success even if the child task returned failure.</span><br>    <span class="hljs-keyword">if</span> (status == TaskStatus.Failure) {<br>        <span class="hljs-keyword">return</span> TaskStatus.Success;<br>    }<br>    <span class="hljs-keyword">return</span> status;<br>}<br></code></pre></td></tr></table></figure><p>无论返回成功还是失败，都是返回相应任务对应的结果</p><ul><li>Until Failure 和 Until Success</li><li>Random Probability</li></ul></li></ul><h3 id="变量相关"><a href="# 变量相关" class="headerlink" title="变量相关"></a>变量相关 </h3><p> 行为树的优点是非常灵活，因为所有任务都是解耦合的，任务之间是不互相依赖的。但是有时候需要提供彼此共享的信息，这是会用到行为树提供的共享变量类型。在需要的 Task 中定义了某个类型，需要在行为树中创建该类型，并在 Task 中引用该类型</p><p>局部变量就是当前行为树可以共享的变量，全局变量就是所有行为树都可以共享的变量，Behaviour Designer 内置的共享变量类型有以下几种：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c#">SharedAnimationCurve<br>SharedBool<br>SharedColor<br>SharedFloat<br>SharedGameObject<br>SharedGameObjectList<br>SharedInt<br>SharedMaterial<br>SharedObject<br>SharedObjectList<br>SharedQuaternion<br>SharedRect<br>SharedString<br>SharedTransform<br>SharedTransformList<br>SharedVector2<br>SharedVector3Int<br>SharedVector3<br>SharedVector3Int<br>SharedVector4<br></code></pre></td></tr></table></figure><h3 id="Behaviour-Designer- 中的共享变量的理解"><a href="#Behaviour-Designer- 中的共享变量的理解" class="headerlink" title="Behaviour Designer 中的共享变量的理解"></a>Behaviour Designer 中的共享变量的理解 </h3><p>Behaviour Designer 的共享变量是一种黑板（Blackboard）设计模式<br> 输入内容的来源取决于行为树用在整个 AI 架构的哪一层，可以是游戏世界的信息，或者是上层模块的输出。输入的形式，可以是分散的（Decentralized），也可以是集中的（Centralized）。举个例子来说，如果我们做一个战士是移动，还是攻击的决策，这是决策层的行为，所以输入内容就是游戏世界的信息，它可能包括战士自身状态（在模块 A 中），敌人状态（在模块 B 中），装备物品情况（在模块 C），地图场景情况（在模块 D 中）等等，所以，当我们搜索和执行行为树时，我们需要从 4 个模块中获取信息来帮助决策，这样的方式就是我上面说的分散的方式，它的好处是调用非常直接（可能是用多个 Singleton 提供的接口），没有数据冗余，缺点是使得行为树对于数据的依赖度太分散。</p><p>集中的方式的话，就是我们可以定义一个数据结构专门用于行为树的输入，将上面提到的需要用到的数据，在进行行为树决策前，先从各个模块中收集到这个数据结构里，然后再递交给行为树使用。集中式的输入减少了输入和行为树之间的接口数量（只和预定义的数据结构通信），但缺点是，存在数据冗余。不过，我们可以看到集中式的数据输入使得行为树的表现更像一个黑盒了（可以伪造数据来测试行为树），这也是我们一直以来想要的。可以参看下面对于两种方式的示意图：<br>在行为树的使用过程中，发现有时候节点和节点间，行为树和行为树之间确实需要有数据共享，比如对于序列（Sequence）节点来说，它的执行行为是依次执行每一个子节点，直白一点说的话，就是执行完一个再执行下一个。一般用到序列的行为，其子节点间总会有一些联系，这里就可能存在节点间通信的问题。再比如，在一些团队 AI 的决策过程中，当前 AI 的行为树决策可能需要参考其他 AI 的决策结果，所以这样就存在了行为树之间需要通信的情况。</p><p>所以，在实践过程中，我们还会定义另一块黑板来负责行为树间和节点间的通信需求，示意图如下</p><h3 id="RO- 中的 MShareData"><a href="#RO- 中的 MShareData" class="headerlink" title="RO 中的 MShareData"></a>RO 中的 <code>MShareData</code></h3><h4 id="可共享的变量类型"><a href="# 可共享的变量类型" class="headerlink" title="可共享的变量类型"></a> 可共享的变量类型</h4><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> MSharedDataType<br>{<br>    kSharedDataInt = <span class="hljs-number">0</span>,<br>    kSharedDataBool,<br>    kSharedDataFloat,<br>    kSharedDataString,<br>    kSharedDataVector,<br>    kSharedDataTransform,<br>    kSharedDataInt64,<br>    kSharedDataTypeCount,<br>};<br></code></pre></td></tr></table></figure><h4 id="AI- 节点中变量名和值的存储"><a href="#AI- 节点中变量名和值的存储" class="headerlink" title="AI 节点中变量名和值的存储"></a>AI 节点中变量名和值的存储 </h4><p> 主要由记录变量名对应的哈希值（其实就是自增值）和存储各个变量类型的数组（类型值数组）建立起来的映射关系，这些数组里以变量名的哈希值作为下标，存储相应的值；主要的变量如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 存储变量名的哈希值，每种变量类型分别记录，读取时根据不同的变量类型读取相应的类型值数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">uint</span>&gt;[] name_hash_ =<br>    <span class="hljs-keyword">new</span> Dictionary&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">uint</span>&gt;[(<span class="hljs-built_in">int</span>)MSharedDataType.kSharedDataTypeCount];<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">uint</span>[] name_index_ =<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[(<span class="hljs-built_in">int</span>)MSharedDataType.kSharedDataTypeCount]; <span class="hljs-comment">//int 型数组里面的值默认初始化为 0</span><br>    <br><span class="hljs-comment">// 声明类型值数组</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> kMaxAIDataCount = <span class="hljs-number">150</span>; <span class="hljs-comment">// 所有变量的数量上限</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">float</span>[] float_var_;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span>[] int_var_;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">long</span>[] long_var_;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">bool</span>[] bool_var_;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">ulong</span>[] trans_var_;<br><span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span>[] string_var_;<br><span class="hljs-keyword">private</span> Vector3[] vector3_var_;<br><br><span class="hljs-comment">/* 默认初始化 </span><br><span class="hljs-comment"> * bool --&gt; false</span><br><span class="hljs-comment"> * int、float --&gt; 0</span><br><span class="hljs-comment"> * 其他值类型 --&gt; 该类型字段默认值</span><br><span class="hljs-comment"> * 引用类型（包括 string) --&gt; null</span><br><span class="hljs-comment">*/</span><br>float_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[kMaxAIDataCount];<br>int_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[kMaxAIDataCount];<br>long_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">long</span>[kMaxAIDataCount];<br>bool_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">bool</span>[kMaxAIDataCount];<br>trans_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ulong</span>[kMaxAIDataCount];<br>string_var_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[kMaxAIDataCount];<br>vector3_var_ = <span class="hljs-keyword">new</span> Vector3[kMaxAIDataCount];<br></code></pre></td></tr></table></figure><p>运行时通过以下映射关系读取对应 AI 节点中的变量值</p><center>    <img src="/2024/05/09/8015191e61fc/type-map.png" alt></center><h4 id="PB- 数据"><a href="#PB- 数据" class="headerlink" title="PB 数据"></a>PB 数据 </h4><h5 id="客户端行为树的 -Node- 生成"><a href="# 客户端行为树的 -Node- 生成" class="headerlink" title="客户端行为树的 Node 生成"></a> 客户端行为树的 Node 生成</h5><ul><li><p>主要解析运行时 AI 代码的源文件，遍历 Assets/Scripts/MoonClient/AI/Node 目录下所有。cs 文件，源文件中每个类都继承自 MAINodeAction 或者 MAINodeAction，根据基类的不同导出不同类型的节点<br>[Image]</p></li><li><p>根据类中定义 MNodeArgs 的成员变量添加 public 成员变量，成员变量的类型根据下面的字典映射</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Dictionary&lt;Type, Type&gt; typeRemapDict = <span class="hljs-keyword">new</span> Dictionary&lt;Type, Type&gt;()<br>{<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">int</span>), <span class="hljs-keyword">typeof</span>(SharedInt) },<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">long</span>), <span class="hljs-keyword">typeof</span>(SharedLong) },<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">ulong</span>), <span class="hljs-keyword">typeof</span>(SharedULong) },<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">float</span>), <span class="hljs-keyword">typeof</span>(SharedFloat) },<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">string</span>), <span class="hljs-keyword">typeof</span>(SharedString) },<br>    {<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">bool</span>), <span class="hljs-keyword">typeof</span>(SharedBool) },<br>    {<span class="hljs-keyword">typeof</span>(UnityEngine.Vector3), <span class="hljs-keyword">typeof</span>(SharedUnityVector3) },<br>    {<span class="hljs-keyword">typeof</span>(ROGameLibs.Vector3), <span class="hljs-keyword">typeof</span>(SharedVector3) },<br>    {<span class="hljs-keyword">typeof</span>(SWIGTYPE_p_Vector3), <span class="hljs-keyword">typeof</span>(SharedVector3) },<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LIBS_EDITOR</span><br>    {<span class="hljs-keyword">typeof</span>(SWIGTYPE_p_ROObject), <span class="hljs-keyword">typeof</span>(SharedTransform) },<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    {<span class="hljs-keyword">typeof</span>(MoonClient.MEntity), <span class="hljs-keyword">typeof</span>(SharedTransform) },<br>    {<span class="hljs-keyword">typeof</span>(IntVector), <span class="hljs-keyword">typeof</span>(SharedIntList) },<br>    {<span class="hljs-keyword">typeof</span>(LongVector), <span class="hljs-keyword">typeof</span>(SharedLongList) },<br>    {<span class="hljs-keyword">typeof</span>(FloatVector), <span class="hljs-keyword">typeof</span>(SharedFloatList) },<br>    {<span class="hljs-keyword">typeof</span>(StringVector), <span class="hljs-keyword">typeof</span>(SharedStringList) },<br>    {<span class="hljs-keyword">typeof</span>(ULongVector), <span class="hljs-keyword">typeof</span>(SharedULongList) },<br>};<br></code></pre></td></tr></table></figure></li><li><p>同时根据属性 NodeComment，设置编辑器中变量的悬浮注释</p></li><li><p>固定格式的代码段</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> MoonClient.XXX node; <span class="hljs-comment">// XXX 为源文件类名</span><br><span class="hljs-keyword">private</span> MEntity entity;<br><span class="hljs-keyword">private</span> MoonClient.XXX.MNodeArgs args; <span class="hljs-comment">// XXX 为源文件类名</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnAwake</span>()</span><br>{<br>    entity = MEntityMgr.singleton.GetEntity(<span class="hljs-built_in">ulong</span>.Parse(Owner.  gameObject.name));<br>    <span class="hljs-keyword">if</span>(entity == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    node = <span class="hljs-keyword">new</span> MoonClient.MAIAutoFollow();<br>    args = <span class="hljs-keyword">new</span> MoonClient.MAIAutoFollow.MNodeArgs();<br>    <span class="hljs-comment">// args.follow_target_radius = follow_target_radius.swigValue;</span><br>    <span class="hljs-comment">// args.teleport_distance = teleport_distance.swigValue;</span><br>    <span class="hljs-comment">// 源文件中 MNodeArgs 的成员变量赋值</span><br>    node.SetNodeArgs(args);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> TaskStatus <span class="hljs-title">OnUpdate</span>()</span><br>{<br>    <span class="hljs-keyword">if</span>(entity == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> TaskStatus.Failure;<br>    <span class="hljs-keyword">return</span> node.Update(entity) ? TaskStatus.Success : TaskStatus.  Failure;<br>}<br></code></pre></td></tr></table></figure></li></ul><h3 id="运行时 -AI"><a href="# 运行时 -AI" class="headerlink" title="运行时 AI"></a>运行时 AI</h3><h4 id="初始化"><a href="# 初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>初始化 AI 组件：MPlayer::InitComponents</li><li>初始化行为树：MAIComponent::InitBehaviorTree<ul><li>初始化所有玩家通用的 AI 树：MAIBehaviorTree::Init<ul><li>加载 PlayerAI/Player_Auto_AI.bytes 文件：MAITreeManager::LoadFile</li><li>构造 AI 树：MAITreeManager::BuildAITree</li><li>递归构造节点：MAITreeManager::BuildOneNode<ul><li>未初始化时，初始化所有节点类型对象的委托：MAINodeFactory::CreateAINodeByName</li><li>初始化完成即调用，解析 PB 初始化节点</li></ul></li></ul></li></ul></li></ul><h4 id="调用逻辑"><a href="# 调用逻辑" class="headerlink" title="调用逻辑"></a>调用逻辑</h4><ul><li>在 MAIComponent::Update 每次 Update 满足一定条件后都执行一次_behaviorTree.Tick(Entity)</li><li>每次 tick 都从 AINode 的 RootNode 递归到每个子节点，执行相应业务逻辑节点的 Update 函数中的逻辑</li></ul><h4 id="客户端如何进行自动释放"><a href="# 客户端如何进行自动释放" class="headerlink" title="客户端如何进行自动释放"></a>客户端如何进行自动释放</h4><ul><li>策划会在行为树中配置一些列的条件（顺序执行或选择执行）<ul><li>自动跟随的距离</li><li>Entity 类型限制</li><li>战斗半径大小</li><li>变身情况</li><li>…</li></ul></li><li>依次遍历装配在自动战斗槽位的技能（1~6）</li><li>当第 i 个槽位有装配技能时，根据技能 id 读取技能表中配置的<code>AITreeName</code></li><li>将查询到的 <code>AITreeName</code> 放置到 <code>tree_name</code> 共享变量中</li><li>再通过 <code>MAIDynamicTreeReference</code> 读取 <code>tree_name</code> 中的值，并读取改节点树的 PB，合并到当前 <code>MAIDynamicTreeReference</code> 的父节点上</li><li>读取到相关技能节点树后，根据策划的配置条件，满足后可释放<ul><li>技能是否存在</li><li>释放技能后，是否存在不可叠加的 buff</li><li>…</li></ul></li><li>释放技能：通过 <code>MWaitingDataMgr</code> 添加可释放的技能到待执行队列中，每次 update 走技能释放逻辑</li></ul><h3 id="相关改进"><a href="# 相关改进" class="headerlink" title="相关改进"></a>相关改进 </h3><p> 线上 bug：某些职业释放技能后，已经上了不可叠加的 buff（buff 效果消失之前不能够重复释放改技能），但是客户端的 AI 依然会继续持续释放，造成抽搐的表现（偶现问题没有查到具体原因）<br>解决方案：更改 <code>MAICastSkill</code> 节点，释放次数超过一定数值，不可释放该技能</p><h2 id="附身"><a href="# 附身" class="headerlink" title="附身"></a>附身 </h2><h3 id="需求"><a href="# 需求" class="headerlink" title="需求"></a> 需求</h3><ul><li>技能：灵喵附身</li><li>技能描述：喵喵附身于选中的队友身上，每秒消耗 5 点自然力量，持续 20 秒，自身处于无敌状态，且将自身 10% 的六维属性附加于附身的队友</li></ul><h3 id="实现方式"><a href="# 实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li><p>释放技能为角色添加 Buff</p></li><li><p>客户端根据 Buff 状态类型进行判断，如果是附身 Buff 状态类型</p><ul><li>附身目标只有一个，取服务器发过来的第一个 Buff 相关目标（区别于 Buff 目标）的 uid</li><li>在 <code>MBuffComponent</code> 组件中记录该 uid</li><li>广播 <code>StopMove</code> 事件，让玩家无法移动</li><li>设置玩家的位置、朝向与被附身的玩家一致</li></ul></li><li><p>屏蔽玩家的碰撞体，使玩家和被附身的人保持一致</p></li><li><p>在 <code>MHideComponent</code> 组件中，将玩家设置为半透明状态</p></li><li><p>控制移动</p><ul><li><p>屏蔽摇杆和点击地面的移动效果</p></li><li><p>在 <code>MMoveComponent</code> 组件的 Update 中，每帧设置玩家的移动距离改为和被附身的玩家做差</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> buffFollowTarget = Entity.BuffFollowTarget;<br><span class="hljs-keyword">if</span> (buffFollowTarget != <span class="hljs-literal">null</span>)<br>{<br>    Entity.AppendMove(buffFollowTarget.Position - Entity.Position);<br>}<br><span class="hljs-keyword">else</span><br>{<br>    Entity.AppendMove(Entity.ServerPos - Entity.Position);<br>}<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Odin-OdinMenuTree"><a href="#Odin-OdinMenuTree" class="headerlink" title="Odin OdinMenuTree"></a>Odin OdinMenuTree</h2><h2 id="UI- 框架"><a href="#UI- 框架" class="headerlink" title="UI 框架"></a>UI 框架</h2><h3 id="Windows- 生命周期"><a href="#Windows- 生命周期" class="headerlink" title="Windows 生命周期"></a>Windows 生命周期</h3><ul><li>打开 UI：Active -&gt; BindEvents -&gt; OnActive -&gt; OnShow -&gt; AfterShow</li><li>关闭 UI：Deactive -&gt; UnBindEvents -&gt; OnHide -&gt; OnDeActive -&gt; AfterOnDeActive -&gt; ReleaseAll</li></ul><h3 id="UIBase"><a href="#UIBase" class="headerlink" title="UIBase"></a><code>UIBase</code></h3><ul><li><code>OnLoad</code>：加载资源<ul><li><code>baseloadCallback</code>：资源加载成功后的回调</li><li><code>Init</code>：初始化</li></ul></li><li><code>OnBindPanel</code>：绑定预制</li><li><code>OnUnload</code>：释放资源，关闭界面或者切换语言</li><li><code>Init</code>：<code>OnUnload</code>后调用</li><li><code>Uninit</code>：<code>UnLoad</code>或关闭游戏进程后调用</li><li><code>OnActive</code>：<code>Active</code>后调用</li><li><code>OnDeActive</code>：<code>DeActive</code>后调用</li><li><code>OnShow</code></li><li><code>AfterShow</code>：当上层界面完全关闭后调用</li><li><code>OnHide</code></li><li><code>BindEvents</code>：<code>Active</code>后，<code>OnActive</code>之前调用</li><li><code>Update</code></li><li><code>UpdateInput</code></li><li><code>OnLogout</code></li><li><code>OnReconnected</code></li></ul><h3 id="UIManager"><a href="#UIManager" class="headerlink" title="UIManager"></a><code>UIManager</code></h3><ul><li>UIManager 打开关闭界面以组的方式进行处理。<ul><li>所有的组信息都会进栈进行管理。</li><li>会根据配置来确定这个组里面有哪些界面</li><li>没做配置的界面会把这一个界面当成一组</li><li>支持静态配置和打开界面时传递动态配置</li></ul></li></ul><blockquote><ul><li><code>ActiveUI</code>打开某个 Window 函数入口</li><li>通过 <code>require</code> 指定 Window 名字，并进行初始化<code>UI[panelClassName].new()</code></li><li>为当前 Window 添加<code>groupName</code></li><li><code>_createUIPanelConfig</code> 生成 UIPanel 配置，得到界面的配置数据</li><li><code>ActiveUIPanelInGroup</code> 打开界面时对栈进行处理</li></ul></blockquote><h4 id="设置 -UI- 层级（UILayer）"><a href="# 设置 -UI- 层级（UILayer）" class="headerlink" title="设置 UI 层级（UILayer）"></a>设置 UI 层级（UILayer）</h4><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">---@class UILayer</span><br>UILayer = {<br>    Normal = <span class="hljs-number">0</span>,   <span class="hljs-comment">-- 20</span><br>    Function = <span class="hljs-number">1</span>, <span class="hljs-comment">-- 40</span><br>    Tips = <span class="hljs-number">2</span>,     <span class="hljs-comment">-- 60</span><br>    Guiding = <span class="hljs-number">3</span>,  <span class="hljs-comment">-- 80</span><br>    Top = <span class="hljs-number">4</span>       <span class="hljs-comment">-- 100</span><br>}<br></code></pre></td></tr></table></figure><h4 id="界面类型（ActiveType）"><a href="# 界面类型（ActiveType）" class="headerlink" title="界面类型（ActiveType）"></a>界面类型（ActiveType）</h4><ul><li><code>None</code>：不做任何处理</li><li><code>Normal</code>：显示时会把这个界面加入主界面组中（NormalLayer -&gt; MainPanelsGroupGroup，无视设置的 UILayer 放到 NormalLayer）</li><li><code>Exclusive</code>：显示时会隐藏前面的组（隐藏 Normal Exclusive 类型 UI，Layer 无关）</li><li><code>Standalone</code>：显示后不会被 Exclusive 类型隐藏</li></ul><h2 id="剧本解析"><a href="# 剧本解析" class="headerlink" title="剧本解析"></a>剧本解析 </h2><h3 id="代码结构"><a href="# 代码结构" class="headerlink" title="代码结构"></a> 代码结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">clientcode\CSProject\MoonClient\CommandSystem:. <br>│  CommandBlock.cs 创建以及执行 Block 的方法都会在这里<br>│  CommandBlockManager.cs 上下文环境管理，变量储存<br>│  CommandBlockTriggerManager.cs 触发器管理<br>│  CommandConst.cs 所有与命令相关的常量都会记录在这里<br>│   <br>├─Attribute 静态语法检查<br>│      CommandArgsAttribute.cs <br>│      CommandCheckAttribute.cs <br>│       <br>├─Checker 静态语法检查<br>│      CommandBlockChecker.cs <br>│       <br>├─Commands C# 命令<br>│  │  BaseCommand.cs <br>│  │  LuaCommand.cs <br>│  │   <br>│  ├─NPC <br>│  │      ChangeEmotionCommand.cs <br>│  │      .​.. 省略<br>│  │       <br>│  ├─Other <br>│  │      FindElfCommand.cs <br>│  │      ShowModelAlarmCommand.cs <br>│  │       <br>│  └─System <br>│          AddLocalBuffCommand.cs <br>│          .​.. 省略<br>│           <br>├─Compile 二进制编译<br>│      CommandBlockBinaryCompiler.cs <br>│      CommandBlockParser.cs <br>│       <br>├─Data PB 数据结构以及动态参数解析<br>│      BaseArg.cs <br>│      BlockIndexArg.cs <br>│      BlockVarArg.cs <br>│      CommandBlockArg.cs <br>│      CommandBlockStringArg.cs <br>│      CommandData.cs <br>│      CommandLuaArg.cs <br>│      ExpressionArg.cs <br>│      FunctionArg.cs <br>│      ValueArg.cs <br>│       <br>├─Expression 表达式词法解析器<br>│      EOFToken.cs <br>│      IdentifierToken.cs <br>│      Lexer.cs <br>│      LuaConverter.cs <br>│      NumberToken.cs <br>│      StringToken.cs <br>│      Token.cs <br>│       <br>└─Trigger 触发器相关<br>    │  CommandTrigger.cs <br>    │   <br>    └─Event 触发器事件埋点<br>            BaseEvent.cs <br>            OnCollectSuccEvent.cs <br>            OnDamagedByPlayerEvent.cs <br>            OnEnterDungeons.cs <br>            OnExitDungeons.cs <br>            OnKilledByPlayerEvent.cs <br>            OnNpcCreateEvent.cs <br>            OnNpcDestroyEvent.cs <br>            OnStartCollectEvent.cs<br></code></pre></td></tr></table></figure><p>在 <code>ScriptHandle</code> 函数解析每一行剧本时确定是用 C# 中的 <code>BaseCommand</code> 还是 Lua 中的 <code>LuaCommand</code> 进行解析</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 只有在列出的类型或者 Lua 类型才会通过池子进行复用</span><br><span class="hljs-keyword">if</span> (CommandConst.CommandTypeDict.TryGetValue(dacommandType, <span class="hljs-keyword">out</span> <span class="hljs-keyword">var</span> type))<br>{<br>    command = UUIDObjectPool.Get(type) <span class="hljs-keyword">as</span> BaseCommand;<br>}<br><span class="hljs-keyword">else</span><br>{<br>    <span class="hljs-keyword">var</span> luaCommand = UUIDObjectPool.Get(<span class="hljs-keyword">typeof</span>(LuaCommand)) <span class="hljs-keyword">as</span> LuaCommand;<br>    luaCommand?.SetCodeId(data.commandType);<br>    command = luaCommand;<br>}<br></code></pre></td></tr></table></figure><h3 id="解析特殊表达式"><a href="# 解析特殊表达式" class="headerlink" title="解析特殊表达式"></a>解析特殊表达式</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// Arg 数字 | 任意字符 | LUA&lt;&lt; 函数名 &gt;&gt; | &lt;&lt; 函数名 &gt;&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">string</span> ArgsRegex = <span class="hljs-string">@"{{Arg(\d+?)}}|{{(.+?)}}|LUA&lt;&lt;(.+?)&gt;&gt;|&lt;&lt;(.+?)&gt;&gt;"</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> CommandBlockStringArg <span class="hljs-title">Init</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> origin</span>)</span><br>{<br>    OriginString = origin;<br>    <span class="hljs-keyword">if</span> (origin == <span class="hljs-literal">null</span>)<br>    {<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    }<br>    _formatString = origin;<br>    <span class="hljs-built_in">int</span> argNum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> argMatch = Regex.Matches(_formatString, ArgsRegex);<br>    <span class="hljs-keyword">foreach</span> (Match match <span class="hljs-keyword">in</span> argMatch)<br>    {<br>        <span class="hljs-keyword">var</span> blockArgValue = match.Groups[<span class="hljs-number">1</span>].Value;<br>        <span class="hljs-keyword">var</span> blockVarValue = match.Groups[<span class="hljs-number">2</span>].Value;<br>        <span class="hljs-keyword">var</span> luaValue = match.Groups[<span class="hljs-number">3</span>].Value;<br>        <span class="hljs-keyword">var</span> exprValue = match.Groups[<span class="hljs-number">4</span>].Value;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(blockArgValue))<br>        {<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>.TryParse(blockArgValue, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> index))<br>            {<br>                <span class="hljs-keyword">var</span> arg = MCommonObjectPool&lt;BlockIndexArg&gt;.Get().Init(index);<br>                _formatArgs.Add(arg);<br>                _formatString = _formatString.Replace(match.Groups[<span class="hljs-number">0</span>].Value, <span class="hljs-string">$"{{<span class="hljs-subst">{argNum}</span>}}"</span>);<br>                argNum++;<br>            }<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(blockVarValue))<br>        {<br>            <span class="hljs-keyword">var</span> arg = MCommonObjectPool&lt;BlockVarArg&gt;.Get().Init(blockVarValue);<br>            _formatArgs.Add(arg);<br>            _formatString = _formatString.Replace(match.Groups[<span class="hljs-number">0</span>].Value, <span class="hljs-string">$"{{<span class="hljs-subst">{argNum}</span>}}"</span>);<br>            argNum++;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(luaValue))<br>        {<br>            <span class="hljs-keyword">var</span> arg = MCommonObjectPool&lt;CommandLuaArg&gt;.Get().Init(luaValue);<br>            _formatArgs.Add(arg);<br>            _formatString = _formatString.Replace(match.Groups[<span class="hljs-number">0</span>].Value, <span class="hljs-string">$"{{<span class="hljs-subst">{argNum}</span>}}"</span>);<br>            argNum++;<br>        }<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">string</span>.IsNullOrEmpty(exprValue))<br>        {<br>            <span class="hljs-keyword">var</span> arg = MCommonObjectPool&lt;ExpressionArg&gt;.Get().Init(exprValue);<br>            _formatArgs.Add(arg);<br>            _formatString = _formatString.Replace(match.Groups[<span class="hljs-number">0</span>].Value, <span class="hljs-string">$"{{<span class="hljs-subst">{argNum}</span>}}"</span>);<br>            argNum++;<br>        }<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>}<br></code></pre></td></tr></table></figure><h2 id="UI-Renderer-Texture"><a href="#UI-Renderer-Texture" class="headerlink" title="UI Renderer Texture"></a>UI Renderer Texture</h2><h3 id="使用 -URP- 管线进行 -RT- 渲染"><a href="# 使用 -URP- 管线进行 -RT- 渲染" class="headerlink" title="使用 URP 管线进行 RT 渲染"></a>使用 URP 管线进行 RT 渲染</h3><ul><li><code>CreatUIModelData</code>：RtModelAssistant[RT 动效助手] 进行模型创建<ul><li><code>MModel.OriginData</code>设置相关数据</li><li><code>Layer</code>设置为 <code>ID_RTFACTORY</code>，只渲染<code>ID_RTFACTORY</code> 层</li></ul></li><li><code>MUIRTData</code>：定义 RT 渲染设置数据<ul><li><code>RawImage</code></li><li>相机位置</li><li>描边</li><li>阴影</li><li>反射</li><li>大小</li></ul></li><li><code>CreateRawImageRT</code><ul><li>创建新的 RawImage</li><li>创建新的 RTStage，用于管理 RT<ul><li><code>RTCamera.Init</code><ul><li>加载 Camera 预制（UIRTCamera）</li><li>Culling Mask</li><li>位置</li><li>projectionMatrix</li><li>targetTexture</li><li>替他<ul><li>阴影</li><li>反射</li></ul></li></ul></li></ul></li><li>RawImage 与 RTStage 绑定</li></ul></li><li>UIRTCamera（采用 UniversalRenderPipelineAsset_RTRenderer 管线配置）<ul><li>由于设定了 Culling Mask，相机只会照到需要渲染的物体</li></ul></li></ul><h4 id="自定义 MCBRTRendererFeature"><a href="# 自定义 MCBRTRendererFeature" class="headerlink" title="自定义 MCBRTRendererFeature"></a>自定义<code>MCBRTRendererFeature</code></h4><ul><li><p>调用 <code>CreatUIModelData</code> 时会存储 Rt 和对其应的渲染数据<code>RawImageRtDataDicAdd</code></p></li><li><p><code>UpdateRawImageRT</code> 处理模型的 renders</p><ul><li>收集全部 renders</li><li>收集不透明材质的 renders</li></ul></li><li><p><code>UpdateRendererByRawImage</code> 开始真正的渲染</p><ul><li>渲染 All Renders<ul><li>初始化<code>CBRTData</code></li><li><code>RenderEx</code><ul><li>检查设备是否支持<code>RenderTextureFormat.ARGB32</code></li><li>texture 大小是否为正数</li><li><code>GetRenderTexture</code><ul><li><code>CameraMode</code> 相机模式</li><li><code>OutlineRenderer</code>Shader 传入相机位置属性标记<code>_CameraPos</code></li><li><code>data.pMatrix.m00 /= aspect;</code></li><li>判断是否可以使用共享 RT <code>_sharedRT</code><ul><li><code>_sharedRT</code>会在 <code>Awake</code> 时初始化为 <code>Vector2.one</code> 的大小</li><li>不使用共享 RT 时，则会根据传入的 <code>width</code> 和<code>height</code>大小获取 texture <code>RenderTexture.GetTemporary</code></li></ul></li><li>创建渲染队列</li><li>设置材质的标识符和 rt 关联</li></ul></li></ul></li></ul></li><li>描边、阴影、描边<ul><li>因为在场景中模型的材质和 UI 中用的材质不一样所以需要替换一下</li><li><code>MResLoader.singleton.CreateMatFromPool(MShaderUtil.EffectOutlineMaterialPath);</code></li><li>记录到 <code>CBRTQuene</code> 的<code>materialDict</code>中</li></ul></li></ul></li><li><p><code>MCBRTRenderPass</code>执行 URP 管线中的 <code>Excute</code> 函数，通过 <code>CommandBuff</code> 进行绘制</p><ul><li>不使用共享 RT 绘制，绘制单个 RT<ul><li>设置渲染目标 <code>SetRenderTarget</code> texture 为初始化 CBRT 队列时传入的 texture</li><li>清除渲染状态 <code>ClearRenderTarget</code></li><li>调用绘制函数 <code>DrawRenderers</code></li></ul></li><li>开启了共享 RT 绘制的会继续绘制共享 RT<ul><li>设置渲染目标 <code>SetRenderTarget</code> texture 为<code>_sharedRT</code></li><li>清除渲染状态 <code>ClearRenderTarget</code></li><li>调用绘制函数 <code>DrawRenderers</code></li></ul></li></ul></li><li><p>绘制 <code>DrawRenderers</code></p><ul><li>设置自定义 MVP 矩阵</li><li>根据 Render 的材质生成 <code>CommandBuffer</code> 列表</li><li>根据 <code>renderQueue</code> 和<code>CameraDistance</code>对 <code>CommandBuffer</code> 列表进行排序</li><li>调用 <code>DrawRenderer</code> 进行渲染</li></ul></li><li><p>每帧进行 <code>_sharedRT</code> 大小检测，超出 256 进行扩容</p>  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">LateUpdate</span>()</span><br>{<br>    <span class="hljs-comment">//if (_temporaryCBRTs.Count &gt; _GCThreshold)</span><br>    {<br>        <span class="hljs-comment">// 当池中数量超过阈值时触发清空空队列，提升一些性能</span><br>        ReleaseEmpty();<br>    }<br>    <span class="hljs-comment">// 合并 RT 图集</span><br>    List&lt;CBRTQuene&gt; rtQuenes = MListPool&lt;CBRTQuene&gt;.Get();<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> rtQuene <span class="hljs-keyword">in</span> _CBRTQuenes)<br>    {<br>        <span class="hljs-keyword">if</span> (rtQuene.isValid &amp;&amp; rtQuene.isRTAltas &amp;&amp; rtQueneIsInActiveRawImage())<br>        {<br>            rtQuenes.Add(rtQuene);<br>        }<br>    }<br>    <span class="hljs-keyword">if</span> (rtQuenes.Count == <span class="hljs-number">0</span>)<br>    {<br>        ResizeShareRT(Vector2.one);<br>        MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    rtQuenes.Sort((x, y) =&gt; y.clipRect.width.CompareTo(xclipRect.width));<br>    <span class="hljs-comment">// clipRect 计算 x y</span><br>    Vector2 targetSize = <span class="hljs-keyword">new</span> Vector2(<span class="hljs-number">256</span>, <span class="hljs-number">256</span>);<br>    <span class="hljs-built_in">bool</span> loop = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 重新计算</span><br>    <span class="hljs-keyword">while</span> (loop)<br>    {<br>        Vector2 position = Vector2.zero;<br>        <span class="hljs-built_in">float</span> nextX = <span class="hljs-number">0.0f</span>;<br>        loop = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> rtQuene <span class="hljs-keyword">in</span> rtQuenes)<br>        {<br>            <span class="hljs-comment">// 一个 ClipRect.height 高超出 y，则 y *= 2</span><br>            <span class="hljs-keyword">if</span> (rtQuene.clipRect.height &gt; targetSize.y)<br>            {<br>                loop = <span class="hljs-literal">true</span>;<br>                targetSize.y *= <span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            <span class="hljs-comment">// 高超出了 y，则下一列</span><br>            <span class="hljs-keyword">if</span> (position.y + rtQuene.clipRect.height &gt;targetSize.y)<br>            {<br>                position.x = nextX;<br>                position.y = <span class="hljs-number">0</span>;                        <br>            }<br>            rtQuene.clipRect.x = position.x;<br>            rtQuene.clipRect.y = position.y;<br>            nextX = Mathf.Max(nextX, position.x + rtQueneclipRect.width);<br>            <span class="hljs-comment">// nextX 超出 x</span><br>            <span class="hljs-keyword">if</span> (nextX &gt; targetSize.x)<br>            {<br>                loop = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 先扩展 x</span><br>                <span class="hljs-keyword">if</span> (targetSize.x &lt;= targetSize.y)<br>                {<br>                    targetSize.x += <span class="hljs-number">256</span>;<br>                }<br>                <span class="hljs-comment">// 再扩展 y</span><br>                <span class="hljs-keyword">else</span><br>                {<br>                    targetSize.y += <span class="hljs-number">256</span>;<br>                }<br>                <span class="hljs-keyword">break</span>;<br>            }<br>            position.y += rtQuene.clipRect.height;<br>        }<br>    }<br>    ResizeShareRT(targetSize);<br>    <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> rtQuene <span class="hljs-keyword">in</span> rtQuenes)<br>    {<br>        rtQuene.renderTexture = _sharedRT;<br>        rtQuene.AltasComplete();<br>    }<br>    MListPool&lt;CBRTQuene&gt;.Release(rtQuenes);<br>}<br></code></pre></td></tr></table></figure></li></ul><blockquote><p><a href="https://docs.unity3d.com/ScriptReference/RenderTexture.GetTemporary.html">RenderTexture.GetTemporary</a></p><p>Allocate a temporary render texture.</p><p>This function is optimized for when you need a quick RenderTexture to do some temporary calculations. Release it using ReleaseTemporary as soon as you’re done with it, so another call can start reusing it if needed.</p><p>Internally Unity keeps a pool of temporary render textures, so a call to GetTemporary most often just returns an already created one (if the size and format matches). These temporary render textures are actually &gt; destroyed when they aren’t used for a couple of frames.</p><p>If you are doing a series of post-processing “blits”, it’s best for performance to get and release a temporary render texture for each blit, instead of getting one or two render textures upfront and reusing them. &gt; This is mostly beneficial for mobile (tile-based) and multi-GPU systems: GetTemporary will internally do a DiscardContents call which helps to avoid costly restore operations on the previous render texture contents.</p><p>You can not depend on any particular contents of the RenderTexture you get from GetTemporary function. It might be garbage, or it might be cleared to some color, depending on the platform</p></blockquote><h2 id="TimeLine"><a href="#TimeLine" class="headerlink" title="TimeLine"></a>TimeLine</h2><center>    <img src="/2024/05/09/8015191e61fc/cutscene.png" alt></center><h3 id="运行时"><a href="# 运行时" class="headerlink" title="运行时"></a>运行时</h3><h4 id="MCutSceneMgr"><a href="#MCutSceneMgr" class="headerlink" title="MCutSceneMgr"></a><code>MCutSceneMgr</code></h4><ul><li><p>外部调用 <code>Play(int id, DirectoreWrapMode mode = DirectorWrapMode.Hold, Action endCallback = null, Action = startCallback = null)</code> 进行 CutScene 播放</p></li><li><p>根据表格配置的路径进行 <strong> 资源 </strong> 预处理<code>preAll</code></p><ul><li>播放黑屏 显示黑屏 UI</li><li>设置播放状态为<code>CutSceneState.Prepare</code><ul><li>利用引用计数来决定所有资源是否加载完成，引用计数为 0 时表示资源都加载好了</li><li>每次进行资源加载或预加载引用计数加 1，在加载完成后的回调函数中引用计数减 1</li><li>引用计数包括：<code>_necessaryLoadCount</code>、<code>_preloadFlag</code>、<code>_preloadRootCount</code></li><li>加载完成后可以进行播放</li></ul></li><li>模型、特效等 Root 节点初始化；扩展功能初始化</li><li>资源异步加载，加载的资源类型为<code>.playable</code></li><li>加载 <code>.playable</code> 资源成功后继续预加载各种根节点<ul><li><code>VcRoot</code></li><li><code>VcPathRoot</code></li><li><code>SpineRoot</code></li></ul></li><li>加载 Track<ul><li>特效</li><li>视频</li><li>天气</li><li>模型</li><li>虚拟相机</li><li>Cinemachine</li><li>动画</li><li>Spine 动画</li></ul></li></ul></li><li><p><code>Update</code>函数中每帧执行</p><ul><li><p>资源全部加载好之后（所有加载资源相关的引用计数为 0），设置播放状态为<code>CutSceneState.Ready</code></p></li><li><p>设置相机的裁剪遮罩</p></li><li><p>设置播放状态为<code>CutSceneState.Play</code></p></li><li><p>调用 CutScene 播放开始的回调函数<code>_startAction</code></p></li><li><p>调用 <code>PlayableDirector.Play()</code> 进行播放</p></li><li><p>调用扩展功能的 <code>Update</code> 函数</p></li><li><p>调用 CutScene 播放结束的回调函数<code>_endCallback</code></p></li><li><p>检测是否可以更新下一个 CutScene</p><ul><li><p>没有循环播放或者正在播放，可进行下面的判断</p></li><li><p>计算剩余时长 <strong> 的相反数</strong> <code>remain = (float)(_playableDirector.time - _playableDirector.duration);</code></p></li><li><p><code>DirectorWrapMode</code>为 <code>Hold</code> 时，<code>remain &gt;= 0f</code>时立即准备下一个 CutScene 播放</p></li><li><p><code>DirectorWrapMode</code>为 <code>None</code> 时，不太清除这块的逻辑了</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">if</span> (MCommonFunctions.IsEqual(_playableDirector.time, <span class="hljs-number">0</span>))<br>{<br>    _cntZeroTime++;<br>}<br><span class="hljs-keyword">if</span> (_cntZeroTime &lt;= <span class="hljs-number">1</span> &amp;&amp; (_playPath.Count &lt;= <span class="hljs-number">0</span> || !(Mathf.Abs(tmp) &lt;= <span class="hljs-number">0.1f</span>)) &amp;&amp; !(tmp &gt;= <span class="hljs-number">0f</span>)) <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure></li><li><p>根据表格中的 CutScene 配置，取第二个路径为 <code>nextPath</code> 继续走资源加载然后播放的的流程</p></li></ul></li></ul></li></ul><blockquote><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#">&gt;<span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> DirectorWrapMode<br>&gt;{<br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// 摘要：</span><br>   <span class="hljs-comment">//     Hold the last frame when the playable time reaches it's duration.</span><br>   Hold,<br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// 摘要：</span><br>   <span class="hljs-comment">//     Loop back to zero time and continue playing.</span><br>   Loop,<br>   <span class="hljs-comment">//</span><br>   <span class="hljs-comment">// 摘要：</span><br>   <span class="hljs-comment">//     Do not keep playing when the time reaches the duration.</span><br>   None<br>&gt;}<br></code></pre></td></tr></table></figure></blockquote><h3 id="其他辅助类"><a href="# 其他辅助类" class="headerlink" title="其他辅助类"></a>其他辅助类</h3><ul><li><code>MCutsceneObject</code> 继承自<code>MGameObject</code></li><li><code>MCutSceneHelper</code> 定义在 Hierarchy 结构中显示的节点名称</li><li><code>MCutSceneData</code> 序列化 CutScene 二进制<ul><li><code>List&lt;MCutSceneTrack&gt;</code> 序列化轨道数据<ul><li><code>CStrackType</code></li><li><code>MCutSceneModelData</code></li><li><code>MCutSceneCirtualCameraData</code></li><li><code>List&lt;MCutSceneAnimClip&gt;</code></li><li><code>List&lt;MCutSceneCirCamClip&gt;</code></li><li><code>MCutSceneSpineData</code></li></ul></li><li><code>MDollyCart</code> 可理解为装载轨道摇臂的“轨道车”</li></ul></li></ul><h4 id="PlayableBehaviour、PlayableAsset 和 TrackAsset"><a href="#PlayableBehaviour、PlayableAsset 和 TrackAsset" class="headerlink" title="PlayableBehaviour、PlayableAsset 和 TrackAsset"></a><code>PlayableBehaviour</code>、<code>PlayableAsset</code>和<code>TrackAsset</code></h4><ul><li><code>TrackAsset</code>：轨道资源，用来创建片段和 Playable 混合器，提供序列化数据与 Binding</li><li><code>PlayableAsset</code>：片段资源，用来创建 Playable 以及提供序列化数据</li><li><code>PlayableBehaviour</code>：逻辑行为，用来实现 Playable 具体的业务逻辑</li></ul><h2 id="资源管理"><a href="# 资源管理" class="headerlink" title="资源管理"></a>资源管理 </h2><h3 id="RO- 的资源打包流程"><a href="#RO- 的资源打包流程" class="headerlink" title="RO 的资源打包流程"></a>RO 的资源打包流程</h3><p> 所有可能被打包的资源都会被归类到一个个的 filter 类中</p><ul><li>ABDir：处理后的资源存放的文件夹（前缀都是 roab/ 平台）</li><li>AbType：资源类型。一共三大类型：<ul><li>AB：需要打成 AB 的资源   基类为：<code>ABBaseFilter</code></li><li>bytes：后缀为 robytes 的资源   基类为：<code>ABBaseFilter</code></li><li>直接 copy 的资源：音频、视频、Resources\QualitySetting 和 MiniStringPool 中的 json 文件基类为：<code>ABCopyBaseFilter</code>。他的基类为：<code>ABBaseFilter</code></li></ul></li><li>Filters：将要处理的资源列表。 所有的资源都会用 ABFilter 数据结构存储</li></ul><h3 id="打 -AB- 流程"><a href="# 打 -AB- 流程" class="headerlink" title="打 AB 流程"></a>打 AB 流程</h3><ul><li>XbuildAB：打 AB 的接口文件，这里可以看到打 AB 的各个步骤</li><li>XABContainer：管理所有的 XABItem</li><li>XABItem：AB 的最小单位，一个小的资源对应一个 XABItem 实例。但并不是所有的都会导出</li></ul><p>步骤</p><ul><li>通过 XABContainer 生成 filter 中的文件对应的 XABItem 类，又分为三类：<ul><li>普通 AB</li><li>Atlas 图集</li><li>Shader，将所有 Shader 打成了一个 AB，ab 名字为 shader 的跟文件夹路径的 hash</li></ul></li><li>分析依赖<ul><li>分析步骤一中生成的所有 XABItem 的依赖关系，从而找到所有可能被打成 AB 的资源，并记下来其前后依赖关系（我依赖了哪些，哪些依赖了我，要求不能循环引用）</li><li>确定需要导出的 AB 列表，是否导出根据如下规则<ul><li><code>Asset = 1</code>  // 普通素材，被根素材依赖的，跟随其根素材到一个 AB 中</li><li><code>Root = 1 &lt;&lt; 1</code> // 根，只有 filter 中指定的才会是根，会被单独打成 AB</li><li><code>Standalone = 1 &lt;&lt; 2</code> // 被两个或者离两个以上素材引用的会被单独打成 AB</li></ul></li></ul></li><li>导出 AB<ul><li>导出的 AB 在 roab 这个工程目录中</li><li>先打图集的 AB，再打非图集的。图集要<code>EditorSettings.spritePackerMode = SpritePackerMode.AlwaysOnAtlas</code>，非图集要设置为<code>SpritePackerMode.Disabled</code></li><li>压缩算法选了 lz4, 移动端 &amp;PC 端关闭 typetree, 为了热更的需要设置了<code>DeterministicAssetBundle</code></li><li>构建 <code>AssetBundleBuild</code> 的时候，场景文件不用记录所有依赖，Unity 会自动做</li></ul></li><li>写入 dep.all 文件<ul><li>AB 中包含的资源列表。实际测下来，只有 shader 有多个，其余的都是只有一个</li><li>AB 的 hash 值</li><li>AB 的类型</li><li>需要依赖的 AB 数量及列表</li></ul></li><li>删除冗余的 AB（给增量 bundle 使用）<ul><li>先从其他目录拷贝 AB（资源会有删除的）</li><li>再打增量 AB</li><li>判断没有用的 AB 需要删除掉</li></ul></li><li>Bytes<ul><li>翻译</li><li>其他配置文件</li><li>直接拷贝</li></ul></li><li>脚本<ul><li>通过 luajit 将。lua 文件处理成二进制文件</li></ul></li><li>其他资源</li></ul><blockquote><p><code>_analyze_step == 0</code>：开始分析<br><code>_analyze_step == 1</code>：存在循环依赖（A → B → A 或 A → B → C → A），直接抛出异常<br><code>_analyze_step == 2</code>：已经分析过</p></blockquote><h2 id="读表"><a href="# 读表" class="headerlink" title="读表"></a>读表 </h2><h3 id="读取整表"><a href="# 读取整表" class="headerlink" title="读取整表"></a> 读取整表</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GetTable</span><span class="hljs-params">()</span></span><br>    <span class="hljs-keyword">local</span> l_tables = {}<br>    <span class="hljs-keyword">if</span> l_tablePtr ~= <span class="hljs-literal">nil</span> <span class="hljs-keyword">then</span><br>        <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>, l_tableSize <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">table</span>.<span class="hljs-built_in">insert</span>(l_tables, GetRow(i))<br>        <span class="hljs-keyword">end</span><br>    <span class="hljs-keyword">else</span><br>        logError(<span class="hljs-string">"SkillTable l_tablePtr is nil"</span>)<br>    <span class="hljs-keyword">end</span><br><br>    <span class="hljs-keyword">return</span> l_tables<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="读取一行"><a href="# 读取一行" class="headerlink" title="读取一行"></a>读取一行</h3><ul><li><code>ROGameLibs.TableDataLuaProxy:GetRowIDByINT</code></li></ul><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;sumarry&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 不断地乘 33 （(hash <span class="hljs-doctag">&lt;&lt; 5) + hash）</span></span><br><span class="hljs-doctag"><span class="hljs-comment">/// &lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">uint</span> <span class="hljs-title">GetHash</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">uint</span> hash = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; str.Length; i++&gt;)<br>    {<br>        hash = (hash &lt;&lt; <span class="hljs-number">5</span>) + hash + str[i];<br>    }<br>    <span class="hljs-keyword">return</span> hash;<br>}<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="行为树" scheme="https://silhouettesforyou.github.io/tags/%E8%A1%8C%E4%B8%BA%E6%A0%91/"/>
    
    <category term="剧情脚本" scheme="https://silhouettesforyou.github.io/tags/%E5%89%A7%E6%83%85%E8%84%9A%E6%9C%AC/"/>
    
    <category term="资源管理" scheme="https://silhouettesforyou.github.io/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Life of a triangle</title>
    <link href="https://silhouettesforyou.github.io/2023/04/20/ed6487d7b99b/"/>
    <id>https://silhouettesforyou.github.io/2023/04/20/ed6487d7b99b/</id>
    <published>2023-04-20T14:01:48.000Z</published>
    <updated>2024-07-30T13:36:05.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><blockquote><p><i class="fa-solid fa-link"></i><a href="https://developer.nvidia.com/content/life-triangle-nvidias-logical-pipeline">Life of a triangle</a></p></blockquote><p>Since the release of the ground breaking Fermi architecture almost 5 years have gone by, it might be time to refresh the principle graphics architecture beneath it. Fermi was the first NVIDIA GPU implementing a fully scalable graphics engine and its core architecture can be found in Kepler as well as Maxwell. The following article and especially the “compressed pipeline knowledge” image below should serve as a primer based on the various public materials, such as whitepapers or GTC tutorials about the GPU architecture. This article focuses on the graphics viewpoint on how the GPU works, although some principles such as how shader program code gets executed is the same for compute.</p><p><font color="#BEC6A0">自从开创性的 Fermi 架构发布以来，已经过去了近五年时间，现在揭开其背后的基础图形架构了。Fermi 是 NVIDIA 首款实现完全可扩展图形引擎的 GPU，其核心架构也应用到 Kepler 和 Maxwell 的架构中。以下内容，特别是“管线缩略图”，广泛被各种 GPU 架构相关资料（如白皮书或 GTC 教程）所引用。本文从图形角度出发探讨 GPU 的工作原理，其中涉及到的着色器代码如何运行等原理和实际应用中是相同的。</font></p><div class="note note-info">            <ul class="fa-ul" style="--fa-li-margin: -0.5em;">  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://www.hardwarebg.com/b4k/files/nvidia_gf100_whitepaper.pdf">Fermi Whitepaper</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://www.nvidia.com/content/dam/en-zz/Solutions/Data-Center/tesla-product-literature/NVIDIA-Kepler-GK110-GK210-Architecture-Whitepaper.pdf">Kepler Whitepaper</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://www.techpowerup.com/gpu-specs/docs/nvidia-gtx-750-ti.pdf">Maxwell Whitepaper</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://www.highperformancegraphics.org/previous/www_2010/media/Hot3D/HPG2010_Hot3D_NVIDIA.pdf">Fast Tessellated Rendering on Fermi GF100</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://on-demand.gputechconf.com/gtc/2013/presentations/S3466-Programming-Guidelines-GPU-Architecture.pd">Programming Guidelines and GPU Architecture Reasons Behind Them</a></li></ul>          </div><h2 id="Pipeline-Architecture-Image"><a href="#Pipeline-Architecture-Image" class="headerlink" title="Pipeline Architecture Image"></a><h id="Fermi">Pipeline Architecture Image</h></h2><center>    <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline.png" alt="Fermi Pipeline"></center><h2 id="GPUs-are-Super-Parallel-Work-Distributors"><a href="#GPUs-are-Super-Parallel-Work-Distributors" class="headerlink" title="GPUs are Super Parallel Work Distributors"></a>GPUs are Super Parallel Work Distributors</h2><p>Why all this complexity? In graphics we have to deal with data amplification that creates lots of variable workloads. Each drawcall may generate a different amount of triangles. The amount of vertices after clipping is different from what our triangles were originally made of. After back-face and depth culling, not all triangles may need pixels on the screen. The screen size of a triangle can mean it requires millions of pixels or none at all.</p><p><font color="#BEC6A0">在图形处理中，需要进行数据增强（包括但不限于裁剪、缩放、旋转、翻转、色彩变换、添加噪声等），对整个图形工作流有很大负担。每个 drawcall 都会会产生不同数量的三角形。裁剪后三角形顶点数量可能与原始三角形顶点数量不同。在背面剔除和深度剔除之后，并非所有三角形都需要在屏幕上显示。屏幕上的三角形需要上百万个像素组成，也可以不需要任何像素表示。这就是图形处理中复杂性的原因。我们需要处理这些变化，以确保图像能够正确、高效地渲染出来。</font></p><p>As a consequence modern GPUs let their primitives (triangles, lines, points) follow a logical pipeline, not a physical pipeline. In the old days before G80’s unified architecture (think DX9 hardware, ps3, xbox360), the pipeline was represented on the chip with the different stages and work would run through it one after another. G80 essentially reused some units for both vertex and fragment shader computations, depending on the load, but it still had a serial process for the primitives/rasterization and so on. With Fermi the pipeline became fully parallel, which means the chip implements a logical pipeline (the steps a triangle goes through) by reusing multiple engines on the chip.</p><p><font color="#BEC6A0">简单来说，现代 GPU 让基本图元（如三角形、线条、点）遵循逻辑管线，而不是物理管线。在 G80 统一架构出现之前（比如 DX9 硬件、PS3、Xbox300 等），GPU 的处理流程在芯片上被划分为不同的阶段，并且图元会按照一定的顺序一个接着一个的处理。G80 架构虽然在一定程度上实现了顶点和片元着色器计算的单元复用，但基本图元（如三角形）和栅格化等处理仍然是串行的。而到了 Fermi 架构，处理流程实现了全并行化，这意味着 GPU 通过复用芯片上的多个引擎，来并行地实现一个逻辑管线（即三角形等图元经历的各个处理步骤）。这样的设计大大提高了 GPU 的效率和性能。</font></p><p>Let’s say we have two triangles A and B. Parts of their work could be in different logical pipeline steps. A has already been transformed and needs to be rasterized. Some of its pixels could be running pixel-shader instructions already, while others are being rejected by depth-buffer (Z-cull), others could be already being written to framebuffer, and some may actually wait. And next to all that, we could be fetching the vertices of triangle B. So while each triangle has to go through the logical steps, lots of them could be actively processed at different steps of their lifetime. The job (get drawcall’s triangles on screen) is split into many smaller tasks and even subtasks that can run in parallel. Each task is scheduled to the resources that are available, which is not limited to tasks of a certain type (vertex-shading parallel to pixel-shading).</p><p><font color="#BEC6A0">可以这样来解释：假设我们有两个三角形 A 和 B。它们的工作流程中可能包含不同的逻辑管线。三角形 A 已经完成了变换，接下来需要进行光栅化。在这个过程中，A 的一些像素可能已经在执行像素着色器指令，而另一些可能因为深度缓冲区（Z-cull）而被拒绝，还有一些可能已经被写入到帧缓冲区中，还有一些可能还在等待处理。与此同时，我们可能正在获取三角形 B 的顶点。所以，虽然每个三角形都需要按照逻辑管线进行处理，但在它们的生命周期中，很多步骤都可以并行地进行处理。整个任务（即将 drawcall 后的三角形显示在屏幕上）被分割成许多更小的任务或者子任务，这些子任务可以并行运行。每个子任务都被调度到可用的资源上，包括某些特定的任务（如顶点着色器与像素着色器也可以并行处理）。</font></p><p>Think of a river that fans out. Parallel pipeline streams, that are independent of each other, everyone on their own time line, some may branch more than others. If we would color-code the units of a GPU based on the triangle, or drawcall it’s currently working on, it would be multi-color blinkenlights :)</p><p><font color="#BEC6A0">可以将这个架构想象成河流的支流，形成的多条并行的支流，它们彼此独立，各自按照自己的时间线流动，有些模块可能会生成更多的支流。如果我们根据 GPU 中当前正在处理的三角形或 drawcall 来给 GPU 中的单元模块染色，那么它们就会像各种颜色的信号灯一样闪烁：)</font></p><h2 id="GPU-Architecture"><a href="#GPU-Architecture" class="headerlink" title="GPU Architecture"></a>GPU Architecture</h2><center>    <img src="/2023/04/20/ed6487d7b99b/pipeline-maxwell-gpu.png" alt></center><p>Since Fermi NVIDIA has a similar principle architecture. There is a Giga Thread Engine which manages all the work that’s going on. The GPU is partitioned into multiple GPCs (Graphics Processing Cluster), each has multiple SMs (Streaming Multiprocessor) and one Raster Engine. There is lots of interconnects in this process, most notably a Crossbar that allows work migration across GPCs or other functional units like ROP (render output unit) subsystems.</p><p><font color="#BEC6A0">英伟达（NVIDIA）的 Fermi 架构和 Maxwell 架构原理一样。用一个 <font color="#FF204E"><strong> 千兆线程引擎 </strong></font> 处理所有任务。GPU 被划分为多个图形处理集群（GPC），每个 GPC 都包含若干流式多处理器（SM）和一个光栅引擎（Raster Engine）。在这个过程中，存在大量的互连，其中最重要的是一个交叉开关（Crossbar），它允许任务在 GPC 之间或像 ROP（渲染输出单元）子系统等其他功能单元之间迁移。</font></p><p>The work that a programmer thinks of (shader program execution) is done on the SMs. It contains many Cores which do the math operations for the threads. One thread could be a vertex-, or pixel-shader invocation for example. Those cores and other units are driven by Warp Schedulers, which manage a group of 32 threads as warp and hand over the instructions to be performed to Dispatch Units. The code logic is handled by the scheduler and not inside a core itself, which just sees something like “sum register 4234 with register 4235 and store in 4230” from the dispatcher. A core itself is rather dumb, compared to a CPU where a core is pretty smart. The GPU puts the smartness into higher levels, it conducts the work of an entire ensemble (or multiple if you will).</p><p><font color="#BEC6A0">大部分可编程的工作（着色器的运行）是在 SM（流式多处理器）上完成的。它包含许多以数学计算为核心的线程。例如，一个线程可能被顶点着色器或像素着色器所占用。核心和其他单元都由 Warp 调度器驱动，其中每个 32 个线程组成一个束，并将要执行的指令交给调度单元。代码逻辑由调度器处理，而不是核心本身，例如：“将寄存器 4234 的值与寄存器 4235 的值相加并存储在寄存器 4230 中”的指令是有调度器完成。然而，相比于 CPU 的核可以处理复杂的逻辑，GPU 的核显得更单一。原因是 GPU 的将复杂的逻辑处理放在更高的一级，它可以协调 GPU 整体进行运作。</font></p><p>How many of these units are actually on the GPU (how many SMs per GPC, how many GPCs..) depends on the chip configuration itself. As you can see above GM204 has 4 GPCs with each 4 SMs, but Tegra X1 for example has 1 GPC and 2 SMs, both with Maxwell design. The SM design itself (number of cores, instruction units, schedulers…) has also changed over time from generation to generation (see first image) and helped making the chips so efficient they can be scaled from high-end desktop to notebook to mobile.</p><p><font color="#BEC6A0">这些单元实际上在 GPU 上的数量（每个 GPC 中有多少个 SM，有多少个 GPC 等）取决于芯片配置。例如 GM204 拥有 4 个 GPC，每个 GPC 中有 4 个 SM；Tegra X1 则只有 1 个 GPC 和 2 个 SM，两者都采用了 Maxwell 设计。而 SM 的设计（包括核心数量、指令单元、调度器等）也在更新迭代（请参考 <a href="#Fermi">Fermi 管线架构图</a>），让芯片更加高效，能够从高端主机兼容到笔记本再到移动设备。</font></p><h2 id="The-Logical-Pipeline"><a href="#The-Logical-Pipeline" class="headerlink" title="The Logical Pipeline"></a>The Logical Pipeline</h2><p>For the sake of simplicity several details are omitted. We assume the drawcall references some index- and vertexbuffer that is already filled with data and lives in the DRAM of the GPU and uses only vertex- and pixelshader (GL: fragmentshader).</p><p><font color="#BEC6A0">为了简化说明，假设一次 drawcall 只引用了一些索引缓冲区和顶点缓冲区，这些缓冲区已经被数据填充，并存储在 GPU 的动态随机存取存储器（DRAM）中。一次 drawcall 仅使用顶点着色器和像素着色器（在 OpenGL 中称为片段着色器）来处理数据。</font><font color="#758694">这是一个在 GPU 上执行的图形渲染过程，它利用已经准备好的数据来绘制图形，这些数据通过索引和顶点缓冲区来组织，并使用着色器程序来渲染最终的图像。</font></p><center>    <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-begin.png" alt></center><ol><li><p>The program makes a drawcall in the graphics api (DX or GL). This reaches the driver at some point which does a bit of validation to check if things are “legal” and inserts the command in a GPU-readable encoding inside a pushbuffer. A lot of bottlenecks can happen here on the CPU side of things, which is why it is important programmers use apis well, and techniques that leverage the power of today’s GPUs.</p><p> <font color="#BEC6A0">当用图形 API（如 DirectX 或 OpenGL）发起一次 drawcall，命令会传到驱动程序，并进行合法性验证；然后这个命令以 GPU 可读的编码方式插入到一个推送缓冲区中。由于现代 GPU 的性能和处理速度越来越快，导致整个渲染过程在 CPU 会遇到瓶颈，所以要规范的使用图形 API 才能避免性能瓶颈。</font></p></li><li><p>After a while or explicit “flush” calls, the driver has buffered up enough work in a pushbuffer and sends it to be processed by the GPU (with some involvement of the OS). The Host Interface of the GPU picks up the commands which are processed via the Front End.</p><p> <font color="#BEC6A0">当收到明确的“刷新”指令时或者缓存一定时间后，驱动程序会在推送缓冲区中缓存一定数量的任务，将其发送给 GPU 进行处理（操作系统这时也会参与进来）。GPU 的主机接口用来接收这些命令，并通过前端进行处理。</font><font color="#758694">简单来说，这个过程就是驱动程序先将一些需要 GPU 处理的任务缓存起来，当达到一定量或者通过特定操作触发时，这些任务就会被发送到 GPU 进行进一步的执行。</font></p></li><li><p>We start our work distribution in the Primitive Distributor by processing the indices in the indexbuffer and generating triangle work batches that we send out to multiple GPCs.</p><p> <font color="#BEC6A0">在“图元分配器”（Primitive Distributor）中，开始进行任务分配的。这个过程涉及到处理索引缓冲区（indexbuffer）中的索引，生成三角形批次，然后将每个批次发送到 GPCs 进行处理。</font></p> <center>     <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-sm.png" alt> </center></li><li><p>Within a GPC, the Poly Morph Engine of one of the SMs takes care of fetching the vertex data from the triangle indices (Vertex Fetch).</p><p> <font color="#BEC6A0">在 GPC 中，Poly Morph 模块负责从索引中检索顶点数据（顶点提取）</font><font color="#758694">这个过程是图形渲染流水线中的一部分，它负责从存储的三角形数据中提取出构成这些三角形的顶点信息。Poly Morph 引擎是图形处理单元（GPU）中的一个关键组件，它优化了顶点数据的提取和转换，以便后续进行光栅化和像素着色等处理。</font></p></li><li><p>After the data has been fetched, warps of 32 threads are scheduled inside the SM and will be working on the vertices.</p><p> <font color="#BEC6A0">数据提取后，在 SM 内部会调度 32 个线程的束（warp）处理顶点。</font><font color="#758694">这里的“顶点”是指图计算、图形渲染或任何需要并行处理大量数据点的场景中的元素。束（warp）是 GPU 编程中的一个术语，它指的是一组并行执行的线程，这些线程在 GPU 中一起工作，以提高处理效率。在 NVIDIA 的 GPU 架构中，一个束通常包含 32 个线程。</font></p></li><li><p>The SM’s warp scheduler issues the instructions for the entire warp in-order. The threads run each instruction in lock-step and can be masked out individually if they should not actively execute it. There can be multiple reasons for requiring such masking. For example when the current instruction is part of the “if (true)” branch and the thread specific data evaluated “false”, or when a loop’s termination criteria was reached in one thread but not another. Therefore having lots of branch divergence in a shader can increase the time spent for all threads in the warp significantly. Threads cannot advance individually, only as a warp! Warps, however, are independent of each other.</p><p> <font color="#BEC6A0">SM 的束调度器按顺序为整个束发出指令。线程以同步的方式运行每条指令，如果指令不主动执行，则可以单独屏蔽掉这条指令。可能需要这种屏蔽方式的原因有很多，例如，当前指令只有满足 <code>if (true)</code> 的条件才会执行，而该线程具体的数值计算为 <code>false</code> 时，需要屏蔽掉该指令；或者当一个线程的循环终止条件达到而另一个线程未达到时，需要屏蔽掉已经终止的线程中的指令。因此，着色器中存在大量分支语句会显著增加束中线程运行的时间。线程不能单独运行，只能组成一个束统一调度；但是，束与束之间是独立的。</font></p></li><li><p>The warp’s instruction may be completed at once or may take several dispatch turns. For example the SM typically has less units for load/store than doing basic math operations.</p><p> <font color="#BEC6A0">指令的执行可能是立即完成的，也可能需要几个调度周期。例如，SM 中用于加载 / 存储的单元要比执行基本数学运算的单元要少。</font><font color="#758694">这意味着不同的指令可能需要不同的时间来执行，这取决于它们的类型和所需的资源。在一些情况下，比如需要频繁地访问内存时，执行速度可能会相对较慢。</font></p></li><li><p>As some instructions take longer to complete than others, especially memory loads, the warp scheduler may simply switch to another warp that is not waiting for memory. This is the key concept how GPUs overcome latency of memory reads, they simply switch out groups of active threads. To make this switching very fast, all threads managed by the scheduler have their own registers in the register-file. The more registers a shader program needs, the less threads/warps have space. The less warps we can switch between, the less useful work we can do while waiting for instructions to complete (foremost memory fetches).</p><p> <font color="#BEC6A0">由于某些指令比其他指令需要更长的时间来完成，尤其是内存加载，束调度器会切换到另一个不在等待内存的束。这就是 GPU 解决内存存读取延迟的关键，做法就是简单地切换到活跃线程组。为了使这种切换非常快速，调度器管理的所有线程都有自己的寄存器。着色器程序需要的寄存器越多，线程或束的空间就越少。可切换的束越少，在等待指令完成（主要是内存读取）时能做的有用工作就越少。</font></p> <center>     <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-memory-flow.png" alt> </center></li><li><p>Once the warp has completed all instructions of the vertex-shader, it’s results are being processed by Viewport Transform. The triangle gets clipped by the clipspace volume and is ready for rasterization. We use L1 and L2 Caches for all this cross-task communication data.</p><p> <font color="#BEC6A0">当顶点着色器完成了所有指令的处理后，还需要经过视口变换（Viewport Transform）进一步处理。在这个过程中，三角形会根据裁剪空间进行裁剪，以准备进行光栅化。在整个跨任务通信数据处理的过程中，会使用 L1 和 L2 缓存来加快处理速度。</font></p> <center>     <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-raster.png" alt> </center></li><li><p>Now it gets exciting, our triangle is about to be chopped up and potentially leaving the GPC it currently lives on. The bounding box of the triangle is used to decide which raster engines need to work on it, as each engine covers multiple tiles of the screen. It sends out the triangle to one or multiple GPCs via the Work Distribution Crossbar. We effectively split our triangle into lots of smaller jobs now.</p><p><font color="#BEC6A0">三角形被分割后，会离开它当前的 GPC。一个三角形的包围盒决定需要的光栅引擎的个数，同时每个光栅引擎会覆盖屏幕上多个像素块。这个过程是通过任务分配器的交叉开关可以将三角形分配到一个或多个 GPC(s) 进行处理。这样就三角形的数据处理分配到到多个较小的任务上进行。</font></p><center>    <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-mid.png" alt></center></li><li><p>Attribute Setup at the target SM will ensure that the interpolants (for example the outputs we generated in a vertex-shader) are in a pixel shader friendly format.</p><p><font color="#BEC6A0">在指定的 SM 上进行属性设置时，要保证插值变量（例如在顶点着色器中生成的输出）符合像素着色器处理的格式。</font><font color="#758694">这一步骤是为了保证在图形渲染的后续阶段，尤其是在像素着色器中，这些变量能够被正确且高效地使用。</font></p></li><li><p>The Raster Engine of a GPC works on the triangle it received and generates the pixel information for those sections that it is responsible for (also handles back-face culling and Z-cull).</p><p><font color="#BEC6A0">在 GPC 中的光栅引擎处理其被分配的三角形，并生成像素信息（同时还处理背面剔除和深度剔除）。</font></p></li><li><p>Again we batch up 32 pixel threads, or better say 8 times 2x2 pixel quads, which is the smallest unit we will always work with in pixel shaders. This 2x2 quad allows us to calculate derivatives for things like texture mip map filtering (big change in texture coordinates within quad causes higher mip). Those threads within the 2x2 quad whose sample locations are not actually covering the triangle, are masked out (gl_HelperInvocation). One of the local SM’s warp scheduler will manage the pixel-shading task.</p><p><font color="#BEC6A0">将 32 个像素线程分成 8 个 2x2 像素块，这是像素着色器中处理的最小单元。2x2 像素块是用来计算诸如纹理 mip-map 贴图的导数（如果 2x2 像素块内的纹理坐标变化较大，将使用更高分辨率的 mip-map 贴图）。在 2x2 像素块内，那些不实际覆盖三角形的线程会被屏蔽。用其中一个 SM 的束调度器管理像素着色的任务。</font></p></li><li><p>The same warp scheduler instruction game, that we had in the vertex-shader logical stage, is now performed on the pixel-shader threads. The lock-step processing is particularly handy because we can access the values within a pixel quad almost for free, as all threads are guaranteed to have their data computed up to the same instruction point (NV_shader_thread_group).</p><p><font color="#BEC6A0">像素着色器线程中的束调度器使用了与顶点着色器阶段相同的调度机制。这个机制允许在像素块内访问值几乎不需要任何代价，所以同步处理非常方便。由于所有线程的数据都保证计算到同一步指令位置，线程之间可以高效地共享数据。</font></p><center>    <img src="/2023/04/20/ed6487d7b99b/fermi-pipeline-end.png" alt></center></li><li><p>Are we there yet? Almost, our pixel-shader has completed the calculation of the colors to be written to the rendertargets and we also have a depth value. At this point we have to take the original api ordering of triangles into account before we hand that data over to one of the ROP (render output unit) subsystems, which in itself has multiple ROP units. Here depth-testing, blending with the framebuffer and so on is performed. These operations need to happen atomically (one color/depth set at a time) to ensure we don’t have one triangle’s color and another triangle’s depth value when both cover the same pixel. NVIDIA typically applies memory compression, to reduce memory bandwidth requirements, which increases “effective” bandwidth (see GTX 980 pdf).</p><p><font color="#BEC6A0">像素着色器完成颜色和深度值的计算后，需要考虑三角形按照 API 中的顺序传递给 ROP 单元。在 ROP 单元中进行深度测试和帧缓冲区混合等操作，这些操作是原子性的，以保证渲染结果的正确性。NVIDIA 还使用内存压缩技术来减少内存带宽需求，从而提高传输效率（参考 <a href="https://www.studocu.com/it/document/politecnico-di-milano/advanced-computer-architectures/ge-force-gtx-980-whitepaper-final/2232255">GTX 980</a>）。</font></p></li></ol><h2 id="Further-Reading"><a href="#Further-Reading" class="headerlink" title="Further Reading"></a>Further Reading</h2><ul class="fa-ul" style="--fa-li-margin: -0.5em;">  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="https://fgiesen.wordpress.com/2011/07/09/a-trip-through-the-graphics-pipeline-2011-index/">A trip through the graphics-pipeline</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="http://on-demand.gputechconf.com/gtc/2013/video/S3466-Performance-Optimization-Guidelines-GPU-Architecture-Details.mp4">Performance Optimization Guidelines and the GPU Architecture behind them</a></li>  <li><span class="fa-li"><i class="fa-solid fa-link"></i></span><a href="http://graphics.stanford.edu/papers/pomegranate/">Pomegranate: A Fully Scalable Graphics Architecture </a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="图形学" scheme="https://silhouettesforyou.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Graphics" scheme="https://silhouettesforyou.github.io/tags/Graphics/"/>
    
    <category term="翻译" scheme="https://silhouettesforyou.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="GPU" scheme="https://silhouettesforyou.github.io/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Lua 解释器构建：从虚拟机到编译器</title>
    <link href="https://silhouettesforyou.github.io/2023/04/03/6a4770ec7c72/"/>
    <id>https://silhouettesforyou.github.io/2023/04/03/6a4770ec7c72/</id>
    <published>2023-04-03T11:36:58.000Z</published>
    <updated>2024-07-23T12:46:53.573Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="增量式标记清除算法"><a href="# 增量式标记清除算法" class="headerlink" title="增量式标记清除算法"></a>增量式标记清除算法 </h3><p> 整个 GC 执行的过程中，大致经历以下几个阶段</p><ul><li><p><strong><font color="#FF6000">pause</font></strong> 阶段</p><p><font color="#FFA559">mainthread</font> 和 <font color="#FFA559">global table</font> 包含 GC 起始点，因此要将它们插入到 <font color="#2E4F4F">gray</font> 链表中，并将它们标记为灰色，进入到 <strong><font color="#FF6000">propagate</font></strong> 阶段</p></li><li><p><strong><font color="#FF6000">propagate</font></strong> 阶段</p><ul><li>不断从 <font color="#2E4F4F">gray</font> 链表中取出对象，然后把它从灰色变为黑色，再遍历它所引用的对象，并将其插入到 <font color="#2E4F4F">gray</font> 链表中</li><li><strong><font color="#FF6000">propagate</font></strong> 阶段累积遍历的对象大小超过一定的字节数，本轮 GC 会被终止，等待下一次 GC 步骤开始后继续扫描 <font color="#2E4F4F">gray</font> 链表中的对象</li><li>当 <font color="#2E4F4F">gray</font> 链表为空时，进入 <strong><font color="#FF6000">atomic</font></strong> 阶段</li></ul></li><li><p><strong><font color="#FF6000">atomic</font></strong> 阶段</p><ul><li>GC 步骤在 <strong><font color="#FF6000">pause</font></strong> 阶段是可以被中断的，假如新建的对象被标记为黑色的对象引用，本轮 GC 就不会对其进行遍历和标记，到 <strong><font color="#FF6000">sweep</font></strong> 阶段就会被当作不可达的对象而清除掉</li><li>需要为新建对象设置屏障（barrier）<ul><li>向前设置屏障：直接将新创建的对象标记为灰色，放入到 <font color="#2E4F4F">gray</font> 链表中</li><li>向后设置屏障：将黑色对象标记为灰色， <font color="#2E4F4F">grayagain</font> 链表中</li></ul></li><li>原子执行 <strong><font color="#FF6000">atomic</font></strong> 阶段</li></ul></li><li><p><strong><font color="#FF6000">sweep</font></strong> 阶段</p><p>从 allgc 链表中去除若干个对象；如果已经是本轮 GC 要被清除的 <font color="#E4DCCF"> 白色 </font>，那么它会被清除；如果不是，则标记为<font color="#BACDDB"> 另一种白</font>，以供下一轮 GC 使用</p></li></ul><h3 id="Lua- 虚拟机的字符串"><a href="#Lua- 虚拟机的字符串" class="headerlink" title="Lua 虚拟机的字符串"></a>Lua 虚拟机的字符串</h3><ul><li>从 Lua-5.2.1 开始，字符串就分为长字符串合短字符串。其中短字符串会进行充分的哈希运算，并进行内部优化处理；长字符串不会进行哈希运算和内部化</li><li>字符串内部化的本质就是为每个字符串创建唯一的实例</li><li>在 Lua 中，字符串 Body 长度小于或等于 40B 的是短字符串，大于 40B 的是长字符串；在 Lua-5.3 中，短字符串的大小限制由 <code>LUAI_MAXSHORTLEN</code> 决定，这个宏定义在 llimits.h 中定义</li></ul><h3 id="Lua- 虚拟机的表"><a href="#Lua- 虚拟机的表" class="headerlink" title="Lua 虚拟机的表"></a>Lua 虚拟机的表</h3><h4 id="Lua- 表的基本数据结构"><a href="#Lua- 表的基本数据结构" class="headerlink" title="Lua 表的基本数据结构"></a>Lua 表的基本数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// luaobject.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">lua_Value</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GCObject</span>* <span class="hljs-title">gc</span>;</span><br>    <span class="hljs-type">void</span>* p;<br>    <span class="hljs-type">int</span> b;<br>    lua_Interger i;<br>    lua_Number n;<br>    lua_CFunction f;<br>&#125; Value;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lua_TValue</span> &#123;</span><br>    Value value_;<br>    <span class="hljs-type">int</span> tt_;<br>&#125; TValue;<br><br><span class="hljs-comment">// lua Table</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">union</span> <span class="hljs-title">TKey</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        Value value_;<br>        <span class="hljs-type">int</span> tt; <span class="hljs-comment">// 用来标记 value_是什么类型</span><br>        <span class="hljs-type">int</span> next;<br>    &#125; nk;<br>    TValue tvk;<br>&#125; TKey;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> &#123;</span><br>    TKey key;<br>    TValue value;<br>&#125; Node;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Table</span> &#123;</span><br>    CommonHeader;               <span class="hljs-comment">// GC 部分</span><br>    TValue* <span class="hljs-built_in">array</span>;              <span class="hljs-comment">// 数组部分</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraysize;     <span class="hljs-comment">// 数组大小</span><br>    Node* node;                 <span class="hljs-comment">// hash 部分</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lsizenode;     <span class="hljs-comment">// hash 大小，实际大小为 2&lt;sup&gt;lsizenode</span><br>    Node* lastfree;             <span class="hljs-comment">// 空闲指针</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GCObject</span>* <span class="hljs-title">gclist</span>;</span>    <span class="hljs-comment">// GC 部分</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="键值的哈希运算"><a href="# 键值的哈希运算" class="headerlink" title="键值的哈希运算"></a>键值的哈希运算 </h4><p><code>Node</code> 结构的 <code>key</code> 可以是任意 Lua 类型。<code>key</code>值是如何和哈希表的索引对应起来</p><ul><li>对 <code>key</code> 进行哈希运算</li><li>根据得到的哈希值，换算成表结构 <code>node</code> 数组的索引值<ul><li><code>index = hash_value &amp; (2^lsizenode - 1)</code></li></ul></li><li>查找元素<ul><li>被查找的元素 key 是 <code>int</code> 类型：<ul><li>key 在数组范围之内（在 <code>array</code> 中查找），返回<code>array[k - 1]</code></li><li>key 不在数组范围之内，计算哈希值（在 <code>node</code> 链表中查找）</li></ul></li><li>被查找的元素 key 不是 <code>int</code> 类型：key 不在数组范围之内，计算哈希值（在 <code>node</code> 链表中查找）</li></ul></li></ul><h4 id="调整表的大小"><a href="# 调整表的大小" class="headerlink" title="调整表的大小"></a>调整表的大小</h4><ul><li><p><code>nums[i]</code>的含义：统计 $(2^{i - 1}, 2^i]$ 区间内，所有数组索引值、哈希表<code>key</code>（类型为<code>int</code>）的哈希值位于这个区间的元素总数<code>n</code></p></li><li><p>判断新插入的元素的 <code>key</code> 值是否为整数类型，如果是则对应区间总数增加 1：<code>nums[i]++</code></p></li><li><p>完成 <code>nums</code> 的统计后，根据 <code>nums</code> 计算新的数组大小。在数组大小范围内，<font color="#FF6D60">值不为 <code>nil</code> 的元素要超过数组大小的一半</font>：</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> asize = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">32</span>; i++) &#123;<br>    asize += nums[i];<br>    <span class="hljs-keyword">if</span> (asize &gt; <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i) / <span class="hljs-number">2</span>) &#123;<br>        arraysize = <span class="hljs-built_in">pow</span>(<span class="hljs-number">2</span>, i)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>计算在数组大小范围内有效元素的个数，记为<code>array_used_num</code></p></li><li><p>当数组比原来大时，<font color="#FF6D60">扩展 </font> 原来的数组到新的大小，并将哈希表中 <code>key</code> 值小于等于 <code>arraysize</code>，且大于 0 的元素转移到数组中，并将哈希表大小调整为 $\lceil \log_2^{total - array_used_num} \rceil$，同时对每个<code>node</code> 重新定位</p></li><li><p>当数组比原来小时，<font color="#FF6D60">缩小 </font> 原来的数组到新的大小，并将数组中 <code>key</code> 值超过数组大小的元素转移到哈希表中，并将哈希表大小调整为 $\lceil \log_2^{total - array_used_num} \rceil$，同时对每个 <code>node</code> 重新定位</p></li></ul><h3 id="Lua- 中的三种函数类别"><a href="#Lua- 中的三种函数类别" class="headerlink" title="Lua 中的三种函数类别"></a>Lua 中的三种函数类别 </h3><h4 id="Light-C-Function"><a href="#Light-C-Function" class="headerlink" title="Light C Function"></a>Light C Function</h4><p> 可以理解为普通的 C 函数，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">test_main</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lua_State* L)</span><br>&#123;<br>    <span class="hljs-type">int</span> arg1 = (<span class="hljs-type">int</span>)luaL_tointeger(L, <span class="hljs-number">1</span>);<br>    <span class="hljs-type">int</span> arg2 = (<span class="hljs-type">int</span>)luaL_tointeger(L, <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;test main arg1:%d arg2%d \n&quot;</span>, arg1, arg2);<br>    lua_pushinteger(L, arg1 + arg2);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>要在 Lua 虚拟机中运行 <code>test_main</code> 函数，需要调用<code>lua_pcall</code>，其声明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// L 表示 Lua 线程</span><br><span class="hljs-comment">// narg 表示在 Lua 线程里执行的函数有多少个参数</span><br><span class="hljs-comment">// nresult 表示在 Lua 线程里执行的函数有多少个返回值</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">lua_pcall</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> lau_State* L, <span class="hljs-type">int</span> narg, <span class="hljs-type">int</span> nresult)</span>;<br></code></pre></td></tr></table></figure><h4 id="C- 闭包"><a href="#C- 闭包" class="headerlink" title="C 闭包"></a>C 闭包</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> ClosureHeader \ </span><br>  CommonHeader; lu_byte nupvalues; GCObject* gclist<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CClosure</span> &#123;</span><br>    ClosureHeader;<br>    lua_Function f;<br>    TValue upvalue[<span class="hljs-number">1</span>]; <span class="hljs-comment">// upvalue 列表</span><br>&#125; CClosure;<br></code></pre></td></tr></table></figure><p>一个 C 闭包和 Light C Function 函数相比，除了受 GC 托管并且拥有上值列表外，其他功能和 Light C Function 函数差不多</p><h4 id="Lua- 闭包"><a href="#Lua- 闭包" class="headerlink" title="Lua 闭包"></a>Lua 闭包 </h4><p>Lua 闭包是受 Lua 虚拟机的 GC 托管的，Lua 脚本代码经过编译生成的虚拟指令，以及其他一些编译相关的信息会存放在 LClosure 中的<code>Proto</code> 类型变量中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LClosure</span> &#123;</span><br>    ClosureHeader;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proto</span>* <span class="hljs-title">p</span>;</span><br>    UpVal* upvals[<span class="hljs-number">1</span>];<br>&#125; LClosure;<br></code></pre></td></tr></table></figure><h3 id="Proto 结构"><a href="#Proto 结构" class="headerlink" title="Proto 结构"></a><code>Proto</code>结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// common/luaobject.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proto</span> &#123;</span><br>    CommonHeader;<br>    <span class="hljs-type">int</span> is_vararg;          <span class="hljs-comment">// 标记 Lua 函数参数列表是否为可变参，0 表示否，1 表示是</span><br>    <span class="hljs-type">int</span> nparam;             <span class="hljs-comment">// 当 is_varrag 为 0 时生效，它表示该函数参数的数量</span><br>    Instruction* code;      <span class="hljs-comment">// Lua 函数经过编译后，生成的虚拟机指令列表</span><br>    <span class="hljs-type">int</span> sizecode;           <span class="hljs-comment">// 指明 code 列表的大小</span><br>    TValue* k               <span class="hljs-comment">// 常量列表，如数值、字符串等</span><br>    <span class="hljs-type">int</span> sizek;              <span class="hljs-comment">// 常量列表大小</span><br>    LocVar* localvars;      <span class="hljs-comment">// local 变量列表</span><br>    <span class="hljs-type">int</span> sizelocvar;         <span class="hljs-comment">// local 变量列表大小</span><br>    Upvaldesc* upvalues;    <span class="hljs-comment">// upvalue 信息列表，主要记录 upvalue 的名称，以及其所在的地址，并不是 upvalue 实际值的列表</span><br>    <span class="hljs-type">int</span> sizeupvalues;       <span class="hljs-comment">// upvalue 列表大小</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Proto</span>** <span class="hljs-title">p</span>;</span>       <span class="hljs-comment">// 内嵌定义的函数列表</span><br>    <span class="hljs-type">int</span> sizep;              <span class="hljs-comment">// proto 列表长度</span><br>    TString* source;        <span class="hljs-comment">// 脚本路径</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GCObjects</span>* <span class="hljs-title">gclist</span>;</span><br>    <span class="hljs-type">int</span> maxstacksize;       <span class="hljs-comment">// Proto 所对应的 Lua 函数被调用时，函数栈的最大尺寸</span><br>&#125; Proto;<br></code></pre></td></tr></table></figure><h3 id="上值生成过程"><a href="# 上值生成过程" class="headerlink" title="上值生成过程"></a>上值生成过程 </h3><p> 上值实际上是再编译时确定（位置信息和外层函数的关联等）、在运行时生成的。用来表示上值的数据结构有两个，一个是编译时期存储上值信息的 <code>Upvaldesc</code>（这个结构并不存储上值的实际值，只是用来标记上值的位置信息），另一个是在运行时实际存储上值的<code>UpVal</code> 结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// luaobject.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Upvaldesc</span> &#123;</span><br>    <span class="hljs-comment">// 本函数的上值是否指向外层函数的栈（如果不是则指向外层函数的某个上值）</span><br>    <span class="hljs-type">int</span> in_stack;<br><br>    <span class="hljs-comment">// 上值在外层函数中的位置（栈的位置或 upval 列表中的位置，根据 in_stack 确定）</span><br>    <span class="hljs-type">int</span> idx;<br><br>    <span class="hljs-comment">// 上值的名称</span><br>    TString* name; <br>&#125; Upvaldesc；<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// luafunc.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Upval</span> &#123;</span><br>    <span class="hljs-comment">// 指向外层函数的 local 变量（开放上值），或者指向自己（上值关闭时）</span><br>    TValue* v;<br><br>    <span class="hljs-comment">// Upval 实例被引用的次数</span><br>    <span class="hljs-type">int</span> refcount;<br><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>            <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">UpVal</span>* <span class="hljs-title">next</span>;</span> .. 下一个开放上值<br>            <span class="hljs-type">int</span> touched;<br>        &#125; open;<br>        Tvalue value;<br>    &#125; u;<br>&#125;<br></code></pre></td></tr></table></figure><p>Lua 脚本的编译信息会被存储到 Proto 结构实例中，当一个 Lua 函数的某个变量不是 <code>local</code> 变量时，如果希望获得它的值，实际上就要查找这个变量的位置，如果在 <code>local</code> 列表中找不到，则进入一下流程：</p><ul><li>到自己的 <code>Upvaldesc</code> 列表中，根据变量名查找，如果存在则使用它，否则进行下一步；</li><li>到外层函数查找 <code>local</code> 变量，如果找到它就将它作为自己的上值，否则查找它的 <code>Upvaldesc</code> 表，找到就将其生成为自己的上值，否则进入更外层函数，重复这一步；</li><li>如果一直到顶级函数都找不到，那么表示这个上值不存在，此时需要去 <code>_ENV</code> 中查找</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://silhouettesforyou.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="lua" scheme="https://silhouettesforyou.github.io/tags/lua/"/>
    
    <category term="源码" scheme="https://silhouettesforyou.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Unity 技术美术 - Shader 篇</title>
    <link href="https://silhouettesforyou.github.io/2023/04/03/6539b036c88c/"/>
    <id>https://silhouettesforyou.github.io/2023/04/03/6539b036c88c/</id>
    <published>2023-04-03T02:58:25.000Z</published>
    <updated>2024-07-29T14:23:06.769Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="片段着色器"><a href="# 片段着色器" class="headerlink" title="片段着色器"></a>片段着色器 </h3><h4 id="图元、片元和像素"><a href="# 图元、片元和像素" class="headerlink" title="图元、片元和像素"></a> 图元、片元和像素 </h4><p> 生成的先后顺序：顶点 → 图元 → 片元 → 像素</p><h3 id="ShaderLab- 模板"><a href="#ShaderLab- 模板" class="headerlink" title="ShaderLab 模板"></a>ShaderLab 模板</h3><ul><li>Standard Surface Shader 表面着色器</li><li>Unlit Shader 不受光照（UnLight）</li><li>Image Effect Shader 后处理</li><li>Compute Shader</li><li>Ray Tracing Shader</li></ul><h3 id="SubShader"><a href="#SubShader" class="headerlink" title="SubShader"></a>SubShader</h3><p>GPU 会检查第一个 SubShader，如果 SubShader 不支持（显卡特性等），会检查第二个 SubShader，如果没有找到合适的 SubShader 就会执行 FallBack 中的 Shader 代码</p><h3 id="常用的 cginc"><a href="# 常用的 cginc" class="headerlink" title="常用的 cginc"></a>常用的 cginc</h3><ul><li>HLSLSupport.cginc 编译 CGRPOGRAM 时自动包含此文件，其中声明了很多预处理器宏帮助多平台开发</li><li>UnityShaderVariables.cginc 编译 CGRPOGRAM 时自动包含此文件，其中声明了很多各种内置的全局变量</li><li>UnityCG.cginc 需要手动添加，其中声明了很多内置的帮助函数与结构</li></ul><h3 id="材质属性 Properties"><a href="# 材质属性 Properties" class="headerlink" title="材质属性 Properties"></a>材质属性 Properties</h3><h4 id="语法格式"><a href="# 语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Attribute 为属性</span><br><span class="hljs-comment">// _Name 为变量名</span><br><span class="hljs-comment">// Dispaly_Name 为展示在材质面板上的名字</span><br><span class="hljs-comment">// Type 为变量类型</span><br><span class="hljs-comment">/*********************</span><br><span class="hljs-comment"> *   &#123;</span><br><span class="hljs-comment"> *       color,</span><br><span class="hljs-comment"> *       int,</span><br><span class="hljs-comment"> *       float,</span><br><span class="hljs-comment"> *       vector,</span><br><span class="hljs-comment"> *       2D,</span><br><span class="hljs-comment"> *       3D,</span><br><span class="hljs-comment"> *       cube</span><br><span class="hljs-comment"> *   &#125;</span><br><span class="hljs-comment">**********************/</span><br><span class="hljs-comment">// Default_Value 为默认值</span><br>[Attribute]_Name(<span class="hljs-string">&quot;Display_Name&quot;</span>, Type) = Default_Value<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">Properties<br>&#123;<br>    [HDR]_Color(<span class="hljs-string">&quot; 颜色 &quot;</span>, color) = (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    _Int(<span class="hljs-string">&quot; 整数 &quot;</span>, <span class="hljs-type">int</span>) = <span class="hljs-number">0.5</span><br>    [PowerSlider(<span class="hljs-number">3</span>)]_Float(<span class="hljs-string">&quot; 浮点数 &quot;</span>, range(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>)) = <span class="hljs-number">0.5</span><br>    _Vector(<span class="hljs-string">&quot; 四维向量 &quot;</span>, <span class="hljs-built_in">vector</span>) = (<span class="hljs-number">0.5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>)<br>    _2DTex(<span class="hljs-string">&quot;2D 纹理 &quot;</span>, <span class="hljs-number">2</span>D) = <span class="hljs-string">&quot;black&quot;</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合操作"><a href="# 混合操作" class="headerlink" title="混合操作"></a>混合操作 </h3><p> 片段着色器（源颜色 <code>*</code> SrcFactor） <font color="#2E4F4F"><strong>BlendOp</strong></font> 帧缓冲区 Frame Buffer（目标颜色 <code>*</code> DstFactor）</p><h3 id="Shader 中的时间 -Time"><a href="#Shader 中的时间 -Time" class="headerlink" title="Shader 中的时间_Time"></a>Shader 中的时间<code>_Time</code></h3><p><code>_Time.xyzw</code></p><ul><li><code>_Time.x (t / 20)</code></li><li><code>_Time.y (t)</code></li><li><code>_Time.z (t * 2)</code></li><li><code>_Time.w (t * 3)</code></li></ul><h3 id="相关术语"><a href="# 相关术语" class="headerlink" title="相关术语"></a>相关术语 </h3><h4 id="菲涅尔效应"><a href="# 菲涅尔效应" class="headerlink" title="菲涅尔效应"></a> 菲涅尔效应 </h4><p> 在真实世界中，除了金属之外，其它物质均有不同程度的“菲涅尔效应”。简单的讲，就是视线垂直于表面时，反射较弱，而当视线非垂直表面时，夹角越小，反射越明显。如果你看向一个圆球，那圆球中心的反射较弱，靠近边缘较强。不过这种过度关系被折射率影响。如果你站在湖边，低头看脚下的水，你会发现水是透明的，反射不是特别强烈；如果你看远处的湖面，你会发现水并不是透明的，但反射非常强烈。这就是“菲涅尔效应”</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text&amp;#x2F;css&quot; href=&quot;https://cdn.jsdelivr.net/npm/hexo-tag-hint@0.3.1/dist/hexo-tag-hint.min.css&quot;&gt;&lt;link rel=&quot;st</summary>
      
    
    
    
    <category term="游戏开发" scheme="https://silhouettesforyou.github.io/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Shader" scheme="https://silhouettesforyou.github.io/tags/Shader/"/>
    
    <category term="Unity" scheme="https://silhouettesforyou.github.io/tags/Unity/"/>
    
    <category term="课程" scheme="https://silhouettesforyou.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
</feed>
